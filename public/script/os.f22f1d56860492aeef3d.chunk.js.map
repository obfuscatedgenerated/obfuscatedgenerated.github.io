{"version":3,"file":"os.f22f1d56860492aeef3d.chunk.js","mappings":"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","sources":["webpack://ollieos/./src/kernel/term_ctl.ts","webpack://ollieos/./src/kernel/prog_registry.ts","webpack://ollieos/./src/kernel/filesystem.ts","webpack://ollieos/./src/kernel/processes.ts","webpack://ollieos/./src/kernel/sfx_registry.ts","webpack://ollieos/./src/kernel/index.ts","webpack://ollieos/./src/programs/core/ignition/services.ts","webpack://ollieos/./src/programs/core/ignition/index.ts","webpack://ollieos/./src/programs/core/jetty.ts","webpack://ollieos/./src/programs/core/ash/memory.ts","webpack://ollieos/./src/programs/core/ash/parser.ts","webpack://ollieos/./src/programs/core/ash/core.ts","webpack://ollieos/./src/programs/core/ash/tab_completion.ts","webpack://ollieos/./src/programs/core/ash/index.ts","webpack://ollieos/./src/programs/core/ash/key_handlers.ts","webpack://ollieos/./src/programs/core/default_privilege_agent.ts","webpack://ollieos/./src/programs/core/recovery.ts","webpack://ollieos/./src/programs/help.ts","webpack://ollieos/./src/programs/shutdown.ts","webpack://ollieos/./src/programs/clear.ts","webpack://ollieos/./src/programs/echo.ts","webpack://ollieos/./src/programs/unset.ts","webpack://ollieos/./src/programs/ls.ts","webpack://ollieos/./src/programs/cd.ts","webpack://ollieos/./src/programs/pwd.ts","webpack://ollieos/./src/programs/edit.ts","webpack://ollieos/./src/programs/webget.ts","webpack://ollieos/./src/programs/cat.ts","webpack://ollieos/./src/programs/hex.ts","webpack://ollieos/./src/programs/mefetch.ts","webpack://ollieos/./src/programs/reader.ts","webpack://ollieos/./src/programs/selfdestruct.ts","webpack://ollieos/./src/programs/imagine.ts","webpack://ollieos/./src/programs/ascmagine.ts","webpack://ollieos/./src/programs/fsedit.ts","webpack://ollieos/./src/programs/rm.ts","webpack://ollieos/./src/programs/bugreport.ts","webpack://ollieos/./src/programs/repo.ts","webpack://ollieos/./src/programs/rss.ts","webpack://ollieos/./src/programs/legacy.ts","webpack://ollieos/./src/programs/tour.ts","webpack://ollieos/./src/programs/pkg/remove.ts","webpack://ollieos/./src/programs/pkg/add.ts","webpack://ollieos/./src/programs/pkg/list.ts","webpack://ollieos/./src/programs/pkg/info.ts","webpack://ollieos/./src/programs/pkg/browse.ts","webpack://ollieos/./src/programs/pkg/index.ts","webpack://ollieos/./src/programs/touch.ts","webpack://ollieos/./src/programs/mkdir.ts","webpack://ollieos/./src/programs/mv.ts","webpack://ollieos/./src/programs/window/info.ts","webpack://ollieos/./src/programs/window/list.ts","webpack://ollieos/./src/programs/window/show.ts","webpack://ollieos/./src/programs/window/hide.ts","webpack://ollieos/./src/programs/window/close.ts","webpack://ollieos/./src/programs/window/center.ts","webpack://ollieos/./src/programs/window/index.ts","webpack://ollieos/./src/programs/alias.ts","webpack://ollieos/./src/programs/unalias.ts","webpack://ollieos/./src/programs/ps.ts","webpack://ollieos/./src/programs/kill.ts","webpack://ollieos/./src/programs/spark/service.ts","webpack://ollieos/./src/programs/spark/reload_services.ts","webpack://ollieos/./src/programs/spark/index.ts","webpack://ollieos/./src/programs/ipc_bg_test.ts","webpack://ollieos/./src/programs/ipc_fg_test.ts","webpack://ollieos/./src/programs/taskbar_test.ts","webpack://ollieos/./src/programs/pkg/triggers/create_trigger.ts","webpack://ollieos/./src/programs/pkg/triggers/remove_trigger.ts","webpack://ollieos/./src/fs_impl/localstorage.ts","webpack://ollieos/./src/fs_impl/opfs.ts","webpack://ollieos/./src/initial_fs_setup.ts","webpack://ollieos/./src/kernel/windowing.ts","webpack://ollieos/./src/window_impl/dom.ts","webpack://ollieos/./src/load_global_externals.ts","webpack://ollieos/./src/os_loader.ts"],"sourcesContent":["import {IDisposable, ITerminalOptions, Terminal} from \"@xterm/xterm\";\r\nimport type {KeyEvent, KeyEventHandler, RegisteredKeyEventIdentifier} from \"../types\";\r\n\r\nexport const NEWLINE = \"\\r\\n\";\r\n/* eslint-disable-next-line no-control-regex, no-misleading-character-class */\r\nexport const NON_PRINTABLE_REGEX = /[\\0-\\x1F\\x7F-\\x9F\\xAD\\u0378\\u0379\\u037F-\\u0383\\u038B\\u038D\\u03A2\\u0528-\\u0530\\u0557\\u0558\\u0560\\u0588\\u058B-\\u058E\\u0590\\u05C8-\\u05CF\\u05EB-\\u05EF\\u05F5-\\u0605\\u061C\\u061D\\u06DD\\u070E\\u070F\\u074B\\u074C\\u07B2-\\u07BF\\u07FB-\\u07FF\\u082E\\u082F\\u083F\\u085C\\u085D\\u085F-\\u089F\\u08A1\\u08AD-\\u08E3\\u08FF\\u0978\\u0980\\u0984\\u098D\\u098E\\u0991\\u0992\\u09A9\\u09B1\\u09B3-\\u09B5\\u09BA\\u09BB\\u09C5\\u09C6\\u09C9\\u09CA\\u09CF-\\u09D6\\u09D8-\\u09DB\\u09DE\\u09E4\\u09E5\\u09FC-\\u0A00\\u0A04\\u0A0B-\\u0A0E\\u0A11\\u0A12\\u0A29\\u0A31\\u0A34\\u0A37\\u0A3A\\u0A3B\\u0A3D\\u0A43-\\u0A46\\u0A49\\u0A4A\\u0A4E-\\u0A50\\u0A52-\\u0A58\\u0A5D\\u0A5F-\\u0A65\\u0A76-\\u0A80\\u0A84\\u0A8E\\u0A92\\u0AA9\\u0AB1\\u0AB4\\u0ABA\\u0ABB\\u0AC6\\u0ACA\\u0ACE\\u0ACF\\u0AD1-\\u0ADF\\u0AE4\\u0AE5\\u0AF2-\\u0B00\\u0B04\\u0B0D\\u0B0E\\u0B11\\u0B12\\u0B29\\u0B31\\u0B34\\u0B3A\\u0B3B\\u0B45\\u0B46\\u0B49\\u0B4A\\u0B4E-\\u0B55\\u0B58-\\u0B5B\\u0B5E\\u0B64\\u0B65\\u0B78-\\u0B81\\u0B84\\u0B8B-\\u0B8D\\u0B91\\u0B96-\\u0B98\\u0B9B\\u0B9D\\u0BA0-\\u0BA2\\u0BA5-\\u0BA7\\u0BAB-\\u0BAD\\u0BBA-\\u0BBD\\u0BC3-\\u0BC5\\u0BC9\\u0BCE\\u0BCF\\u0BD1-\\u0BD6\\u0BD8-\\u0BE5\\u0BFB-\\u0C00\\u0C04\\u0C0D\\u0C11\\u0C29\\u0C34\\u0C3A-\\u0C3C\\u0C45\\u0C49\\u0C4E-\\u0C54\\u0C57\\u0C5A-\\u0C5F\\u0C64\\u0C65\\u0C70-\\u0C77\\u0C80\\u0C81\\u0C84\\u0C8D\\u0C91\\u0CA9\\u0CB4\\u0CBA\\u0CBB\\u0CC5\\u0CC9\\u0CCE-\\u0CD4\\u0CD7-\\u0CDD\\u0CDF\\u0CE4\\u0CE5\\u0CF0\\u0CF3-\\u0D01\\u0D04\\u0D0D\\u0D11\\u0D3B\\u0D3C\\u0D45\\u0D49\\u0D4F-\\u0D56\\u0D58-\\u0D5F\\u0D64\\u0D65\\u0D76-\\u0D78\\u0D80\\u0D81\\u0D84\\u0D97-\\u0D99\\u0DB2\\u0DBC\\u0DBE\\u0DBF\\u0DC7-\\u0DC9\\u0DCB-\\u0DCE\\u0DD5\\u0DD7\\u0DE0-\\u0DF1\\u0DF5-\\u0E00\\u0E3B-\\u0E3E\\u0E5C-\\u0E80\\u0E83\\u0E85\\u0E86\\u0E89\\u0E8B\\u0E8C\\u0E8E-\\u0E93\\u0E98\\u0EA0\\u0EA4\\u0EA6\\u0EA8\\u0EA9\\u0EAC\\u0EBA\\u0EBE\\u0EBF\\u0EC5\\u0EC7\\u0ECE\\u0ECF\\u0EDA\\u0EDB\\u0EE0-\\u0EFF\\u0F48\\u0F6D-\\u0F70\\u0F98\\u0FBD\\u0FCD\\u0FDB-\\u0FFF\\u10C6\\u10C8-\\u10CC\\u10CE\\u10CF\\u1249\\u124E\\u124F\\u1257\\u1259\\u125E\\u125F\\u1289\\u128E\\u128F\\u12B1\\u12B6\\u12B7\\u12BF\\u12C1\\u12C6\\u12C7\\u12D7\\u1311\\u1316\\u1317\\u135B\\u135C\\u137D-\\u137F\\u139A-\\u139F\\u13F5-\\u13FF\\u169D-\\u169F\\u16F1-\\u16FF\\u170D\\u1715-\\u171F\\u1737-\\u173F\\u1754-\\u175F\\u176D\\u1771\\u1774-\\u177F\\u17DE\\u17DF\\u17EA-\\u17EF\\u17FA-\\u17FF\\u180F\\u181A-\\u181F\\u1878-\\u187F\\u18AB-\\u18AF\\u18F6-\\u18FF\\u191D-\\u191F\\u192C-\\u192F\\u193C-\\u193F\\u1941-\\u1943\\u196E\\u196F\\u1975-\\u197F\\u19AC-\\u19AF\\u19CA-\\u19CF\\u19DB-\\u19DD\\u1A1C\\u1A1D\\u1A5F\\u1A7D\\u1A7E\\u1A8A-\\u1A8F\\u1A9A-\\u1A9F\\u1AAE-\\u1AFF\\u1B4C-\\u1B4F\\u1B7D-\\u1B7F\\u1BF4-\\u1BFB\\u1C38-\\u1C3A\\u1C4A-\\u1C4C\\u1C80-\\u1CBF\\u1CC8-\\u1CCF\\u1CF7-\\u1CFF\\u1DE7-\\u1DFB\\u1F16\\u1F17\\u1F1E\\u1F1F\\u1F46\\u1F47\\u1F4E\\u1F4F\\u1F58\\u1F5A\\u1F5C\\u1F5E\\u1F7E\\u1F7F\\u1FB5\\u1FC5\\u1FD4\\u1FD5\\u1FDC\\u1FF0\\u1FF1\\u1FF5\\u1FFF\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u2072\\u2073\\u208F\\u209D-\\u209F\\u20BB-\\u20CF\\u20F1-\\u20FF\\u218A-\\u218F\\u23F4-\\u23FF\\u2427-\\u243F\\u244B-\\u245F\\u2700\\u2B4D-\\u2B4F\\u2B5A-\\u2BFF\\u2C2F\\u2C5F\\u2CF4-\\u2CF8\\u2D26\\u2D28-\\u2D2C\\u2D2E\\u2D2F\\u2D68-\\u2D6E\\u2D71-\\u2D7E\\u2D97-\\u2D9F\\u2DA7\\u2DAF\\u2DB7\\u2DBF\\u2DC7\\u2DCF\\u2DD7\\u2DDF\\u2E3C-\\u2E7F\\u2E9A\\u2EF4-\\u2EFF\\u2FD6-\\u2FEF\\u2FFC-\\u2FFF\\u3040\\u3097\\u3098\\u3100-\\u3104\\u312E-\\u3130\\u318F\\u31BB-\\u31BF\\u31E4-\\u31EF\\u321F\\u32FF\\u4DB6-\\u4DBF\\u9FCD-\\u9FFF\\uA48D-\\uA48F\\uA4C7-\\uA4CF\\uA62C-\\uA63F\\uA698-\\uA69E\\uA6F8-\\uA6FF\\uA78F\\uA794-\\uA79F\\uA7AB-\\uA7F7\\uA82C-\\uA82F\\uA83A-\\uA83F\\uA878-\\uA87F\\uA8C5-\\uA8CD\\uA8DA-\\uA8DF\\uA8FC-\\uA8FF\\uA954-\\uA95E\\uA97D-\\uA97F\\uA9CE\\uA9DA-\\uA9DD\\uA9E0-\\uA9FF\\uAA37-\\uAA3F\\uAA4E\\uAA4F\\uAA5A\\uAA5B\\uAA7C-\\uAA7F\\uAAC3-\\uAADA\\uAAF7-\\uAB00\\uAB07\\uAB08\\uAB0F\\uAB10\\uAB17-\\uAB1F\\uAB27\\uAB2F-\\uABBF\\uABEE\\uABEF\\uABFA-\\uABFF\\uD7A4-\\uD7AF\\uD7C7-\\uD7CA\\uD7FC-\\uF8FF\\uFA6E\\uFA6F\\uFADA-\\uFAFF\\uFB07-\\uFB12\\uFB18-\\uFB1C\\uFB37\\uFB3D\\uFB3F\\uFB42\\uFB45\\uFBC2-\\uFBD2\\uFD40-\\uFD4F\\uFD90\\uFD91\\uFDC8-\\uFDEF\\uFDFE\\uFDFF\\uFE1A-\\uFE1F\\uFE27-\\uFE2F\\uFE53\\uFE67\\uFE6C-\\uFE6F\\uFE75\\uFEFD-\\uFF00\\uFFBF-\\uFFC1\\uFFC8\\uFFC9\\uFFD0\\uFFD1\\uFFD8\\uFFD9\\uFFDD-\\uFFDF\\uFFE7\\uFFEF-\\uFFFB\\uFFFE\\uFFFF]/g;\r\nexport const ANSI_ESCAPE_REGEX = /(\\\\u001b|\\\\x1b)(8|7|H|>|\\[(\\?\\d+(h|l)|[0-2]?(K|J)|\\d*(A|B|C|D\\D|E|F|G|g|i|m|n|S|s|T|u)|1000D\\d+|\\d*;\\d*(f|H|r|m)|\\d+;\\d+;\\d+m))/g;\r\n\r\n// eslint-disable-next-line no-control-regex, no-misleading-character-class\r\nexport const ANSI_UNESCAPED_REGEX = /(\\u001b|\\x1b)\\[(\\d+)?(;\\d+)*m/g;\r\n\r\n\r\nconst FG = {\r\n    reset: \"\\x1B[39m\",\r\n    black: \"\\x1B[30m\",\r\n    red: \"\\x1B[31m\",\r\n    green: \"\\x1B[32m\",\r\n    yellow: \"\\x1B[33m\",\r\n    blue: \"\\x1B[34m\",\r\n    magenta: \"\\x1B[35m\",\r\n    cyan: \"\\x1B[36m\",\r\n    white: \"\\x1B[37m\",\r\n    gray: \"\\x1B[90m\"\r\n};\r\n\r\nconst BG = {\r\n    reset: \"\\x1B[49m\",\r\n    black: \"\\x1B[40m\",\r\n    red: \"\\x1B[41m\",\r\n    green: \"\\x1B[42m\",\r\n    yellow: \"\\x1B[44m\",\r\n    blue: \"\\x1B[44m\",\r\n    magenta: \"\\x1B[45m\",\r\n    cyan: \"\\x1B[46m\",\r\n    white: \"\\x1B[47m\",\r\n    gray: \"\\x1B[100m\"\r\n}\r\n\r\nconst STYLE = {\r\n    reset_all: \"\\x1B[0m\",\r\n    bold: \"\\x1B[1m\",\r\n    dim: \"\\x1B[2m\",\r\n    no_bold_or_dim: \"\\x1B[22m\",\r\n    italic: \"\\x1B[3m\",\r\n    no_italic: \"\\x1B[23m\",\r\n    underline: \"\\x1B[4m\",\r\n    double_underline: \"\\x1B[21m\",\r\n    no_underline: \"\\x1B[24m\",\r\n    inverse: \"\\x1B[7m\",\r\n    no_inverse: \"\\x1B[27m\",\r\n    hidden: \"\\x1B[8m\",\r\n    no_hidden: \"\\x1B[28m\",\r\n    strikethrough: \"\\x1B[9m\",\r\n    no_strikethrough: \"\\x1B[29m\",\r\n    negative: \"\\x1B[7m\",\r\n    positive: \"\\x1B[27m\"\r\n}\r\n\r\nconst CURSOR = {\r\n    // TODO: move cursor manipulation from edit to substitution functions here\r\n    invisible: \"\\x1B[?25l\",\r\n    visible: \"\\x1B[?25h\",\r\n}\r\n\r\nconst PREFABS = {\r\n    program_name: FG.cyan + STYLE.italic + STYLE.bold,\r\n    error: FG.red + STYLE.bold,\r\n    variable_name: FG.yellow + STYLE.bold,\r\n    file_path: FG.green + STYLE.bold,\r\n    dir_name: FG.blue + STYLE.bold,\r\n    secret: STYLE.hidden + CURSOR.invisible,\r\n}\r\n\r\nexport const ANSI = {\r\n    FG,\r\n    BG,\r\n    STYLE,\r\n    CURSOR,\r\n    PREFABS\r\n}\r\n\r\n\r\n// TODO: docstrings everywhere\r\n\r\nexport interface ReadLineBuffer {\r\n    current_line: string;\r\n    current_index: number;\r\n    set_current_line: (new_line: string) => void;\r\n    set_current_index: (new_index: number) => void;\r\n}\r\n\r\nexport type ReadLineKeyHandler = (event: KeyEvent, term: WrappedTerminal, buffer: ReadLineBuffer) => void | Promise<void> | boolean | Promise<boolean>;\r\n\r\nexport class WrappedTerminal extends Terminal {\r\n    #disposable_onkey: IDisposable;\r\n\r\n    readonly #key_handlers: Map<RegisteredKeyEventIdentifier, { handler: KeyEventHandler, block: boolean }[]> = new Map();\r\n    readonly #on_printable_handlers: KeyEventHandler[] = [];\r\n    readonly #key_event_queue: KeyEvent[] = [];\r\n    #is_handling_key_events = false;\r\n\r\n    #kernel_has_panicked = false;\r\n\r\n    // TODO: this exporting is a bit lazy, but it works for now\r\n\r\n    get ansi() {\r\n        return ANSI;\r\n    }\r\n\r\n    get newline() {\r\n        return NEWLINE;\r\n    }\r\n\r\n    get non_printable_regex() {\r\n        return NON_PRINTABLE_REGEX;\r\n    }\r\n\r\n    get ansi_escape_regex() {\r\n        return ANSI_ESCAPE_REGEX;\r\n    }\r\n\r\n    get ansi_unescaped_regex() {\r\n        return ANSI_UNESCAPED_REGEX;\r\n    }\r\n\r\n    // line discipline now completely handled by read_line, no global event loop\r\n    read_line = async (custom_key_handlers: { [key_string: string]: ReadLineKeyHandler } = {}, custom_printable_handler?: ReadLineKeyHandler): Promise<string> => {\r\n        const buffer: ReadLineBuffer = {\r\n            current_line: \"\",\r\n            current_index: 0,\r\n\r\n            set_current_line: (new_line: string) => {\r\n                buffer.current_line = new_line;\r\n            },\r\n\r\n            set_current_index: (new_index: number) => {\r\n                buffer.current_index = new_index;\r\n            }\r\n        };\r\n\r\n        let handler_dispose: (() => void) | null = null;\r\n\r\n        return new Promise<string>((resolve) => {\r\n            const handlers: { [key_string: string]: KeyEventHandler } = {\r\n                // arrow left - move cursor left\r\n                \"\\x1b[D\": (_e, term) => {\r\n                    if (buffer.current_index > 0) {\r\n                        term.write(\"\\b\");\r\n                        buffer.current_index--;\r\n                    }\r\n                },\r\n\r\n                // arrow right - move cursor right\r\n                \"\\x1b[C\": (_e, term) => {\r\n                    if (buffer.current_index < buffer.current_line.length) {\r\n                        term.write(buffer.current_line[buffer.current_index]);\r\n                        buffer.current_index++;\r\n                    }\r\n                },\r\n\r\n                // backspace - delete character\r\n                \"\\x7F\": (_e, term) => {\r\n                    if (buffer.current_line.length > 0 && buffer.current_index > 0) {\r\n                        // get everything before the cursor\r\n                        const before = buffer.current_line.slice(0, buffer.current_index - 1);\r\n\r\n                        // get everything after the cursor\r\n                        const after = buffer.current_line.slice(buffer.current_index);\r\n\r\n                        // update current line\r\n                        buffer.current_line = before + after;\r\n\r\n                        // move cursor back one\r\n                        term.write(\"\\b\");\r\n\r\n                        // overwrite with after content and a space (remove last character)\r\n                        term.write(after + \" \");\r\n\r\n                        // move cursor back to original position\r\n                        term.write(\"\\b\".repeat(after.length + 1));\r\n                        buffer.current_index--;\r\n                    }\r\n                },\r\n\r\n                // enter - finish line\r\n                \"\\r\": (_e, term) => {\r\n                    if (handler_dispose) {\r\n                        handler_dispose();\r\n                    }\r\n\r\n                    term.write(NEWLINE);\r\n                    resolve(buffer.current_line);\r\n                }\r\n            }\r\n\r\n            // register blocking catch all key handler which handles all keys during read_line\r\n            handler_dispose = this.register_key_event_handler(\r\n                async (e) => {\r\n                    // check for custom handlers first\r\n                    if (e.key in custom_key_handlers) {\r\n                        const block = await custom_key_handlers[e.key](e, this, buffer);\r\n\r\n                        if (block) {\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    // check for builtin handlers\r\n                    if (e.key in handlers) {\r\n                        await handlers[e.key](e, this);\r\n                        return;\r\n                    }\r\n\r\n                    // check for printable characters\r\n                    if (e.key.match(NON_PRINTABLE_REGEX) === null) {\r\n                        if (custom_printable_handler) {\r\n                            const block = await custom_printable_handler(e, this, buffer);\r\n\r\n                            if (block) {\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        // if at the end of the line, just append the character\r\n                        if (buffer.current_index === buffer.current_line.length) {\r\n                            buffer.current_line += e.key;\r\n                            this.write(e.key);\r\n                            buffer.current_index++;\r\n                            return;\r\n                        }\r\n\r\n                        // insert the character at the cursor, shift the rest of the line to the right\r\n                        const before_cursor = buffer.current_line.slice(0, buffer.current_index);\r\n                        const after_cursor = buffer.current_line.slice(buffer.current_index);\r\n                        buffer.current_line = before_cursor + e.key + after_cursor;\r\n\r\n                        // write the new right of the line over the old one\r\n                        this.write(e.key + after_cursor);\r\n\r\n                        // move back to the cursor position\r\n                        this.write(`\\x1b[${after_cursor.length}D`);\r\n\r\n                        // increment the cursor position\r\n                        buffer.current_index++;\r\n                    } else {\r\n                        console.warn(\"Ignored key event:\", e);\r\n                        // TODO: handle more special keys and sequences (probably in shells)\r\n                    }\r\n                },\r\n                {\r\n                    block: true,\r\n                    high_priority: true\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    _search_handlers = (key: string | undefined, domEventCode: string | undefined, strict = false): { handler: KeyEventHandler, block: boolean }[] => {\r\n        for (const pair of this.#key_handlers.entries()) {\r\n            const identfier = pair[0] as RegisteredKeyEventIdentifier;\r\n\r\n            // if strict matching is required, both key and domEventCode must match\r\n            if (strict) {\r\n                if (identfier.key === key && identfier.domEventCode === domEventCode) {\r\n                    return pair[1] as { handler: KeyEventHandler, block: boolean }[];\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // if the identifier matches, return the entries\r\n            if (identfier.key === key || identfier.domEventCode === domEventCode) {\r\n                return pair[1] as { handler: KeyEventHandler, block: boolean }[];\r\n            }\r\n        }\r\n\r\n        // if no match is found, return an empty array\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Registers a key event handler.\r\n     * Handlers with no filter run BEFORE filtered handlers.\r\n     *\r\n     * @param {KeyEventHandler} handler The handler to register\r\n     * @param {{ keyString?: string, domEventCode?: string, block: boolean, high_priority: boolean }} props The properties of the handler. Key is the key as a string to filter by, domEventCode is the DOM event code to filter by. Block determines whether the event should be blocked from bubbling up to following handlers and/or the terminal display. High priority determines whether the handler should be placed at the beginning of the handler list.\r\n     * @returns {() => () => void} A function to unregister the handler\r\n     */\r\n    register_key_event_handler = (handler: KeyEventHandler, props: { keyString?: string, domEventCode?: string, block?: boolean, high_priority?: boolean }) => {\r\n        // build the identifier\r\n        const identifier: RegisteredKeyEventIdentifier = {\r\n            key: props.keyString,\r\n            domEventCode: props.domEventCode\r\n        };\r\n\r\n        const entry = { handler, block: props.block ?? false };\r\n\r\n        // if the identifier has not already been registered, create a new array for it\r\n        const existing_entries = this._search_handlers(props.keyString, props.domEventCode, true);\r\n        if (existing_entries.length === 0) {\r\n            this.#key_handlers.set(identifier, [entry]);\r\n        } else {\r\n            // otherwise, add the handler to the existing array\r\n            // NOTE: reference is retained so no need to search\r\n            if (props.high_priority) {\r\n                existing_entries.unshift(entry);\r\n            } else {\r\n                existing_entries.push(entry);\r\n            }\r\n        }\r\n\r\n        // return a function to unregister the handler\r\n        // NOTE: reference is retained so no need to search\r\n        return () => {\r\n            const handlers = this.#key_handlers.get(identifier);\r\n            if (!handlers) {\r\n                return;\r\n            }\r\n\r\n            handlers.splice(handlers.indexOf(entry), 1);\r\n\r\n            // if there are no more handlers for the identifier, remove the identifier from the map\r\n            if (handlers.length === 0) {\r\n                this.#key_handlers.delete(identifier);\r\n            }\r\n        }\r\n    }\r\n\r\n    _handle_key_event = async (e: KeyEvent): Promise<void> => {\r\n        // TODO: supress builtin key events when program is running, create ctrl+c handler\r\n\r\n        // look for any handlers against all keys\r\n        const all_key_entries = this._search_handlers(undefined, undefined, true);\r\n        if (all_key_entries) {\r\n            for (const entry of all_key_entries) {\r\n                // await if the handler is async\r\n                await entry.handler(e, this);\r\n\r\n                if (entry.block) {\r\n                    // if the handler is blocking, don't go to next handler or display logic\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // search the handlers for the key\r\n        const entries = this._search_handlers(e.key, e.domEvent.code);\r\n\r\n        // if there are any handlers, run them\r\n        for (const entry of entries) {\r\n            // await if the handler is async\r\n            await entry.handler(e, this);\r\n\r\n            if (entry.block) {\r\n                // if the handler is blocking, don't go to next handler or display logic\r\n                return;\r\n            }\r\n        }\r\n\r\n        // check if the key is printable\r\n        if (e.key.match(NON_PRINTABLE_REGEX) === null) {\r\n            // call any registered printable key handlers\r\n            for (const handler of this.#on_printable_handlers) {\r\n                await handler(e, this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers a handler that is called when any printable key is pressed.\r\n     * @param handler  - The handler to register\r\n     * @param high_priority - If true, the handler will be placed at the beginning of the handler list (cannot run before the default printable key handler)\r\n     */\r\n    register_on_printable_key_event_handler = (handler: KeyEventHandler, high_priority = false) => {\r\n        if (high_priority) {\r\n            this.#on_printable_handlers.unshift(handler);\r\n        } else {\r\n            this.#on_printable_handlers.push(handler);\r\n        }\r\n    }\r\n\r\n    _enqueue_key_event = (e: KeyEvent) => {\r\n        this.#key_event_queue.push(e);\r\n\r\n        // if the queue is not being handled, handle it\r\n        if (!this.#is_handling_key_events) {\r\n            this.#is_handling_key_events = true;\r\n            this._handle_key_event_queue();\r\n        }\r\n    }\r\n\r\n    _handle_key_event_queue = async () => {\r\n        // if there are no events in the queue, return\r\n        if (this.#key_event_queue.length === 0) {\r\n            this.#is_handling_key_events = false;\r\n            return;\r\n        }\r\n\r\n        if (this.#is_handling_key_events) {\r\n            // handle the first event in the queue\r\n            await this._handle_key_event(this.#key_event_queue.shift()!);\r\n\r\n            // handle the rest of the events in the queue\r\n            this._handle_key_event_queue();\r\n        }\r\n    }\r\n\r\n\r\n    // note that this does not recieve pasted input, use a key event handler for that\r\n    wait_for_keypress = async (): Promise<KeyEvent> => {\r\n        // dispose of the current key handler (block bubbling)\r\n        this.#disposable_onkey.dispose();\r\n\r\n        return new Promise((resolve) => {\r\n            this.#disposable_onkey = this.onKey((e) => {\r\n                // dispose of this handler\r\n                this.#disposable_onkey.dispose();\r\n\r\n                // re-register the original handler\r\n                this.#disposable_onkey = this.onKey(this._enqueue_key_event);\r\n\r\n                // resolve the promise\r\n                resolve(e);\r\n            });\r\n        });\r\n    }\r\n\r\n    get_text = async (max_length?: number): Promise<string> => {\r\n        let text = \"\";\r\n\r\n        return new Promise((resolve) => {\r\n            const unregister_handler = this.register_key_event_handler(\r\n                (e) => {\r\n                    if (e.key === \"\\r\") {\r\n                        // if the key is enter, return the text\r\n                        unregister_handler();\r\n                        resolve(text);\r\n                    } else if (e.key === \"\\x7F\") {\r\n                        // if the key is backspace, remove the last character\r\n                        if (text.length > 0) {\r\n                            text = text.slice(0, -1);\r\n                            this.write(\"\\b \\b\");\r\n                        }\r\n                    } else if (e.key.match(NON_PRINTABLE_REGEX) === null) {\r\n                        // if the key is printable, add it to the text\r\n                        if (max_length === undefined || text.length < max_length) {\r\n                            text += e.key;\r\n                            this.write(e.key);\r\n                        }\r\n                    }\r\n                },\r\n                {\r\n                    block: true,\r\n                    high_priority: true\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    word_wrap(text: string, width: number): string {\r\n        const lines = text.split(NEWLINE);\r\n        const wrapped_lines: string[] = [];\r\n\r\n        for (const line of lines) {\r\n            const words = line.split(\" \");\r\n            let current_line = \"\";\r\n\r\n            for (const word of words) {\r\n                if (current_line.length + word.length + 1 > width) {\r\n                    // push word by word until the line is full\r\n                    wrapped_lines.push(current_line);\r\n                    current_line = word;\r\n                } else {\r\n                    // if the current line is empty, don't add a space\r\n                    if (current_line.length === 0) {\r\n                        current_line = word;\r\n                    } else {\r\n                        current_line += \" \" + word;\r\n                    }\r\n                }\r\n            }\r\n\r\n            wrapped_lines.push(current_line);\r\n        }\r\n\r\n        return wrapped_lines.join(NEWLINE);\r\n    }\r\n\r\n    copy() {\r\n        // copy the selected text to the clipboard\r\n        navigator.clipboard.writeText(this.getSelection()).then(() => {\r\n            // clear the selection\r\n            this.clearSelection();\r\n        });\r\n    }\r\n\r\n    paste() {\r\n        if (this.#kernel_has_panicked) {\r\n            return;\r\n        }\r\n\r\n        // TODO: sometimes has issues with large text (queue consumption not restarted properly after execution)\r\n        // read the clipboard\r\n        navigator.clipboard.readText().then((text) => {\r\n            // simulate key events for each character (lazy but it works great, no need to rewrite the key handler)\r\n            for (const char of text) {\r\n                let dom_event_code = `Key${char.toUpperCase()}`;\r\n                let key = char;\r\n\r\n                if (char === \"\\r\") {\r\n                    // skip, its CRLF\r\n                    continue;\r\n                }\r\n\r\n                if (char === \"\\n\") {\r\n                    key = \"\\r\";\r\n                    dom_event_code = \"Enter\";\r\n                }\r\n\r\n                if (char === \" \") {\r\n                    dom_event_code = \"Space\";\r\n                }\r\n\r\n                this.#key_event_queue.push(({ key, domEvent: { code: dom_event_code } } as KeyEvent));\r\n            }\r\n\r\n            // if the queue is not being handled, handle it\r\n            if (!this.#is_handling_key_events) {\r\n                this.#is_handling_key_events = true;\r\n                this._handle_key_event_queue();\r\n            }\r\n        });\r\n    }\r\n\r\n    copy_or_paste() {\r\n        // if there is a selection, copy it\r\n        if (this.hasSelection()) {\r\n            this.copy();\r\n        } else {\r\n            this.paste();\r\n        }\r\n    }\r\n\r\n    handle_kernel_panic = (message: string, process_info: string, debug_info?: string) => {\r\n        if (this.#kernel_has_panicked) {\r\n            return;\r\n        }\r\n\r\n        this.#kernel_has_panicked = true;\r\n\r\n        this.reset();\r\n\r\n        // stop reading key events\r\n        this.#disposable_onkey.dispose();\r\n        this.write(ANSI.CURSOR.invisible);\r\n\r\n        if (this.textarea) {\r\n            this.textarea.disabled = true;\r\n        }\r\n\r\n        this.writeln(`${ANSI.BG.red + ANSI.FG.white}Panic: ${message}`);\r\n        this.writeln(`at time: ${new Date().toISOString()}`);\r\n\r\n        this.write(NEWLINE);\r\n        this.writeln(\"Debug info:\");\r\n        if (debug_info) {\r\n            this.writeln(debug_info);\r\n        } else {\r\n            this.writeln(\"No debug info provided.\");\r\n        }\r\n\r\n        this.write(NEWLINE);\r\n        this.writeln(\"Processes running at time of panic:\");\r\n        this.writeln(process_info || \"None.\");\r\n\r\n        if (typeof window !== \"undefined\") {\r\n            this.write(NEWLINE);\r\n            this.writeln(\"OS unrecoverable?\")\r\n            this.writeln(`Visit ${window.location.origin}/recover_fs if stuck.`);\r\n        }\r\n\r\n        this.writeln(ANSI.STYLE.reset_all);\r\n    }\r\n\r\n    constructor(xterm_opts?: ITerminalOptions) {\r\n        super(xterm_opts);\r\n        this.#disposable_onkey = this.onKey(this._enqueue_key_event);\r\n    }\r\n}\r\n\r\n// TODO: term needs hardening and possibly userspace protection to ensure programs cant dispatch keys to auto accept elevation prompts\r\n\r\n// as of 09/01/2026, the god class of WrappedTerminal is no more!\r\n// this used to be the kernel, shell, tty, and bootstrap all in one\r\n","import type { Program, ProgramRegistrant } from \"../types\";\r\nimport type { AbstractFileSystem } from \"./filesystem\";\r\nimport { ANSI, WrappedTerminal } from \"./term_ctl\";\r\n\r\nconst encode_js_to_url = (js_code: string): string => {\r\n    const encoded = encodeURIComponent(js_code);\r\n    return `data:text/javascript;charset=utf-8,${encoded}`;\r\n}\r\n\r\nexport const build_registrant_from_js = async (js_code: string, built_in = false): Promise<ProgramRegistrant> => {\r\n    // inspect the js code to see if it starts with \"import\". if so, this is outdated, put a deprecation warning\r\n    let warn_deprecation = false;\r\n    if (js_code.startsWith(\"import\")) {\r\n        // delay the warning as we might find out the program name later\r\n        warn_deprecation = true;\r\n    }\r\n\r\n    // note: the webpackIgnore bypasses webpack's import() function and uses the browser's native import() function\r\n    // this is because webpack's import() function does not support data urls\r\n\r\n    const data_url = encode_js_to_url(js_code);\r\n    // note: risk to user, show warning\r\n    // TODO: explore sandboxing via webworkers or other methods\r\n    const imp = await import(/* webpackIgnore: true */data_url);\r\n    let program = imp.default;\r\n\r\n    if (program === undefined) {\r\n        if (warn_deprecation) {\r\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\r\n        }\r\n\r\n        throw new Error(\"Program is not the default export.\");\r\n    }\r\n\r\n    // validate program\r\n    if (typeof program !== \"object\") {\r\n        if (warn_deprecation) {\r\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\r\n        }\r\n\r\n        throw new Error(\"Program is not an object.\");\r\n    }\r\n\r\n    program = program as object;\r\n\r\n    if (typeof program.name !== \"string\") {\r\n        if (warn_deprecation) {\r\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\r\n        }\r\n\r\n        throw new Error(\"Program does not have a name.\");\r\n    }\r\n\r\n    if (warn_deprecation) {\r\n        console.warn(`Program ${program.name} has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.`);\r\n    }\r\n\r\n    // not warning about compat here to make it more obvious to end users when they try to run an incompatible program\r\n\r\n    if (globalThis.OLLIEOS_NODE && program.node_opt_out) {\r\n        throw new Error(`Program ${program.name} is not compatible with Node.js.`);\r\n    }\r\n\r\n    if (typeof program.description !== \"string\") {\r\n        throw new Error(`Program ${program.name} does not have a description.`);\r\n    }\r\n\r\n    if (typeof program.usage_suffix !== \"string\") {\r\n        throw new Error(`Program ${program.name} does not have a usage suffix.`);\r\n    }\r\n\r\n    if (typeof program.arg_descriptions !== \"object\") {\r\n        throw new Error(`Program ${program.name} does not have argument descriptions.`);\r\n    }\r\n\r\n    // migration: we got rid of syncprogram (with main) and asyncprogram (async_main)\r\n    // now there is a single async type called program\r\n    // problem: older packages have a field called async_main, and some have main that doesn't return a promise\r\n    if (!program.main) {\r\n        if (!program.async_main) {\r\n            throw new Error(`Program ${program.name} does not have a main function.`);\r\n        }\r\n\r\n        console.warn(`Program ${program.name} has an async_main function. This is deprecated and will be removed in the future. Please use main instead.`);\r\n\r\n        // migrate: rename async_main to main\r\n        program.main = program.async_main;\r\n        delete program.async_main;\r\n    }\r\n\r\n    if (program.main !== undefined && program.async_main !== undefined) {\r\n        throw new Error(`Program ${program.name} has both a main and async_main (deprecated) function.`);\r\n    }\r\n\r\n    // check if main is async\r\n    if (program.main !== undefined && program.main.constructor.name !== \"AsyncFunction\") {\r\n        console.warn(`Program ${program.name} has a main function that is not async. This is deprecated and will be removed in the future. Please make main async.`);\r\n\r\n        // migrate: wrap main in an async function\r\n        const old_main = program.main;\r\n        program.main = async (data) => {\r\n            return old_main(data);\r\n        }\r\n    }\r\n\r\n    program = program as Program;\r\n\r\n    // can't check what it takes and returns because javascript!\r\n    // just register it and the user can deal with the error if it doesn't work\r\n\r\n    return {\r\n        program,\r\n        built_in,\r\n    };\r\n}\r\n\r\nexport const determine_program_name_from_js = async (js_code: string): Promise<string> => {\r\n    const reg = await build_registrant_from_js(js_code);\r\n    return reg.program.name;\r\n}\r\n\r\n\r\n// mounts and registers a program and outputs errors to the terminal\r\nexport const mount_and_register_with_output = async (filename: string, content: string, prog_reg: ProgramRegistry | UserspaceProgramRegistry, term: WrappedTerminal, output_success = false) => {\r\n    const { PREFABS, FG, STYLE } = ANSI;\r\n\r\n    let reg: ProgramRegistrant;\r\n\r\n    try {\r\n        reg = await build_registrant_from_js(content);\r\n    } catch (e) {\r\n        if (e.message.endsWith(\"is not compatible with Node.js.\")) {\r\n            // silently skip node.js incompatible programs\r\n            // yes this is a weird way to do it, but better than changing how build_registrant works\r\n            return;\r\n        }\r\n\r\n        term.writeln(`${PREFABS.error}Failed to prepare program from '${filename}'.${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}${e}${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}Skipping mount...${STYLE.reset_all}`);\r\n        return;\r\n    }\r\n\r\n    try {\r\n        await prog_reg.registerProgram(reg);\r\n\r\n        if (output_success) {\r\n            term.writeln(`${FG.cyan}(+) ${reg.program.name}${STYLE.reset_all}`);\r\n        }\r\n    } catch (e) {\r\n        term.writeln(`${PREFABS.error}Failed to mount program '${reg.program.name}'.${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}${e}${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}Skipping mount...${STYLE.reset_all}`);\r\n    }\r\n}\r\n\r\n// recurses through a directory and mounts and registers all programs in it as well as its subdirectories\r\nexport const recurse_mount_and_register_with_output = async (fs: AbstractFileSystem, dir_path: string, prog_registry: ProgramRegistry | UserspaceProgramRegistry, term: WrappedTerminal) => {\r\n    const entries = await fs.list_dir(dir_path);\r\n\r\n    for (const entry of entries) {\r\n        const entry_path = fs.join(dir_path, entry);\r\n\r\n        if (await fs.dir_exists(entry_path)) {\r\n            await recurse_mount_and_register_with_output(fs, entry_path, prog_registry, term);\r\n        } else {\r\n            if (!entry.endsWith(\".js\")) {\r\n                continue;\r\n            }\r\n\r\n            const content = await fs.read_file(entry_path) as string;\r\n            await mount_and_register_with_output(entry, content, prog_registry, term);\r\n        }\r\n    }\r\n}\r\n\r\n// TODO: these 2 methods are a bit messy! perhaps remove the output stuff and just have the user deal with it\r\n\r\nexport interface UserspaceProgramRegistry {\r\n    getProgram(name: string): Program | undefined;\r\n    listProgramNames(includes_builtin?: boolean, includes_mounted?: boolean): string[];\r\n    registerProgram(program_reg: ProgramRegistrant): Promise<void>;\r\n    unregister(name: string): Promise<void>;\r\n    forceUnregister(name: string): Promise<void>;\r\n    build_registrant_from_js(js_code: string, built_in?: boolean): Promise<ProgramRegistrant>;\r\n    determine_program_name_from_js(js_code: string): Promise<string>;\r\n    mount_and_register_with_output(filename: string, content: string, term: WrappedTerminal, output_success?: boolean): Promise<void>;\r\n    recurse_mount_and_register_with_output(fs: AbstractFileSystem, dir_path: string, term: WrappedTerminal): Promise<void>;\r\n}\r\n\r\nexport class ProgramRegistry {\r\n    readonly #program_regs: Map<string, ProgramRegistrant> = new Map();\r\n\r\n    async registerProgram(program_reg: ProgramRegistrant) {\r\n        const program = program_reg.program;\r\n\r\n        if (this.#program_regs.has(program.name)) {\r\n            throw new Error(`Program with name ${program.name} already exists.`);\r\n        }\r\n\r\n        if (globalThis.OLLIEOS_NODE && program.node_opt_out) {\r\n            // don't register this program if it is not compatible with node.js\r\n            return;\r\n        }\r\n\r\n        this.#program_regs.set(program.name, program_reg);\r\n    }\r\n\r\n\r\n    getProgramRegistrant(name: string): ProgramRegistrant | undefined {\r\n        return this.#program_regs.get(name);\r\n    }\r\n\r\n    getProgram(name: string): Program | undefined {\r\n        const program_reg = this.getProgramRegistrant(name);\r\n        if (program_reg === undefined) {\r\n            return undefined;\r\n        }\r\n\r\n        return program_reg.program;\r\n    }\r\n\r\n\r\n    listProgramRegistrants(includes_builtin = true, includes_mounted = false): ProgramRegistrant[] {\r\n        const arr = Array.from(this.#program_regs.values());\r\n\r\n        if (includes_builtin && includes_mounted) {\r\n            return arr;\r\n        }\r\n\r\n        if (includes_builtin && !includes_mounted) {\r\n            return arr.filter((program_reg) => program_reg.built_in);\r\n        }\r\n\r\n        if (!includes_builtin && includes_mounted) {\r\n            return arr.filter((program_reg) => !program_reg.built_in);\r\n        }\r\n    }\r\n\r\n    listProgramNames(includes_builtin = true, includes_mounted = false): string[] {\r\n        const arr = Array.from(this.#program_regs.keys());\r\n\r\n        if (includes_builtin && includes_mounted) {\r\n            return arr;\r\n        }\r\n\r\n        if (includes_builtin && !includes_mounted) {\r\n            return arr.filter((program_name) => this.getProgramRegistrant(program_name)?.built_in);\r\n        }\r\n\r\n        if (!includes_builtin && includes_mounted) {\r\n            return arr.filter((program_name) => !this.getProgramRegistrant(program_name)?.built_in);\r\n        }\r\n    }\r\n\r\n    listPrograms(includes_builtin = true, includes_mounted = false): Program[] {\r\n        return this.listProgramRegistrants(includes_builtin, includes_mounted).map((program_reg) => program_reg.program);\r\n    }\r\n\r\n\r\n    async forceUnregister(name: string) {\r\n        this.#program_regs.delete(name);\r\n    }\r\n\r\n    async unregister(name: string) {\r\n        if (!this.#program_regs.has(name)) {\r\n            throw new Error(`Program with name ${name} does not exist.`);\r\n        }\r\n\r\n        await this.forceUnregister(name);\r\n    }\r\n\r\n    // note that some methods above are async because the userspace proxy needs them to be async\r\n\r\n    // TODO: move usage of above methods to use class methods instead of the standalone functions\r\n\r\n    async build_registrant_from_js(js_code: string, built_in = false): Promise<ProgramRegistrant> {\r\n        return build_registrant_from_js(js_code, built_in);\r\n    }\r\n\r\n    async determine_program_name_from_js(js_code: string): Promise<string> {\r\n        return determine_program_name_from_js(js_code);\r\n    }\r\n\r\n    async mount_and_register_with_output(filename: string, content: string, term: WrappedTerminal, output_success = false) {\r\n        return mount_and_register_with_output(filename, content, this, term, output_success);\r\n    }\r\n\r\n    async recurse_mount_and_register_with_output(fs: AbstractFileSystem, dir_path: string, term: WrappedTerminal) {\r\n        return recurse_mount_and_register_with_output(fs, dir_path, this, term);\r\n    }\r\n\r\n    create_userspace_proxy(init_program: string, fs: AbstractFileSystem): UserspaceProgramRegistry {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        const check_protected = async (name: string) => {\r\n            const reg = self.getProgramRegistrant(name);\r\n\r\n            // userspace cannot unregister built-in programs\r\n            if (reg?.built_in) {\r\n                throw new Error(`Security Error: Built-in program '${name}' is protected and cannot be modified.`);\r\n            }\r\n\r\n            // userspace cannot unregister the loaded init system\r\n            // TODO: is this actually necessary security wise? it wont get run as kernel til next boot anyway. maybe the boot file should be protected instead?\r\n            if (name === init_program) {\r\n                throw new Error(`Security Error: The init system program '${name}' cannot be modified.`);\r\n            }\r\n\r\n            // userspace cannot unregister program referenced by /sys/privilege_agent\r\n            let privilege_agent_program = \"default_privilege_agent\";\r\n            try {\r\n                const pa_data = await fs.read_file(\"/sys/privilege_agent\") as string;\r\n                privilege_agent_program = pa_data.trim();\r\n            } catch {\r\n                // ignore error\r\n            }\r\n\r\n            if (!privilege_agent_program) {\r\n                privilege_agent_program = \"default_privilege_agent\";\r\n            }\r\n\r\n            if (name === privilege_agent_program) {\r\n                throw new Error(`Security Error: The privilege agent program '${name}' cannot be modified.`);\r\n            }\r\n        }\r\n\r\n        Object.defineProperties(proxy, {\r\n            getProgram: {\r\n                value: (name: string) => self.getProgram(name),\r\n                enumerable: true\r\n            },\r\n            listProgramNames: {\r\n                value: (inc_builtin?: boolean, inc_mounted?: boolean) =>\r\n                    self.listProgramNames(inc_builtin, inc_mounted),\r\n                enumerable: true\r\n            },\r\n            registerProgram: {\r\n                value: async (program_reg: ProgramRegistrant) => {\r\n                    if (program_reg.built_in) {\r\n                        throw new Error(\"Security Error: Cannot register built-in programs from userspace.\");\r\n                    }\r\n\r\n                    await check_protected(program_reg.program.name);\r\n                    await self.registerProgram(program_reg);\r\n                },\r\n                enumerable: true\r\n            },\r\n            unregister: {\r\n                value: async (name: string) => {\r\n                    await check_protected(name);\r\n                    await self.unregister(name);\r\n                },\r\n                enumerable: true\r\n            },\r\n            forceUnregister: {\r\n                value: async (name: string) => {\r\n                    await check_protected(name);\r\n                    await self.forceUnregister(name);\r\n                },\r\n                enumerable: true\r\n            },\r\n\r\n            // its fine to build the registrant as builtin, but not fine to register it\r\n            build_registrant_from_js: {\r\n                value: async (js_code: string, built_in = false) =>\r\n                    self.build_registrant_from_js(js_code, built_in),\r\n                enumerable: true\r\n            },\r\n            determine_program_name_from_js: {\r\n                value: async (js_code: string) =>\r\n                    self.determine_program_name_from_js(js_code),\r\n                enumerable: true\r\n            },\r\n\r\n            // ensure the proxy is used for these methods to enforce protections\r\n            mount_and_register_with_output: {\r\n                value: async (filename: string, content: string, term: WrappedTerminal, output_success = false) =>\r\n                    mount_and_register_with_output(filename, content, proxy, term, output_success),\r\n                enumerable: true\r\n            },\r\n            recurse_mount_and_register_with_output: {\r\n                value: async (dir_path: string, term: WrappedTerminal) =>\r\n                    recurse_mount_and_register_with_output(fs, dir_path, proxy, term),\r\n                enumerable: true\r\n            },\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\n// TODO: restructure methods to not need fs (i.e. move this closer to the kernel where fs is accessible)\r\n\r\n","export class PathNotFoundError extends Error {\r\n    constructor(path: string) {\r\n        super(`Path not found: ${path}`);\r\n    }\r\n}\r\n\r\nexport class NonRecursiveDirectoryError extends Error {\r\n    constructor(path: string) {\r\n        super(`Refusing to delete non-empty directory: ${path}`);\r\n    }\r\n}\r\n\r\nexport class MoveDestinationDirectoryNotEmptyError extends Error {\r\n    constructor(path: string) {\r\n        super(`Destination directory is not empty: ${path}`);\r\n    }\r\n}\r\n\r\nexport class ReadOnlyError extends Error {\r\n    constructor(path: string) {\r\n        super(`Path is read-only: ${path}`);\r\n    }\r\n}\r\n\r\nexport enum FSEventType {\r\n    READING_FILE,\r\n    WROTE_FILE,\r\n    DELETED_FILE,\r\n    MOVED_FILE,\r\n    SET_READONLY,\r\n\r\n    LISTING_DIR,\r\n    MADE_DIR,\r\n    DELETED_DIR,\r\n    MOVED_DIR,\r\n\r\n    SET_CWD,\r\n    GETTING_CWD,\r\n    SET_HOME,\r\n    GETTING_HOME,\r\n    SET_ROOT,\r\n    GETTING_ROOT,\r\n\r\n    CHECKING_EXISTS,\r\n    CHECKING_DIR_EXISTS,\r\n}\r\n\r\n// TODO: ensure all functions fire these events... or do we even need this system other than for cwd changing?\r\n\r\nexport type FSEventHandler = (data: string, fs: AbstractFileSystem) => void;\r\n\r\nexport interface UserspaceFileSystem {\r\n    get_unique_fs_type_name(): string;\r\n    erase_all(): Promise<void>;\r\n    purge_cache(smart?: boolean): void;\r\n    read_file(path: string, as_uint?: boolean): Promise<string | Uint8Array>;\r\n    write_file(path: string, data: string | Uint8Array, force?: boolean): Promise<void>;\r\n    delete_file(path: string): Promise<void>;\r\n    move_file(path: string, new_path: string): Promise<void>;\r\n    list_dir(path: string, dirs_first?: boolean): Promise<string[]>;\r\n    make_dir(path: string): Promise<void>;\r\n    delete_dir(path: string, recursive?: boolean): Promise<void>;\r\n    move_dir(src: string, dest: string, force_move_inside?: boolean): Promise<void>;\r\n    set_readonly(path: string, readonly: boolean): Promise<void>;\r\n    is_readonly(path: string): Promise<boolean>;\r\n    exists(path: string): Promise<boolean>;\r\n    dir_exists(path: string): Promise<boolean>;\r\n    join(base_dir: string, ...paths: string[]): string;\r\n    absolute(path: string): string;\r\n    get_cwd(): string;\r\n    set_cwd(path: string): void;\r\n    get_home(): string;\r\n    get_root(): string;\r\n}\r\n\r\n// TODO: could protect erase_all but then also need to check recursive deletion, doesnt really gain much\r\n\r\nexport abstract class AbstractFileSystem {\r\n    //TODO: dry\r\n\r\n    // note some members are conventionally private with _ prefix to allow implementations to access them\r\n    // they wont be exposed to userspace though\r\n\r\n    _initialised = false;\r\n\r\n    readonly #cache: Map<string, { readonly: boolean, content: string | Uint8Array, as_uint: boolean }> = new Map();\r\n    readonly #callbacks: Map<FSEventType, FSEventHandler[]> = new Map();\r\n\r\n    _root = \"/\";\r\n    _home = \"/home\";\r\n    _cwd = this._home;\r\n\r\n    abstract get_unique_fs_type_name(): string;\r\n    abstract erase_all(): Promise<void>;\r\n\r\n    abstract is_ready(): Promise<boolean>;\r\n\r\n    purge_cache(smart = false): void {\r\n        if (smart) {\r\n            for (const path in this.#cache) {\r\n                if (!this.exists_direct(path)) {\r\n                    this.#cache.delete(path);\r\n                }\r\n            }\r\n        } else {\r\n            this.#cache.clear();\r\n        }\r\n    }\r\n\r\n    force_remove_from_cache(path: string): void {\r\n        this.#cache.delete(path);\r\n    }\r\n\r\n    remote_purge_cache(smart: boolean): void {\r\n        localStorage.setItem(\"purge_cache\", smart.toString());\r\n    }\r\n\r\n    remote_remove_from_cache(path: string): void {\r\n        localStorage.setItem(\"remove_from_cache\", path);\r\n    }\r\n\r\n    #remote_listener(): void {\r\n        const purge_cache = localStorage.getItem(\"purge_cache\");\r\n        if (purge_cache) {\r\n            this.purge_cache(purge_cache === \"true\");\r\n            localStorage.removeItem(\"purge_cache\");\r\n        }\r\n\r\n        const remove_from_cache = localStorage.getItem(\"remove_from_cache\");\r\n        if (remove_from_cache) {\r\n            this.force_remove_from_cache(remove_from_cache);\r\n            localStorage.removeItem(\"remove_from_cache\");\r\n        }\r\n    }\r\n\r\n\r\n    register_callback(event_type: FSEventType, callback: FSEventHandler): () => void {\r\n        // if there are no callbacks for this event type, create an empty array\r\n        if (!this.#callbacks.has(event_type)) {\r\n            this.#callbacks.set(event_type, []);\r\n        }\r\n\r\n        // add callback to array\r\n        this.#callbacks.get(event_type).push(callback);\r\n\r\n        // return function to remove callback\r\n        return () => {\r\n            this.#callbacks.get(event_type).splice(this.#callbacks.get(event_type).indexOf(callback), 1);\r\n        }\r\n    }\r\n\r\n    _call_callbacks(event_type: FSEventType, data: string): void {\r\n        // call all callbacks\r\n        for (const callback of this.#callbacks.get(event_type) ?? []) {\r\n            callback(data, this);\r\n        }\r\n    }\r\n\r\n\r\n    abstract read_file_direct(path: string, as_uint: boolean): Promise<string | Uint8Array>;\r\n    abstract write_file_direct(path: string, data: string | Uint8Array): Promise<void>;\r\n    abstract delete_file_direct(path: string): Promise<void>;\r\n    // does not check if destination exists\r\n    abstract move_file_direct(src: string, new_path: string): Promise<void>;\r\n    abstract set_readonly_direct(path: string, readonly: boolean): Promise<void>;\r\n    abstract is_readonly_direct(path: string): Promise<boolean>;\r\n\r\n\r\n    async read_file(path: string, as_uint = false): Promise<string | Uint8Array> {\r\n        // prevent prototype pollution\r\n\r\n        this._call_callbacks(FSEventType.READING_FILE, path);\r\n\r\n        // check if file is in cache and still exists, as well as if it's the correct type\r\n        const cached = this.#cache.get(path);\r\n        if (cached && await this.exists(path) && cached.as_uint === as_uint) {\r\n            return this.#cache.get(path).content;\r\n        }\r\n\r\n        // if not, read it from disk and cache it\r\n        const content = await this.read_file_direct(path, as_uint);\r\n        this.#cache.set(path, { readonly: await this.is_readonly(path), content, as_uint });\r\n        return content;\r\n    }\r\n\r\n    async write_file(path: string, data: string | Uint8Array, force = false): Promise<void> {\r\n        // check if file is readonly\r\n        let readonly = false;\r\n        if (await this.exists(path)) {\r\n            readonly = await this.is_readonly(path);\r\n            \r\n            if (!force && readonly) {\r\n                throw new ReadOnlyError(path);\r\n            }\r\n        }\r\n\r\n        // write to disk and cache\r\n        this.#cache.set(path, { readonly, content: data, as_uint: data instanceof Uint8Array });\r\n        await this.write_file_direct(path, data);\r\n        this._call_callbacks(FSEventType.WROTE_FILE, path);\r\n    }\r\n\r\n    async delete_file(path: string): Promise<void> {\r\n        // delete from cache and disk\r\n        if (this.#cache.has(path)) {\r\n            this.#cache.delete(path);\r\n        }\r\n        await this.delete_file_direct(path);\r\n        this._call_callbacks(FSEventType.DELETED_FILE, path);\r\n    }\r\n\r\n    // does not check if destination exists\r\n    async move_file(path: string, new_path: string): Promise<void> {\r\n        // move in cache and disk\r\n        this.#cache.set(new_path, this.#cache.get(path));\r\n        this.#cache.delete(path);\r\n        await this.move_file_direct(path, new_path);\r\n        this._call_callbacks(FSEventType.MOVED_FILE, path);\r\n    }\r\n\r\n    async set_readonly(path: string, readonly: boolean): Promise<void> {\r\n        // check if file exists\r\n        if (!await this.exists(path)) {\r\n            throw new PathNotFoundError(path);\r\n        }\r\n\r\n        // set readonly in cache and disk\r\n        const entry = this.#cache.get(path);\r\n        if (entry) {\r\n            entry.readonly = readonly;\r\n            this.#cache.set(path, entry);\r\n        } else {\r\n            this.#cache.set(path, {readonly, content: await this.read_file(path), as_uint: false});\r\n        }\r\n\r\n        await this.set_readonly_direct(path, readonly);\r\n        this._call_callbacks(FSEventType.SET_READONLY, path);\r\n    }\r\n\r\n    async is_readonly(path: string): Promise<boolean> {\r\n        // check if file exists\r\n        if (!await this.exists(path)) {\r\n            throw new PathNotFoundError(path);\r\n        }\r\n\r\n        // check if file is in cache\r\n        const cached = this.#cache.get(path);\r\n        if (cached) {\r\n            return cached.readonly;\r\n        }\r\n\r\n        // if not, check on disk (cannot cache as would need to read content, causes recursive call)\r\n        return this.is_readonly_direct(path);\r\n    }\r\n\r\n\r\n    abstract list_dir(path: string, dirs_first?: boolean): Promise<string[]>;\r\n    // (recursive)\r\n    abstract make_dir(path: string): Promise<void>;\r\n    abstract delete_dir_direct(path: string, recursive: boolean): Promise<void>;\r\n    abstract move_dir_direct(src: string, dest: string, force_move_inside: boolean): Promise<void>;\r\n\r\n    async delete_dir(path: string, recursive = false): Promise<void> {\r\n        await this.delete_dir_direct(path, recursive);\r\n\r\n        // smart purge cache\r\n        this.purge_cache(true);\r\n    }\r\n\r\n    async move_dir(src: string, dest: string, force_move_inside = false): Promise<void> {\r\n        await this.move_dir_direct(src, dest, force_move_inside);\r\n\r\n        // smart purge cache\r\n        this.purge_cache(true);\r\n    }\r\n\r\n    get_cwd(): string {\r\n        this._call_callbacks(FSEventType.GETTING_CWD, this._cwd);\r\n        return this._cwd;\r\n    }\r\n\r\n    set_cwd(path: string): void {\r\n        // if path ends with /, remove it\r\n        if (path.endsWith(\"/\")) {\r\n            path = path.slice(0, -1);\r\n        }\r\n\r\n        // if path is empty, set to root\r\n        if (path === \"\") {\r\n            path = this._root;\r\n        }\r\n\r\n        this._cwd = path;\r\n        this._call_callbacks(FSEventType.SET_CWD, path);\r\n    }\r\n\r\n\r\n    get_home(): string {\r\n        this._call_callbacks(FSEventType.GETTING_HOME, this._home);\r\n        return this._home;\r\n    }\r\n\r\n    set_home(path: string): void {\r\n        this._home = path;\r\n        this._call_callbacks(FSEventType.SET_HOME, path);\r\n    }\r\n\r\n    get_root(): string {\r\n        this._call_callbacks(FSEventType.GETTING_ROOT, this._root);\r\n        return this._root;\r\n    }\r\n\r\n    set_root(path: string): void {\r\n        this._root = path;\r\n        this._call_callbacks(FSEventType.SET_ROOT, path);\r\n    }\r\n\r\n\r\n    abstract exists_direct(path: string): Promise<boolean>;\r\n    abstract dir_exists(path: string): Promise<boolean>;\r\n\r\n    async exists(path: string): Promise<boolean> {\r\n        // check if file is in cache\r\n        if (this.#cache.has(path)) {\r\n            return true;\r\n        }\r\n\r\n        // if not, check if it exists on disk\r\n        this._call_callbacks(FSEventType.CHECKING_EXISTS, path);\r\n        return this.exists_direct(path);\r\n    }\r\n\r\n    absolute(path: string): string {\r\n        // if path is blank, path is root\r\n        if (path === \"\") {\r\n            return this._root;\r\n        }\r\n\r\n        // if path is ., return cwd\r\n        // TODO: is it safer to run this assumption then do the rest of the code rather than do the following root/cwd checks?\r\n        if (path === \".\") {\r\n            return this._cwd;\r\n        }\r\n\r\n        // if path is ~, return home\r\n        // TODO: again, same for this and the later ~/ check\r\n        if (path === \"~\") {\r\n            return this._home;\r\n        }\r\n\r\n        // if path starts with cwd and doesn't contain .., it is absolute\r\n        if (path.startsWith(this._cwd) && !path.includes(\"..\")) {\r\n            return path;\r\n        }\r\n\r\n        // if path starts with root and doesn't contain .., it is absolute\r\n        if (path.startsWith(this._root) && !path.includes(\"..\")) {\r\n            return path;\r\n        }\r\n\r\n        // drop leading ./\r\n        if (path.startsWith(\"./\")) {\r\n            path = path.slice(2);\r\n        }\r\n\r\n\r\n        let effective_cwd = this._cwd;\r\n\r\n        // if path starts with .., step up the cwd\r\n        while (path.startsWith(\"..\") && effective_cwd !== this._root) {\r\n            path = path.slice(2);\r\n\r\n            // drop leading /\r\n            if (path.startsWith(\"/\")) {\r\n                path = path.slice(1);\r\n            }\r\n\r\n            effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\r\n        }\r\n\r\n        // TODO: doesn't support middle of path ..\r\n        // if path ends with .., remove the last part of the full path\r\n        while (path.endsWith(\"..\")) {\r\n            path = path.slice(0, path.lastIndexOf(\"..\"));\r\n\r\n            // drop trailing /\r\n            if (path.endsWith(\"/\")) {\r\n                path = path.slice(0, path.length - 1);\r\n            }\r\n\r\n            // slice path, slicing effective_cwd if path is empty\r\n            if (path === \"\") {\r\n                effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\r\n            } else {\r\n                path = path.slice(0, path.lastIndexOf(\"/\"));\r\n\r\n                if (path === \"\") {\r\n                    effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\r\n                }\r\n            }\r\n        }\r\n\r\n        // if path starts with ~/, replace it with home\r\n        if (path.startsWith(\"~/\")) {\r\n            path = path.slice(2);\r\n            effective_cwd = this._home;\r\n        }\r\n\r\n        // if path still starts with /, drop it\r\n        if (path.startsWith(\"/\")) {\r\n            path = path.slice(1);\r\n        }\r\n\r\n        return this.join(effective_cwd, path);\r\n    }\r\n\r\n    join(base_dir: string, ...paths: string[]): string {\r\n        // drop trailing /\r\n        if (base_dir.endsWith(\"/\")) {\r\n            base_dir = base_dir.slice(0, base_dir.length - 1);\r\n        }\r\n\r\n        // join base_dir and path, using slash if path is not empty\r\n        for (let path of paths) {\r\n            if (path.startsWith(\"/\")) {\r\n                path = path.slice(1);\r\n            }\r\n\r\n            if (path === \"\") {\r\n                continue;\r\n            }\r\n\r\n            base_dir += \"/\" + path;\r\n        }\r\n\r\n        return base_dir;\r\n    }\r\n\r\n    protected constructor() {\r\n        // check if the cache should be purged from remote changes\r\n        setInterval(() => this.#remote_listener(), 100);\r\n    }\r\n\r\n    static create_userspace_proxy(fs: AbstractFileSystem): UserspaceFileSystem {\r\n        const self = fs;\r\n        const proxy = Object.create(null);\r\n\r\n        // write protect certain kernel secured paths\r\n        const check_path = (path: string): string => {\r\n            const absolute_path = self.absolute(path);\r\n\r\n            const is_protected =\r\n                absolute_path === \"/sys\" ||\r\n                absolute_path.startsWith(\"/sys/\") ||\r\n                absolute_path === \"/boot\" ||\r\n                absolute_path.startsWith(\"/boot/\");\r\n\r\n            if (is_protected) {\r\n                throw new ReadOnlyError(absolute_path);\r\n            }\r\n\r\n            return absolute_path;\r\n        };\r\n\r\n        Object.defineProperties(proxy, {\r\n            get_unique_fs_type_name: { value: () => self.get_unique_fs_type_name(), enumerable: true },\r\n            erase_all: { value: () => self.erase_all(), enumerable: true },\r\n            purge_cache: { value: (smart?: boolean) => self.purge_cache(smart), enumerable: true },\r\n            read_file: { value: (path: string, as_uint?: boolean) => self.read_file(self.absolute(path), as_uint), enumerable: true },\r\n            list_dir: { value: (path: string, dirs_first?: boolean) => self.list_dir(self.absolute(path), dirs_first), enumerable: true },\r\n            exists: { value: (path: string) => self.exists(self.absolute(path)), enumerable: true },\r\n            dir_exists: { value: (path: string) => self.dir_exists(self.absolute(path)), enumerable: true },\r\n            is_readonly: {\r\n                value: async (path: string) => {\r\n                    try {\r\n                        check_path(path);\r\n                    } catch (e) {\r\n                        if (e instanceof ReadOnlyError) {\r\n                            return true;\r\n                        }\r\n\r\n                        throw e;\r\n                    }\r\n\r\n                    return await self.is_readonly(self.absolute(path));\r\n                },\r\n                enumerable: true\r\n            },\r\n            join: { value: (base: string, ...paths: string[]) => self.join(base, ...paths), enumerable: true },\r\n            absolute: { value: (path: string) => self.absolute(path), enumerable: true },\r\n            get_cwd: { value: () => self.get_cwd(), enumerable: true },\r\n            get_home: { value: () => self.get_home(), enumerable: true },\r\n            get_root: { value: () => self.get_root(), enumerable: true },\r\n            write_file: {\r\n                value: (path: string, data: string | Uint8Array, force?: boolean) =>\r\n                    self.write_file(check_path(path), data, force),\r\n                enumerable: true\r\n            },\r\n            delete_file: {\r\n                value: (path: string) => self.delete_file(check_path(path)),\r\n                enumerable: true\r\n            },\r\n            move_file: {\r\n                value: (path: string, new_path: string) => {\r\n                    return self.move_file(check_path(path), check_path(new_path));\r\n                },\r\n                enumerable: true\r\n            },\r\n            make_dir: {\r\n                value: (path: string) => self.make_dir(check_path(path)),\r\n                enumerable: true\r\n            },\r\n            delete_dir: {\r\n                value: (path: string, recursive?: boolean) => self.delete_dir(check_path(path), recursive),\r\n                enumerable: true\r\n            },\r\n            move_dir: {\r\n                value: (src: string, dest: string, move_inside?: boolean) => {\r\n                    return self.move_dir(check_path(src), check_path(dest), move_inside);\r\n                },\r\n                enumerable: true\r\n            },\r\n            set_readonly: {\r\n                value: (path: string, readonly: boolean) => self.set_readonly(check_path(path), readonly),\r\n                enumerable: true\r\n            },\r\n            set_cwd: { value: (path: string) => self.set_cwd(path), enumerable: true }\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\n// TODO: need a way to block programs from accessing the localstorage/OPFS themselves directly, maybe need a function wrapper for that to shadow it away?\r\n","import type {AbstractWindow, AbstractWindowManager} from \"./windowing\";\r\nimport type {AbstractShell} from \"../abstract_shell\";\r\nimport type {ParsedCommandLine} from \"./index\";\r\n\r\nexport interface IPCMessage {\r\n    from: number;\r\n    to: number;\r\n\r\n    data: unknown;\r\n}\r\n\r\nexport type IPCChannelListener = (msg: IPCMessage) => Promise<void>;\r\n\r\ninterface IPCChannel {\r\n    initiator: number;\r\n    peer: number;\r\n\r\n    initiator_to_peer_queue: IPCMessage[];\r\n    peer_to_initiator_queue: IPCMessage[];\r\n\r\n    // pid -> set of listeners\r\n    listeners: Map<number, Set<IPCChannelListener>>;\r\n}\r\n\r\nexport type IPCServiceOnConnectionCallback = (channel_id: number, from_pid: number) => Promise<void>;\r\n\r\ninterface IPCService {\r\n    pid: number;\r\n    on_connection: IPCServiceOnConnectionCallback;\r\n}\r\n\r\nexport const KERNEL_FAKE_PID = 0;\r\nconst UNASSIGNED_FAKE_PID = -1;\r\n\r\nexport interface UserspaceIPCManager {\r\n    service_register(name: string, on_connection: IPCServiceOnConnectionCallback): void;\r\n    service_unregister(name: string): void;\r\n    service_lookup(name: string): number | undefined;\r\n    create_channel(service_name: string): number | null;\r\n    destroy_channel(channel_id: number): void;\r\n    channel_listen(channel_id: number, listener: IPCChannelListener): boolean;\r\n    channel_unlisten(channel_id: number, listener: IPCChannelListener): boolean;\r\n    channel_send(channel_id: number, data: unknown): boolean;\r\n}\r\n\r\nexport class IPCManager {\r\n    readonly #process_manager: ProcessManager;\r\n\r\n    // service name -> IPCService\r\n    readonly #services: Map<string, IPCService> = new Map();\r\n\r\n    // channel id -> IPCChannel\r\n    readonly #channels: Map<number, IPCChannel> = new Map();\r\n    #next_channel_id = 1;\r\n\r\n    constructor(process_manager: ProcessManager) {\r\n        this.#process_manager = process_manager;\r\n\r\n        // clean up dead services and channels periodically\r\n        // TODO: add a global exit listener to process manager to be immediately notified of process exits\r\n        setInterval(() => {\r\n            // clean up services\r\n            for (const [name, service] of this.#services) {\r\n                const process = this.#process_manager.get_process(service.pid);\r\n                if (!process) {\r\n                    this.#services.delete(name);\r\n                }\r\n            }\r\n\r\n            // clean up channels\r\n            for (const [channel_id, channel] of this.#channels) {\r\n                const initiator_process = this.#process_manager.get_process(channel.initiator);\r\n                const peer_process = this.#process_manager.get_process(channel.peer);\r\n\r\n                if (!initiator_process || !peer_process) {\r\n                    this.#channels.delete(channel_id);\r\n                }\r\n            }\r\n        }, 10000);\r\n    }\r\n\r\n    dispose_all(): void {\r\n        this.#services.clear();\r\n        this.#channels.clear();\r\n    }\r\n\r\n    service_register(name: string, pid: number, on_connection: IPCServiceOnConnectionCallback): void {\r\n        this.#services.set(name, { pid, on_connection });\r\n    }\r\n\r\n    // TODO: disconnect callback? or change the on_connection to on_event with different event types\r\n\r\n    service_unregister(name: string): void {\r\n        this.#services.delete(name);\r\n    }\r\n\r\n    service_lookup(name: string): number | undefined {\r\n        const service = this.#services.get(name);\r\n\r\n        if (!service) {\r\n            return undefined;\r\n        }\r\n\r\n        // check if process is still running\r\n        const process = this.#process_manager.get_process(service.pid);\r\n        if (!process) {\r\n            this.#services.delete(name);\r\n            return undefined;\r\n        }\r\n\r\n        return service.pid;\r\n    }\r\n\r\n    create_direct_channel(initiator_pid: number, peer_pid: number): number {\r\n        const channel_id = this.#next_channel_id++;\r\n\r\n        this.#channels.set(channel_id, {\r\n            initiator: initiator_pid,\r\n            peer: peer_pid,\r\n\r\n            initiator_to_peer_queue: [],\r\n            peer_to_initiator_queue: [],\r\n\r\n            listeners: new Map(),\r\n        });\r\n\r\n        return channel_id;\r\n    }\r\n\r\n    create_channel(initiator_pid: number, service_name: string): number | null {\r\n        const peer_pid = this.service_lookup(service_name);\r\n\r\n        if (!peer_pid) {\r\n            return null;\r\n        }\r\n\r\n        const channel_id = this.create_direct_channel(initiator_pid, peer_pid);\r\n\r\n        // notify service of new connection without blocking\r\n        const service = this.#services.get(service_name)!;\r\n        service.on_connection(channel_id, initiator_pid).catch((err) => {\r\n            console.error(\"IPC service on_connection error:\", err);\r\n        });\r\n\r\n        return channel_id;\r\n    }\r\n\r\n    reserve_kernel_channel(): number {\r\n        return this.create_direct_channel(KERNEL_FAKE_PID, UNASSIGNED_FAKE_PID);\r\n    }\r\n\r\n    assign_kernel_channel(channel_id: number, peer_pid: number): boolean {\r\n        const channel = this.#channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        if (channel.initiator !== KERNEL_FAKE_PID || channel.peer !== UNASSIGNED_FAKE_PID) {\r\n            return false;\r\n        }\r\n\r\n        channel.peer = peer_pid;\r\n        return true;\r\n    }\r\n\r\n    destroy_channel(channel_id: number): void {\r\n        this.#channels.delete(channel_id);\r\n    }\r\n\r\n    channel_listen(channel_id: number, listening_pid: number, listener: IPCChannelListener): boolean {\r\n        const channel = this.#channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        if (channel.initiator !== listening_pid && channel.peer !== listening_pid) {\r\n            return false;\r\n        }\r\n\r\n        if (!channel.listeners.has(listening_pid)) {\r\n            channel.listeners.set(listening_pid, new Set());\r\n        }\r\n\r\n        channel.listeners.get(listening_pid)!.add(listener);\r\n        return true;\r\n    }\r\n\r\n    channel_unlisten(channel_id: number, listening_pid: number, listener: IPCChannelListener): boolean {\r\n        const channel = this.#channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        if (channel.initiator !== listening_pid && channel.peer !== listening_pid) {\r\n            return false;\r\n        }\r\n\r\n        const listeners = channel.listeners.get(listening_pid);\r\n        if (!listeners) {\r\n            return false;\r\n        }\r\n\r\n        listeners.delete(listener);\r\n        return true;\r\n    }\r\n\r\n    channel_send(channel_id: number, from_pid: number, data: unknown): boolean {\r\n        const channel = this.#channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        let msg: IPCMessage;\r\n        if (channel.initiator === from_pid) {\r\n            msg = {\r\n                from: from_pid,\r\n                to: channel.peer,\r\n                data,\r\n            };\r\n\r\n            channel.initiator_to_peer_queue.push(msg);\r\n        } else if (channel.peer === from_pid) {\r\n            msg = {\r\n                from: from_pid,\r\n                to: channel.initiator,\r\n                data,\r\n            };\r\n\r\n            channel.peer_to_initiator_queue.push(msg);\r\n        } else {\r\n            return false;\r\n        }\r\n\r\n        // notify listeners on the receiving end without blocking\r\n        const to_pid = msg.to;\r\n        const listeners = channel.listeners.get(to_pid);\r\n        if (listeners) {\r\n            for (const listener of listeners) {\r\n                listener(msg).catch((err) => {\r\n                    console.error(\"IPC channel listener error:\", err);\r\n                });\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    create_userspace_proxy(process_pid: number): UserspaceIPCManager {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        Object.defineProperties(proxy, {\r\n            service_register: { value: (name: string, on_connection: IPCServiceOnConnectionCallback) => {\r\n                self.service_register(name, process_pid, on_connection);\r\n            }, enumerable: true },\r\n            service_unregister: { value: (name: string) => {\r\n                self.service_unregister(name);\r\n            }, enumerable: true },\r\n            service_lookup: { value: (name: string) => {\r\n                return self.service_lookup(name);\r\n            }, enumerable: true },\r\n            create_channel: { value: (service_name: string) => {\r\n                return self.create_channel(process_pid, service_name);\r\n            }, enumerable: true },\r\n            destroy_channel: { value: (channel_id: number) => {\r\n                self.destroy_channel(channel_id);\r\n            }, enumerable: true },\r\n            channel_listen: { value: (channel_id: number, listener: IPCChannelListener) => {\r\n                return self.channel_listen(channel_id, process_pid, listener);\r\n            }, enumerable: true },\r\n            channel_unlisten: { value: (channel_id: number, listener: IPCChannelListener) => {\r\n                return self.channel_unlisten(channel_id, process_pid, listener);\r\n            }, enumerable: true },\r\n            channel_send: { value: (channel_id: number, data: unknown) => {\r\n                return self.channel_send(channel_id, process_pid, data);\r\n            }, enumerable: true },\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\n// TODO: could migrate the stuff where programs grab \"scary\" stuff like WindowManager and ProcessManager to be services\r\n\r\nenum ProcessAttachment {\r\n    FOREGROUND,\r\n    BACKGROUND,\r\n    DETACHED,\r\n}\r\n\r\nexport interface UserspaceOtherProcessContext {\r\n    readonly pid: number;\r\n    readonly created_at: Date;\r\n    readonly is_detached: boolean;\r\n    readonly is_background: boolean;\r\n    readonly is_foreground: boolean;\r\n    readonly attachment: ProcessAttachment;\r\n    readonly source_command: ParsedCommandLine;\r\n}\r\n\r\nexport interface UserspaceProcessContext extends UserspaceOtherProcessContext {\r\n    detach(silently?: boolean): void;\r\n    kill(exit_code?: number): void;\r\n    create_timeout(callback: () => void, delay: number): number;\r\n    cancel_timeout(id: number): void;\r\n    create_interval(callback: () => void, interval: number): number;\r\n    clear_interval(id: number): void;\r\n    create_window(): AbstractWindow | null;\r\n}\r\n\r\nexport class ProcessContext {\r\n    readonly #pid: number;\r\n    readonly #manager: ProcessManager;\r\n\r\n    readonly #source_command: ParsedCommandLine;\r\n    readonly #created_at: Date = new Date();\r\n    readonly #shell: AbstractShell | undefined;\r\n\r\n    readonly #exit_listeners: Set<(exit_code: number) => Promise<void> | void> = new Set();\r\n\r\n    #attachment: ProcessAttachment = ProcessAttachment.FOREGROUND;\r\n    #detach_silently = false;\r\n\r\n    readonly #timeouts: Set<number> = new Set();\r\n    readonly #timeout_promises: Map<number, Set<{resolve: (finished: boolean) => void}>> = new Map(); // timeout id -> promise resolvers (for waiting on timeouts but listening to cancellation)\r\n    readonly #timeout_cancel_callbacks: Map<number, () => void> = new Map(); // timeout id -> cancel callback\r\n\r\n    readonly #intervals: Set<number> = new Set();\r\n\r\n    readonly #windows: Set<AbstractWindow> = new Set();\r\n\r\n    constructor(pid: number, source_command: ParsedCommandLine, registry: ProcessManager, shell?: AbstractShell) {\r\n        this.#pid = pid;\r\n        this.#source_command = source_command;\r\n        this.#manager = registry;\r\n\r\n        if (shell) {\r\n            this.#shell = shell;\r\n        }\r\n\r\n        if (source_command.run_in_bg) {\r\n            this.#attachment = ProcessAttachment.BACKGROUND;\r\n        }\r\n    }\r\n\r\n    get pid(): number {\r\n        return this.#pid;\r\n    }\r\n    get source_command(): ParsedCommandLine {\r\n        return this.#source_command;\r\n    }\r\n\r\n    get created_at(): Date {\r\n        return this.#created_at;\r\n    }\r\n\r\n    get shell(): AbstractShell | undefined {\r\n        return this.#shell;\r\n    }\r\n\r\n    get is_detached(): boolean {\r\n        return this.#attachment === ProcessAttachment.DETACHED;\r\n    }\r\n\r\n    get is_background(): boolean {\r\n        return this.#attachment === ProcessAttachment.BACKGROUND;\r\n    }\r\n\r\n    get is_foreground(): boolean {\r\n        return this.#attachment === ProcessAttachment.FOREGROUND;\r\n    }\r\n\r\n    get attachment(): ProcessAttachment {\r\n        return this.#attachment;\r\n    }\r\n\r\n    get detaches_silently(): boolean {\r\n        return this.#detach_silently;\r\n    }\r\n\r\n    detach(silently = false): void {\r\n        this.#attachment = ProcessAttachment.DETACHED;\r\n        this.#detach_silently = silently;\r\n    }\r\n\r\n    dispose_resources(): void {\r\n        this.#intervals.forEach((id) => {\r\n            clearInterval(id);\r\n        });\r\n\r\n        this.#timeouts.forEach((id) => {\r\n            clearTimeout(id);\r\n        });\r\n\r\n        this.#timeout_promises.clear();\r\n        this.#timeout_cancel_callbacks.clear();\r\n\r\n        this.#windows.forEach((win) => {\r\n            win.dispose();\r\n        });\r\n    }\r\n\r\n    kill(exit_code = 0): void {\r\n        this.dispose_resources();\r\n\r\n        this.#manager.mark_terminated(this.#pid);\r\n\r\n        for (const listener of this.#exit_listeners) {\r\n            listener(exit_code);\r\n        }\r\n    }\r\n\r\n    add_exit_listener(listener: (exit_code: number) => Promise<void> | void): void {\r\n        this.#exit_listeners.add(listener);\r\n    }\r\n\r\n    create_timeout(callback: () => void, delay: number, on_cancel? : () => void): number {\r\n        const id = window.setTimeout(() => {\r\n            this.#timeouts.delete(id);\r\n\r\n            // resolve any waiters\r\n            if (this.#timeout_promises.has(id)) {\r\n                const resolvers = this.#timeout_promises.get(id)!;\r\n                for (const { resolve } of resolvers) {\r\n                    resolve(true);\r\n                }\r\n                this.#timeout_promises.delete(id);\r\n            }\r\n\r\n            callback();\r\n\r\n            if (on_cancel) {\r\n                this.#timeout_cancel_callbacks.delete(id);\r\n            }\r\n        }, delay);\r\n\r\n        this.#timeouts.add(id);\r\n\r\n        if (on_cancel) {\r\n            this.#timeout_cancel_callbacks.set(id, on_cancel);\r\n        }\r\n\r\n        return id;\r\n    }\r\n\r\n    cancel_timeout(id: number): void {\r\n        if (this.#timeouts.has(id)) {\r\n            clearTimeout(id);\r\n            this.#timeouts.delete(id);\r\n\r\n            // resolve any waiters as cancelled\r\n            if (this.#timeout_promises.has(id)) {\r\n                const resolvers = this.#timeout_promises.get(id)!;\r\n                for (const {resolve} of resolvers) {\r\n                    resolve(false);\r\n                }\r\n                this.#timeout_promises.delete(id);\r\n            }\r\n\r\n            // call cancel callback if exists\r\n            if (this.#timeout_cancel_callbacks.has(id)) {\r\n                const cancel_callback = this.#timeout_cancel_callbacks.get(id)!;\r\n                cancel_callback();\r\n                this.#timeout_cancel_callbacks.delete(id);\r\n            }\r\n        }\r\n    }\r\n\r\n    has_timeout(id: number): boolean {\r\n        return this.#timeouts.has(id);\r\n    }\r\n\r\n    create_interval(callback: () => void, interval: number): number {\r\n        const id = window.setInterval(callback, interval);\r\n        this.#intervals.add(id);\r\n        return id;\r\n    }\r\n\r\n    has_interval(id: number): boolean {\r\n        return this.#intervals.has(id);\r\n    }\r\n\r\n    clear_interval(id: number): void {\r\n        if (this.#intervals.has(id)) {\r\n            clearInterval(id);\r\n            this.#intervals.delete(id);\r\n        }\r\n    }\r\n\r\n    async wait_for_timeout(id: number): Promise<boolean> {\r\n        if (!this.#timeouts.has(id)) {\r\n            throw new Error(`Timeout ID ${id} does not exist.`);\r\n        }\r\n\r\n        return new Promise<boolean>((resolve) => {\r\n            if (!this.#timeout_promises.has(id)) {\r\n                this.#timeout_promises.set(id, new Set());\r\n            }\r\n\r\n            this.#timeout_promises.get(id)!.add({ resolve });\r\n        });\r\n    }\r\n\r\n    create_window(): AbstractWindow | null {\r\n        const wm = this.#manager.window_manager;\r\n        if (!wm) {\r\n            return null;\r\n        }\r\n\r\n        const win = new wm.Window(this.#pid);\r\n        this.#windows.add(win);\r\n\r\n        // clean up on close\r\n        win.add_event_listener(\"close\", () => {\r\n            this.#windows.delete(win);\r\n        });\r\n\r\n        return win;\r\n    }\r\n\r\n\r\n    create_userspace_proxy_as_other_process(): UserspaceOtherProcessContext {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        Object.defineProperties(proxy, {\r\n            pid: { get: () => self.pid, enumerable: true },\r\n            created_at: { get: () => self.created_at, enumerable: true },\r\n            is_detached: { get: () => self.is_detached, enumerable: true },\r\n            is_background: { get: () => self.is_background, enumerable: true },\r\n            is_foreground: { get: () => self.is_foreground, enumerable: true },\r\n            attachment: { get: () => self.attachment, enumerable: true },\r\n            source_command: { get: () => self.source_command, enumerable: true },\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n\r\n    create_userspace_proxy(): UserspaceProcessContext {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        Object.defineProperties(proxy, {\r\n            pid: { get: () => self.pid, enumerable: true },\r\n            created_at: { get: () => self.created_at, enumerable: true },\r\n            is_detached: { get: () => self.is_detached, enumerable: true },\r\n            is_background: { get: () => self.is_background, enumerable: true },\r\n            is_foreground: { get: () => self.is_foreground, enumerable: true },\r\n            attachment: { get: () => self.attachment, enumerable: true },\r\n            source_command: { get: () => self.source_command, enumerable: true },\r\n\r\n            detach: { value: (silently = false) => { self.detach(silently); }, enumerable: true },\r\n            kill: { value: (exit_code = 0) => { self.kill(exit_code); }, enumerable: true },\r\n            create_timeout: { value: (callback: () => void, delay: number) => self.create_timeout(callback, delay), enumerable: true },\r\n            cancel_timeout: { value: (id: number) => { self.cancel_timeout(id); }, enumerable: true },\r\n            create_interval: { value: (callback: () => void, interval: number) => self.create_interval(callback, interval), enumerable: true },\r\n            clear_interval: { value: (id: number) => { self.clear_interval(id); }, enumerable: true },\r\n            create_window: { value: () => self.create_window(),  enumerable: true },\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\nexport interface UserspaceProcessManager {\r\n    readonly ipc_manager: UserspaceIPCManager;\r\n    list_pids(): number[];\r\n    get_process(pid: number): UserspaceOtherProcessContext | undefined;\r\n    kill(pid: number, exit_code?: number): boolean;\r\n}\r\n\r\nexport class ProcessManager {\r\n    readonly #processes: Map<number, ProcessContext> = new Map();\r\n    #next_pid = 1;\r\n\r\n    readonly #wm: AbstractWindowManager | null;\r\n    readonly #ipc_manager: IPCManager = new IPCManager(this);\r\n\r\n    constructor(wm: AbstractWindowManager | null = null) {\r\n        this.#wm = wm;\r\n    }\r\n\r\n    get window_manager(): AbstractWindowManager | null {\r\n        return this.#wm;\r\n    }\r\n\r\n    get ipc_manager(): IPCManager {\r\n        return this.#ipc_manager;\r\n    }\r\n\r\n    dispose_all(): void {\r\n        this.#ipc_manager.dispose_all();\r\n\r\n        for (const process of this.#processes.values()) {\r\n            process.dispose_resources();\r\n        }\r\n\r\n        this.#processes.clear();\r\n    }\r\n\r\n    create_process(source_command: ParsedCommandLine, shell?: AbstractShell): ProcessContext {\r\n        const pid = this.#next_pid++;\r\n        const context = new ProcessContext(pid, source_command, this, shell);\r\n        this.#processes.set(pid, context);\r\n        return context;\r\n    }\r\n\r\n    get_process(pid: number): ProcessContext | undefined {\r\n        return this.#processes.get(pid);\r\n    }\r\n\r\n    list_pids(): number[] {\r\n        return Array.from(this.#processes.keys());\r\n    }\r\n\r\n    mark_terminated(pid: number): void {\r\n        this.#processes.delete(pid);\r\n    }\r\n\r\n    kill(pid: number, exit_code = 0): boolean {\r\n        const process = this.#processes.get(pid);\r\n        if (!process) {\r\n            return false;\r\n        }\r\n\r\n        process.kill(exit_code);\r\n        return true;\r\n    }\r\n\r\n    create_userspace_proxy(process_pid: number): UserspaceProcessManager {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        const ipc_mgr_proxy = self.#ipc_manager.create_userspace_proxy(process_pid);\r\n\r\n        Object.defineProperties(proxy, {\r\n            ipc_manager: { get: () => ipc_mgr_proxy, enumerable: true },\r\n            list_pids: { value: () => self.list_pids(), enumerable: true },\r\n            get_process: { value: (pid: number) => {\r\n                const process = self.get_process(pid);\r\n                return process ? process.create_userspace_proxy_as_other_process() : undefined;\r\n            }, enumerable: true },\r\n            kill: { value: (pid: number, exit_code?: number) => self.kill(pid, exit_code), enumerable: true },\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n","import { Howl } from \"howler\";\r\n\r\nexport class SoundRegistry {\r\n    readonly #registry: Map<string, { ready: boolean, howl: Howl }> = new Map();\r\n\r\n    register_howl(name: string, howl: Howl, ready = false) {\r\n        this.#registry.set(name, { ready, howl });\r\n    }\r\n\r\n    register_file(name: string, file: string) {\r\n        const howl = new Howl({\r\n            src: [file],\r\n            onload: () => {\r\n                const entry = this.#registry.get(name);\r\n                entry.ready = true;\r\n                this.#registry.set(name, entry);\r\n            },\r\n        });\r\n\r\n        this.register_howl(name, howl);\r\n    }\r\n\r\n    async await_ready(name: string, interval = 100): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            const timer = setInterval(() => {\r\n                if (this.#registry.get(name).ready) {\r\n                    clearInterval(timer);\r\n                    resolve();\r\n                }\r\n            }, interval);\r\n        });\r\n    }\r\n\r\n    play(name: string) {\r\n        if (!this.#registry.has(name)) {\r\n            throw new Error(`Sound \"${name}\" is not registered.`);\r\n        }\r\n\r\n        if (!this.#registry.get(name).ready) {\r\n            throw new Error(`Sound \"${name}\" is not ready yet.`);\r\n        }\r\n\r\n        this.#registry.get(name).howl.play();\r\n    }\r\n\r\n    get(name: string) {\r\n        if (!this.#registry.has(name)) {\r\n            throw new Error(`Sound \"${name}\" is not registered.`);\r\n        }\r\n\r\n        return this.#registry.get(name).howl;\r\n    }\r\n\r\n    is_ready(name: string) {\r\n        return this.#registry.get(name).ready;\r\n    }\r\n\r\n    wait_to_play(name: string, interval = 100) {\r\n        if (this.is_ready(name)) {\r\n            this.play(name);\r\n        } else {\r\n            console.log(`Sound ${name} is not ready yet, waiting...`);\r\n            this.await_ready(name, interval).then(() => {\r\n                this.play(name);\r\n            });\r\n        }\r\n    }\r\n}","import {ProgramRegistry, recurse_mount_and_register_with_output, UserspaceProgramRegistry} from \"./prog_registry\";\r\nimport {AbstractFileSystem, type UserspaceFileSystem} from \"./filesystem\";\r\n\r\nimport {SoundRegistry} from \"./sfx_registry\";\r\nimport {AbstractWindowManager, UserspaceWindowManager} from \"./windowing\";\r\nimport {\r\n    IPCManager,\r\n    KERNEL_FAKE_PID,\r\n    ProcessContext,\r\n    ProcessManager,\r\n    UserspaceIPCManager, UserspaceOtherProcessContext,\r\n    UserspaceProcessManager\r\n} from \"./processes\";\r\nimport type {AbstractShell} from \"../abstract_shell\";\r\n\r\nimport {NEWLINE, type WrappedTerminal} from \"./term_ctl\";\r\n\r\nimport semver_validate from \"semver/functions/valid\";\r\nimport semver_compare from \"semver/functions/compare\"\r\n\r\nconst CURRENT_API_COMPAT = \"2.0.0\";\r\n\r\nexport interface SpawnResult {\r\n    process: ProcessContext;\r\n    completion: Promise<number>;\r\n}\r\n\r\nexport interface UserspaceKernel {\r\n    readonly privileged: boolean;\r\n    get_program_registry(): UserspaceProgramRegistry;\r\n    get_sound_registry(): SoundRegistry;\r\n    get_fs(): UserspaceFileSystem;\r\n    get_window_manager(): UserspaceWindowManager | null;\r\n    has_window_manager(): boolean;\r\n    get_process_manager(): UserspaceProcessManager;\r\n    get_ipc(): UserspaceIPCManager;\r\n    get_env_info(): {version: string, env: string};\r\n    spawn(cmd_or_line_parse: string | ParsedCommandLine, explicit_args?: string[], shell?: AbstractShell): SpawnResult; // TODO: how safe will this be to expose?\r\n    request_privilege(reason: string): Promise<Kernel | false>;\r\n}\r\n\r\nexport interface ParsedCommandLine {\r\n    command: string;\r\n    args: string[];\r\n    unsubbed_args: string[];\r\n    raw_parts: string[];\r\n    run_in_bg: boolean;\r\n}\r\n\r\nexport class Kernel {\r\n    readonly #term: WrappedTerminal;\r\n    readonly #process_manager: ProcessManager;\r\n    readonly #prog_registry: ProgramRegistry;\r\n    readonly #sfx_registry: SoundRegistry;\r\n    readonly #fs: AbstractFileSystem;\r\n    readonly #wm: AbstractWindowManager | null = null;\r\n\r\n    #panicked = false;\r\n\r\n    #env_info = {\r\n        version: \"unknown\",\r\n        env: \"unknown\"\r\n    };\r\n\r\n    #init_program_name: string | null = null;\r\n\r\n    get privileged(): boolean {\r\n        return true;\r\n    }\r\n\r\n    get panicked(): boolean {\r\n        return this.#panicked;\r\n    }\r\n\r\n    get_program_registry(): ProgramRegistry {\r\n        return this.#prog_registry;\r\n    }\r\n\r\n    get_sound_registry(): SoundRegistry {\r\n        return this.#sfx_registry;\r\n    }\r\n\r\n    get_fs(): AbstractFileSystem {\r\n        return this.#fs;\r\n    }\r\n\r\n    get_window_manager(): AbstractWindowManager | null {\r\n        return this.#wm;\r\n    }\r\n\r\n    has_window_manager(): boolean {\r\n        return this.#wm !== null;\r\n    }\r\n\r\n    get_process_manager(): ProcessManager {\r\n        return this.#process_manager;\r\n    }\r\n\r\n    get_ipc(): IPCManager {\r\n        return this.#process_manager.ipc_manager;\r\n    }\r\n\r\n    get_env_info(): {version: string, env: string} {\r\n        return {...this.#env_info};\r\n    }\r\n\r\n    set_env_info(version: string, env: string) {\r\n        this.#env_info.version = version;\r\n        this.#env_info.env = env;\r\n    }\r\n\r\n    // TODO: cleaner interface, shame theres no function overloading (but could make two more methods)\r\n    spawn = (cmd_or_parse: string | ParsedCommandLine, explicit_args?: string[], shell?: AbstractShell, start_privileged?: boolean): SpawnResult => {\r\n        // TODO: is passing shell around annoying? how can it be alleviated without affecting separation of concerns?\r\n        // TODO: replace the above with process ownership :)\r\n\r\n        // we may not be provided a parsed line (if this is a direct call, not from execute()), but we can create one by assumption\r\n        // args are only used if cmd_or_parse is a string\r\n        // by ensuring only 1 source of truth is used at a time, we avoid manipulation from conflicting data\r\n        let parsed_line: ParsedCommandLine;\r\n        if (typeof cmd_or_parse === \"string\") {\r\n            if (!explicit_args) {\r\n                explicit_args = [];\r\n            }\r\n\r\n            parsed_line = {\r\n                command: cmd_or_parse,\r\n                args: [...explicit_args],\r\n                unsubbed_args: [...explicit_args],\r\n                raw_parts: [cmd_or_parse, ...explicit_args],\r\n                run_in_bg: false\r\n            };\r\n        } else {\r\n            parsed_line = cmd_or_parse;\r\n        }\r\n\r\n        const {command} = parsed_line;\r\n\r\n        // shallow clone args to avoid mutation exploits (you never know)\r\n        const args = parsed_line.args.slice();\r\n\r\n        // search for the command in the registry\r\n        const program = this.#prog_registry.getProgram(command);\r\n        if (program === undefined) {\r\n            throw new Error(`Command not found: ${command}`);\r\n        }\r\n\r\n        // validate that the name stored in the program matches the command called\r\n        // under normal circumstances this should always be true, but doing this prevents obscure spoofing exploits\r\n        if (program.name !== command) {\r\n            throw new Error(`Program name mismatch for command ${command}: expected ${command}, got ${program.name}`);\r\n        }\r\n\r\n        let compat = \"1.0.0\";\r\n        if (typeof program.compat === \"string\") {\r\n            compat = program.compat;\r\n        }\r\n\r\n        if (!semver_validate(compat)) {\r\n            throw new Error(`Program ${program.name} has an invalid compat SemVer: ${compat}`);\r\n        }\r\n\r\n        if (semver_compare(compat, CURRENT_API_COMPAT) < 0) {\r\n            throw new Error(`Program ${program.name} is not compatible with OllieOS 2. (Add compat: \"2.0.0\" to the program object to mark it as ported.)`);\r\n        }\r\n\r\n        // create new process context\r\n        const process = this.#process_manager.create_process(parsed_line, shell);\r\n\r\n        // protect from pollution\r\n        const data = Object.create(null);\r\n\r\n        // provide either privileged or userspace kernel access\r\n        if (start_privileged) {\r\n            data.kernel = this;\r\n        } else {\r\n            data.kernel = this.create_userspace_proxy(process);\r\n        }\r\n\r\n        data.term = this.#term;\r\n        data.args = args;\r\n        data.shell = shell;\r\n        data.unsubbed_args = parsed_line.unsubbed_args;\r\n        data.raw_parts = parsed_line.raw_parts;\r\n        data.process = process;\r\n\r\n        Object.freeze(data);\r\n\r\n        // create a promise that resolves when the program completes\r\n        let result_promise: Promise<number>;\r\n        if (\"main\" in program) {\r\n            result_promise = Promise.resolve(program.main(data));\r\n        } else {\r\n            throw new Error(\"Invalid program type\");\r\n        }\r\n\r\n        return {\r\n            process,\r\n            completion: result_promise\r\n        };\r\n    }\r\n\r\n    panic(message: string, debug_info?: string) {\r\n        if (this.#panicked) {\r\n            return;\r\n        }\r\n\r\n        this.#panicked = true;\r\n\r\n        // print formatted panic to js console\r\n        console.error(`%cPANIC: ${message}\\n${debug_info || \"\"}`, \"background: red; color: white; font-weight: bold;\");\r\n\r\n        const proc_mgr = this.get_process_manager();\r\n        const pids = proc_mgr.list_pids();\r\n\r\n        let process_info = \"\"\r\n\r\n        for (const pid of pids) {\r\n            const proc = proc_mgr.get_process(pid);\r\n\r\n            if (proc) {\r\n                process_info += `- PID ${proc.pid}: ${proc.source_command.command} (started at ${proc.created_at.toISOString()})${NEWLINE}`;\r\n            }\r\n        }\r\n\r\n        // remove last NEWLINE\r\n        process_info = process_info.trimEnd();\r\n\r\n        proc_mgr.dispose_all();\r\n        this.#term.handle_kernel_panic(message, process_info, debug_info);\r\n    }\r\n\r\n    async boot(on_init_spawned?: (kernel: Kernel) => Promise<void>): Promise<boolean> {\r\n        const fs = this.get_fs();\r\n\r\n        // mount all programs in any subdirectory of /usr/bin\r\n        // TODO: get rid of the concept of a programregistry being the sole way to run programs. mounting is a bad concept. it should be a cache, not the sole execution method. may need to redesign how programs are stored to have it be more part of the filesystem\r\n        // TODO: smarter system that has files to be mounted so any stray js files don't get mounted? or maybe it doesn't matter and is better mounting everything for hackability!\r\n        const usr_bin = fs.absolute(\"/usr/bin\");\r\n        if (await fs.exists(usr_bin)) {\r\n            await recurse_mount_and_register_with_output(fs, usr_bin, this.get_program_registry(), this.#term);\r\n        }\r\n\r\n        // read /boot/init to determine init system\r\n        let init_program: string;\r\n        let init_args: string[] = [];\r\n\r\n        try {\r\n            const init_data = await fs.read_file(\"/boot/init\") as string;\r\n            init_program = init_data.trim();\r\n        } catch {\r\n            this.panic(\"Failed to read /boot/init to determine init system!\");\r\n            return false;\r\n        }\r\n\r\n        if (!init_program) {\r\n            this.panic(\"No init program specified in /boot/init!\");\r\n            return false;\r\n        }\r\n\r\n        // separate args if any\r\n        const init_parts = init_program.split(\" \");\r\n        init_program = init_parts[0];\r\n\r\n        if (init_parts.length > 1) {\r\n            init_args = init_parts.slice(1);\r\n        }\r\n\r\n        // run init program\r\n        try {\r\n            const init = this.spawn(init_program, init_args, undefined, true);\r\n\r\n            this.#init_program_name = init_program;\r\n            this.#term.focus();\r\n\r\n            if (on_init_spawned) {\r\n                on_init_spawned(this).catch((e) => {\r\n                    console.error(e);\r\n                });\r\n            }\r\n\r\n            if (init.process.pid !== 1) {\r\n                this.panic(`init program ${init_program} did not start as PID 1!`);\r\n                return false;\r\n            }\r\n\r\n            try {\r\n                const exit_code = await init.completion;\r\n\r\n                this.panic(`init program ${init_program} exited ${exit_code === 0 ? \"unexpectedly\" : \"with an error\"}!`, `Exit code: ${exit_code}`);\r\n                return false;\r\n            } catch (e) {\r\n                console.error(e);\r\n                this.panic(`init program ${init_program} error!`, e.toString());\r\n                return false;\r\n            }\r\n        } catch (e) {\r\n            console.error(e);\r\n            this.panic(`Failed to start init program ${init_program}!`, e.toString());\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async request_privilege(reason: string, process: ProcessContext): Promise<Kernel | false> {\r\n        // TODO: remember my answer option when /sys security is implemented\r\n        // TODO: implement killing in the proxies so that when the process dies, any privileged access is revoked\r\n\r\n        // read /sys/privilege_agent to determine privilege agent\r\n        const fs = this.get_fs();\r\n        let agent_program = \"default_privilege_agent\";\r\n        try {\r\n            const agent_data = await fs.read_file(\"/sys/privilege_agent\") as string;\r\n            agent_program = agent_data.trim();\r\n        } catch {\r\n            // ignore, use default\r\n            console.warn(\"Failed to read /sys/privilege_agent, using default privilege agent.\");\r\n        }\r\n\r\n        if (!agent_program) {\r\n            agent_program = \"default_privilege_agent\";\r\n            console.warn(\"/sys/privilege_agent is empty, using default privilege agent.\");\r\n        }\r\n\r\n        // create an unassigned ipc channel\r\n        const ipc = this.get_ipc();\r\n        const channel_id = ipc.reserve_kernel_channel();\r\n\r\n        // spawn the privilege agent program, passing the channel id, and assign the channel to it\r\n        const agent_proc = this.spawn(agent_program, [channel_id.toString()]);\r\n        ipc.assign_kernel_channel(channel_id, agent_proc.process.pid);\r\n\r\n        let handling_request = false;\r\n        let approved: boolean | null = null;\r\n\r\n        // listen for response on the channel\r\n        ipc.channel_listen(channel_id, KERNEL_FAKE_PID, async (msg) => {\r\n            const data = msg.data as { process: UserspaceOtherProcessContext; granted?: boolean; handling?: boolean; };\r\n\r\n            // validate approved pid matches requesting pid\r\n            if (data.process.pid !== process.pid) {\r\n                console.warn(`Privilege request response pid ${data.process.pid} does not match requesting pid ${process.pid}, ignoring response.`);\r\n                return;\r\n            }\r\n\r\n            // check if handling acknowledgement\r\n            if (data.handling) {\r\n                handling_request = true;\r\n                return;\r\n            }\r\n\r\n            // otherwise, check for granted/denied\r\n            if (data.granted !== undefined) {\r\n                approved = data.granted;\r\n            }\r\n        });\r\n\r\n        const process_proxy = process.create_userspace_proxy_as_other_process();\r\n\r\n        // wait to handle for up to 10 seconds, repeating the request if not yet being handled\r\n        // overall timeout up to 60 seconds\r\n        const start_time = Date.now();\r\n        // TODO: cleaner logic here\r\n        while ((Date.now() - start_time) < 60000 && approved === null && (handling_request || (Date.now() - start_time) < 10000)) {\r\n            if (!handling_request) {\r\n                ipc.channel_send(channel_id, KERNEL_FAKE_PID, {\r\n                    process: process_proxy,\r\n                    reason\r\n                });\r\n            }\r\n\r\n            await new Promise((resolve) => setTimeout(resolve, 500));\r\n        }\r\n\r\n        ipc.destroy_channel(channel_id);\r\n\r\n        if (approved === null) {\r\n            console.warn(\"Privilege request timed out.\");\r\n        }\r\n\r\n        agent_proc.process.kill(approved === null ? 1 : 0);\r\n\r\n        // return result\r\n        if (approved) {\r\n            return this;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    constructor(term: WrappedTerminal, fs: AbstractFileSystem, prog_registry?: ProgramRegistry, sound_registry?: SoundRegistry, wm?: AbstractWindowManager) {\r\n        this.#term = term;\r\n        this.#fs = fs;\r\n        this.#prog_registry = prog_registry || new ProgramRegistry();\r\n        this.#sfx_registry = sound_registry || new SoundRegistry();\r\n        this.#wm = wm || null;\r\n        this.#process_manager = new ProcessManager(this.#wm);\r\n    }\r\n\r\n    create_userspace_proxy(process: ProcessContext): Promise<UserspaceKernel> {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        const kernel_fs = self.get_fs();\r\n\r\n        const proc_mgr_proxy = self.get_process_manager().create_userspace_proxy(process.pid);\r\n        const prog_reg_proxy = self.get_program_registry().create_userspace_proxy(this.#init_program_name, kernel_fs);\r\n        const fs_proxy = AbstractFileSystem.create_userspace_proxy(kernel_fs);\r\n\r\n        Object.defineProperties(proxy, {\r\n            privileged: { value: false, enumerable: true },\r\n            get_program_registry: { value: () => prog_reg_proxy, enumerable: true },\r\n            get_sound_registry: { value: () => self.get_sound_registry(), enumerable: true },\r\n            get_fs: { value: () => fs_proxy, enumerable: true },\r\n            get_window_manager: {\r\n                value: () => {\r\n                    const wm = self.get_window_manager();\r\n                    return wm ? wm.create_userspace_proxy() : null;\r\n                },\r\n                enumerable: true\r\n            },\r\n            has_window_manager: { value: () => self.has_window_manager(), enumerable: true },\r\n            get_process_manager: { value: () => proc_mgr_proxy, enumerable: true },\r\n            get_ipc: { value: () => proc_mgr_proxy.ipc_manager, enumerable: true },\r\n            get_env_info: { value: () => self.get_env_info(), enumerable: true },\r\n            spawn: {\r\n                value: (command: string | ParsedCommandLine, args?: string[], shell?: AbstractShell) =>\r\n                    self.spawn(command, args, shell, false),\r\n                enumerable: true\r\n            },\r\n            request_privilege: {\r\n                value: (reason: string) => self.request_privilege(reason, process),\r\n                enumerable: true\r\n            }\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n","import type {Kernel, SpawnResult} from \"../../../kernel\";\r\n\r\nconst SERVICES_DIR = \"/etc/services/\";\r\n\r\ninterface ServiceRestartPolicyBase {\r\n    on: \"failure\" | \"always\" | \"never\";\r\n}\r\n\r\ninterface ServiceRestartPolicyWithRules extends ServiceRestartPolicyBase {\r\n    on: \"failure\" | \"always\";\r\n    max_retries?: number;\r\n    delay_ms?: number;\r\n}\r\n\r\ntype ServiceRestartPolicy = ServiceRestartPolicyBase | ServiceRestartPolicyWithRules;\r\n\r\ninterface ServiceFile {\r\n    name?: string;\r\n    dependencies?: string[];\r\n    exec: string;\r\n    args?: string[];\r\n    oneshot?: boolean;\r\n    restart?: ServiceRestartPolicy;\r\n}\r\n\r\n// TODO: support oneshot\r\n// TODO: do something with name\r\n// TODO: do something with max_retries\r\n\r\ninterface ServiceFileWithId extends ServiceFile {\r\n    id: string;\r\n}\r\n\r\nconst CLEAN_EXIT_CODES = new Set([0, 143]); // 0 = success, 143 = SIGTERM\r\n\r\ninterface ServiceStatusBase {\r\n    state: \"running\" | \"stopped\" | \"failed\";\r\n}\r\n\r\ninterface ServiceStatusNotRunning extends ServiceStatusBase {\r\n    state: \"stopped\" | \"failed\";\r\n}\r\n\r\ninterface ServiceStatusRunning extends ServiceStatusBase {\r\n    state: \"running\";\r\n    pid: number;\r\n}\r\n\r\n// TODO: store stop code for failed services\r\n// TODO: store start time for running services\r\n\r\nexport type ServiceStatus = ServiceStatusRunning | ServiceStatusNotRunning;\r\n\r\nexport class ServiceManager {\r\n    readonly #kernel: Kernel;\r\n\r\n    readonly #service_files: Map<string, ServiceFileWithId> = new Map();\r\n    readonly #running_services: Map<string, SpawnResult> = new Map(); // service ID to spawn result\r\n    readonly #should_be_running_services: Set<string> = new Set();\r\n    readonly #failed_services: Set<string> = new Set();\r\n\r\n    constructor(kernel: Kernel) {\r\n        this.#kernel = kernel;\r\n    }\r\n\r\n    async load_service_files() {\r\n        const fs = this.#kernel.get_fs();\r\n\r\n        if (!await fs.exists(SERVICES_DIR)) {\r\n            console.warn(`Services directory ${SERVICES_DIR} does not exist. Skipping service loading.`);\r\n            return;\r\n        }\r\n\r\n        const service_files = await fs.list_dir(SERVICES_DIR);\r\n\r\n        // load each service file\r\n        for (const file_name of service_files) {\r\n            if (file_name.endsWith(\".service.json\")) {\r\n                const file_path = fs.join(SERVICES_DIR, file_name);\r\n                const file_content = await fs.read_file(file_path) as string;\r\n\r\n                try {\r\n                    const service_data = JSON.parse(file_content) as ServiceFile;\r\n                    const service_id = file_name.substring(0, file_name.length - \".service.json\".length);\r\n\r\n                    // TODO: validate service_data here\r\n\r\n                    const service: ServiceFileWithId = {\r\n                        id: service_id,\r\n                        ...service_data\r\n                    };\r\n\r\n                    // add or update service file\r\n                    this.#service_files.set(service_id, service);\r\n                } catch (e) {\r\n                    console.error(`Failed to parse service file ${file_name}:`, e);\r\n                }\r\n            }\r\n        }\r\n\r\n        // remove any services that no longer exist\r\n        for (const existing_service_id of this.#service_files.keys()) {\r\n            if (!service_files.includes(existing_service_id + \".service.json\")) {\r\n                this.#service_files.delete(existing_service_id);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _calculate_service_start_order(): string[] {\r\n        const visited: Set<string> = new Set();\r\n        const temp_mark: Set<string> = new Set();\r\n        const result: string[] = [];\r\n\r\n        const visit = (service_id: string) => {\r\n            if (visited.has(service_id)) {\r\n                return;\r\n            }\r\n            if (temp_mark.has(service_id)) {\r\n                throw new Error(`Circular dependency detected involving service: ${service_id}`);\r\n            }\r\n\r\n            temp_mark.add(service_id);\r\n\r\n            const service = this.#service_files.get(service_id);\r\n            if (service && service.dependencies) {\r\n                for (const dep of service.dependencies) {\r\n                    visit(dep);\r\n                }\r\n            }\r\n\r\n            temp_mark.delete(service_id);\r\n            visited.add(service_id);\r\n            result.push(service_id);\r\n        };\r\n\r\n        for (const service_id of this.#service_files.keys()) {\r\n            visit(service_id);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    start_initial_services() {\r\n        const start_order = this._calculate_service_start_order();\r\n        for (const service_id of start_order) {\r\n            this.start_service(service_id);\r\n        }\r\n    }\r\n\r\n    start_service(service_id: string) {\r\n        // TODO: check dependencies are running\r\n\r\n        if (this.#running_services.has(service_id)) {\r\n            console.warn(`Service ${service_id} is already running.`);\r\n            return;\r\n        }\r\n\r\n        const service = this.#service_files.get(service_id);\r\n        if (!service) {\r\n            console.error(`Service ${service_id} not found.`);\r\n            return;\r\n        }\r\n\r\n        // mark service as should be running, so exit handlers know to restart it\r\n        this.#should_be_running_services.add(service_id);\r\n\r\n        let spawn_result: SpawnResult;\r\n        try {\r\n            spawn_result = this.#kernel.spawn(service.exec, service.args || []);\r\n        } catch (e) {\r\n            console.error(`Failed to start service ${service_id}:`, e);\r\n            return;\r\n        }\r\n\r\n        this.#running_services.set(service_id, spawn_result);\r\n        this.#failed_services.delete(service_id);\r\n\r\n        const { process, completion } = spawn_result;\r\n\r\n        // mark process as detached\r\n        process.detach(true);\r\n\r\n        // check for errors\r\n        completion.catch((e) => {\r\n            console.error(`Service ${service_id} encountered an error:`, e);\r\n            this.#running_services.delete(service_id);\r\n            this.#failed_services.add(service_id);\r\n            this._handle_service_exit(service_id, -1);\r\n        });\r\n\r\n        // handle normal exit\r\n        process.add_exit_listener((exit_code) => {\r\n            this.#running_services.delete(service_id);\r\n            this._handle_service_exit(service_id, exit_code);\r\n        });\r\n    }\r\n\r\n    stop_service(service_id: string) {\r\n        if (!this.#running_services.has(service_id)) {\r\n            console.warn(`Service ${service_id} is not running.`);\r\n            return;\r\n        }\r\n\r\n        const spawn_result = this.#running_services.get(service_id);\r\n        if (!spawn_result) {\r\n            console.error(`Service ${service_id} spawn result not found.`);\r\n            return;\r\n        }\r\n\r\n        const { process } = spawn_result;\r\n\r\n        // mark service as should not be running\r\n        this.#should_be_running_services.delete(service_id);\r\n\r\n        // send SIGTERM\r\n        process.kill(143);\r\n\r\n        // removal from running services will be handled in exit listener\r\n    }\r\n\r\n    restart_service(service_id: string) {\r\n        this.stop_service(service_id);\r\n        this.start_service(service_id); // TODO: will this conflict with the exit listener?\r\n    }\r\n\r\n    get_service_status(service_id: string): ServiceStatus | null {\r\n        if (!this.#service_files.has(service_id)) {\r\n            return null;\r\n        }\r\n\r\n        if (this.#running_services.has(service_id)) {\r\n            const spawn_result = this.#running_services.get(service_id);\r\n            if (spawn_result) {\r\n                return {\r\n                    state: \"running\",\r\n                    pid: spawn_result.process.pid\r\n                };\r\n            }\r\n        } else {\r\n            if (this.#failed_services.has(service_id)) {\r\n                return {\r\n                    state: \"failed\"\r\n                };\r\n            } else {\r\n                return {\r\n                    state: \"stopped\"\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private _handle_service_exit(service_id: string, exit_code: number) {\r\n        console.warn(`Service ${service_id} exited with code ${exit_code}.`);\r\n\r\n        if (!this.#should_be_running_services.has(service_id)) {\r\n            return;\r\n        }\r\n\r\n        const service = this.#service_files.get(service_id);\r\n        if (!service) {\r\n            return;\r\n        }\r\n\r\n        const restart_policy = service.restart;\r\n        if (!restart_policy || restart_policy.on === \"never\") {\r\n            return;\r\n        }\r\n\r\n        if (restart_policy.on === \"always\" || (restart_policy.on === \"failure\" && !CLEAN_EXIT_CODES.has(exit_code))) {\r\n            console.log(`Restarting service ${service_id} as per restart policy.`);\r\n\r\n            let delay_ms = 0;\r\n            if (\"delay_ms\" in restart_policy && restart_policy.delay_ms) {\r\n                delay_ms = restart_policy.delay_ms;\r\n            }\r\n\r\n            setTimeout(() => {\r\n                this.start_service(service_id);\r\n            }, delay_ms);\r\n        }\r\n    }\r\n}\r\n","import type { PrivilegedProgram } from \"../../../types\";\r\n\r\nimport {ServiceManager} from \"./services\";\r\nimport type {ProcessContext} from \"../../../kernel/processes\";\r\n\r\nimport {ANSI} from \"../../../kernel/term_ctl\";\r\n\r\ninterface IgnitionIPCMessageBase {\r\n    type: string;\r\n}\r\n\r\ninterface IgnitionIPCPowerMessage extends IgnitionIPCMessageBase {\r\n    type: \"power\";\r\n    action: \"shutdown\" | \"reboot\";\r\n    hard?: boolean;\r\n}\r\n\r\ninterface IgnitionIPCServiceMessage extends IgnitionIPCMessageBase {\r\n    type: \"service\";\r\n    action: \"start\" | \"stop\" | \"restart\" | \"status\";\r\n    service_id: string;\r\n}\r\n\r\ninterface IgnitionIPCReloadServicesMessage extends IgnitionIPCMessageBase {\r\n    type: \"reload_services\";\r\n}\r\n\r\nexport type IgnitionIPCMessage =\r\n    IgnitionIPCPowerMessage |\r\n    IgnitionIPCServiceMessage |\r\n    IgnitionIPCReloadServicesMessage;\r\n\r\ninterface IgnitionIPCResponse extends IgnitionIPCMessageBase {\r\n    type: \"response\";\r\n    message: string;\r\n}\r\n\r\ninterface IgnitionIPCDataResponse extends IgnitionIPCMessageBase {\r\n    type: \"data\";\r\n    data: unknown;\r\n}\r\n\r\ninterface IgnitionIPCError extends IgnitionIPCMessageBase {\r\n    type: \"error\";\r\n    message: string;\r\n}\r\n\r\nexport type IgnitionIPCReply =\r\n    IgnitionIPCResponse |\r\n    IgnitionIPCDataResponse |\r\n    IgnitionIPCError;\r\n\r\n// TODO: split ipc handling etc into files\r\n\r\nexport default {\r\n    name: \"ignition\",\r\n    description: \"System init process\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const { kernel, term, process } = data;\r\n\r\n        const {CURSOR} = ANSI;\r\n\r\n        // check if ignition is already running (only allowed to be PID 1)\r\n        if (process.pid !== 1) {\r\n            term.writeln(\"ignition can only be run as PID 1!\");\r\n            return 1;\r\n        }\r\n\r\n        // check for privileged environment\r\n        if (!kernel.privileged) {\r\n            term.writeln(\"ignition requires privileged environment!\");\r\n            return 1;\r\n        }\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        // determine boot target from /etc/boot_target\r\n        let boot_target = \"jetty\";\r\n        let boot_args: string[] = [];\r\n\r\n        try {\r\n            const boot_target_data = await fs.read_file(\"/etc/boot_target\") as string;\r\n            boot_target = boot_target_data.trim();\r\n        } catch (e) {\r\n            term.writeln(\"Warning: /etc/boot_target not found, defaulting to 'jetty' target!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        if (!boot_target) {\r\n            term.writeln(\"Warning: /etc/boot_target is empty, defaulting to 'jetty' target!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        // separate args if any\r\n        const boot_target_parts = boot_target.split(\" \");\r\n        boot_target = boot_target_parts[0];\r\n\r\n        if (boot_target_parts.length > 1) {\r\n            boot_args = boot_target_parts.slice(1);\r\n        }\r\n\r\n        // create service manager\r\n        const svc_mgr = new ServiceManager(kernel);\r\n\r\n        // load service files but don't start them yet\r\n        await svc_mgr.load_service_files();\r\n\r\n        // open and handle ipc communication\r\n        const ipc = kernel.get_ipc();\r\n\r\n        ipc.service_register(\"init\", process.pid, async (channel_id) => {\r\n            ipc.channel_listen(channel_id, process.pid, async (msg) => {\r\n                const payload = msg.data as IgnitionIPCMessage;\r\n\r\n                // TODO: clean up when it gets more complex\r\n\r\n                switch (payload.type) {\r\n                    case \"reload_services\": {\r\n                        await svc_mgr.load_service_files();\r\n                        ipc.channel_send(channel_id, process.pid, {\r\n                            type: \"response\",\r\n                            message: \"Service files reloaded.\"\r\n                        });\r\n                        break;\r\n                    }\r\n                    case \"service\": {\r\n                        const service_msg = payload as IgnitionIPCServiceMessage;\r\n                        switch (service_msg.action) {\r\n                            case \"start\": {\r\n                                svc_mgr.start_service(service_msg.service_id);\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"response\",\r\n                                    message: `Service ${service_msg.service_id} started.`\r\n                                });\r\n                                break;\r\n                            }\r\n                            case \"stop\": {\r\n                                svc_mgr.stop_service(service_msg.service_id);\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"response\",\r\n                                    message: `Service ${service_msg.service_id} stopped.`\r\n                                });\r\n                                break;\r\n                            }\r\n                            case \"restart\": {\r\n                                svc_mgr.restart_service(service_msg.service_id);\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"response\",\r\n                                    message: `Service ${service_msg.service_id} restarted.`\r\n                                });\r\n                                break;\r\n                            }\r\n                            case \"status\": {\r\n                                const status = svc_mgr.get_service_status(service_msg.service_id);\r\n\r\n                                if (!status) {\r\n                                    ipc.channel_send(channel_id, process.pid, {\r\n                                        type: \"error\",\r\n                                        message: `Service ${service_msg.service_id} not found.`\r\n                                    });\r\n                                    break;\r\n                                }\r\n\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"data\",\r\n                                    data: status\r\n                                });\r\n                                break;\r\n                            }\r\n                            default:\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"error\",\r\n                                    message: `Unknown service action: ${service_msg.action}`\r\n                                });\r\n                        }\r\n                    }\r\n                        break;\r\n                    default:\r\n                        ipc.channel_send(channel_id, process.pid, {\r\n                            type: \"error\",\r\n                            message: `Unknown message type: ${payload.type}`\r\n                        });\r\n                }\r\n            });\r\n        });\r\n\r\n        let running = true;\r\n        let final_code = 0;\r\n        let current_tty_process: ProcessContext;\r\n\r\n        // on exit, force boot target to exit too\r\n        // TODO: add process ownership to automatically kill child processes\r\n        const proc_mgr = kernel.get_process_manager();\r\n        process.add_exit_listener(async (exit_code) => {\r\n            if (current_tty_process && proc_mgr.get_process(current_tty_process.pid)) {\r\n                current_tty_process.kill(exit_code);\r\n            }\r\n\r\n            final_code = exit_code;\r\n            running = false;\r\n        });\r\n\r\n        // start initial services\r\n        svc_mgr.start_initial_services();\r\n\r\n        let window_start: number | null = null;\r\n        let deaths_in_window = 0;\r\n\r\n        // execute boot target in a respawn loop\r\n        while (running) {\r\n            const boot_target_proc = kernel.spawn(boot_target, boot_args);\r\n            current_tty_process = boot_target_proc.process;\r\n\r\n            let exit_code: number;\r\n            let error: Error | null = null;\r\n            try {\r\n                exit_code = await boot_target_proc.completion;\r\n            } catch (e) {\r\n                console.error(e);\r\n                error = e as Error;\r\n                exit_code = -1;\r\n            }\r\n\r\n            boot_target_proc.process.kill(exit_code);\r\n            console.log(`boot target ${boot_target} exited with code ${exit_code}`);\r\n\r\n            term.writeln(`Boot target ${boot_target} exited with code ${exit_code}!`);\r\n            if (error) {\r\n                term.writeln(`Error details: ${error}`);\r\n            }\r\n\r\n            const now = Date.now();\r\n            if (!window_start || (now - window_start) > 10000) {\r\n                window_start = now;\r\n                deaths_in_window = 0;\r\n            }\r\n\r\n            deaths_in_window++;\r\n\r\n            if (deaths_in_window >= 5) {\r\n                term.writeln(\"Boot target has crashed too many times in a short period.\");\r\n                term.writeln(\"Press R key to enter recovery mode, or any other key to retry...\");\r\n                term.write(CURSOR.invisible);\r\n\r\n                const key = await term.wait_for_keypress();\r\n                if (key.key.toLowerCase() === \"r\") {\r\n                    term.writeln(\"Entering recovery mode...\");\r\n\r\n                    const recovery_proc = kernel.spawn(\"recovery\", [], undefined, true);\r\n                    let recovery_exit_code: number;\r\n                    try {\r\n                        recovery_exit_code = await recovery_proc.completion;\r\n                        recovery_proc.process.kill(recovery_exit_code);\r\n                    } catch (e) {\r\n                        console.error(e);\r\n                        recovery_exit_code = -1;\r\n                    }\r\n\r\n                    term.writeln(`Recovery environment exited with code ${recovery_exit_code}. Retrying boot target...`);\r\n                } else {\r\n                    term.writeln(\"Retrying boot target...\");\r\n                }\r\n\r\n                term.write(CURSOR.visible);\r\n\r\n                deaths_in_window = 0;\r\n                window_start = null;\r\n            }\r\n\r\n            // TODO: add recovery options\r\n        }\r\n\r\n        return final_code;\r\n    }\r\n} as PrivilegedProgram;\r\n\r\n// TODO: implement graceful shutdown, stops programs, stops services in reverse order etc as well as move the actual final shutdown/reboot logic to kern`","import type {Program} from \"../../types\";\r\nimport type {ProcessContext} from \"../../kernel/processes\";\r\nimport {ANSI} from \"../../kernel/term_ctl\";\r\n\r\nexport default {\r\n    name: \"jetty\",\r\n    description: \"TTY init process\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const {kernel, term, process} = data;\r\n\r\n        term.reset();\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        // determine default shell from /etc/default_shell\r\n        let default_shell = \"ash\";\r\n        let default_shell_args: string[] = [];\r\n\r\n        try {\r\n            const default_shell_data = await fs.read_file(\"/etc/default_shell\") as string;\r\n            default_shell = default_shell_data.trim();\r\n        } catch (e) {\r\n            term.writeln(\"Warning: /etc/default_shell not found, defaulting to 'ash' shell!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        if (!default_shell) {\r\n            term.writeln(\"Warning: /etc/default_shell is empty, defaulting to 'ash' shell!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        // separate shell args if any\r\n        const default_shell_parts = default_shell.split(\" \");\r\n        default_shell = default_shell_parts[0];\r\n\r\n        if (default_shell_parts.length > 1) {\r\n            default_shell_args = default_shell_parts.slice(1);\r\n        }\r\n\r\n        let running = true;\r\n        let final_code = 0;\r\n        let current_shell_process: ProcessContext;\r\n\r\n        // on exit, force shell to exit too\r\n        // TODO: add process ownership to automatically kill child processes\r\n        const proc_mgr = kernel.get_process_manager();\r\n        process.add_exit_listener(async (exit_code) => {\r\n            if (current_shell_process && proc_mgr.get_process(current_shell_process.pid)) {\r\n                current_shell_process.kill(exit_code);\r\n            }\r\n\r\n            final_code = exit_code;\r\n            running = false;\r\n        });\r\n\r\n        // execute shell in a respawn loop\r\n        while (running) {\r\n            const shell_proc = kernel.spawn(default_shell, default_shell_args);\r\n            current_shell_process = shell_proc.process;\r\n\r\n            let exit_code: number;\r\n            let error: Error | null = null;\r\n            try {\r\n                exit_code = await shell_proc.completion;\r\n                shell_proc.process.kill(exit_code);\r\n            } catch (e) {\r\n                console.error(e);\r\n                error = e as Error;\r\n                exit_code = -1;\r\n            }\r\n\r\n            console.log(`default shell ${default_shell} exited with code ${exit_code}`);\r\n\r\n            // early break in case jetty is being killed\r\n            if (!running) {\r\n                break;\r\n            }\r\n\r\n            term.reset();\r\n\r\n            term.writeln(exit_code === 0 ? \"Logged out.\" : `Shell exited with code ${exit_code}!`);\r\n\r\n            if (error) {\r\n                term.writeln(`Error details: ${error}`);\r\n            }\r\n\r\n            term.writeln(`Press any key to log back in.${ANSI.CURSOR.invisible}`);\r\n\r\n            await term.wait_for_keypress();\r\n            term.write(ANSI.CURSOR.visible);\r\n\r\n            term.reset();\r\n\r\n            // TODO: add recovery logic here too, maybe add /etc/safe_mode_shell file to launch ash --no-scripts or similar\r\n        }\r\n\r\n        return final_code;\r\n    }\r\n} as Program;\r\n","import type {AbstractShellMemory} from \"../../../abstract_shell\";\r\n\r\nexport class AshMemory implements AbstractShellMemory {\r\n    // TODO: backup history in a file\r\n    #history: string[] = [];\r\n\r\n    current_history_index = 0;\r\n\r\n    readonly #vars: Map<string, string> = new Map();\r\n    readonly #aliases: Map<string, string> = new Map();\r\n\r\n    clear_history(): void {\r\n        this.#history = [];\r\n        this.current_history_index = 0;\r\n    }\r\n\r\n    get_previous_history_entry(): string | undefined {\r\n        if (this.#history.length === 0 || this.current_history_index >= this.#history.length) {\r\n            return undefined;\r\n        }\r\n\r\n        const entry = this.#history[this.#history.length - 1 - this.current_history_index];\r\n        this.current_history_index += 1;\r\n        return entry;\r\n    }\r\n\r\n    get_next_history_entry(): string | undefined {\r\n        if (this.#history.length === 0 || this.current_history_index <= 0) {\r\n            return undefined;\r\n        }\r\n\r\n        this.current_history_index -= 1;\r\n        if (this.current_history_index === 0) {\r\n            return \"\";\r\n        }\r\n\r\n        return this.#history[this.#history.length - 1 - this.current_history_index];\r\n    }\r\n\r\n    add_history_entry(entry: string): void {\r\n        this.#history.push(entry);\r\n        this.current_history_index = 0;\r\n    }\r\n\r\n    list_variables(): Map<string, string> {\r\n        return this.#vars;\r\n    }\r\n\r\n    get_variable(name: string): string | undefined {\r\n        return this.#vars.get(name);\r\n    }\r\n\r\n    set_variable(name: string, value: string): void {\r\n        this.#vars.set(name, value);\r\n    }\r\n\r\n    unset_variable(name: string): boolean {\r\n        return this.#vars.delete(name);\r\n    }\r\n\r\n    list_aliases(): Map<string, string> {\r\n        return this.#aliases;\r\n    }\r\n\r\n    get_alias(name: string): string | undefined {\r\n        return this.#aliases.get(name);\r\n    }\r\n\r\n    set_alias(name: string, value: string): void {\r\n        this.#aliases.set(name, value);\r\n    }\r\n\r\n    unset_alias(name: string): boolean {\r\n        return this.#aliases.delete(name);\r\n    }\r\n}\r\n","import {AshMemory} from \"./memory\";\r\nimport type {ParsedCommandLine} from \"../../../kernel\";\r\n\r\nexport interface LineParseResultCommand extends ParsedCommandLine {\r\n    type: \"command\";\r\n}\r\n\r\nexport interface LineParseResultVarAssignment {\r\n    type: \"var\";\r\n\r\n    var_name: string;\r\n    var_value: string;\r\n}\r\n\r\nexport type LineParseResult = LineParseResultCommand | LineParseResultVarAssignment | null;\r\n\r\nconst VAR_ASSIGNMENT_REGEX = /^([a-zA-Z0-9_]+)=(.+)$/;\r\n\r\nexport const parse_line = (line: string, memory?: AshMemory): LineParseResult => {\r\n    if (line.length === 0) {\r\n        // if the line is empty, nothing to parse\r\n        return null;\r\n    }\r\n\r\n    // TODO: handle multiple commands separated by semicolons\r\n\r\n    // remove leading and trailing whitespace and split by spaces, unless contained in single or double quotes\r\n    // TODO: use a proper stack based parser for readability and maintainability\r\n    const raw_parts = line.split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\r\n    const sub = line.trim().split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\r\n\r\n    // handle aliases\r\n    // for each part, check if it's an alias, and if so, replace it with the value\r\n    // if the value ends with a space, check the next part as well\r\n    for (let i = 0; i < sub.length; i++) {\r\n        const part = sub[i];\r\n        const alias_value = memory ? memory.get_alias(part) : undefined;\r\n\r\n        if (!alias_value) {\r\n            // not an alias, abort (alias only applies to the first word unless chaining)\r\n            break;\r\n        }\r\n\r\n        // split the alias value into parts\r\n        const alias_parts = alias_value.split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\r\n\r\n        // if ends with a space, remove the trailing empty part\r\n        if (alias_value.endsWith(\" \")) {\r\n            alias_parts.pop();\r\n        }\r\n\r\n        // remove the current part and insert the alias parts\r\n        sub.splice(i, 1, ...alias_parts);\r\n\r\n        // adjust the index to account for the new parts\r\n        i += alias_parts.length - 1;\r\n\r\n        // if the alias value ends with a space, check the next part as well\r\n        if (!alias_value.endsWith(\" \")) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    const skip_variable_sub_idxs = [];\r\n\r\n    // remove quotes from arguments if starting and ending with quotes\r\n    // if they are single quotes then disable substitution\r\n    for (let i = 0; i < sub.length; i++) {\r\n        if (i === 0) {\r\n            // skip the first argument (the command)\r\n            continue;\r\n        }\r\n\r\n        const arg = sub[i];\r\n\r\n        if (arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\")) {\r\n            sub[i] = arg.slice(1, -1);\r\n        }\r\n\r\n        if (arg.startsWith(\"'\") && arg.endsWith(\"'\")) {\r\n            sub[i] = arg.slice(1, -1);\r\n            skip_variable_sub_idxs.push(i - 1); // skip variable substitution for this argument (adjust for slice)\r\n        }\r\n    }\r\n\r\n    // the first word is the command, the rest are arguments\r\n    const command = sub[0];\r\n\r\n    if (command === \"#\") {\r\n        // if the command is a comment, just ignore\r\n        return null;\r\n    }\r\n\r\n    // determine if the line is a variable assignment with regex\r\n    if (command.includes(\"=\")) {\r\n        const match = line.match(VAR_ASSIGNMENT_REGEX);\r\n\r\n        if (match) {\r\n            const var_name = match[1];\r\n            let var_value = match[2];\r\n\r\n            // remove single or double quotes from the value\r\n            // TODO: make this more unixy when we add semicolons\r\n            if (var_value.startsWith(\"'\") || var_value.startsWith(\"\\\"\")) {\r\n                var_value = var_value.slice(1, -1);\r\n            }\r\n\r\n            // this is a variable assignment\r\n            return {\r\n                type: \"var\",\r\n\r\n                var_name,\r\n                var_value\r\n            }\r\n        }\r\n    }\r\n\r\n    const args = sub.slice(1);\r\n\r\n    // if the last arg value is &, run in bg and remove it from args BEFORE variable substitution\r\n    let run_in_bg = false;\r\n    if (args.length > 0 && args[args.length - 1] === \"&\") {\r\n        run_in_bg = true;\r\n        args.pop();\r\n    }\r\n\r\n    const unsubbed_args = args.slice();\r\n\r\n    // substitute args with variables\r\n    for (let arg_idx = 0; arg_idx < args.length; arg_idx++) {\r\n        if (skip_variable_sub_idxs.includes(arg_idx)) {\r\n            // skip variable substitution for this argument\r\n            continue;\r\n        }\r\n\r\n        let arg = args[arg_idx];\r\n\r\n        // replaces any instance of $VAR or ${VAR} with the value of the variable VAR (alphabetical only except special var $?)\r\n        // TODO: backslash to escape dollar sign without using single quotes\r\n        arg = arg.replace(/\\$(\\w+|\\?)|\\$\\{([^}]+)\\}/g, (match, var1, var2) => {\r\n            const var_name = var1 || var2;\r\n            const var_value = memory ? memory.get_variable(var_name) : undefined;\r\n\r\n            if (!var_value) {\r\n                // if the variable is not set, return the original match\r\n                return match;\r\n            }\r\n\r\n            return var_value;\r\n        });\r\n\r\n        args[arg_idx] = arg;\r\n    }\r\n\r\n    // this is a command\r\n    return {\r\n        type: \"command\",\r\n\r\n        command,\r\n        args,\r\n        unsubbed_args,\r\n        raw_parts,\r\n        run_in_bg\r\n    };\r\n}\r\n","import type {AbstractShell} from \"../../../abstract_shell\";\r\nimport type {UserspaceKernel, SpawnResult} from \"../../../kernel\";\r\n\r\nimport {ANSI, NEWLINE, type WrappedTerminal} from \"../../../kernel/term_ctl\";\r\n\r\nimport {AshMemory} from \"./memory\";\r\nimport {parse_line} from \"./parser\";\r\n\r\nconst {PREFABS, FG, STYLE} = ANSI;\r\n\r\nexport class AshShell implements AbstractShell {\r\n    readonly #kernel: UserspaceKernel;\r\n    readonly #term: WrappedTerminal;\r\n    readonly #memory = new AshMemory();\r\n\r\n    #prompt_suffix = \"$ \";\r\n\r\n    // TODO: find a better place/way to handle this, maybe tab completion should be a class that stores its own state\r\n    _discard_cached_matches = false;\r\n\r\n    constructor(term: WrappedTerminal, kernel: UserspaceKernel) {\r\n        this.#term = term;\r\n        this.#kernel = kernel;\r\n    }\r\n\r\n    get memory(): AshMemory {\r\n        return this.#memory;\r\n    }\r\n\r\n    // returns success flag (or error if critical)\r\n    execute = async (line: string, edit_doc_title = true, program_final_completion_callback?: (exit_code?: number) => void): Promise<boolean> => {\r\n        const kernel = this.#kernel;\r\n        const term = this.#term;\r\n        const memory = this.#memory;\r\n\r\n        // TODO: semicolon to run multiple commands regardless of success\r\n        // TODO: double ampersand to run multiple commands only if previous succeeded\r\n        // TODO: double pipe to run multiple commands only if previous failed\r\n        // TODO: single pipe to pipe output of previous command to next command\r\n        // TODO: allow certain control characters to be escaped e.g. $\r\n        // TODO: support sh files\r\n\r\n        if (line.length === 0) {\r\n            // if the line is empty, just move to the next line (additional check if called from external source)\r\n            return true;\r\n        }\r\n\r\n        const parsed_line = parse_line(line, memory);\r\n\r\n        if (parsed_line === null) {\r\n            // if the line is a comment or empty, do nothing\r\n            return true;\r\n        }\r\n\r\n        // handle variable assignment\r\n        if (parsed_line.type === \"var\") {\r\n            memory.set_variable(parsed_line.var_name, parsed_line.var_value);\r\n            return true;\r\n        }\r\n\r\n        // otherwise, it's a command. destructure it\r\n        const { command } = parsed_line;\r\n\r\n        // check if the command exists\r\n        const prog_reg = kernel.get_program_registry();\r\n        if (!prog_reg.getProgram(command)) {\r\n            term.writeln(`${PREFABS.error}Command not found: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n            return false;\r\n        }\r\n\r\n        let old_title = \"\";\r\n        if (edit_doc_title) {\r\n            old_title = document.title;\r\n            document.title = command;\r\n        }\r\n\r\n        // spawn the process\r\n        let spawn_result: SpawnResult;\r\n        try {\r\n            spawn_result = kernel.spawn(parsed_line, undefined, this);\r\n        } catch (e) {\r\n            if (edit_doc_title) {\r\n                document.title = old_title;\r\n            }\r\n\r\n            term.writeln(`${PREFABS.error}Failed to execute command: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}.`);\r\n            term.writeln(`${FG.red + STYLE.italic}${(e as Error).message}${STYLE.reset_all}`);\r\n\r\n            console.error(e);\r\n\r\n            return false;\r\n        }\r\n\r\n        const { process, completion } = spawn_result;\r\n\r\n        const on_execute_completion = (exit_code?: number) => {\r\n            if (exit_code === undefined) {\r\n                exit_code = -2;\r\n                console.warn(`Program ${command} did not return an exit code. Defaulting to -2.`)\r\n            }\r\n\r\n            memory.current_history_index = 0;\r\n\r\n            if (edit_doc_title) {\r\n                document.title = old_title;\r\n            }\r\n\r\n            if (process.is_detached) {\r\n                process.add_exit_listener((code) => {\r\n                    if (program_final_completion_callback) {\r\n                        try {\r\n                            program_final_completion_callback(code);\r\n                        } catch (e) {\r\n                            console.error(\"Error in program final completion callback for detached process:\", e);\r\n                        }\r\n                    }\r\n\r\n                    if (process.detaches_silently) {\r\n                        return;\r\n                    }\r\n\r\n                    const status = code === 0 ? \"Done\" : `Exit ${code}`;\r\n                    const color = code === 0 ? FG.green : FG.red;\r\n\r\n                    // TODO: erase existing prompt and line\r\n                    term.writeln(\"\");\r\n                    term.writeln(`${FG.gray}[${process.pid}] + ${color}${status}${FG.gray} \\t ${command}${STYLE.reset_all}`);\r\n\r\n                    // reinsert the prompt and current line\r\n                    // TODO: respect running programs, maybe need a notification queue\r\n                    this.insert_prompt(false);\r\n                });\r\n\r\n                // don't kill the process\r\n                return;\r\n            }\r\n\r\n            process.kill(exit_code);\r\n\r\n            if (program_final_completion_callback) {\r\n                try {\r\n                    program_final_completion_callback(exit_code);\r\n                } catch (e) {\r\n                    console.error(\"Error in program final completion callback:\", e);\r\n                }\r\n            }\r\n\r\n            if (process.is_background) {\r\n                term.writeln(`\\n${FG.gray}[${process.pid}] + Done \\t ${command}${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        // now handle awaiting program completion\r\n        try {\r\n            if (process.is_detached) {\r\n                if (!process.detaches_silently) {\r\n                    term.writeln(`${FG.gray}[${process.pid}] process detached${STYLE.reset_all}`);\r\n                }\r\n\r\n                completion.then((exit_code) => {\r\n                    on_execute_completion(exit_code);\r\n                }).catch((e) => {\r\n                    term.writeln(`${PREFABS.error}An unhandled error occurred in detached process [${process.pid}]: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n                    console.error(e);\r\n                    on_execute_completion(-1);\r\n                });\r\n            } else if (process.is_foreground) {\r\n                const exit_code = await completion;\r\n                on_execute_completion(exit_code);\r\n\r\n                // set the exit code variable\r\n                memory.set_variable(\"?\", exit_code.toString());\r\n            } else {\r\n                this.#term.writeln(`${FG.gray}[${process.pid}] ${STYLE.italic}running in background${STYLE.reset_all}`);\r\n\r\n                completion.then((exit_code) => {\r\n                    on_execute_completion(exit_code);\r\n                }).catch((e) => {\r\n                    this.#term.writeln(`${PREFABS.error}An unhandled error occurred in background process [${process.pid}]: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n                    console.error(e);\r\n\r\n                    on_execute_completion(-1);\r\n                });\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}An unhandled error occurred while running the command: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            on_execute_completion(-1);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async run_script(path: string) {\r\n        const fs = this.#kernel.get_fs();\r\n\r\n        if (await fs.exists(path)) {\r\n            // iter through the lines of the file and execute them\r\n            const content = await fs.read_file(path) as string;\r\n            for (const line of content.split(NEWLINE)) {\r\n                // TODO: catch errors\r\n                await this.execute(line);\r\n            }\r\n        }\r\n    }\r\n\r\n    get_prompt_suffix(): string {\r\n        return this.#prompt_suffix;\r\n    }\r\n\r\n    set_prompt_suffix(suffix: string): void {\r\n        this.#prompt_suffix = suffix;\r\n    }\r\n\r\n    get_prompt_string(): string {\r\n        const fs = this.#kernel.get_fs();\r\n\r\n        let path = fs.get_cwd();\r\n\r\n        if (path.startsWith(fs.get_home())) {\r\n            // replace home with ~ at start of path only\r\n            path = path.replace(new RegExp(`^${fs.get_home()}`), \"~\");\r\n        }\r\n\r\n        // build result e.g. ~$\r\n        return `${PREFABS.dir_name}${path}${STYLE.reset_all}${this.#prompt_suffix}`;\r\n    }\r\n\r\n    async insert_prompt(newline = true) {\r\n        const term = this.#term;\r\n\r\n        if (newline) {\r\n            term.write(NEWLINE);\r\n        }\r\n\r\n        // resolve a promise when writing is complete\r\n        await new Promise<void>((resolve) => {\r\n            term.write(this.get_prompt_string(), () => {\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n}\r\n","import type {UserspaceKernel} from \"../../../kernel\";\r\nimport type {ReadLineBuffer, WrappedTerminal} from \"../../../kernel/term_ctl\";\r\nimport type {CompletionData} from \"../../../types\";\r\n\r\nimport {parse_line} from \"./parser\";\r\nimport {AbstractShell} from \"../../../abstract_shell\";\r\n\r\n// TODO this is really poor OOP\r\nlet cached_matches: string[] = [];\r\nlet current_cached_match_index = 0;\r\n\r\nconst complete_command = (buffer: ReadLineBuffer, discard_cached_matches: boolean, kernel: UserspaceKernel) => {\r\n    // get the program registry\r\n    const registry = kernel.get_program_registry();\r\n    const programs = registry.listProgramNames(true, true);\r\n\r\n    // check for existing matches\r\n    let match: string;\r\n    if (!discard_cached_matches && cached_matches.length > 0) {\r\n        // if the current line hasn't changed, just get the next match\r\n        current_cached_match_index = (current_cached_match_index + 1) % cached_matches.length;\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n    } else {\r\n        // if the current line has changed, refresh the matches\r\n        cached_matches = programs.filter((program) => program.startsWith(buffer.current_line));\r\n        current_cached_match_index = 0;\r\n\r\n        // get the first match\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n\r\n        // mark as unmodified\r\n        discard_cached_matches = false;\r\n    }\r\n\r\n    return {match, discard_cached_matches};\r\n}\r\n\r\nconst is_async_generator = (obj: unknown): obj is AsyncGenerator<string> => {\r\n    return obj && typeof obj[Symbol.asyncIterator] === \"function\";\r\n}\r\n\r\nconst get_completeable_arguments = async (buffer: ReadLineBuffer, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\r\n    // parse the line\r\n\r\n    const parsed_line = parse_line(buffer.current_line);\r\n    if (parsed_line.type !== \"command\") {\r\n        console.warn(\"Tab completion for non-command lines is not yet implemented\");\r\n        return null;\r\n    }\r\n\r\n    // destructure parsed line\r\n    const {command, args, unsubbed_args, raw_parts} = parsed_line;\r\n\r\n    // get the command from the registry\r\n    const registry = kernel.get_program_registry();\r\n    const program = registry.getProgram(command);\r\n    if (!program) {\r\n        console.warn(`Tab completion for unknown command \"${command}\"`);\r\n        return null;\r\n    }\r\n\r\n    // if the program has no completion generator, complete based on file paths\r\n    if (!program.completion) {\r\n        // TODO need to change data structure first\r\n        console.warn(`Tab completion for command \"${command}\" with no completion generator is not yet implemented`);\r\n        return null;\r\n    }\r\n\r\n    const completion_data = {\r\n        term,\r\n        kernel,\r\n        shell,\r\n        command,\r\n        args,\r\n        raw_parts: raw_parts,\r\n        unsubbed_args,\r\n        current_partial: raw_parts[raw_parts.length - 1] || \"\",\r\n        arg_index: raw_parts.length - 2, // -1 for current arg, -1 for program name\r\n    };\r\n\r\n    const completion_result = await program.completion(completion_data);\r\n\r\n    // if the result is an async generator, get all values for now\r\n    // in future this will be done incrementally, but the current data structure doesn't support that yet\r\n    if (is_async_generator(completion_result)) {\r\n        const results: string[] = [];\r\n        for await (const value of completion_result) {\r\n            results.push(value);\r\n        }\r\n        return results;\r\n    } else {\r\n        if (completion_result === null) {\r\n            // TODO fall back to file path completion\r\n            console.warn(`Tab completion for command \"${command}\" with null completion result is not yet implemented`);\r\n            return null;\r\n        }\r\n\r\n        return completion_result;\r\n    }\r\n}\r\n\r\nconst complete_argument = async (buffer: ReadLineBuffer, discard_cached_matches: boolean, kernel: UserspaceKernel, term: WrappedTerminal, shell?: AbstractShell) => {\r\n    // get the completeable arguments\r\n    const completeable_arguments = await get_completeable_arguments(buffer, term, kernel, shell);\r\n    if (!completeable_arguments) {\r\n        return {match: \"\", discard_cached_matches};\r\n    }\r\n\r\n    // check for existing matches\r\n    let match: string;\r\n    if (!discard_cached_matches && cached_matches.length > 0) {\r\n        // if the current line hasn't changed, just get the next match\r\n        current_cached_match_index = (current_cached_match_index + 1) % cached_matches.length;\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n    } else {\r\n        // if the current line has changed, refresh the matches\r\n        cached_matches = completeable_arguments.filter((arg) => arg.startsWith(buffer.current_line.split(\" \").pop() || \"\"));\r\n        current_cached_match_index = 0;\r\n\r\n        // get the first match\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n\r\n        // mark as unmodified\r\n        discard_cached_matches = false;\r\n    }\r\n\r\n    return {match, discard_cached_matches};\r\n}\r\n\r\nconst fill_completed_command = (term: WrappedTerminal, buffer: ReadLineBuffer, match: string) => {\r\n    // erase the current line\r\n    term.write(\"\\b \\b\".repeat(buffer.current_index));\r\n\r\n    // write the match\r\n    term.write(match);\r\n\r\n    // NOTE: above is done rather than filling what is remaining because if tab is hit again, the next match will be written\r\n\r\n    // update current line and index\r\n    buffer.set_current_line(match);\r\n    buffer.set_current_index(match.length);\r\n}\r\n\r\nconst fill_completed_argument = (term: WrappedTerminal, buffer: ReadLineBuffer, match: string) => {\r\n    // get the current line parts\r\n    const parts = buffer.current_line.split(\" \");\r\n    const current_arg_partial = parts.pop() || \"\";\r\n\r\n    // erase the current argument partial\r\n    term.write(\"\\b \\b\".repeat(current_arg_partial.length));\r\n\r\n    // write the match\r\n    term.write(match);\r\n\r\n    // NOTE: above is done rather than filling what is remaining because if tab is hit again, the next match will be written\r\n\r\n    // update current line and index\r\n    parts.push(match);\r\n    buffer.set_current_line(parts.join(\" \"));\r\n    buffer.set_current_index(buffer.current_line.length);\r\n}\r\n\r\n// TODO: how does this work? would be good to make it linked to the terminal instance. what is discard_cached_matches even for?\r\nexport const tab_complete = async (buffer: ReadLineBuffer, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell, discard_cached_matches = false): Promise<boolean> => {\r\n    // if the current line is empty, do nothing\r\n    if (buffer.current_line.length === 0) {\r\n        return;\r\n    }\r\n\r\n    // if the current line has no spaces, tab complete the command\r\n    if (!buffer.current_line.includes(\" \")) {\r\n        const {match, discard_cached_matches: updated_discard} = complete_command(buffer, discard_cached_matches, kernel);\r\n        discard_cached_matches = updated_discard;\r\n\r\n        // if there is a match, tab complete\r\n        if (match) {\r\n            fill_completed_command(term, buffer, match);\r\n        }\r\n    } else {\r\n        // otherwise, tab complete the argument\r\n        const {match, discard_cached_matches: updated_discard} = await complete_argument(buffer, discard_cached_matches, kernel, term, shell);\r\n        discard_cached_matches = updated_discard;\r\n\r\n        // if there is a match, tab complete\r\n        if (match) {\r\n            fill_completed_argument(term, buffer, match);\r\n        }\r\n    }\r\n\r\n    return discard_cached_matches;\r\n}\r\n\r\n// TODO: the discard cache arg is janky. come up with a better solution. should also be using generators directly instead of arrays for completions\r\n// TODO: would be much better as a class that maintains its own state and remembers term, kernel etc.\r\n\r\nexport const helper_completion_options = (options: string[]) => {\r\n    return async function* (data: CompletionData): AsyncGenerator<string> {\r\n        const {current_partial} = data;\r\n        for (const option of options) {\r\n            if (option.startsWith(current_partial)) {\r\n                yield option;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nexport const helper_completion_options_ordered = (options: string[][]) => {\r\n    return async function* (data: CompletionData): AsyncGenerator<string> {\r\n        const {current_partial, raw_parts} = data;\r\n        const index = raw_parts.length - 1;\r\n        const options_at_index = options[index] || [];\r\n        for (const option of options_at_index) {\r\n            if (option.startsWith(current_partial)) {\r\n                yield option;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// TODO: make these helpers available to 3rd party programs","import type {Program} from \"../../../types\";\r\nimport {NEWLINE} from \"../../../kernel/term_ctl\";\r\n\r\nimport {AshShell} from \"./core\";\r\nimport {make_read_line_key_handlers, make_read_line_printable_handler} from \"./key_handlers\";\r\n\r\nexport default {\r\n    name: \"ash\",\r\n    description: \"A shell.\",\r\n    usage_suffix: \"[--login] [--no-scripts]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"--login\": \"Start the shell as a login shell. Don't pass this flag manually, it's handled by the system.\",\r\n            \"--no-scripts\": \"Do not run any startup scripts like .ashrc or .ash_profile.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const {kernel, term, process, args} = data;\r\n\r\n        const shell = new AshShell(term, kernel);\r\n\r\n        const env_info = kernel.get_env_info();\r\n        shell.memory.set_variable(\"VERSION\", env_info.version);\r\n        shell.memory.set_variable(\"ENV\", env_info.env);\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        const absolute_profile = fs.absolute(\"~/.ash_profile\");\r\n        const absolute_rc = fs.absolute(\"~/.ashrc\");\r\n\r\n        // create .ash_profile file if it doesn't exist\r\n        const profile_content = `# ash configuration file${NEWLINE}# This file is run at login.${NEWLINE}${NEWLINE}cat /etc/motd.txt${NEWLINE}echo \"OllieOS v$VERSION ($ENV)\"${NEWLINE}`;\r\n        if (!(await fs.exists(absolute_profile))) {\r\n            await fs.write_file(absolute_profile, profile_content);\r\n        }\r\n\r\n        // create .ashrc file if it doesn't exist\r\n        const rc_content = `# ash configuration file${NEWLINE}# This file is run when a shell is created.${NEWLINE}${NEWLINE}`;\r\n        if (!(await fs.exists(absolute_rc))) {\r\n            await fs.write_file(absolute_rc, rc_content);\r\n        }\r\n\r\n        if (args.includes(\"--login\")) {\r\n            // enable screen reader mode if stored in local storage\r\n            if (localStorage.getItem(\"reader\") === \"true\") {\r\n                await shell.execute(\"reader -s on\");\r\n            }\r\n\r\n            // run .ash_profile, checking it exists again just in case (because why not)\r\n            if (!args.includes(\"--no-scripts\") && await fs.exists(absolute_profile)) {\r\n                await shell.run_script(absolute_profile);\r\n            }\r\n        }\r\n\r\n        // run .ashrc, checking it exists again just in case (could be deleted in profile)\r\n        if (!args.includes(\"--no-scripts\") && await fs.exists(absolute_rc)) {\r\n            await shell.run_script(absolute_rc);\r\n        }\r\n\r\n        let running = true;\r\n        let final_code = 0;\r\n        process.add_exit_listener((exit_code) => {\r\n            final_code = exit_code;\r\n            running = false;\r\n        });\r\n\r\n        const read_line_key_handlers = make_read_line_key_handlers(shell, kernel);\r\n        const read_line_printable_handler = make_read_line_printable_handler(shell);\r\n\r\n        while (running) {\r\n            await shell.insert_prompt(true);\r\n\r\n            const input = await term.read_line(read_line_key_handlers, read_line_printable_handler);\r\n            if (!input.trim()) {\r\n                continue;\r\n            }\r\n\r\n            // TODO: have an actual builtin processor instead of just reading input here\r\n            if (input === \"exit\") {\r\n                running = false;\r\n                break;\r\n            }\r\n\r\n            shell.memory.add_history_entry(input);\r\n            await shell.execute(input);\r\n        }\r\n\r\n        return final_code;\r\n    }\r\n} as Program;\r\n","import type {ReadLineKeyHandler} from \"../../../kernel/term_ctl\";\r\n\r\nimport type {AshShell} from \"./core\";\r\nimport type {UserspaceKernel} from \"../../../kernel\";\r\nimport {tab_complete} from \"./tab_completion\";\r\n\r\nexport const make_read_line_key_handlers = (shell: AshShell, kernel: UserspaceKernel): { [key: string]: ReadLineKeyHandler } => ({\r\n    // arrow up - previous history\r\n    \"\\x1b[A\": (_e, term, buffer) => {\r\n        const command = shell.memory.get_previous_history_entry();\r\n\r\n        if (command) {\r\n            shell._discard_cached_matches = true;\r\n\r\n            // bring cursor to end of line\r\n            term.write(\" \".repeat(buffer.current_line.length - buffer.current_index));\r\n\r\n            // clear current line (and move cursor back to start)\r\n            term.write(\"\\b \\b\".repeat(buffer.current_line.length));\r\n\r\n            // write command\r\n            term.write(command);\r\n\r\n            // update current line and index\r\n            buffer.set_current_line(command);\r\n            buffer.set_current_index(command.length);\r\n        }\r\n    },\r\n\r\n    // arrow down - next history\r\n    \"\\x1b[B\": (_e, term, buffer) => {\r\n        const command = shell.memory.get_next_history_entry();\r\n\r\n        shell._discard_cached_matches = true;\r\n\r\n        // bring cursor to end of line\r\n        term.write(\" \".repeat(buffer.current_line.length - buffer.current_index));\r\n\r\n        // clear current line (and move cursor back to start)\r\n        term.write(\"\\b \\b\".repeat(buffer.current_line.length));\r\n\r\n        if (command) {\r\n            // write command\r\n            term.write(command);\r\n\r\n            // update current line and index\r\n            buffer.set_current_line(command);\r\n            buffer.set_current_index(command.length);\r\n        } else {\r\n            // end of history, just clear line\r\n            buffer.set_current_line(\"\");\r\n            buffer.set_current_index(0);\r\n        }\r\n    },\r\n\r\n    // tab - tab completion\r\n    \"\\t\": async (_e, term, buffer) => {\r\n        shell._discard_cached_matches = await tab_complete(buffer, term, kernel, shell, shell._discard_cached_matches);\r\n    },\r\n\r\n    // backspace - discard cached matches\r\n    \"\\x7f\": () => {\r\n        // TODO: doesnt work quite the same, if they tab with nothing and hit backspace it will reset. need a way to check current line discipline\r\n        shell._discard_cached_matches = true;\r\n    }\r\n});\r\n\r\nexport const make_read_line_printable_handler = (shell: AshShell) => () => {\r\n    shell._discard_cached_matches = true;\r\n};\r\n","import type { Program } from \"../../types\";\r\nimport type {UserspaceOtherProcessContext} from \"../../kernel/processes\";\r\n\r\nimport {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\r\n\r\ninterface PrivilegeRequestMessage {\r\n    process: UserspaceOtherProcessContext;\r\n    reason: string;\r\n}\r\n\r\nexport default {\r\n    name: \"default_privilege_agent\",\r\n    description: \"Default agent for handling kernel privilege requests\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const { kernel, term, args, process: my_process } = data;\r\n\r\n        // expect arg for channel id\r\n        const channel_id_str = args[0];\r\n        if (!channel_id_str) {\r\n            term.writeln(\"Error in privilege agent: No channel ID provided.\");\r\n            return 1;\r\n        }\r\n\r\n        const channel_id = parseInt(channel_id_str, 10);\r\n        if (isNaN(channel_id)) {\r\n            term.writeln(\"Error in privilege agent: Invalid channel ID.\");\r\n            return 1;\r\n        }\r\n\r\n        // wait briefly to ensure the channel is assigned to us\r\n        // TODO: a way to fix the race condition without making the kernel expose ipc, could at least use a retry mechanism\r\n        await new Promise((resolve) => setTimeout(resolve, 250));\r\n\r\n        // listen to the channel\r\n        const ipc = kernel.get_ipc();\r\n\r\n        let finished = false;\r\n        let handling_request = false;\r\n\r\n        ipc.channel_listen(channel_id, async (msg) => {\r\n            if (handling_request) {\r\n                // already handling a request, ignore new ones\r\n                return;\r\n            }\r\n\r\n            handling_request = true;\r\n\r\n            const { process, reason } = msg.data as PrivilegeRequestMessage;\r\n\r\n            // immediately acknowledge the request is being handled\r\n            ipc.channel_send(channel_id, {\r\n                process,\r\n                handling: true\r\n            });\r\n\r\n            term.writeln(`${NEWLINE}${ANSI.STYLE.bold}${ANSI.BG.blue}${ANSI.FG.white}KERNEL PRIVILEGE REQUEST${ANSI.STYLE.reset_all}${ANSI.BG.gray}${NEWLINE}`);\r\n\r\n            term.writeln(`Process PID ${process.pid} (${process.source_command.command}) is requesting elevated kernel privileges.`);\r\n            term.writeln(`The process gave the following reason for the request:${NEWLINE}`);\r\n\r\n            term.writeln(`${ANSI.STYLE.bold}${ANSI.FG.yellow}\"${reason}\"${ANSI.FG.reset}${ANSI.STYLE.no_bold_or_dim}${NEWLINE}`);\r\n\r\n            term.writeln(\"Granting this request will allow the process full access to the kernel, which may compromise system security and stability.\");\r\n            term.writeln(\"It may also be able to temporarily share this access with other running processes.\");\r\n\r\n            term.writeln(`${NEWLINE}Do you wish to grant elevated privileges to PID ${process.pid}? (y/n)${ANSI.STYLE.reset_all}${ANSI.CURSOR.invisible}`);\r\n\r\n            const event = await term.wait_for_keypress();\r\n            term.write(ANSI.CURSOR.visible);\r\n\r\n            if (event.key.toLowerCase() === \"y\") {\r\n                term.writeln(`${NEWLINE}${ANSI.BG.green}${ANSI.FG.white}Privilege request granted.${ANSI.STYLE.reset_all}${NEWLINE}`);\r\n                ipc.channel_send(channel_id, {\r\n                    process,\r\n                    granted: true\r\n                });\r\n            } else {\r\n                term.writeln(`${NEWLINE}${ANSI.BG.red}${ANSI.FG.white}Privilege request denied.${ANSI.STYLE.reset_all}${NEWLINE}`);\r\n                ipc.channel_send(channel_id, {\r\n                    process,\r\n                    granted: false\r\n                });\r\n            }\r\n\r\n            finished = true;\r\n        });\r\n\r\n        my_process.add_exit_listener(() => {\r\n            finished = true;\r\n        });\r\n\r\n        // wait to handle for up to 10 seconds\r\n        // overall timeout up to 60 seconds\r\n        const start_time = Date.now();\r\n        // TODO: clean up logic here\r\n        while ((Date.now() - start_time) < 60000 && !finished && (handling_request || (Date.now() - start_time) < 10000)) {\r\n            const timeout_id = my_process.create_timeout(() => {}, 100);\r\n            await my_process.wait_for_timeout(timeout_id);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import type {PrivilegedProgram} from \"../../types\";\r\n\r\nimport {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\r\n\r\nexport default {\r\n    name: \"recovery\",\r\n    description: \"Emergency recovery environment\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const { kernel, term } = data;\r\n\r\n        const {CURSOR} = ANSI;\r\n\r\n        if (!kernel.privileged) {\r\n            term.writeln(\"Recovery requires privileged environment.\");\r\n            return 1;\r\n        }\r\n\r\n        let running = true;\r\n        while (running) {\r\n            term.reset();\r\n\r\n            term.writeln(\"RECOVERY ENVIRONMENT\");\r\n            term.writeln(\"===================\");\r\n            term.write(NEWLINE);\r\n            term.writeln(\"1. Reboot\");\r\n            term.writeln(\"2. Privileged ash shell\");\r\n            term.writeln(\"3. Reset bootloader and reboot\");\r\n            term.writeln(\"4. Wipe filesystem and reboot\");\r\n            term.write(NEWLINE);\r\n            term.writeln(\"X: Exit recovery\");\r\n            term.write(NEWLINE);\r\n            term.writeln(\"Press the corresponding key to select an option.\");\r\n\r\n            if (typeof window !== \"undefined\") {\r\n                term.writeln(`Recovery also available at ${window.location.origin}/recover_fs`);\r\n            }\r\n\r\n            term.write(CURSOR.invisible);\r\n\r\n            const key = await term.wait_for_keypress();\r\n\r\n            switch (key.key.toLowerCase()) {\r\n                case \"1\":\r\n                    term.writeln(NEWLINE + \"Rebooting...\");\r\n                    window.location.reload();\r\n                    break;\r\n                case \"2\": {\r\n                    term.writeln(NEWLINE + \"Starting privileged ash shell...\");\r\n                    term.write(CURSOR.visible);\r\n\r\n                    // TODO: this doesnt make much difference being privileged as the programs are separate processes\r\n                    // TODO: bypass the privilege agent instead\r\n                    let exit_code: number;\r\n                    const shell = kernel.spawn(\"ash\", [\"--no-scripts\"], undefined, true);\r\n                    try {\r\n                        exit_code = await shell.completion;\r\n                    } catch (e) {\r\n                        exit_code = -1;\r\n                        term.writeln(\"Error in privileged shell:\");\r\n                        term.writeln(e);\r\n                    }\r\n\r\n                    shell.process.kill(exit_code)\r\n                }\r\n                    break;\r\n                case \"3\": {\r\n                    term.writeln(\"Are you sure you want to reset the bootloader? This will clear your choice of init system, boot target, default shell, and privilege agent but retains your files.\");\r\n                    term.writeln(\"Press Y to confirm, or any other key to cancel.\");\r\n\r\n                    const confirm_key = await term.wait_for_keypress();\r\n                    if (confirm_key.key.toLowerCase() !== \"y\") {\r\n                        term.writeln(\"Bootloader reset cancelled.\");\r\n                        break;\r\n                    }\r\n\r\n                    term.writeln(NEWLINE + \"Resetting bootloader...\");\r\n\r\n                    // delete /boot/init, /etc/boot_target, /etc/default_shell, /sys/privilege_agent\r\n                    const fs = kernel.get_fs();\r\n                    try {\r\n                        await fs.delete_file(\"/boot/init\");\r\n                    } catch (e) {\r\n                        term.writeln(\"Warning: Failed to delete /boot/init\");\r\n                        term.writeln(e);\r\n                    }\r\n\r\n                    try {\r\n                        await fs.delete_file(\"/etc/boot_target\");\r\n                    } catch (e) {\r\n                        term.writeln(\"Warning: Failed to delete /etc/boot_target\");\r\n                        term.writeln(e);\r\n                    }\r\n\r\n                    try {\r\n                        await fs.delete_file(\"/etc/default_shell\");\r\n                    } catch (e) {\r\n                        term.writeln(\"Warning: Failed to delete /etc/default_shell\");\r\n                        term.writeln(e);\r\n                    }\r\n\r\n                    try {\r\n                        await fs.delete_file(\"/sys/privilege_agent\");\r\n                    } catch (e) {\r\n                        term.writeln(\"Warning: Failed to delete /sys/privilege_agent\");\r\n                        term.writeln(e);\r\n                    }\r\n\r\n                    term.writeln(\"Rebooting...\");\r\n                    window.location.reload();\r\n                }\r\n                    break;\r\n                case \"4\": {\r\n                    term.writeln(\"Are you sure you want to erase the filesystem? This action cannot be undone.\");\r\n                    term.writeln(\"Press Y to confirm, or any other key to cancel.\");\r\n\r\n                    const confirm_key = await term.wait_for_keypress();\r\n                    if (confirm_key.key.toLowerCase() !== \"y\") {\r\n                        term.writeln(\"Filesystem wipe cancelled.\");\r\n                        break;\r\n                    }\r\n\r\n                    term.writeln(NEWLINE + \"Wiping filesystem...\");\r\n\r\n                    const fs = kernel.get_fs();\r\n                    try {\r\n                        await fs.erase_all();\r\n                    } catch (e) {\r\n                        term.writeln(\"Error: Failed to wipe filesystem.\");\r\n                        term.writeln(e);\r\n                    }\r\n\r\n                    term.writeln(\"Rebooting...\");\r\n                    window.location.reload();\r\n                }\r\n                    break;\r\n                case \"x\":\r\n                    term.writeln(NEWLINE + \"Exiting recovery.\");\r\n                    running = false;\r\n                    break;\r\n                default:\r\n                    // ignore other keys\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as PrivilegedProgram;\r\n","import { ANSI, NEWLINE, ANSI_ESCAPE_REGEX } from \"../kernel/term_ctl\";\r\nimport type { Program, ArgDescriptions } from \"../types\";\r\n\r\n\r\n// deferred to prevent double printing of header if program has to re-execute itself\r\nconst header = (term, includes_mounted: boolean) => {\r\n    // write header\r\n\r\n    if (!includes_mounted) {\r\n        term.writeln(`${ANSI.STYLE.italic}(Only built-in programs are included. Use the -m flag to include only mounted programs, or the -a flag to include all.)${ANSI.STYLE.reset_all}`);\r\n    }\r\n\r\n    term.writeln(`For help on a specific command, type ${ANSI.PREFABS.program_name}help${ANSI.STYLE.reset_all} [command].`)\r\n    term.writeln(`The exit code of the most recently executed program is stored in the ${ANSI.PREFABS.variable_name}$?${ANSI.STYLE.reset_all} variable.`)\r\n    term.writeln(`You can set variables with the syntax ${ANSI.PREFABS.variable_name}variable${ANSI.STYLE.reset_all}=value and unset them with ${ANSI.PREFABS.program_name}unset${ANSI.STYLE.reset_all}.`)\r\n    term.writeln(`To persist the variables, define them in the ${ANSI.PREFABS.file_path}.ollierc${ANSI.STYLE.reset_all} file in your ${ANSI.PREFABS.dir_name}home${ANSI.STYLE.reset_all} directory.`)\r\n    term.writeln(`You can run commands in the background by appending ${ANSI.STYLE.bold}${ANSI.FG.magenta}&${ANSI.STYLE.reset_all} to the end of the command.`)\r\n    term.write(NEWLINE);\r\n}\r\n\r\n// TODO: this should also probably be part of the shell rather than a program? i guess it doesn't matter much, it just acts more like man\r\nexport default {\r\n    name: \"help\",\r\n    description: \"List programs or get help for a specific program.\",\r\n    usage_suffix: \"[command | -s] [-a | -m]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"command\": \"The name of the program to get help for.\",\r\n        },\r\n        \"Flags:\": {\r\n            \"-s\": \"Single-column mode. Forces the program list to be displayed in a single column.\",\r\n            \"-a\": \"All programs. Includes all programs, built-in and mounted.\",\r\n            \"-m\": \"Mounted programs. Includes only mounted programs.\",\r\n        },\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // TODO smarter completion to handle number of args and flags\r\n        const programs = data.kernel.get_program_registry().listProgramNames();\r\n        return programs.filter((program) => program.startsWith(data.current_partial));\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        const registry = kernel.get_program_registry();\r\n\r\n        let single_column = false;\r\n        let includes_mounted = false;\r\n        let includes_builtin = true;\r\n\r\n        // parse and remove flags from args\r\n        for (let i = 0; i < args.length; i++) {\r\n            switch (args[i]) {\r\n                case \"-s\":\r\n                    single_column = true;\r\n                    args.splice(i, 1);\r\n                    i--;\r\n                    break;\r\n                case \"-a\":\r\n                    includes_mounted = true;\r\n                    includes_builtin = true;\r\n                    args.splice(i, 1);\r\n                    i--;\r\n                    break;\r\n                case \"-m\":\r\n                    includes_mounted = true;\r\n                    includes_builtin = false;\r\n                    args.splice(i, 1);\r\n                    i--;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // if no arguments remain, use list mode\r\n        if (args.length === 0) {\r\n            // get program names\r\n            const programs = registry.listProgramNames(includes_builtin, includes_mounted);\r\n\r\n            // remove hidden programs\r\n            const visible_programs = programs.filter((program_name) => {\r\n                const program = registry.getProgram(program_name);\r\n                return program !== undefined && !program.hide_from_help;\r\n            });\r\n\r\n            // add usage suffix and styling to each program name\r\n            const programs_fmt = visible_programs.map((program) => {\r\n                return `${PREFABS.program_name}${program}${STYLE.reset_all} ${registry.getProgram(program).usage_suffix}`;\r\n            });\r\n\r\n            // sort the programs alphabetically (usually already sorted alphabetically by Object.keys, but not guaranteed)\r\n            programs_fmt.sort();\r\n\r\n\r\n            if (single_column) {\r\n                // FORMAT THE PROGRAMS INTO 1 COLUMN\r\n\r\n                header(term, includes_mounted);\r\n                term.writeln(programs_fmt.join(NEWLINE));\r\n            } else {\r\n                // FORMAT THE PROGRAMS INTO 2 COLUMNS\r\n\r\n\r\n                // get the maximum length of a column\r\n                const max_allowable_length = Math.floor(term.cols / 2) - 1;\r\n\r\n\r\n                // split the programs into 2 columns\r\n                const column1 = programs_fmt.filter((_, i) => i <= programs_fmt.length / 2);\r\n                const column2 = programs_fmt.filter((_, i) => i > programs_fmt.length / 2);\r\n\r\n\r\n                // compute the length of the longest program name\r\n                const longest_program_length = Math.max(...programs_fmt.map((program) => program.replace(ANSI_ESCAPE_REGEX, \"\").length));\r\n\r\n                // compute the smallest padding length\r\n                const min_padding_length = max_allowable_length - longest_program_length;\r\n\r\n                // if there is negative padding (overlap, terminal too small), re-execute the program in single-column mode\r\n                if (min_padding_length < 0) {\r\n                    term.writeln(\"Terminal too small to display programs in 2 columns. Re-executing in single-column mode.\");\r\n                    term.write(NEWLINE);\r\n                    \r\n                    const new_args = [\"-s\"];\r\n\r\n                    if (includes_mounted) {\r\n                        new_args.push(\"-m\");\r\n                    }\r\n\r\n                    if (includes_builtin) {\r\n                        new_args.push(\"-a\");\r\n                    }\r\n                    \r\n                    return await kernel.spawn(\"help\", new_args, shell).completion;\r\n                }\r\n\r\n\r\n                // pair the programs in the 2 columns\r\n                const paired_programs = column1.map((program1, i) => {\r\n                    let program2 = column2[i] ?? \"\";\r\n\r\n                    const program1_real_length = program1.replace(ANSI_ESCAPE_REGEX, \"\").length;\r\n                    const program2_real_length = program2.replace(ANSI_ESCAPE_REGEX, \"\").length;\r\n\r\n                    // if the program name is too long, truncate it\r\n                    if (program1_real_length > max_allowable_length) {\r\n                        program1 = program1.slice(0, max_allowable_length / 2 - 3) + \"...\";\r\n                    }\r\n                    if (program2_real_length > max_allowable_length) {\r\n                        program2 = program2.slice(0, max_allowable_length / 2 - 3) + \"...\";\r\n                    }\r\n\r\n                    // pad the programs so that they are both left-aligned\r\n                    const padding = \" \".repeat(max_allowable_length - program1_real_length);\r\n                    return program1 + padding + program2;\r\n                });\r\n\r\n\r\n                // write the programs to the terminal\r\n                header(term, includes_mounted);\r\n                term.writeln(paired_programs.join(NEWLINE));\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        // if an argument remains, get help for it\r\n        const program = registry.getProgram(args[0]);\r\n\r\n        if (program === undefined) {\r\n            term.writeln(`${PREFABS.error}Could not resolve help for ${args[0]}.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        term.writeln(`${NEWLINE}${PREFABS.program_name}${program.name}${STYLE.reset_all}`);\r\n        term.writeln(`${program.description}`);\r\n        term.write(NEWLINE);\r\n        term.writeln(`Usage: ${PREFABS.program_name}${program.name}${STYLE.reset_all} ${program.usage_suffix}`);\r\n\r\n        if (Object.keys(program.arg_descriptions).length > 0) {\r\n            // recurse each level of nesting\r\n            // each level is a section title, until the innermost object, in which they are pairs of argument name and description.\r\n            // add indents depending on the level of nesting\r\n            const recurse = (descs: ArgDescriptions, nest_level: number): string => {\r\n                let output = \"\";\r\n\r\n                for (const [key, value] of Object.entries(descs)) {\r\n                    if (typeof value === \"string\") {\r\n                        // argument, innermost nest\r\n                        output += `${\" \".repeat(nest_level * 4)}${key} - ${value}${NEWLINE}`;\r\n                    } else {\r\n                        // title, deeper nest\r\n                        output += `${NEWLINE}${\" \".repeat(nest_level * 4)}${STYLE.bold + STYLE.italic}${key}${STYLE.reset_all}${NEWLINE}`;\r\n                        output += recurse(value, nest_level + 1);\r\n                    }\r\n                }\r\n\r\n                return output;\r\n            }\r\n\r\n\r\n            term.write(NEWLINE);\r\n            term.write(recurse(program.arg_descriptions, 0));\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI } from \"../kernel/term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"shutdown\",\r\n    description: \"Stops the OS.\",\r\n    usage_suffix: \"[-h] [-r] [-t ms]\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-r\": \"Reboot the terminal.\",\r\n            \"-t\": \"Set the time before shutdown in milliseconds. Default is 1000.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { FG, STYLE } = ANSI;\r\n\r\n        let time = 1000;\r\n        let restart = false;\r\n\r\n        for (const arg of args) {\r\n            switch (arg) {\r\n                case \"-h\":\r\n                    return await kernel.spawn(\"help\", [\"shutdown\"], shell).completion;\r\n                case \"-r\":\r\n                    restart = true;\r\n                    break;\r\n                case \"-t\": {\r\n                    // get the next argument\r\n                    const time_arg = args[args.indexOf(arg) + 1];\r\n                    if (time_arg === undefined) {\r\n                        term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    // parse the time\r\n                    const parsed_time = parseInt(time_arg);\r\n                    if (isNaN(parsed_time)) {\r\n                        term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    time = parsed_time;\r\n\r\n                    // skip the next argument\r\n                    args.splice(args.indexOf(arg) + 1, 1);\r\n                    break;\r\n                }\r\n                default:\r\n                    term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\r\n                    return 1;\r\n            }\r\n        }\r\n\r\n        if (restart) {\r\n            term.writeln(`${FG.red}Restarting...${STYLE.reset_all}`);\r\n        } else {\r\n            term.writeln(`${FG.red}Shutting down...${STYLE.reset_all}`);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            if (restart) {\r\n                window.location.reload();\r\n            } else {\r\n                term.dispose();\r\n            }\r\n        }, time);\r\n\r\n        // hang the terminal until it is shut down or restarted (dont allow any more commands)\r\n        // await an event that will never happen\r\n        await new Promise(() => {});\r\n    }\r\n} as Program;\r\n\r\n// TODO: move this to talk to ignition to perform a soft (or hard) shutdown via IPC\r\n","import { ANSI } from \"../kernel/term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"clear\",\r\n    description: \"Clears the screen, and/or the scrollback.\",\r\n    usage_suffix: \"[-h | -s | -so]\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-s\": \"Clear the screen and the scrollback.\",\r\n            \"-so\": \"Only clear the scrollback.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: helper_completion_options([\"-h\", \"-s\", \"-so\"]),\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { FG, STYLE, PREFABS } = ANSI;\r\n\r\n        switch (args[0]) {\r\n            case undefined:\r\n                term.reset();\r\n                break;\r\n            case \"-s\":\r\n                term.reset();\r\n\r\n                if (shell) {\r\n                    shell.memory.clear_history();\r\n                } else {\r\n                    term.writeln(`${PREFABS.error}Cannot clear scrollback: no shell available.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                break;\r\n            case \"-so\":\r\n                if (!shell) {\r\n                    term.writeln(`${PREFABS.error}Cannot clear scrollback: no shell available.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                shell.memory.clear_history();\r\n                term.writeln(`${STYLE.bold + FG.gray}Scrollback cleared.${STYLE.reset_all}`);\r\n                break;\r\n            case \"-h\":\r\n                return await kernel.spawn(\"help\", [\"clear\"], shell).completion;\r\n            default:\r\n                term.writeln(`${FG.red}Invalid argument: ${args[0]}${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"echo\",\r\n    description: \"Echos a string to the terminal.\",\r\n    usage_suffix: \"string\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"string\": \"The string to echo.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { args, term } = data;\r\n\r\n        const content = args.join(\" \");\r\n        term.writeln(content);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"unset\",\r\n    description: \"Unsets a list of variables.\",\r\n    usage_suffix: \"[names...]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"names\": \"The names of each variable to unset.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (!data.shell) {\r\n            return [];\r\n        }\r\n\r\n        const var_names = [...data.shell.memory.list_variables().keys()];\r\n        // TODO: check type to see why helper_completion_options wont work here\r\n        return var_names.filter(name => name.startsWith(data.current_partial));\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, args, term } = data;\r\n\r\n        if (!shell) {\r\n            term.writeln(\"No shell available\");\r\n            return 1;\r\n        }\r\n\r\n        // TODO: move to shell builtin, not actual program\r\n\r\n        // for each variable name, unset it, with no regards to whether it exists or not\r\n        for (const name of args) {\r\n            shell.memory.unset_variable(name);\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI, ANSI_ESCAPE_REGEX, ANSI_UNESCAPED_REGEX } from \"../kernel/term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"ls\",\r\n    description: \"List files in the current or another directory.\",\r\n    usage_suffix: \"[-h] [-a] [path]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the directory to list. Defaults to the current directory.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-a\": \"Show hidden files.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // parse arguments\r\n        let show_hidden = false;\r\n        let path = fs.get_cwd();\r\n\r\n        for (const arg of args) {\r\n            switch (arg) {\r\n                case \"-a\":\r\n                    show_hidden = true;\r\n                    break;\r\n                case \"-h\":\r\n                    return await kernel.spawn(\"help\", [\"ls\"], shell).completion;\r\n                default:\r\n                    path = fs.absolute(arg);\r\n            }\r\n        }\r\n\r\n        // check if path is a directory and exists\r\n        if (!(await fs.dir_exists(path))) {\r\n            term.writeln(`${PREFABS.error}No such directory: ${path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // list dir\r\n        let dir = await fs.list_dir(path);\r\n\r\n        // sort alphabetically (usually already sorted by Object.keys but just in case)\r\n        dir.sort();\r\n\r\n        // filter out hidden files\r\n        if (!show_hidden) {\r\n            dir = dir.filter((file) => !file.startsWith(\".\"));\r\n        }\r\n\r\n        // fit as many files as possible on one line, with a space between each, otherwise wrap\r\n        const max_width = term.cols;\r\n        let line = \"\";\r\n\r\n        for (const file of dir) {\r\n            // check if file will fit on current line\r\n            const real_length = line.replace(ANSI_ESCAPE_REGEX, \"\").replace(ANSI_UNESCAPED_REGEX, \"\").length;\r\n            if (real_length + file.length + 1 > max_width) {\r\n                // write line and reset\r\n                term.writeln(line);\r\n                line = \"\";\r\n            }\r\n\r\n            // add to line\r\n            if (await fs.dir_exists(fs.join(path, file))) {\r\n                line += `${PREFABS.dir_name}${file}${STYLE.reset_all} `;\r\n            } else {\r\n                line += `${PREFABS.file_path}${file}${STYLE.reset_all} `;\r\n            }\r\n        }\r\n\r\n        // write last line\r\n        term.writeln(line);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI } from \"../kernel/term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"cd\",\r\n    description: \"Change directory.\",\r\n    usage_suffix: \"[path]\",\r\n    arg_descriptions: {\r\n        path: \"Path to directory to change to. If no path is given, change to home directory.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n        \r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        \r\n        // if no arguments, go to home directory\r\n        if (args.length === 0) {\r\n            fs.set_cwd(fs.get_home());\r\n            return 0;\r\n        }\r\n\r\n        // if more than one argument, print error\r\n        if (args.length > 1) {\r\n            term.writeln(`${PREFABS.error}Too many arguments${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // check if path is a directory and exists\r\n        const path = args[0];\r\n        const absolute_path = fs.absolute(path);\r\n\r\n        if (!(await fs.dir_exists(absolute_path))) {\r\n            term.writeln(`${PREFABS.error}No such directory: ${path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // change directory\r\n        fs.set_cwd(absolute_path);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI } from \"../kernel/term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"pwd\",\r\n    description: \"Print working directory.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n        \r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // print working directory\r\n        term.writeln(PREFABS.dir_name + fs.get_cwd() + STYLE.reset_all);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE, WrappedTerminal, NON_PRINTABLE_REGEX } from \"../kernel/term_ctl\";\r\n\r\nconst HEADER = 2;\r\n\r\nconst setup = (term: WrappedTerminal, content: string, path: string, readonly: boolean) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, BG, FG } = ANSI;\r\n\r\n    // clear the screen\r\n    term.clear();\r\n\r\n    // write the file name centered in the header, showing the read-only status if the file is read-only\r\n    const filename = path.split(\"/\").pop() || \"\";\r\n    const header = readonly ? `Viewing read-only file: ${filename}` : `Editing file: ${filename}`;\r\n    const h_padding_l = \" \".repeat(Math.ceil((term.cols - header.length) / 2));\r\n    const h_padding_r = \" \".repeat(Math.floor((term.cols - header.length) / 2));\r\n\r\n    term.write(BG.white + FG.black + STYLE.bold);\r\n    term.write(h_padding_l);\r\n    term.write(header);\r\n    term.write(h_padding_r);\r\n    term.write(STYLE.reset_all)\r\n\r\n    // go to the bottom of the screen with ansi\r\n    term.write(`\\x1b[${term.rows - 1};0H`);\r\n\r\n    // write the footer, showing the save and exit key if the file is not read-only\r\n    const footer = `${readonly ? \"\" : \"F1: Save & Exit | \"}ESC: Exit without saving | F2: Debug Redraw`;\r\n    const f_padding_l = \" \".repeat(Math.ceil((term.cols - footer.length) / 2));\r\n    const f_padding_r = \" \".repeat(Math.floor((term.cols - footer.length) / 2));\r\n\r\n    term.write(BG.white + FG.black + STYLE.bold);\r\n    term.write(f_padding_l);\r\n    term.write(footer);\r\n    term.write(f_padding_r);\r\n    term.write(STYLE.reset_all)\r\n\r\n    // reset the cursor position to under the header\r\n    term.write(\"\\x1b[2;0H\");\r\n    term.write(NEWLINE);\r\n\r\n    // write the content\r\n    term.write(content);\r\n\r\n    // reset the cursor position to under the header\r\n    term.write(\"\\x1b[2;0H\");\r\n    term.write(NEWLINE);\r\n}\r\n\r\n\r\n// TODO: expose ANSI cursor control codes as functions in term_ctl\r\n// TODO: consider instead using a hidden textarea to store the character buffer, or using a queue and reimplementing the terminal's keypress handler\r\n// TODO: provide method in terminal to set up the above ^^^\r\n// TODO: none of this accounts for scrolling!! use of cursorPos will not function properly if the terminal is scrolled\r\n// TODO: it would be nice to not \"cheat\" at enter and backspace, but to actually handle them properly. this is fine for now i guess\r\n\r\nexport default {\r\n    name: \"edit\",\r\n    description: \"Edits the specified file.\",\r\n    usage_suffix: \"path\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // parse argument\r\n        if (args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}A single argument, the path, is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        const path = fs.absolute(args[0]);\r\n\r\n\r\n        let content = \"\";\r\n\r\n        // if the file exists, load it in. otherwise, keep the content empty\r\n        let readonly = false;\r\n        if (await fs.exists(path)) {\r\n            content = await fs.read_file(path) as string;\r\n            readonly = await fs.is_readonly(path);\r\n\r\n            // lock the file by making it read-only\r\n            // TODO: the user can lock the file permanently if edit crashes, they close the tab, reload, or their computer loses power! perhaps use a separate flag for this and have the os erase the lock on boot, not the same as readonly\r\n            // TODO: i'm disabling this for now for my own sanity (when it crashes and dies). its incredibly unlikely the user will concurrent write with fsedit and if they do they're stupid\r\n            //fs.set_readonly(path, true);\r\n        }\r\n\r\n        // temporary note\r\n        // TODO: remove when scrolling is implemented properly\r\n        term.writeln(`${FG.yellow}Note: This program is still in development and has numerous issues, including no scrolling!${NEWLINE}Pressing F2 to redraw may help some visual issues, but not any file writing related issues.${NEWLINE}Consider using ${PREFABS.program_name}cat${STYLE.reset_all + FG.yellow} or the ${PREFABS.program_name}fsedit${STYLE.reset_all + FG.yellow} UI for your purposes.${NEWLINE}Please don't report issues in this program unless you know a fix :)${NEWLINE}Press any key to proceed.${STYLE.reset_all}`);\r\n        await term.wait_for_keypress();\r\n\r\n        // setup the screen\r\n        setup(term, content, path, readonly);\r\n\r\n        const split_content = content.split(NEWLINE);\r\n\r\n        // wait for keypresses\r\n        let exit_code: number | null = null;\r\n        let saved = false;\r\n        while (exit_code === null) {\r\n            const key = await term.wait_for_keypress();\r\n\r\n            switch (key.domEvent.code) {\r\n                case \"Escape\":\r\n                    // revert the file to its original read-only status\r\n                    if (await fs.exists(path)) {\r\n                        await fs.set_readonly(path, readonly);\r\n                    }\r\n\r\n                    exit_code = 0;\r\n                    break;\r\n                case \"F1\":\r\n                    // if readonly, don't allow saving\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n                    await fs.write_file(path, split_content.join(NEWLINE));\r\n                    saved = true;\r\n\r\n                    // revert the file to its original read-only status\r\n                    await fs.set_readonly(path, readonly);\r\n\r\n                    exit_code = 0;\r\n                    break;\r\n                case \"F2\":\r\n                    term.reset();\r\n                    setup(term, split_content.join(NEWLINE), path, readonly);\r\n                    console.log(split_content.join(\"\\n\"));\r\n                    break;\r\n                case \"ArrowUp\": {\r\n                    // determine the current cursor position\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    if (cursor_y === 2) {\r\n                        // TODO: scroll file\r\n                        // we're at the top of the file, so we can't move up\r\n                        break;\r\n                    }\r\n\r\n                    // pass through to the terminal\r\n                    term.write(key.key);\r\n\r\n                    // determine the current line's length (sub 2 for header, sub 1 for moving up)\r\n                    const line_length = split_content[cursor_y - HEADER - 1].length;\r\n\r\n                    // determine the cursor's x position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n\r\n                    // move cursor to the end of the line, typing backspaces if it is past the end or the right arrow code if it is not\r\n                    if (cursor_x >= line_length) {\r\n                        term.write(\"\\b\".repeat(cursor_x - line_length));\r\n                    } else {\r\n                        term.write(\"\\x1b[C\".repeat(line_length - cursor_x));\r\n                    }\r\n                }\r\n                    break;\r\n                case \"ArrowDown\": {\r\n                    // determine the current cursor position\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    if (cursor_y === term.rows - 4) {\r\n                        // TODO: scroll file\r\n                        // we're at the bottom of the screen, so we can't move down\r\n                        break;\r\n                    }\r\n\r\n                    if (cursor_y === split_content.length + HEADER - 1) { // (add 2 for header, sub 1 for 0-indexing)\r\n                        // we're at the bottom of the file, so we can't move down\r\n                        break;\r\n                    }\r\n\r\n                    // pass through to the terminal\r\n                    term.write(key.key);\r\n\r\n                    // determine the current line's length (sub 2 for header, add 1 for moving down)\r\n                    const line_length = split_content[cursor_y - HEADER + 1].length;\r\n\r\n                    // determine the cursor's x position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n\r\n                    // move cursor to the end of the line, typing backspaces if it is past the end or the right arrow code if it is not\r\n                    if (cursor_x >= line_length) {\r\n                        term.write(\"\\b\".repeat(cursor_x - line_length));\r\n                    } else {\r\n                        term.write(\"\\x1b[C\".repeat(line_length - cursor_x));\r\n                    }\r\n                }\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    // left arrow can always be passed through to the terminal as the terminal will handle the left margin\r\n                    term.write(key.key);\r\n                    break;\r\n                case \"ArrowRight\": {\r\n                    // determine cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // determine the current line's length (sub 2 for header)\r\n                    const line_length = split_content[cursor_y - HEADER].length;\r\n\r\n                    if (cursor_x < line_length) {\r\n                        // pass through to the terminal\r\n                        // NOTE: no need to check right margin, because the terminal will handle that\r\n                        term.write(key.key);\r\n                    }\r\n                }\r\n                    break;\r\n                case \"Enter\": {\r\n                    // if readonly, don't allow editing\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n\r\n                    // determine cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    let cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // split the current line at the cursor position\r\n                    const line = split_content[cursor_y - HEADER];\r\n\r\n                    const before_newline = line.slice(0, cursor_x);\r\n                    const after_newline = line.slice(cursor_x);\r\n\r\n                    const old_split_content = split_content.slice();\r\n\r\n                    // insert the new line into the content, between the before_newline and after_newline\r\n                    split_content.splice(cursor_y - HEADER, 1, before_newline, after_newline);\r\n\r\n                    // the code below to redraw selectively is a mess and doesn't work properly for all cases, but is improving\r\n                    // for now, just to get edit in a somewhat working state, we'll just clear the screen and redraw everything (debug redraw but restoring cursor position)\r\n\r\n                    // debug redraw\r\n                    term.reset();\r\n                    setup(term, split_content.join(NEWLINE), path, readonly);\r\n\r\n                    // move the cursor to the start of the new line\r\n                    term.write(`\\x1b[${cursor_y + 2};1H`);\r\n\r\n                    break;\r\n\r\n                    // clear text past the cursor\r\n                    term.write(\" \".repeat(line.length - cursor_x));\r\n\r\n                    // move the cursor down one line and to the beginning of the line\r\n                    term.write(\"\\x1b[1B\\x1b[1G\");\r\n\r\n                    // we are now on the new line. clear it using the old line length and write the new content from after_newline\r\n                    // TODO: could just clear what overruns the new content, but the logic is more confusing. clearing everything is simpler but less efficient\r\n                    term.write(\" \".repeat(old_split_content[cursor_y - HEADER].length)); // doesnt work for all cases, sometime leaves longer line stray\r\n                    term.write(\"\\x1b[1G\")\r\n                    term.write(after_newline);\r\n\r\n                    // adjust cursor y to reflect the real newline being handled\r\n                    cursor_y++;\r\n\r\n                    // clear all the lines below the new cursor position, then write the new content into them\r\n                    // TODO: could just clear what overruns the new content, but the logic is more confusing. clearing everything is simpler but less efficient\r\n                    let lines_redrawn = 0;\r\n                    for (let i = cursor_y - HEADER + 1; i < split_content.length; i++) {\r\n                        term.write(\"\\x1b[1B\\x1b[1G\");\r\n                        if (old_split_content[i]) {\r\n                            term.write(\" \".repeat(old_split_content[i].length));\r\n                            term.write(\"\\x1b[1G\");\r\n                        }\r\n                        term.write(split_content[i]);\r\n                        lines_redrawn++;\r\n                    }\r\n\r\n                    // move the cursor back to the original line at the start of the new line\r\n                    term.write(\"\\x1b[1G\");\r\n                    if (lines_redrawn > 0) {\r\n                        term.write(`\\x1b[${lines_redrawn}A`);\r\n                    }\r\n                }\r\n                    break;\r\n                case \"Backspace\": {\r\n                    // if readonly, don't allow editing\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n                    // get the current cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // do nothing at the start of the file\r\n                    if (cursor_x === 0 && cursor_y === 2) {\r\n                        break;\r\n                    }\r\n\r\n                    // if at the beginning of the line, remove the newline\r\n                    if (cursor_x === 0) {\r\n                        // move previous line's content to the end of the current line\r\n                        const newline_content = split_content[cursor_y - HEADER];\r\n                        split_content[cursor_y - HEADER - 1] += newline_content;\r\n\r\n                        split_content.splice(cursor_y - HEADER, 1);\r\n\r\n                        // the code below to handle backspacing a newline ever only partly worked\r\n                        // for now, just to get edit in a somewhat working state, we'll just clear the screen and redraw everything (debug redraw but restoring cursor position)\r\n\r\n                        // debug redraw\r\n                        term.reset();\r\n                        setup(term, split_content.join(NEWLINE), path, readonly);\r\n\r\n                        // move the cursor to the previous line to the right length across (N from the end where N is the length of the line we just merged, newline_content)\r\n                        // TODO: why isn't this working in all cases??????????????????????????????????\r\n                        term.write(`\\x1b[${cursor_y};${split_content[cursor_y - HEADER - 1].length - newline_content.length + 1}G`);\r\n\r\n                        break;\r\n\r\n                        // move the cursor up one line\r\n                        term.write(\"\\x1b[1A\");\r\n\r\n                        // move the cursor to the end of the line\r\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER - 1].length + 1}G`);\r\n\r\n                        // write the rest of the line\r\n                        term.write(split_content[cursor_y - HEADER]);\r\n\r\n                        // move the cursor back to the original position\r\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER].length + 1}D`);\r\n\r\n                        // TODO: redraw following lines properly\r\n\r\n                        break;\r\n                    }\r\n\r\n\r\n                    // otherwise, remove the character to the left of the cursor\r\n                    const left = split_content[cursor_y - HEADER].slice(0, cursor_x - 1);\r\n                    const right = split_content[cursor_y - HEADER].slice(cursor_x);\r\n\r\n                    split_content[cursor_y - HEADER] = left + right;\r\n\r\n                    // move the cursor back one space\r\n                    term.write(\"\\b\");\r\n\r\n                    // write the rest of the line\r\n                    term.write(right + \" \");\r\n\r\n                    // move the cursor back to the original position\r\n                    term.write(`\\x1b[${right.length + 1}D`);\r\n\r\n                    // if the line is now empty, remove it, unless it's the first line\r\n                    if (cursor_y !== 2 && split_content[cursor_y - HEADER] === \"\") {\r\n                        split_content.splice(cursor_y - HEADER, 1);\r\n                        term.write(\"\\x1b[1M\");\r\n                        break;\r\n                    }\r\n\r\n                    // if the cursor is now past the end of the line, move it to the end of the line\r\n                    if (cursor_x > split_content[cursor_y - HEADER].length) {\r\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER].length + 1}G`);\r\n                    }\r\n                }\r\n                    break;\r\n                default: {\r\n                    // if readonly, don't allow editing\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n                    // get the current cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // if the key is a printable character, write it in\r\n                    if (!NON_PRINTABLE_REGEX.test(key.key)) {\r\n                        // if at the end of the line, append to the line\r\n                        if (cursor_x === split_content[cursor_y - HEADER].length + 1) {\r\n                            split_content[cursor_y - HEADER] += key.key;\r\n                            term.write(key.key);\r\n                        } else {\r\n                            // otherwise, insert it and shift the rest of the line\r\n                            const left = split_content[cursor_y - HEADER].slice(0, cursor_x);\r\n                            const right = split_content[cursor_y - HEADER].slice(cursor_x);\r\n\r\n                            split_content[cursor_y - HEADER] = left + key.key + right;\r\n\r\n                            // overwrite the line\r\n                            term.write(key.key + right);\r\n\r\n                            // move the cursor back to the correct position + 1\r\n                            term.write(`\\x1b[${cursor_x + 2}G`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        term.reset();\r\n\r\n        if (saved) {\r\n            term.writeln(`${FG.green}File saved!${STYLE.reset_all}`);\r\n        } else {\r\n            // TODO: cant exit without saving, crashes the program when trying to set readonly status\r\n            term.writeln(`${FG.red}Exited without saving!${STYLE.reset_all}`);\r\n        }\r\n\r\n        return exit_code;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE } from \"../kernel/term_ctl\";\r\n\r\nexport default {\r\n    name: \"webget\",\r\n    description: \"Downloads a file from the World Wide Web.\",\r\n    usage_suffix: \"url filepath [-o] [-n] [-X method] [-H header] [-B body]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"url\": \"The URL to download from.\",\r\n            \"filepath\": \"The path to save the file to.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"System flags:\": {\r\n                \"-h\": \"Print this help message.\",\r\n                \"-o\": \"Overwrite existing files.\",\r\n                \"-n\": \"Do not replace newlines with the current system's newline character, store as a binary (binary mode).\",\r\n            },\r\n            \"Request flags:\": {\r\n                \"-X\": \"Specify a custom HTTP method. (default: GET)\",\r\n                \"-H\": \"Add a custom header to the request.\",\r\n                \"-B\": \"Specify a custom request body. (only works with POST and PUT methods)\"\r\n            }\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // TODO: replace filename with using piping and send content to stdout\r\n        // TODO: automatically guess binary mode based on file extension or recieved header\r\n\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        if (args[0] === \"-h\") {\r\n            return await kernel.spawn(\"help\", [\"webget\"], shell).completion;\r\n        }\r\n\r\n        // check if the user provided a URL\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}A URL is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // parse url\r\n        const url = args.shift();\r\n\r\n        // validate url\r\n        try {\r\n            const proc_url = new URL(url);\r\n\r\n            if (proc_url.protocol !== \"http:\" && proc_url.protocol !== \"https:\") {\r\n                throw new Error(\"Invalid protocol\");\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Invalid URL. Expected a valid HTTP or HTTPS protocol URL.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        let file_path = \"\";\r\n        let overwrite = false;\r\n        let binary = false;\r\n        let method = \"GET\";\r\n        const headers: Map<string, string> = new Map();\r\n        let body = null;\r\n\r\n        for (let arg_idx = 0; arg_idx < args.length; arg_idx++) {\r\n            const arg = args[arg_idx];\r\n\r\n            switch (arg) {\r\n                case \"-X\": {\r\n                    // consume next argument\r\n                    const next_arg = args[arg_idx + 1];\r\n\r\n                    if (next_arg === undefined) {\r\n                        term.writeln(`${PREFABS.error}Expected a method after -X.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    method = next_arg;\r\n                    args.splice(arg_idx + 1, 1);\r\n                }\r\n                    break;\r\n                case \"-H\": {\r\n                    // consume next argument\r\n                    const header = args[arg_idx + 1];\r\n\r\n                    if (header === undefined) {\r\n                        term.writeln(`${PREFABS.error}Expected a header after -H.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    const split = header.split(\": \");\r\n\r\n                    if (split.length !== 2 || split[0].includes(\" \")) {\r\n                        term.writeln(`${PREFABS.error}Invalid header. Expected a header in the format \"Header-Name: Header-Value\".${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    headers.set(split[0], split[1]);\r\n                    args.splice(arg_idx + 1, 1);\r\n                }\r\n                    break;\r\n                case \"-B\": {\r\n                    // consume next argument\r\n                    const next_arg = args[arg_idx + 1];\r\n\r\n                    if (next_arg === undefined) {\r\n                        term.writeln(`${PREFABS.error}Expected a body after -B.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    body = next_arg;\r\n                    args.splice(arg_idx + 1, 1);\r\n                }\r\n                    break;\r\n                case \"-o\":\r\n                    overwrite = true;\r\n                    break;\r\n                case \"-n\":\r\n                    binary = true;\r\n                    break;\r\n                default:\r\n                    if (file_path === \"\") {\r\n                        file_path = arg;\r\n                    } else {\r\n                        term.writeln(`${PREFABS.error}Unexpected string argument.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n            }\r\n        }\r\n\r\n        // check if the user provided a filename and i it is not a directory\r\n        if (file_path === \"\") {\r\n            term.writeln(`${PREFABS.error}A file path is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (file_path.endsWith(\"/\")) {\r\n            term.writeln(`${PREFABS.error}Cannot write to a directory.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // check if the file already exists\r\n        const abs_path = fs.absolute(file_path);\r\n\r\n        if (await fs.exists(abs_path) && !overwrite) {\r\n            term.writeln(`${PREFABS.error}File already exists.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // if overwriting, run initial check of readonly status\r\n        if (overwrite) {\r\n            if (await fs.is_readonly(abs_path)) {\r\n                term.writeln(`${PREFABS.error}File is readonly.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        // lock the file, creating it if it does not exist\r\n        if (!(await fs.exists(abs_path))) {\r\n            await fs.write_file(abs_path, \"\");\r\n        }\r\n        await fs.set_readonly(abs_path, true);\r\n\r\n        // fetch the file\r\n        let response: Response;\r\n\r\n        term.writeln(`${FG.green}Downloading file...${STYLE.reset_all}`);\r\n\r\n        try {\r\n            // convert headers to object\r\n            const headers_obj: Record<string, string> = {};\r\n            headers.forEach((value, key) => {\r\n                headers_obj[key] = value;\r\n            });\r\n\r\n            response = await fetch(url, { method, headers: headers_obj, body });\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to fetch file.${STYLE.reset_all}`);\r\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            // reset readonly state\r\n            await fs.set_readonly(abs_path, false);\r\n\r\n            //  if this wasn't an overwrite, delete the file that was created\r\n            if (!overwrite) {\r\n                await fs.delete_file(abs_path);\r\n            }\r\n\r\n            return 1;\r\n        }\r\n\r\n        if (!response.ok) {\r\n            term.writeln(`${PREFABS.error}Request not OK.${STYLE.reset_all}`);\r\n\r\n            // get the error message\r\n            const text = await response.text();\r\n\r\n            if (text !== \"\") {\r\n                term.writeln(`${PREFABS.error}${text}${STYLE.reset_all}`);\r\n            }\r\n\r\n            // reset readonly state\r\n            await fs.set_readonly(abs_path, false);\r\n\r\n            //  if this wasn't an overwrite, delete the file that was created\r\n            if (!overwrite) {\r\n                await fs.delete_file(abs_path);\r\n            }\r\n\r\n            return 1;\r\n        }\r\n\r\n        if (binary) {\r\n            // write the file as binary\r\n            const buffer = await response.arrayBuffer();\r\n\r\n            await fs.write_file(abs_path, new Uint8Array(buffer), true);\r\n        } else {\r\n            // write the file as text\r\n            const text = await response.text();\r\n\r\n            await fs.write_file(abs_path, text.replace(/\\r?\\n/g, NEWLINE), true);\r\n        }\r\n\r\n        // reset readonly state (must've be writable or else this wouldn't be reached)\r\n        await fs.set_readonly(abs_path, false);\r\n\r\n        term.writeln(`${FG.green}File downloaded successfully.${STYLE.reset_all}`);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../kernel/term_ctl\";\r\n\r\nexport default {\r\n    name: \"cat\",\r\n    description: \"Reads files and prints their contents to the terminal.\",\r\n    usage_suffix: \"[filepaths...]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"filepaths\": \"The paths of the files to read.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // get each file's content and print it to the terminal\r\n        for (const filepath of args) {\r\n            const abs_path = fs.absolute(filepath);\r\n\r\n            // check if the file exists and is a file\r\n            if (await fs.dir_exists(abs_path)) {\r\n                term.writeln(`${PREFABS.error}Cannot read a directory: ${abs_path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            if (!(await fs.exists(abs_path))) {\r\n                term.writeln(`${PREFABS.error}File not found: ${abs_path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // get file\r\n            const content = await fs.read_file(abs_path);\r\n\r\n            // print file content to terminal\r\n            term.writeln(content);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../kernel/term_ctl\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\n// TODO: when edit is done, add a flag to edit the file in the editor\r\n\r\nexport default {\r\n    name: \"hex\",\r\n    description: \"Reads a file as hexadecimal.\",\r\n    usage_suffix: \"[-h] path [-i]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the file to read.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-h\": \"Print this help message.\",\r\n            \"-i\": \"Print indexes.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // use default logic for first argument\r\n        if (data.arg_index === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (data.arg_index === 1) {\r\n            if (\"-i\".startsWith(data.current_partial)) {\r\n                return [\"-i\"];\r\n            }\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // check if the user provided a filepath\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}A file path is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args[0] === \"-h\") {\r\n            await kernel.spawn(\"help\", [\"hex\"], shell).completion;\r\n        }\r\n\r\n        // get filepath\r\n        const filepath = args[0];\r\n\r\n        // get absolute path\r\n        const abs_path = fs.absolute(filepath);\r\n\r\n        // check if the file exists and is a file\r\n        if (abs_path.endsWith(\"/\")) {\r\n            term.writeln(`${PREFABS.error}Cannot read a directory: ${abs_path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (!(await fs.exists(abs_path))) {\r\n            term.writeln(`${PREFABS.error}File not found: ${abs_path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get file\r\n        const content = await fs.read_file(abs_path, true) as Uint8Array;\r\n\r\n        // convert uint8array to hex string\r\n        const hex = Array.from(content).map((byte) => byte.toString(16).toUpperCase().padStart(2, \"0\"));\r\n\r\n        // if printing indexes, print the header\r\n        if (args[1] === \"-i\") {\r\n            term.writeln(`         ${FG.blue}00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F${STYLE.reset_all}`);\r\n        }\r\n\r\n        // print hex bytes to terminal up to 16 bytes per line, padding the end with .. in place of the missing bytes\r\n        // if printing indexes, print the index of the first byte on the line, in hexadecimal up to 8 bytes\r\n        for (let i = 0; i < hex.length; i += 16) {\r\n            const line = hex.slice(i, i + 16);\r\n\r\n            if (args[1] === \"-i\") {\r\n                const idx = i <= 0xffffffff ? i.toString(16).toUpperCase() : \"........\";\r\n\r\n\r\n                term.write(`${FG.blue}${idx.padStart(8, \"0\")}${STYLE.reset_all} `);\r\n            }\r\n\r\n            const padded = line.concat(Array(16 - line.length).fill(`${FG.gray}..${STYLE.reset_all}`));\r\n            term.writeln(padded.join(\" \"));\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { NEWLINE, ANSI, ANSI_UNESCAPED_REGEX } from \"../kernel/term_ctl\";\r\n\r\nimport { default as img2ascii } from \"imgToAscii\";\r\n\r\n\r\nconst MY_USERNAME = \"obfuscatedgenerated\";\r\nconst GH_USERNAME_REGEX = /^[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}$/i;\r\n\r\nconst username_to_avatar_url = (username: string): string => {\r\n    return `https://avatars.githubusercontent.com/${username}`;\r\n}\r\n\r\ntype GHInfo = { name: string, bio: string, location: string, blog: string, followers: number, following: number, twitter: string };\r\nconst get_github_info = async (username: string): Promise<GHInfo> => {\r\n    const url = `https://api.github.com/users/${username}`;\r\n    const res = await fetch(url);\r\n\r\n    if (!res.ok) {\r\n        return null;\r\n    }\r\n\r\n    const json = await res.json();\r\n\r\n    return {\r\n        name: json.name,\r\n        bio: json.bio,\r\n        location: json.location,\r\n        blog: json.blog,\r\n        followers: json.followers,\r\n        following: json.following,\r\n        twitter: json.twitter_username\r\n    };\r\n}\r\n\r\nconst convert_to_ascii = async (url: string, size: number): Promise<string> => {\r\n    const img = new img2ascii(url, size, Math.round(size / 2));\r\n    await img.loadImage;\r\n\r\n    // convert newlines in string\r\n    const ascii = img.stringANSI8BitColor.replace(/\\n/g, NEWLINE);\r\n    return ascii;\r\n}\r\n\r\n\r\nconst known_info = (username: string, data: { [key: string]: any }, gh_info: GHInfo | null, version_str: string) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, FG, PREFABS } = ANSI;\r\n\r\n    return `\r\n${STYLE.bold}${username}\r\n-------------------\r\n${STYLE.bold}OS${STYLE.reset_all + FG.cyan}: OllieOS v${version_str}\r\n\r\n${STYLE.bold}Name${STYLE.reset_all + FG.cyan}: ${data.name || gh_info?.name || \"Unknown\"}\r\n${STYLE.bold}Pronouns${STYLE.reset_all + FG.cyan}: ${data.pronouns.subject}/${data.pronouns.object_or_alt}${data.pronouns.possessive ? `/${data.pronouns.possessive}` : \"\"}\r\n${STYLE.bold}Location${STYLE.reset_all + FG.cyan}: ${data.location || gh_info?.location || \"Unknown\"}\r\n${STYLE.bold}Interests${STYLE.reset_all + FG.cyan}: ${data.interests.join(\", \") || \"None listed\"}\r\n\r\n${data.websites ? Object.entries(data.websites).map(\r\n    ([name, url]) => `${STYLE.bold}${name}${STYLE.reset_all + FG.cyan}: ${url}`\r\n).join(NEWLINE) : \"\"}\r\n\r\n${STYLE.bold}GitHub Followers${STYLE.reset_all + FG.cyan}: ${gh_info.followers || 0}\r\n${STYLE.bold}GitHub Following${STYLE.reset_all + FG.cyan}: ${gh_info.following || 0}\r\n\r\n${data.extra ? Object.entries(data.extra).map(\r\n    ([name, value]) => `${STYLE.bold}${name}${STYLE.reset_all + FG.cyan}: ${value}`\r\n).join(NEWLINE) : \"\"}\r\n        `.replace(/\\n/g, NEWLINE);\r\n}\r\n\r\nconst stranger_info = (username: string, gh_info: GHInfo | null, cols: number, version_str: string) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, FG } = ANSI;\r\n\r\n    // line wrap the bio and make sure newlines ARE NOT CRLF (to retain columns)\r\n    if (gh_info.bio) {\r\n        gh_info.bio = gh_info.bio.replace(/\\r\\n/g, \"\\n\").replace(new RegExp(`(.{${Math.floor(cols * 0.25)}})\\\\s`, \"g\"), \"$1\\n\");\r\n    }\r\n\r\n    // TODO: messy, clean up\r\n    // insert known data or move up a line if not known (to undo the newline added by the ternary operator)\r\n    return `\r\n${STYLE.bold}${username}\r\n${\"-\".repeat(username.length)}\r\n${STYLE.bold}OS${STYLE.reset_all + FG.cyan}: OllieOS v${version_str}\r\n\r\n${gh_info.name ? `${STYLE.bold}Name${STYLE.reset_all + FG.cyan}: ${gh_info.name}` : \"\\x1b[1A\"}\r\n${gh_info.location ? `${STYLE.bold}Location${STYLE.reset_all + FG.cyan}: ${gh_info.location}` : \"\\x1b[1A\"}\r\n${gh_info.bio ? `${STYLE.bold}Bio${STYLE.reset_all + FG.cyan}: ${gh_info.bio}` : \"\\x1b[1A\"}\r\n\r\n${gh_info.blog ? `${STYLE.bold}Website${STYLE.reset_all + FG.cyan}: ${gh_info.blog}` : \"\\x1b[1A\"}\r\n\r\n${STYLE.bold}GitHub${STYLE.reset_all + FG.cyan}: https://github.com/${username}\r\n${gh_info.twitter ? `${STYLE.bold}Twitter${STYLE.reset_all + FG.cyan}: https://twitter.com/${gh_info.twitter}` : \"\\x1b[1A\"}\r\n\r\n${STYLE.bold}GitHub Followers${STYLE.reset_all + FG.cyan}: ${gh_info.followers || 0}\r\n${STYLE.bold}GitHub Following${STYLE.reset_all + FG.cyan}: ${gh_info.following || 0}\r\n    `.replace(/\\n/g, NEWLINE);\r\n}\r\n\r\nexport default {\r\n    name: \"mefetch\",\r\n    description: \"Shows information about me (or you!)\",\r\n    usage_suffix: \"[username]\",\r\n    arg_descriptions: {\r\n        \"username\": \"The GitHub username to show basic info about. Defaults to my username, with the special info shown.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term, args } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, FG } = ANSI;\r\n\r\n        // get version string\r\n        const version_str = kernel.get_env_info().version;\r\n\r\n        // restrict to first 3 quarters of screen\r\n        const max_columns = Math.floor(term.cols * 0.75);\r\n\r\n        // set image size\r\n        const asc_width = Math.floor(max_columns / 3);\r\n\r\n        // get username\r\n        const username = args[0] || MY_USERNAME;\r\n\r\n        // check if username is valid\r\n        if (!username.match(GH_USERNAME_REGEX)) {\r\n            term.write(`${STYLE.bold}${FG.red}Invalid username.${STYLE.reset_all}\\n`);\r\n            return 1;\r\n        }\r\n\r\n        // get info from GitHub\r\n        const gh_info = await get_github_info(username);\r\n\r\n        // if info is null, then the user doesn't exist\r\n        if (gh_info === null) {\r\n            term.write(`${STYLE.bold}${FG.red}User not found.${STYLE.reset_all}\\n`);\r\n            return 1;\r\n        }\r\n\r\n        // use local logo for efficiency if username is mine\r\n        const avatar_url = MY_USERNAME === username ? \"https://ollieg.codes/public/logo.png\" : username_to_avatar_url(username);\r\n\r\n        // convert image to ascii\r\n        const ascii_pfp = await convert_to_ascii(avatar_url, asc_width);\r\n\r\n        // check synced data if username exists in data repo\r\n        let known_data = null;\r\n        const fs = kernel.get_fs();\r\n        if (await fs.exists(\"/var/lib/data/person/index.json\")) {\r\n            const data_index_str = await fs.read_file(\"/var/lib/data/person/index.json\") as string;\r\n            const data_index = JSON.parse(data_index_str) as string[];\r\n\r\n            if (data_index.includes(username)) {\r\n                const user_data_str = await fs.read_file(`/var/lib/data/person/${username}.json`) as string;\r\n                known_data = JSON.parse(user_data_str);\r\n            }\r\n        }\r\n\r\n        // text is written with \\n as newlines for simplicity, replaced with NEWLINE\r\n        let text: string;\r\n        if (known_data) {\r\n            text = known_info(username, known_data, gh_info, version_str);\r\n        } else {\r\n            text = stranger_info(username, gh_info, term.cols, version_str);\r\n        }\r\n\r\n        // reapply style each line as image will override it\r\n        const txt_line_prefix = FG.cyan;\r\n        const txt_line_suffix = STYLE.reset_all;\r\n\r\n        // go line by line through both text and ascii\r\n        const asc_lines = ascii_pfp.split(NEWLINE);\r\n        const txt_lines = text.split(NEWLINE);\r\n\r\n        // get the greater of the two lengths\r\n        const max_lines = Math.max(asc_lines.length, txt_lines.length);\r\n\r\n        // get the longest length of a line of ascii ignoring ansi characters, and the longest length of a line of text\r\n        const max_asc_line_length = Math.max(...asc_lines.map(line => line.replace(ANSI_UNESCAPED_REGEX, \"\").length));\r\n        const max_txt_line_length = Math.max(...txt_lines.map(line => line.length));\r\n\r\n        // determine padding around and between text and ascii\r\n        const center_padding_size = Math.floor(max_columns / 15);\r\n        const side_padding_size = Math.floor((max_columns - max_txt_line_length - (max_asc_line_length / 2) - center_padding_size) / 2);\r\n\r\n        // generate padding strings, if positive\r\n        const center_padding = \" \".repeat(center_padding_size > 0 ? center_padding_size : 0);\r\n        const side_padding = \" \".repeat(side_padding_size > 0 ? side_padding_size : 0);\r\n\r\n        // print each line\r\n        for (let i = 0; i < max_lines; i++) {\r\n            const asc_line = asc_lines[i] || \"\";\r\n            const txt_line = txt_lines[i] || \"\";\r\n\r\n            // add additional padding so the width of the ascii line is always the same\r\n            const asc_line_padding = \" \".repeat(max_asc_line_length - asc_line.replace(ANSI_UNESCAPED_REGEX, \"\").length);\r\n\r\n            // print side by side with padding\r\n            term.writeln(side_padding + asc_line + asc_line_padding + center_padding + txt_line_prefix + txt_line + txt_line_suffix);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import { ANSI } from \"../kernel/term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"reader\",\r\n    description: \"Toggles screen reader mode. Due to a technical limitation, on-screen links will not be clickable in screen reader mode.\",\r\n    usage_suffix: \"[-h] [-q] [-s on|off]\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-q\": \"Query the current screen reader mode.\",\r\n            \"-s\": \"Explicitly set the screen reader mode to on or off, rather than toggling it.\"\r\n        }\r\n    },\r\n    node_opt_out: true,\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (data.arg_index === 0) {\r\n            return helper_completion_options([\"-h\", \"-q\", \"-s\"])(data);\r\n        }\r\n\r\n        if (data.arg_index === 1 && data.args[0] === \"-s\") {\r\n            return helper_completion_options([\"on\", \"off\"])(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get sound registry\r\n        const sfx_reg = kernel.get_sound_registry();\r\n\r\n        switch (args[0]) {\r\n            case \"-h\":\r\n                return await kernel.spawn(\"help\", [\"clear\"], shell).completion;\r\n            case \"-q\":\r\n                // query screen reader mode\r\n                term.writeln(`Screen reader mode is currently ${term.options.screenReaderMode ? \"on\" : \"off\"}.`);\r\n                return 0;\r\n            case \"-s\":\r\n                // set screen reader mode\r\n                switch (args[1]) {\r\n                    case \"on\":\r\n                        term.options.screenReaderMode = true;\r\n                        break;\r\n                    case \"off\":\r\n                        term.options.screenReaderMode = false;\r\n                        break;\r\n                    default:\r\n                        term.writeln(\"Invalid argument. Expected \\\"on\\\" or \\\"off\\\".\");\r\n                        return 1;\r\n                }\r\n                break;\r\n            default:\r\n                // toggle screen reader mode\r\n                term.options.screenReaderMode = !term.options.screenReaderMode;\r\n        }\r\n\r\n        const state = term.options.screenReaderMode ? \"on\" : \"off\";\r\n\r\n        // play sound\r\n        const sound_name = `reader_${state}`;\r\n        sfx_reg.wait_to_play(sound_name);\r\n\r\n        // print message\r\n        term.writeln(`Screen reader mode was turned ${state}. This setting is saved in your browser's local storage. Use the ${PREFABS.program_name}reader${STYLE.reset_all} command to toggle it.`);\r\n\r\n        // remove hint element if screen reader mode is on\r\n        if (term.options.screenReaderMode) {\r\n            const hint = document.querySelector(\"#screenreader_hint\");\r\n\r\n            if (hint) {\r\n                hint.remove();\r\n            }\r\n        }\r\n\r\n        // save into local storage\r\n        localStorage.setItem(\"reader\", term.options.screenReaderMode.toString());\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE } from \"../kernel/term_ctl\";\r\n\r\nexport default {\r\n    name: \"selfdestruct\",\r\n    description: \"Permanently erases the filesystem and other data, then restarts the terminal.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { FG, BG, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        const pad = (str: string, invis_codes = \"\") => {\r\n            if (str.length >= term.cols) {\r\n                return str;\r\n            }\r\n\r\n            return str + \" \".repeat(term.cols - str.length + invis_codes.length);\r\n        }\r\n\r\n        // make sure the user really wants to do this\r\n        term.writeln(BG.red + FG.white + STYLE.bold);\r\n        term.write(pad(\"WARNING: This will permanently erase the filesystem and other data, and restart the terminal.\"));\r\n        term.writeln(pad(\"This data cannot be recovered. Are you sure you want to do this?\"));\r\n        term.writeln(pad(`Press ${BG.blue}Y${BG.red} 3 times to continue, or anything else to cancel.`, BG.blue + BG.red));\r\n        term.write(STYLE.reset_all);\r\n\r\n        // wait for the user to press Y 3 times\r\n        let y_count = 0;\r\n        while (y_count < 3) {\r\n            const key = await term.wait_for_keypress();\r\n            if (key.key === \"y\" || key.key === \"Y\") {\r\n                y_count++;\r\n            } else {\r\n                term.writeln(\"Cancelled.\");\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        // clear the screen and erase the filesystem\r\n        term.reset();\r\n\r\n        term.writeln(\"Erasing filesystem and other data...\");\r\n        await fs.erase_all();\r\n        localStorage.removeItem(\"fetch_ttl_cache\");\r\n\r\n        term.writeln(`${NEWLINE}Thank you for using OllieOS!${NEWLINE}`);\r\n\r\n        // TODO: talk to ignition instead of using shutdown command\r\n        return await kernel.spawn(\"shutdown\", [\"-r\", \"-t\", \"3000\"], shell).completion;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../kernel/term_ctl\";\r\n\r\nimport { image2sixel } from \"sixel\";\r\n\r\n\r\n// returns null if image is invalid\r\nconst convert_to_image_data = async (url: string) => {\r\n    // create a canvas to draw the image on\r\n    const canvas = document.createElement(\"canvas\");\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    // create an image to draw the png data on\r\n    const img = new Image();\r\n    img.crossOrigin = \"anonymous\";\r\n    img.src = url;\r\n\r\n    // wait for the image to load via promise\r\n    try {\r\n        await new Promise((resolve, reject) => {\r\n            img.onload = () => {\r\n                resolve(null);\r\n            };\r\n\r\n            img.onerror = () => {\r\n                reject(null);\r\n            };\r\n        });\r\n    } catch (e) {\r\n        return null;\r\n    }\r\n\r\n    // draw the image on the canvas\r\n    canvas.width = img.width;\r\n    canvas.height = img.height;\r\n    ctx.drawImage(img, 0, 0);\r\n\r\n    // get the image data\r\n    const img_data = ctx.getImageData(0, 0, img.width, img.height);\r\n\r\n    // convert image data to uint8array\r\n    const data_arr = new Uint8Array(img_data.data);\r\n\r\n    return { array: data_arr, width: img.width, height: img.height };\r\n};\r\n\r\nexport default {\r\n    name: \"imagine\",\r\n    description: \"Views images natively in the terminal.\",\r\n    usage_suffix: \"path [-w width] [-u]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the image to view.\"\r\n        },\r\n        \"Options:\": {\r\n            \"-w\": \"The width of the image in PIXELS. Defaults to the width of the image.\",\r\n            \"-u\": \"Path is an web URL instead of a local filesystem path.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // get the path to the image\r\n        const path = args[0];\r\n\r\n        if (!path) {\r\n            term.writeln(`${PREFABS.error}No path specified.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get the width of the image specified or the terminal width\r\n        let width_arg = args.includes(\"-w\") ? parseInt(args[args.indexOf(\"-w\") + 1]) : undefined;\r\n        const is_web_url = args.includes(\"-u\");\r\n\r\n        let url: string;\r\n        let mime: string;\r\n        if (!is_web_url) {\r\n            // process the path\r\n            url = fs.absolute(path);\r\n            if (!(await fs.exists(url))) {\r\n                term.writeln(`${PREFABS.error}No such file or directory: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // get the extension\r\n            const ext = url.slice(-4).toLowerCase();\r\n\r\n            // get the mime type\r\n            switch (ext) {\r\n                case \".png\":\r\n                    mime = \"image/png\";\r\n                    break;\r\n                case \".jpg\":\r\n                case \"jpeg\":\r\n                    mime = \"image/jpeg\";\r\n                    break;\r\n                case \".gif\":\r\n                    mime = \"image/gif\";\r\n                    break;\r\n                default:\r\n                    term.writeln(`${PREFABS.error}File is not known to be a .png, .jpg/.jpeg or .gif: ${url}${STYLE.reset_all}`);\r\n                    return 1;\r\n            }\r\n\r\n\r\n            // convert to blob URL\r\n            const content = await fs.read_file(url, true) as Uint8Array;\r\n            //@ts-expect-error\r\n            url = URL.createObjectURL(new Blob([content]));\r\n\r\n        } else {\r\n            // check path is a valid URL\r\n            try {\r\n                new URL(path);\r\n                url = path;\r\n            } catch (e) {\r\n                term.writeln(`${PREFABS.error}Invalid URL: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // do a HEAD request to get the mime type\r\n            try {\r\n                const head_req = await fetch(url, { method: \"HEAD\" });\r\n\r\n                // if the HEAD request failed, try a GET request\r\n                if (!head_req.ok) {\r\n                    console.log(\"HEAD request failed, trying GET request\");\r\n                    const get_req = await fetch(url);\r\n\r\n                    // if the GET request failed, error\r\n                    if (!get_req.ok) {\r\n                        term.writeln(`${PREFABS.error}URL is not accessible: ${url}${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    mime = get_req.headers.get(\"content-type\");\r\n                } else {\r\n                    mime = head_req.headers.get(\"content-type\");\r\n                }\r\n\r\n                // check the mime type is valid\r\n                if ([\"image/png\", \"image/jpeg\", \"image/gif\"].indexOf(mime) === -1) {\r\n                    term.writeln(`${PREFABS.error}URL does not point to a .png, .jpg/.jpeg or .gif: ${url}${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n            } catch (e) {\r\n                term.writeln(`${PREFABS.error}Error accessing URL: ${url}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        const data_out = await convert_to_image_data(url);\r\n\r\n        if (!data_out) {\r\n            term.writeln(`${PREFABS.error}Failed to convert image to data. Did you download it as a binary file?${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        const { array: img_data, width: img_width, height: img_height } = data_out\r\n\r\n        if (!width_arg) {\r\n            width_arg = img_width;\r\n        }\r\n\r\n        // scale the height to fit the width\r\n        const width_scale = width_arg / img_width;\r\n        const new_height = img_height * width_scale;\r\n\r\n        // scale the image data by chopping every nth pixel\r\n        const scaled_img_data = new Uint8Array(width_arg * new_height * 4);\r\n        for (let i = 0; i < scaled_img_data.length; i++) {\r\n            const x = Math.floor(i / 4) % width_arg;\r\n            const y = Math.floor(Math.floor(i / 4) / width_arg);\r\n\r\n            const scaled_x = Math.floor(x / width_scale);\r\n            const scaled_y = Math.floor(y / width_scale);\r\n\r\n            const scaled_i = (scaled_y * img_width + scaled_x) * 4 + (i % 4);\r\n\r\n            scaled_img_data[i] = img_data[scaled_i];\r\n        }\r\n\r\n        try {\r\n            // convert the Uint8Array to a sixel image\r\n            const sixel = image2sixel(scaled_img_data, width_arg, new_height);\r\n\r\n            // write the sixel image to the terminal\r\n            term.write(sixel);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to convert image to sixel.${STYLE.reset_all}`);\r\n            console.error(e);\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE } from \"../kernel/term_ctl\";\r\n\r\nimport { default as img2ascii } from \"imgToAscii\";\r\n\r\n\r\n// TODO: DRY with mefetch\r\nconst convert_to_ascii = async (url: string, size: number): Promise<string> => {\r\n    const img = new img2ascii(url, size, Math.round(size / 2));\r\n    await img.loadImage;\r\n\r\n    // convert newlines in string\r\n    const ascii = img.stringANSI8BitColor.replace(/\\n/g, NEWLINE);\r\n    return ascii;\r\n}\r\n\r\nexport default {\r\n    name: \"ascmagine\",\r\n    description: \"Views images as ANSI/ASCII art.\",\r\n    usage_suffix: \"path [-w width] [-u]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the image to view.\"\r\n        },\r\n        \"Options:\": {\r\n            \"-w\": \"The width of the image in COLUMNS. Defaults to the width of the terminal.\",\r\n            \"-u\": \"Path is an web URL instead of a local filesystem path.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // get the path to the image\r\n        const path = args[0];\r\n\r\n        if (!path) {\r\n            term.writeln(`${PREFABS.error}No path specified.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get the width of the image specified or the terminal width\r\n        const width_arg = args.includes(\"-w\") ? parseInt(args[args.indexOf(\"-w\") + 1]) : undefined;\r\n        const is_web_url = args.includes(\"-u\");\r\n\r\n        let url: string;\r\n        if (!is_web_url) {\r\n            // process the path\r\n            url = fs.absolute(path);\r\n            if (!(await fs.exists(url))) {\r\n                term.writeln(`${PREFABS.error}No such file or directory: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // convert to blob\r\n            const content = await fs.read_file(url, true) as Uint8Array;\r\n            //@ts-expect-error\r\n            const blob = new Blob([content]);\r\n\r\n            // attempt createImageBitmap on the file to determine if it's a canvas-compatible image in the browser\r\n            if (typeof createImageBitmap === \"function\") {\r\n                try {\r\n                    // using tiny region at low res for efficiency\r\n                    await createImageBitmap(blob, 0, 0, 1, 1);\r\n                } catch (e) {\r\n                    term.writeln(`${PREFABS.error}File is not a valid image: ${path}. Did you download it as a binary file?${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n            } else {\r\n                term.writeln(`${FG.yellow}Warning: ${STYLE.reset_all}createImageBitmap is not supported in this browser. Falling back to list of trusted image formats.${STYLE.reset_all}`)\r\n                \r\n                const trusted_formats = [\".png\", \".jpg\", \".jpeg\", \".gif\", \".bmp\", \".ico\", \".svg\"];\r\n                const ext = url.slice(-4).toLowerCase();\r\n\r\n                if (!(trusted_formats.includes(ext))) {\r\n                    term.writeln(`${PREFABS.error}File is not a valid image: ${path}. Did you download it as a binary file?${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n            }\r\n\r\n            // create a blob URL\r\n            //@ts-expect-error\r\n            url = URL.createObjectURL(new Blob([content]));\r\n\r\n        } else {\r\n            // check path is a valid URL\r\n            try {\r\n                new URL(path);\r\n                url = path;\r\n            } catch (e) {\r\n                term.writeln(`${PREFABS.error}Invalid URL: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // do a HEAD request to check the mime type\r\n            const head_req = await fetch(url, { method: \"HEAD\" });\r\n            let mime: string;\r\n\r\n            // if the HEAD request failed, try a GET request\r\n            if (!head_req.ok) {\r\n                console.log(\"HEAD request failed, trying GET request\");\r\n                const get_req = await fetch(url);\r\n\r\n                // if the GET request failed, error\r\n                if (!get_req.ok) {\r\n                    term.writeln(`${PREFABS.error}URL is not accessible: ${url}${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                mime = get_req.headers.get(\"content-type\");\r\n            } else {\r\n                mime = head_req.headers.get(\"content-type\");\r\n            }\r\n\r\n            // check the mime type is valid\r\n            if (!mime.startsWith(\"image/\")) {\r\n                term.writeln(`${PREFABS.error}URL is not an image: ${url}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        // get the image\r\n        const img = await convert_to_ascii(url, width_arg || term.cols - 1);\r\n\r\n        // write the image\r\n        term.write(img);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../kernel/term_ctl\";\r\n\r\nexport default {\r\n    name: \"fsedit\",\r\n    description: \"Opens the fsedit program to edit the filesystem.\",\r\n    usage_suffix: \"[directory]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            directory: \"The directory to open fsedit in. Defaults to the current working directory.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term, process } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // get fs name\r\n        const fs_name = fs.get_unique_fs_type_name();\r\n\r\n        // check args\r\n        let dir = fs.get_cwd();\r\n        if (args.length > 1) {\r\n            term.writeln(`${PREFABS.error}Too many arguments.${STYLE.reset_all}`);\r\n            return 1;\r\n        } else if (args.length === 1) {\r\n            // set dir\r\n            dir = fs.absolute(args[0]);\r\n        }\r\n\r\n        // check if directory exists\r\n        if (!(await fs.dir_exists(dir))) {\r\n            term.writeln(`${PREFABS.error}Directory '${args[0]}' does not exist.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // url encode the directory\r\n        const encoded_dir = encodeURIComponent(dir);\r\n\r\n        if (!kernel.has_window_manager()) {\r\n            // fallback to opening in a popup window\r\n            window.open(`./fsedit?type=${fs_name}&dir=${encoded_dir}`, \"_blank\", \"popup=true\");\r\n            term.writeln(\"Opened fsedit in a new popup window.\");\r\n            return 0;\r\n        }\r\n\r\n        const iframe = document.createElement(\"iframe\");\r\n        iframe.src = `./fsedit?type=${fs_name}&dir=${encoded_dir}`;\r\n        iframe.style.border = \"none\";\r\n        iframe.style.width = \"100%\";\r\n        iframe.style.height = \"100%\";\r\n\r\n        const wind = process.create_window();\r\n        wind.title = \"fsedit\";\r\n\r\n        wind.width = \"75vw\";\r\n        wind.height = \"75vh\";\r\n\r\n        wind.x = \"12.5vw\";\r\n        wind.y = \"12.5vh\";\r\n\r\n        wind.dom.appendChild(iframe);\r\n        wind.show();\r\n\r\n        // send message\r\n        term.writeln(\"Opened fsedit in a new window.\");\r\n\r\n        wind.add_event_listener(\"close\", async () => {\r\n            // backup unlock logic TODO improve the design of fsedit in general\r\n            if (await fs.exists(\"/.fs.lock\")) {\r\n                // check that no other fsedit processes are running\r\n                let other_fsedit_running = false;\r\n                const processes = kernel.get_process_manager().list_pids();\r\n                for (const pid of processes) {\r\n                    if (pid === process.pid) {\r\n                        continue;\r\n                    }\r\n\r\n                    const proc = kernel.get_process_manager().get_process(pid);\r\n                    if (proc && proc.source_command.command === \"fsedit\") {\r\n                        other_fsedit_running = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!other_fsedit_running) {\r\n                    await fs.delete_file(\"/.fs.lock\");\r\n                }\r\n            }\r\n\r\n            process.kill(0);\r\n        });\r\n\r\n        // listen for message from iframe to close window\r\n        const message_handler = (event: MessageEvent) => {\r\n            if (event.source === iframe.contentWindow && event.data === \"closing-fsedit\") {\r\n                wind.close();\r\n                window.removeEventListener(\"message\", message_handler);\r\n            }\r\n        };\r\n        window.addEventListener(\"message\", message_handler);\r\n\r\n        process.detach();\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../kernel/term_ctl\";\r\nimport { NonRecursiveDirectoryError, PathNotFoundError } from \"../kernel/filesystem\";\r\n\r\nexport default {\r\n    name: \"rm\",\r\n    description: \"Deletes a file or directory.\",\r\n    usage_suffix: \"[-rf | -f] path\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the file or directory to delete.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-rf\": \"Recursively and forcibly delete directories (ignoring if directory has content, treated as -f if a file is passed).\",\r\n            \"-f\": \"Forcibly delete files (ignoring readonly state, NOT treated as -rf if a directory is passed).\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // determine if -rf OR -f was passed\r\n        let rimraf = false;\r\n        let force = false;\r\n\r\n        if (args[0] === \"-rf\") {\r\n            rimraf = true;\r\n            force = true;\r\n            args.shift();\r\n        } else if (args[0] === \"-f\") {\r\n            force = true;\r\n            args.shift();\r\n        }\r\n\r\n        // check if there is only one argument after parsing flag\r\n        if (args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}Invalid arguments.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get path\r\n        const path = args[0];\r\n        const abs_path = fs.absolute(path);\r\n\r\n        // check if path exists\r\n        if (!(await fs.exists(abs_path))) {\r\n            term.writeln(`${PREFABS.error}Path does not exist.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // check if path is a directory\r\n        const is_dir = await fs.dir_exists(abs_path);\r\n\r\n        // perform deletion\r\n        if (is_dir) {\r\n            try {\r\n                await fs.delete_dir(abs_path, rimraf);\r\n            } catch (e) {\r\n                if (e instanceof NonRecursiveDirectoryError) {\r\n                    term.writeln(`${PREFABS.error}Directory is not empty. Refusing to delete without -rf flag.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                if (e instanceof PathNotFoundError) {\r\n                    term.writeln(`${PREFABS.error}Path no longer exists.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                throw e;\r\n            }\r\n        } else {\r\n            // if not forcing, check if file is readonly\r\n            if (!force && await fs.is_readonly(abs_path)) {\r\n                term.writeln(`${PREFABS.error}File is readonly. Refusing to delete without -f flag.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            await fs.delete_file(abs_path);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../kernel/term_ctl\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nconst type_suffixes = {\r\n    bug: \"?assignees=&labels=awaiting+effort+estimate%2C+awaiting+triage%2C+bug%2C+unreviewed&template=bug-report-%F0%9F%90%9B.md&title=%5B%F0%9F%90%9B%5D+-+Descriptive%2C+short+title\",\r\n    feature: \"?assignees=&labels=awaiting+effort+estimate%2C+awaiting+triage%2C+feature%2C+unreviewed&template=feature-request-%F0%9F%92%A1.md&title=%5B%F0%9F%92%A1%5D+-+Descriptive%2C+short+title\",\r\n    other: \"/choose\",\r\n}\r\n\r\nexport default {\r\n    name: \"bugreport\",\r\n    description: \"Opens the bug reporter.\",\r\n    usage_suffix: \"[bug|feature|other]\",\r\n    arg_descriptions: {\r\n        bug: \"Opens the bug reporter with the bug report template.\",\r\n        feature: \"Opens the bug reporter with the feature request template.\",\r\n        other: \"Opens the bug reporter with the template chooser (default).\",\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: helper_completion_options([\"bug\", \"feature\", \"other\"]),\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { term, args } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // if no arguments are provided, default to bug\r\n        let type = \"other\";\r\n        if (args.length > 0) {\r\n            type = args[0].toLowerCase();\r\n\r\n            // check if the type is valid (don't use in, it won't filter __proto__ etc.)\r\n            if (!Object.keys(type_suffixes).includes(type)) {\r\n                term.writeln(`${PREFABS.error} Invalid type: ${type}. Please choose bug, feature, or other.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        window.open(`https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io/issues/new${type_suffixes[type]}`, \"_blank\", \"\");\r\n\r\n        term.writeln(\"Opened bug reporter in a new tab.\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"repo\",\r\n    description: \"Opens the GitHub repository for OllieOS.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { term } = data;\r\n\r\n        window.open(\"https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io\", \"_blank\", \"\");\r\n\r\n        term.writeln(\"Opened repo in a new tab.\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import type { Program } from \"../types\";\r\n\r\nimport { ANSI, NEWLINE } from \"../kernel/term_ctl\";\r\n\r\nimport { convert as convert_html_to_text } from \"html-to-text\";\r\n\r\nconst HTML_TAG_REGEX = /<\\/?[a-z][\\s\\S]*>/i;\r\n\r\n// modified from source: https://github.com/rbren/rss-parser/blob/master/lib/fields.js\r\nconst fields = { feed: {}, item: {} };\r\n\r\n// known feed fields\r\nfields.feed = {\r\n    author: [\"author\", \"creator\"],\r\n    publisher: [\"dc:publisher\", \"publisher\"],\r\n    title: [\"dc:title\", \"title\"],\r\n    description: \"description\",\r\n    date: \"pubDate\",\r\n    link: \"link\",\r\n};\r\n\r\n// known item fields\r\nfields.item = {\r\n    author: [\"author\", \"creator\"],\r\n    date: [\"dc:date\", \"date\", \"pubDate\"],\r\n    title: [\"dc:title\", \"title\"],\r\n    link: \"link\",\r\n    summary: \"summary\",\r\n    description: [\"content:encoded\", \"content\", \"description\"],\r\n};\r\n// end source: https://github.com/rbren/rss-parser/blob/master/lib/fields.js\r\n\r\nenum DocType {\r\n    FEED,\r\n    ITEM\r\n}\r\n\r\nconst get_field = (doc: Document | Element, doc_type: DocType, field: string, as_html = false) => {\r\n    // get the fields object\r\n    const dict = doc_type === DocType.FEED ? fields.feed : fields.item;\r\n\r\n    // check if the field is known (don't use in, it won't filter out __proto__ etc.)\r\n    if (!Object.keys(dict).includes(field)) {\r\n        return undefined;\r\n    }\r\n\r\n    // get the field\r\n    const field_value = dict[field];\r\n\r\n    // if the field is an array, concatenate the values\r\n    if (Array.isArray(field_value)) {\r\n        let value = \"\";\r\n\r\n        for (const sub_field of field_value) {\r\n            const sub_field_doc = doc.getElementsByTagName(sub_field)[0];\r\n            let sub_value: string;\r\n\r\n            if (as_html) {\r\n                sub_value = sub_field_doc?.innerHTML;\r\n            } else {\r\n                sub_value = sub_field_doc?.textContent;\r\n            }\r\n\r\n            if (sub_value) {\r\n                value += sub_value;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    } else {\r\n        // otherwise, get the value\r\n        if (as_html) {\r\n            return doc.getElementsByTagName(field_value)[0]?.innerHTML;\r\n        } else {\r\n            return doc.getElementsByTagName(field_value)[0]?.textContent;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport default {\r\n    name: \"rss\",\r\n    description: \"Reads from an RSS feed.\",\r\n    usage_suffix: \"[-h] [url] [-m items] [-x]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"url\": \"The URL to the XML feed (plaintext feed recommended, unless the HTML is basic). Defaults to https://blog.ollieg.codes/rss/feed.xml\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-h\": \"Print this help message.\",\r\n            \"-m\": \"The maximum number of items to display. Defaults to no limit.\",\r\n            \"-x\": \"Only display titles, links and publishing dates, not descriptions.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"rss\"], shell).completion;\r\n        }\r\n\r\n        let max_items: number | undefined = undefined;\r\n        if (args.includes(\"-m\")) {\r\n            // get the index of the flag\r\n            const index = args.indexOf(\"-m\");\r\n\r\n            // get the value after the flag\r\n            const value = args[index + 1];\r\n\r\n            // check if the value is valid\r\n            if (!value || isNaN(parseInt(value)) || parseInt(value) < 0) {\r\n                term.writeln(`${PREFABS.error}Invalid value for -m flag. Expected a positive integer.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // set the max items\r\n            max_items = parseInt(value);\r\n\r\n            // remove the flag and value from the args\r\n            args.splice(index, 2);\r\n        }\r\n\r\n        const no_content = args.includes(\"-x\");\r\n\r\n\r\n        // check if the user provided a URL\r\n        let url = \"https://blog.ollieg.codes/rss/feed.xml\";\r\n        if (args.length !== 0) {\r\n            url = args.shift();\r\n        }\r\n\r\n        // validate url\r\n        try {\r\n            const proc_url = new URL(url);\r\n\r\n            if (proc_url.protocol !== \"http:\" && proc_url.protocol !== \"https:\") {\r\n                throw new Error(\"Invalid protocol\");\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Invalid URL. Expected a valid HTTP or HTTPS protocol URL.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // fetch the feed\r\n        // TODO: potential DRY with webget\r\n        let response: Response;\r\n\r\n        term.writeln(`${FG.green}Fetching feed...${STYLE.reset_all}`);\r\n\r\n        try {\r\n            response = await fetch(url);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to fetch feed.${STYLE.reset_all}`);\r\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            return 1;\r\n        }\r\n\r\n        if (!response.ok) {\r\n            term.writeln(`${PREFABS.error}Request not OK.${STYLE.reset_all}`);\r\n\r\n            // get the error message\r\n            const text = await response.text();\r\n\r\n            if (text !== \"\") {\r\n                term.writeln(`${PREFABS.error}${text}${STYLE.reset_all}`);\r\n            }\r\n\r\n            return 1;\r\n        }\r\n\r\n        // get the text and convert newlines (\\r\\n or \\n) to the terminal's newline\r\n        const text = (await response.text()).replace(/\\r\\n|\\n/g, NEWLINE);\r\n\r\n        // parse the text\r\n        const parser = new DOMParser();\r\n\r\n        let doc: Document;\r\n\r\n        try {\r\n            doc = parser.parseFromString(text, \"text/xml\");\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to parse feed.${STYLE.reset_all}`);\r\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            return 1;\r\n        }\r\n\r\n        term.write(NEWLINE);\r\n\r\n        // print the title if it exists\r\n        const feed_title = get_field(doc, DocType.FEED, \"title\") ?? \"Untitled feed\";\r\n        term.writeln(`${FG.cyan + STYLE.bold + STYLE.italic}${feed_title}${STYLE.reset_all}`);\r\n\r\n        // print the site link if it exists\r\n        const site_link = get_field(doc, DocType.FEED, \"link\") ?? \"\";\r\n        term.writeln(`${FG.cyan}${site_link}${STYLE.reset_all}`);\r\n\r\n        // print the site description if it exists\r\n        const site_description = get_field(doc, DocType.FEED, \"description\") ?? \"\";\r\n        term.writeln(`${site_description}`);\r\n\r\n        term.write(NEWLINE);\r\n        term.writeln(`${FG.gray}------${STYLE.reset_all}`);\r\n        term.write(NEWLINE);\r\n\r\n        // get the items\r\n        const items = doc.getElementsByTagName(\"item\");\r\n\r\n        if (max_items === undefined) {\r\n            max_items = items.length;\r\n        }\r\n\r\n        // print the items\r\n        for (let item_idx = 0; item_idx < max_items; item_idx++) {\r\n            const item = items.item(item_idx);\r\n\r\n            // check if the item exists\r\n            if (!item) {\r\n                // hit the end of the items, break\r\n                break;\r\n            }\r\n\r\n            // get each field of the item if they exist\r\n\r\n            // title\r\n            const item_title = get_field(item, DocType.ITEM, \"title\") ?? \"Untitled item\";\r\n\r\n            // link\r\n            const link = get_field(item, DocType.ITEM, \"link\") ?? \"\";\r\n\r\n\r\n            let description = \"\";\r\n            if (!no_content) {\r\n                description = get_field(item, DocType.ITEM, \"description\") ?? \"\";\r\n\r\n                // if the description is html, attempt to convert it to plaintext\r\n                if (HTML_TAG_REGEX.test(description)) {\r\n                    term.writeln(`${FG.gray}(interpreting description as HTML)${STYLE.reset_all}`)\r\n                    term.write(NEWLINE);\r\n\r\n                    // reparse as html\r\n                    description = get_field(item, DocType.ITEM, \"description\", true) ?? \"\";\r\n\r\n                    // remove CDATA tags if present\r\n                    description = description.replace(/<!\\[CDATA\\[|\\]\\]>/g, \"\");\r\n\r\n                    // parse the description using custom highlighters\r\n                    description = convert_html_to_text(description,\r\n                        {\r\n                            formatters: {\r\n                                \"ansi_formatter\": (elem, walk, builder, options) => {\r\n                                    builder.openBlock();\r\n                                    builder.addInline(options.opener);\r\n                                    walk(elem.children, builder);\r\n                                    builder.addInline(STYLE.reset_all);\r\n                                    builder.closeBlock();\r\n                                },\r\n                                \"img_highlight\": (elem, walk, builder, options) => {\r\n                                    const img_fmt = builder.options.formatters[\"image\"];\r\n                                    if (img_fmt) {\r\n                                        builder.addInline(STYLE.bold + FG.magenta);\r\n                                        img_fmt(elem, walk, builder, options);\r\n                                        builder.addInline(STYLE.reset_all);\r\n                                    }\r\n                                },\r\n                                \"a_highlight\": (elem, walk, builder, options) => {\r\n                                    const a_fmt = builder.options.formatters[\"anchor\"];\r\n                                    if (a_fmt) {\r\n                                        builder.addInline(STYLE.bold + FG.blue);\r\n                                        a_fmt(elem, walk, builder, options);\r\n                                        builder.addInline(STYLE.reset_all);\r\n                                    }\r\n                                }\r\n                            },\r\n                            selectors: [\r\n                                {\r\n                                    selector: \"b\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.bold\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"strong\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.bold\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"i\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.italic\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"em\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.italic\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"u\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.underline\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"img\",\r\n                                    format: \"img_highlight\"\r\n                                },\r\n                                {\r\n                                    selector: \"a\",\r\n                                    format: \"a_highlight\"\r\n                                },\r\n                                {\r\n                                    selector: \"table\",\r\n                                    format: \"dataTable\"\r\n                                }\r\n                            ]\r\n                        }\r\n                    );\r\n                }\r\n\r\n                // trim start and end whitespace\r\n                description = description.trim();\r\n\r\n                // replace newlines again in case the description was html\r\n                description = description.replace(/\\r\\n|\\n/g, NEWLINE);\r\n            }\r\n\r\n            // pubDate\r\n            const date = get_field(item, DocType.ITEM, \"date\") ?? \"\";\r\n\r\n            // print the item\r\n            term.writeln(`${FG.green + STYLE.bold + STYLE.underline}${item_title}${STYLE.reset_all}`);\r\n            term.writeln(`${FG.cyan}${link}${STYLE.reset_all}`);\r\n            term.writeln(`${FG.yellow}${date}${STYLE.reset_all}`);\r\n            term.write(NEWLINE);\r\n\r\n            if (!no_content) {\r\n                term.writeln(`${description}`);\r\n                term.write(NEWLINE);\r\n            }\r\n\r\n            term.writeln(`${FG.gray}------${STYLE.reset_all}`);\r\n            term.write(NEWLINE);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"legacy\",\r\n    description: \"Opens the legacy ollieg.codes site if you're having trouble with this version.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (_data) => {\r\n        window.location.assign(\"https://legacy.ollieg.codes/\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: keep this or not?\r\n","import type {Program, ProgramMainData} from \"../types\";\r\nimport { ANSI, NEWLINE, type WrappedTerminal } from \"../kernel/term_ctl\";\r\n\r\n\r\nconst wait_block = (term: WrappedTerminal) => {\r\n    term.write(NEWLINE);\r\n    term.writeln(`${ANSI.STYLE.italic}Press any key to continue...${ANSI.STYLE.reset_all}`)\r\n    return term.wait_for_keypress();\r\n};\r\n\r\nconst run_cmd = async (data: ProgramMainData, cmd: string, args: string[] = []) => {\r\n    data.term.writeln(`${ANSI.STYLE.bold}$ ${cmd}${ANSI.STYLE.reset_all}${NEWLINE}`);\r\n    await data.kernel.spawn(cmd, args, data.shell).completion;\r\n    data.term.write(NEWLINE);\r\n};\r\n\r\n\r\nconst welcome = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}Welcome to OllieOS!`);\r\n    term.writeln(`===================${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"This tour covers the basic commands and features of OllieOS.\");\r\n    term.writeln(`First, let's use ${PREFABS.program_name}mefetch${STYLE.reset_all} to view info about me.`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"Normally, you would type the command into the terminal and press RETURN, but for this tour, the command will be run automatically.\");\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst mefetch = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}mefetch`);\r\n    term.writeln(`=======${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"mefetch\");\r\n\r\n    term.writeln(`The ${PREFABS.program_name}mefetch${STYLE.reset_all} command is used to display information about a GitHub user.`);\r\n    term.writeln(\"By default, it uses my username, obfuscatedgenerated. You can also specify a different username as an argument.\");\r\n    term.writeln(\"If another username is used, less information will be displayed.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.write(`Now, let's use ${PREFABS.program_name}rss${STYLE.reset_all} to read my blog.`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst rss = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}rss`);\r\n    term.writeln(`===${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"rss\", [\"-m\", \"1\"]);\r\n\r\n    term.writeln(`The ${PREFABS.program_name}rss${STYLE.reset_all} command is used to read RSS feeds.`);\r\n    term.writeln(\"By default, it uses my blog's RSS feed. You can also specify a different RSS feed as an argument.\");\r\n    term.writeln(\"A plaintext RSS feed is recommended, but the program can also parse basic HTML.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"For the output above, the -m 1 flag was used to only display the first item in the feed. Without it, all items would be displayed.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`Let's use the ${PREFABS.program_name}help${STYLE.reset_all} command to view a list of all available commands, and to get help with a specific command.`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst fs = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}Filesystem`);\r\n    term.writeln(`==========${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"OllieOS has a filesystem, which is used to store files and folders.\");\r\n    term.writeln(\"The filesystem is persistent, so files and folders will not be deleted when the OS is restarted.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`Let's use the ${PREFABS.program_name}ls${STYLE.reset_all} command to view the contents of the home directory.`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"ls\");\r\n\r\n    term.writeln(`There's a file in the directory called ${PREFABS.file_path}credits.txt${STYLE.reset_all}. Let's use the ${PREFABS.program_name}cat${STYLE.reset_all} command to view its contents.`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n    await run_cmd(data, \"cat\", [\"credits.txt\"]);\r\n\r\n    term.writeln(`The ${PREFABS.program_name}cat${STYLE.reset_all} command is used to view the contents of one or more files.`);\r\n    term.writeln(\"If multiple files are specified, their contents will be concatenated together.\");\r\n    term.write(NEWLINE);\r\n    \r\n    term.writeln(`There are many other commands that can be used to interact with the filesystem, such as ${PREFABS.program_name}cd${STYLE.reset_all}, ${PREFABS.program_name}fsedit${STYLE.reset_all}, ${PREFABS.program_name}rm${STYLE.reset_all}, and more.`);\r\n    term.writeln(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst help = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}help`);\r\n    term.writeln(`====${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"help\");\r\n\r\n    term.write(NEWLINE);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`The ${PREFABS.program_name}help${STYLE.reset_all} command is used to view a list of all available commands, and to get help with a specific command.`);\r\n    term.writeln(\"If a command is specified as an argument, the help text for that command will be displayed.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`For example, let's view the help text for the ${PREFABS.program_name}rss${STYLE.reset_all} command:`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n    await run_cmd(data, \"help\", [\"rss\"]);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\n\r\nconst end = async (data: ProgramMainData,) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, FG, PREFABS } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}Thanks for using OllieOS!`);\r\n    term.writeln(`=========================${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"That's all for now!\");\r\n    term.writeln(\"There is a lot more to explore, so feel free to play around with the OS and try out different commands.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"Things to try:\");\r\n    term.writeln(` - Use ${PREFABS.program_name}mefetch${STYLE.reset_all}, passing your GitHub username as an argument.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}cd${STYLE.reset_all} to enter the ${PREFABS.dir_name}projects${STYLE.reset_all} directory, and then use ${PREFABS.program_name}ls${STYLE.reset_all} to view its contents.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}imagine${STYLE.reset_all} and ${PREFABS.program_name}ascmagine${STYLE.reset_all} to view an image.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}fsedit${STYLE.reset_all} to explore the filesystem.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}webget${STYLE.reset_all} to download a file from the Internet into the OS.`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"Thanks for using OllieOS.\");\r\n    term.writeln(\"The OS will now restart.\");\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n\r\n    await run_cmd(data, \"shutdown\", [\"-r\", \"-t\", \"0\"]);\r\n};\r\n\r\n\r\nexport default {\r\n    name: \"tour\",\r\n    description: \"Runs the onboarding tour.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        await welcome(data);\r\n\r\n        await mefetch(data);\r\n        await rss(data);\r\n        await fs(data);\r\n        await help(data);\r\n\r\n        await end(data);\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import {determine_program_name_from_js} from \"../../kernel/prog_registry\";\r\nimport { ANSI, NEWLINE } from \"../../kernel/term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {graph_query, triggers} from \"./index\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, PREFABS, FG } = ANSI;\r\n\r\n// TODO: resolve unused deps?\r\n\r\nexport const remove_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel, shell } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing package name.`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // remove duplicate args\r\n    let unique_args = [...new Set(args)];\r\n\r\n    // if any args contain @, trim to before @ and show warning\r\n    // TODO: accept version specifier and check that the requested version is the one installed before removing\r\n    for (const arg of unique_args) {\r\n        if (arg.includes(\"@\")) {\r\n            term.writeln(`${FG.yellow}Warning: ${arg} contains a version specifier.`);\r\n            term.writeln(`This will be ignored.${STYLE.reset_all}`);\r\n        }\r\n    }\r\n\r\n    // perform removal\r\n    unique_args = unique_args.map(arg => arg.split(\"@\")[0]);\r\n\r\n    // remove duplicates again\r\n    unique_args = [...new Set(unique_args)];\r\n\r\n    let error_count = 0;\r\n    // returns 0 for success, 1 for failure, 2 for fatal error\r\n\r\n    const fs = kernel.get_fs();\r\n    const prog_reg = kernel.get_program_registry();\r\n\r\n    // iter over remaining args\r\n    const total_pkgs = unique_args.length;\r\n    while (unique_args.length >= 1) {\r\n        term.writeln(`${NEWLINE}${FG.gray}------------------------${STYLE.reset_all}${NEWLINE}`);\r\n\r\n        const pkg = unique_args.shift();\r\n\r\n        term.writeln(`${FG.yellow}Checking for ${pkg}...${STYLE.reset_all}`);\r\n\r\n        // if .., /, or \\ in pkg, skip\r\n        if (pkg.includes(\"..\") || pkg.includes(\"/\") || pkg.includes(\"\\\\\")) {\r\n            term.writeln(`${PREFABS.error}Illegal package name '${pkg}'.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        const pkg_dir = `/usr/bin/${pkg}`;\r\n\r\n        // check if pkg exists\r\n        if (!(await fs.dir_exists(pkg_dir))) {\r\n            term.writeln(`${PREFABS.error}Package '${pkg}' not installed.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Updating graph...${STYLE.reset_all}`);\r\n\r\n        let meta_triggers = {};\r\n        let meta_version = \"unknown\";\r\n        let meta_deps: string[] = [];\r\n\r\n        if (await fs.exists(fs.join(pkg_dir, \"meta.json\"))) {\r\n            try {\r\n                const meta_raw = await fs.read_file(fs.join(pkg_dir, \"meta.json\")) as string;\r\n                const meta = JSON.parse(meta_raw);\r\n\r\n                meta_triggers = meta.triggers || {};\r\n                meta_version = meta.version || \"unknown\";\r\n                meta_deps = meta.deps || [];\r\n            } catch (e) {\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Could not read meta.json for package ${pkg}: ${e.message}${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        // remove self as a dependent from packages listed as dependencies\r\n        for (const dep_pkg of meta_deps) {\r\n            try {\r\n                // split into name and version if @ present\r\n                const dep_pkg_name = dep_pkg.split(\"@\")[0];\r\n                await graph_query.remove_pkg_dependent(fs, dep_pkg_name, pkg);\r\n            } catch (e) {\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Could not remove dependent ${pkg} from package ${dep_pkg}: ${e.message}${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        try {\r\n            await graph_query.remove_pkg(fs, pkg);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Error removing package '${pkg}': ${e.message}${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        term.writeln(`${FG.cyan}Unmounting programs...${STYLE.reset_all}`);\r\n\r\n        const files = await fs.list_dir(pkg_dir);\r\n\r\n        for (const file of files) {\r\n            if (!file.endsWith(\".js\")) {\r\n                continue;\r\n            }\r\n\r\n            const file_path = fs.join(pkg_dir, file);\r\n\r\n            let program_name: string;\r\n            try {\r\n                const content = await fs.read_file(file_path) as string;\r\n                program_name = await determine_program_name_from_js(content);\r\n            } catch (e) {\r\n                if (e.message.endsWith(\"is not compatible with Node.js.\")) {\r\n                    // silently skip node.js incompatible programs (they wouldn't have been mounted anyway)\r\n                    // yes this is a weird way to do it, but better than changing how build_registrant works\r\n                    continue;\r\n                }\r\n\r\n                term.writeln(`${PREFABS.error}Error determining program name for ${file}: ${e.message}${STYLE.reset_all}`);\r\n                term.writeln(`${FG.yellow}Skipping program (will remain mounted until restart)...${STYLE.reset_all}`);\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                await prog_reg.unregister(program_name);\r\n                term.writeln(`${FG.cyan}(-) ${program_name}${STYLE.reset_all}`);\r\n            } catch (e) {\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Program ${program_name} was never registered.${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Removing package data...${STYLE.reset_all}`);\r\n        await fs.delete_dir(pkg_dir, true);\r\n        fs.purge_cache();\r\n\r\n        term.writeln(`${FG.green}Package '${pkg}' removed.${STYLE.reset_all}`);\r\n\r\n        // check for any removal triggers\r\n        // check for any triggers\r\n        if (meta_triggers && Object.keys(meta_triggers).length > 0) {\r\n            term.writeln(`${FG.cyan}Processing uninstall triggers...${STYLE.reset_all}`);\r\n\r\n            for (const [trigger_name, trigger_data] of Object.entries(meta_triggers)) {\r\n                if (!await triggers.trigger_exists(fs, trigger_name)) {\r\n                    term.writeln(`${FG.yellow}Warning: trigger '${trigger_name}' is not recognised and will be skipped.${STYLE.reset_all}`);\r\n                    continue;\r\n                }\r\n\r\n                term.writeln(`${FG.cyan}Processing uninstall trigger: ${trigger_name}...${STYLE.reset_all}`);\r\n                await triggers.process_uninstall_trigger(trigger_name, trigger_data, pkg, meta_version, term, kernel, shell)\r\n            }\r\n\r\n            term.writeln(`${FG.cyan}Uninstall trigger processing complete.${STYLE.reset_all}`);\r\n        }\r\n    }\r\n\r\n    term.writeln(`${NEWLINE}${FG.magenta + STYLE.bold}========================${STYLE.reset_all}${NEWLINE}`);\r\n\r\n    if (error_count > 0) {\r\n        term.writeln(`${PREFABS.error}Failed to remove ${error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.green}Successfully removed ${total_pkgs - error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.cyan}Total packages: ${total_pkgs}${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`${FG.green}Successfully removed all ${total_pkgs} package(s).${STYLE.reset_all}`);\r\n\r\n    return 0;\r\n}\r\n","import {graph_query, json_convert_dep_sets_to_arrs, repo_query, triggers} from \".\";\r\n\r\nimport {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\r\nimport {ProgramMainData} from \"../../types\"\r\nimport {remove_subcommand} from \"./remove\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS, FG} = ANSI;\r\n\r\n// we arent allowing multiple versions of the same package to be installed at once to simplify things significantly\r\n// TODO: write to a file that tracks installed packages and their dependents (for list and smart removal/cleanup)\r\n\r\nexport const add_subcommand = async (data: ProgramMainData, depended_by?: string) => {\r\n    // extract from data to make code less verbose\r\n    const {args, term, kernel, shell} = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing package name.`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // remove duplicate args\r\n    const unique_args = [...new Set(args)];\r\n\r\n    let error_count = 0;\r\n    // returns 0 for success, 1 for failure, 2 for fatal error\r\n\r\n    const fs = kernel.get_fs();\r\n    const prog_reg = kernel.get_program_registry();\r\n\r\n    // iter over remaining args\r\n    const total_pkgs = unique_args.length;\r\n    while (unique_args.length >= 1) {\r\n        term.writeln(`${NEWLINE}${FG.gray}------------------------${STYLE.reset_all}${NEWLINE}`);\r\n\r\n        const pkg_at_version = unique_args.shift();\r\n\r\n        // if in the format of pkg@version, split it up\r\n        const pkg_split = pkg_at_version.split(\"@\");\r\n        if (pkg_split.length > 2) {\r\n            term.writeln(`${PREFABS.error}Invalid package name: ${pkg_at_version}`);\r\n            term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n            return 2;\r\n        }\r\n\r\n        const pkg_name = pkg_split[0];\r\n        let pkg_version = pkg_split[1];\r\n\r\n        term.writeln(`${FG.yellow}Checking for ${pkg_name}...${STYLE.reset_all}`);\r\n\r\n        const pkg_json = await repo_query.get_pkg_json(pkg_name);\r\n\r\n        if (!pkg_json) {\r\n            term.writeln(`${PREFABS.error}Package '${pkg_name}' not found.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        // if no version specified, use latest\r\n        if (!pkg_version) {\r\n            pkg_version = pkg_json.latest_version;\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Using ${pkg_name}@${pkg_version}...${STYLE.reset_all}`);\r\n\r\n        // check if version exists (and get metadata)\r\n        const meta = await repo_query.get_pkg_meta(pkg_name, pkg_version);\r\n\r\n        if (!meta) {\r\n            term.writeln(`${PREFABS.error}Version '${pkg_version}' of '${pkg_name}' not found.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        if (!meta.externals || meta.externals !== \"global\") {\r\n            term.writeln(`${PREFABS.error}Package '${pkg_name}' is not using the new global externals system. Please build the package with a newer version of pkgbuild.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        const pkg_dir = `/usr/bin/${pkg_name}`;\r\n\r\n        // check version file if already installed\r\n        // TODO: switch to pkg graph?\r\n        if (graph_query.pkg_is_installed(pkg_name)) {\r\n            const installed_version = graph_query.get_pkg_version(pkg_name);\r\n\r\n            if (installed_version === pkg_version) {\r\n                // if exact version already installed, check dep graph then skip\r\n                // ie if depended_by is set but that isn't a dependent yet then add it\r\n\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: ${pkg_name}@${pkg_version} already installed. If you wish to reinstall the package, remove it first.${STYLE.reset_all}`);\r\n\r\n                // cant do this here as top level package isn't installed yet. it's the caller's job to do this. it wouldn't be safe to refactor the method in a way that allows this\r\n                // if (depended_by) {\r\n                //     graph_query.add_pkg_dependent(fs, pkg_name, depended_by);\r\n                //     term.writeln(`${FG.yellow}(dep graph updated)${STYLE.reset_all}`);\r\n                // }\r\n\r\n                continue;\r\n            } else {\r\n                // uninstall old version\r\n                term.writeln(`${FG.yellow}Uninstalling old ${pkg_name}@${pkg_version}...${STYLE.reset_all}`);\r\n\r\n                const remove_data = {kernel, term, process: data.process, args: [\"remove\", pkg_name], unsubbed_args: [\"remove\", pkg_name], raw_parts: [...data.raw_parts, \"remove\", pkg_name]};\r\n                const remove_exit_code = await remove_subcommand(remove_data);\r\n                if (remove_exit_code !== 0) {\r\n                    term.writeln(`${PREFABS.error}Failed to uninstall old version.${STYLE.reset_all}`);\r\n                    error_count++;\r\n                    term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        // firstly, install dependencies\r\n        if (meta.deps && meta.deps.size > 0) {\r\n            term.writeln(`${NEWLINE + FG.magenta + STYLE.bold}Installing dependencies...${STYLE.reset_all}`);\r\n\r\n            // simulate a call to this function with the deps as arguments\r\n            // TODO: is it worth doing this properly and decomposing each stage to a function and calling it?\r\n            // TODO: clearer logs\r\n            // TODO: unshifting add is silly, should this func be changed to accept args with add removed?\r\n            // TODO: parallelism with promise.all???\r\n            const virtual_args: string[] = [...meta.deps];\r\n            virtual_args.unshift(\"add\");\r\n\r\n            // we need to also pass the name of the dependent package to the virtual call to let the graph know\r\n            const virtual_data = {kernel, term, process: data.process, args: virtual_args, unsubbed_args: virtual_args, raw_parts: [...data.raw_parts, ...virtual_args]};\r\n            const virtual_exit_code = await add_subcommand(virtual_data, pkg_name);\r\n\r\n            if (virtual_exit_code !== 0) {\r\n                term.writeln(`${PREFABS.error}Failed to install dependencies.${STYLE.reset_all}`);\r\n                error_count++;\r\n                term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n                continue;\r\n                // TODO: remove partial installation\r\n            }\r\n\r\n            term.writeln(`${FG.magenta + STYLE.bold}Dependencies installed.${STYLE.reset_all + NEWLINE}`);\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Enumerating contents...${STYLE.reset_all}`);\r\n\r\n        const content_list = meta.files;\r\n\r\n        if (content_list.length === 0 || content_list.length === 1 && content_list[0] === \"\") {\r\n            term.writeln(`${PREFABS.error}Empty package.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        // get each file in contents and load it into memory\r\n        const file_map = new Map<string, string>();\r\n\r\n        for (const file of content_list) {\r\n            if (file === \"\") {\r\n                continue;\r\n            }\r\n\r\n            term.writeln(`${FG.yellow}Downloading ${file}...${STYLE.reset_all}`);\r\n\r\n            const file_contents = await repo_query.get_pkg_file(pkg_name, pkg_version, file);\r\n\r\n            if (!file_contents) {\r\n                term.writeln(`${PREFABS.error}Not found.${STYLE.reset_all}`);\r\n                error_count++;\r\n                term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n                continue;\r\n            }\r\n\r\n            file_map.set(file, file_contents);\r\n        }\r\n\r\n        // add pkg.json and meta.json to file map\r\n        file_map.set(\"pkg.json\", JSON.stringify(pkg_json));\r\n        // TODO: adding this might be redundant, we could just move build timestamp to the graph. could also use file array to help mounting? prob not needed.\r\n        // TODO: build timestamp isnt actually used anywhere yet so not a big deal until implemented. might be quicker to just open this file rather than access the graph anyway!\r\n        file_map.set(\"meta.json\", JSON.stringify(meta, json_convert_dep_sets_to_arrs));\r\n\r\n        // not actually executing the file map yet, as we need to ensure the graph is valid\r\n\r\n        term.writeln(`${FG.yellow}Updating graph...${STYLE.reset_all}`);\r\n\r\n        // don't need to check if installed or do anything fancy if it is, as previous checks have already run and updated the graph if needed\r\n        // this is guaranteed to be a new install (whether first time or remove was just run)\r\n        // TODO: test if that's true! test it more!\r\n        try {\r\n            await graph_query.install_new_pkg(fs, pkg_name, pkg_version, meta.deps, !depended_by, depended_by);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to add to graph: ${e.message}${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        // if there were dependencies, add this package as a dependent to each of them\r\n        try {\r\n            if (meta.deps && meta.deps.size > 0) {\r\n                for (const dep of meta.deps) {\r\n                    const dep_name = dep.split(\"@\")[0];\r\n                    await graph_query.add_pkg_dependent(fs, dep_name, pkg_name);\r\n                }\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to update dependencies: ${e.message}${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Rolling back graph...${STYLE.reset_all}`);\r\n            // TODO: safety check? is it safer to capture the entire graph before starting and then rollback to that? add a capture and rollback method to graph_query?\r\n            await graph_query.remove_pkg(fs, pkg_name);\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Installing ${pkg_name}...${STYLE.reset_all}`);\r\n\r\n        await fs.make_dir(pkg_dir);\r\n\r\n        // write each file\r\n        for (const [file, value] of file_map) {\r\n            await fs.write_file(`${pkg_dir}/${file}`, value, true);\r\n        }\r\n\r\n        // TODO: check if this fails somehow, and if it does, rollback the graph\r\n\r\n        term.writeln(`${FG.green}Installed!${STYLE.reset_all}`);\r\n\r\n        term.writeln(`${FG.cyan}Mounting package ${pkg_name}...${STYLE.reset_all}`);\r\n\r\n        // it doesn't matter if mounting fails, the graph is fine and the files are downloaded properly, so no rollback needed\r\n\r\n        // mount each program\r\n        for (const [filename, value] of file_map) {\r\n            if (!filename.endsWith(\".js\")) {\r\n                continue;\r\n            }\r\n\r\n            await prog_reg.mount_and_register_with_output(filename, value, term, true);\r\n        }\r\n\r\n        term.writeln(`${FG.green}Package ${pkg_name}@${pkg_version} installed.${STYLE.reset_all}`);\r\n\r\n        // check for any triggers\r\n        if (meta && meta.triggers && Object.keys(meta.triggers).length > 0) {\r\n            term.writeln(`${FG.cyan}Processing install triggers...${STYLE.reset_all}`);\r\n\r\n            for (const [trigger_name, trigger_data] of Object.entries(meta.triggers)) {\r\n                if (!await triggers.trigger_exists(fs, trigger_name)) {\r\n                    term.writeln(`${FG.yellow}Warning: trigger '${trigger_name}' is not recognised and will be skipped.${STYLE.reset_all}`);\r\n                    continue;\r\n                }\r\n\r\n                term.writeln(`${FG.cyan}Processing install trigger: ${trigger_name}...${STYLE.reset_all}`);\r\n                await triggers.process_install_trigger(trigger_name, trigger_data, pkg_name, pkg_version, term, kernel, shell);\r\n            }\r\n\r\n            term.writeln(`${FG.cyan}Install trigger processing complete.${STYLE.reset_all}`);\r\n        }\r\n    }\r\n\r\n    term.writeln(`${NEWLINE}${FG.magenta + STYLE.bold}========================${STYLE.reset_all}${NEWLINE}`);\r\n\r\n    if (error_count > 0) {\r\n        term.writeln(`${PREFABS.error}Failed to install ${error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.green}Successfully installed ${total_pkgs - error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.cyan}Total packages: ${total_pkgs}${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`${FG.green}Successfully installed all ${total_pkgs} package(s).${STYLE.reset_all}`);\r\n\r\n    return 0;\r\n}\r\n// TODO: decompose into smaller functions\r\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {graph_query} from \"./index\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG } = ANSI;\r\nexport const list_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // check for presence of -t flag\r\n    let only_top_level = false;\r\n    if (args[0] === \"-t\") {\r\n        only_top_level = true;\r\n        args.shift();\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n\r\n    const pkg_names = graph_query.list_pkgs(only_top_level);\r\n\r\n    // print each package, marking top level packages in green, dependencies in white, and unused dependencies in gray\r\n    for (const pkg_name of pkg_names) {\r\n        const info = graph_query.get_pkg_info(pkg_name);\r\n\r\n        let color = FG.gray;\r\n        if (info.top_level) {\r\n            color = FG.green;\r\n        } else if (info.dependents.size !== 0) {\r\n            color = FG.white;\r\n        }\r\n\r\n        term.writeln(`${STYLE.bold}${color}${pkg_name}${STYLE.no_bold_or_dim}@${info.version}${STYLE.reset_all}`);\r\n    }\r\n\r\n    return 0;\r\n}\r\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\r\nimport type { WrappedTerminal } from \"../../kernel/term_ctl\";\r\nimport type { ProgramMainData } from \"../../types\"\r\nimport {graph_query, repo_query} from \"./index\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, PREFABS } = ANSI;\r\n\r\ninterface PkgInfo {\r\n    description?: string;\r\n    author?: string;\r\n    license?: string;\r\n    homepage_url?: string;\r\n    repo_url?: string;\r\n    long_desc?: string;\r\n}\r\n\r\nconst print_info = (term: WrappedTerminal, pkg_name: string, pkg_version: string, pkg_data: PkgInfo, installed: boolean) => {\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`Package: ${STYLE.bold}${pkg_name}${STYLE.no_bold_or_dim}`);\r\n    term.writeln(`Version: ${STYLE.bold}${pkg_version}${STYLE.no_bold_or_dim}`);\r\n    term.writeln(`Description: ${pkg_data.description || \"No description provided.\"}`);\r\n    term.writeln(`Author: ${pkg_data.author || \"Unknown\"}`);\r\n    term.writeln(`License: ${pkg_data.license || \"Unknown\"}`);\r\n    term.writeln(`Installed: ${STYLE.bold}${installed ? \"Yes\" : \"No\"}${STYLE.no_bold_or_dim}`);\r\n\r\n    if (pkg_data.homepage_url) {\r\n        term.writeln(`Homepage: ${pkg_data.homepage_url}`);\r\n    }\r\n\r\n    if (pkg_data.repo_url) {\r\n        term.writeln(`Repository: ${pkg_data.repo_url}`);\r\n    }\r\n\r\n    if (pkg_data.long_desc) {\r\n        term.write(NEWLINE);\r\n        term.writeln(`Long description available. Use ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} read${STYLE.reset_all} ${pkg_name} to read it.`);\r\n    }\r\n}\r\n\r\nexport const info_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // check for presence of -r flag\r\n    let always_fetch = false;\r\n    if (args[0] === \"-r\") {\r\n        always_fetch = true;\r\n        args.shift();\r\n    }\r\n\r\n    // check for package name\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing package name.`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const pkg_at_version = args[0];\r\n\r\n    // if in the format of pkg@version, split it up\r\n    const pkg_split = pkg_at_version.split(\"@\");\r\n    if (pkg_split.length > 2) {\r\n        term.writeln(`${PREFABS.error}Invalid package name: ${pkg_at_version}`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    const pkg_name = pkg_split[0];\r\n    let pkg_version = pkg_split[1];\r\n\r\n    // if no version specified, use what's installed\r\n    // if not installed, fetch latest from repo\r\n    // note that version doesnt really matter other than as a test whether the version exists and installed locally, as pkg.json is shared across versions\r\n    if (!pkg_version) {\r\n        const installed_pkg = graph_query.get_pkg_version(pkg_name);\r\n        if (installed_pkg && !always_fetch) {\r\n            pkg_version = installed_pkg;\r\n        } else {\r\n            const pkg_json = await repo_query.get_pkg_json(pkg_name);\r\n            if (!pkg_json) {\r\n                term.writeln(`${PREFABS.error}Package not found: ${pkg_name}`);\r\n                term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n                return 3;\r\n            }\r\n\r\n            pkg_version = pkg_json.latest_version;\r\n        }\r\n    }\r\n\r\n    const installed_pkg = graph_query.get_pkg_version(pkg_name);\r\n    const requested_version_installed = installed_pkg === pkg_version;\r\n\r\n    const fs = kernel.get_fs();\r\n\r\n    if (!always_fetch && requested_version_installed) {\r\n        const pkg_json_path = graph_query.get_file_path_in_pkg_bin(fs, pkg_name, \"pkg.json\");\r\n\r\n        if (!fs.exists(pkg_json_path)) {\r\n            // shouldnt happen, but just in case\r\n            console.error(`Invalid pkg.json path: ${pkg_json_path}`);\r\n            term.writeln(`${PREFABS.error}Error reading package files for ${pkg_name}`);\r\n            return 3;\r\n        }\r\n\r\n        const pkg_json = await fs.read_file(pkg_json_path) as string;\r\n        const pkg_data = JSON.parse(pkg_json);\r\n\r\n        print_info(term, pkg_name, pkg_version, pkg_data, true);\r\n        return 0;\r\n    }\r\n\r\n    // fetch package data from repo\r\n    const pkg_data = await repo_query.get_pkg_json(pkg_name);\r\n    if (!pkg_data) {\r\n        term.writeln(`${PREFABS.error}Package not found: ${pkg_name}`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 3;\r\n    }\r\n\r\n    print_info(term, pkg_name, pkg_version, pkg_data, requested_version_installed);\r\n    return 0;\r\n}\r\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\r\nimport type { WrappedTerminal } from \"../../kernel/term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {graph_query, repo_query} from \"./index\";\r\nimport type {UserspaceKernel} from \"../../kernel\";\r\nimport type {AbstractShell} from \"../../abstract_shell\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, CURSOR } = ANSI;\r\n\r\nconst ROWS = 10;\r\n\r\nconst view_pkg_info = async (pkg_name: string, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\r\n    const pkg_data = await repo_query.get_pkg_json(pkg_name);\r\n    const pkg_versions = await repo_query.get_pkg_versions(pkg_name);\r\n\r\n    term.clear();\r\n\r\n    term.write(NEWLINE);\r\n    term.writeln(`${STYLE.bold}${FG.cyan}${pkg_name}`);\r\n    term.write(STYLE.dim);\r\n    term.writeln(\"=\".repeat(pkg_name.length));\r\n    term.writeln(STYLE.reset_all);\r\n\r\n    // check for installed version\r\n    const installed_version = graph_query.get_pkg_version(pkg_name);\r\n\r\n    term.write(NEWLINE);\r\n    term.writeln(`${STYLE.bold}Available versions:${STYLE.no_bold_or_dim}`);\r\n    for (const version of pkg_versions) {\r\n        term.writeln(`  - ${version} ${installed_version === version ? `${STYLE.italic}(installed)${STYLE.reset_all}` : \"\"}`);\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n    term.writeln(`${STYLE.bold}Description:${STYLE.no_bold_or_dim} ${pkg_data.description || \"No description provided.\"}`);\r\n    term.writeln(`${STYLE.bold}Author:${STYLE.no_bold_or_dim} ${pkg_data.author || \"Unknown\"}`);\r\n    term.writeln(`${STYLE.bold}License:${STYLE.no_bold_or_dim} ${pkg_data.license || \"Unknown\"}`);\r\n\r\n    let printed_link_header = false;\r\n\r\n    if (pkg_data.homepage_url) {\r\n        if (!printed_link_header) {\r\n            term.write(NEWLINE);\r\n            printed_link_header = true;\r\n        }\r\n\r\n        term.writeln(`${STYLE.bold}Homepage:${STYLE.no_bold_or_dim} ${pkg_data.homepage_url}`);\r\n    }\r\n\r\n    if (pkg_data.repo_url) {\r\n        if (!printed_link_header) {\r\n            term.write(NEWLINE);\r\n            printed_link_header = true;\r\n        }\r\n\r\n        term.writeln(`${STYLE.bold}Repository:${STYLE.no_bold_or_dim} ${pkg_data.repo_url}`);\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`${STYLE.dim}Press 'i' to install the latest version of this package.${STYLE.reset_all}`);\r\n    term.writeln(`${STYLE.dim}Press any other key to return to the list...${STYLE.reset_all}`);\r\n\r\n    const key = await term.wait_for_keypress();\r\n\r\n    if (key.domEvent.key === \"i\") {\r\n        // double check installation\r\n        term.write(NEWLINE);\r\n        term.write(`${STYLE.bold}Are you sure you want to install '${pkg_name}'? (y/N)${STYLE.no_bold_or_dim}`);\r\n\r\n        const confirm_key = await term.wait_for_keypress();\r\n\r\n        if (confirm_key.domEvent.key.toLowerCase() === \"y\") {\r\n            term.write(\" yes\");\r\n            term.write(NEWLINE);\r\n\r\n            await kernel.spawn(\"pkg\", [\"add\", pkg_name], shell).completion;\r\n\r\n            term.write(NEWLINE);\r\n            term.writeln(`${STYLE.dim}Press any key to return to the list...${STYLE.reset_all}`);\r\n            await term.wait_for_keypress();\r\n        } else {\r\n            term.write(\" no\");\r\n            term.writeln(NEWLINE);\r\n\r\n            term.writeln(`${STYLE.dim}Installation cancelled. Press any key to return to the list...${STYLE.reset_all}`);\r\n            await term.wait_for_keypress();\r\n        }\r\n    }\r\n}\r\n\r\n// TODO: accept name argument to jump to specific package\r\n\r\nexport const browse_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel, shell } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    const provided = await repo_query.get_provided_list();\r\n\r\n    let offset = 0;\r\n    let selected_index = 0;\r\n    const draw = () => {\r\n        term.clear();\r\n\r\n        term.write(NEWLINE);\r\n        term.writeln(\"(use up/down arrow keys to scroll, enter to show more info, escape to quit)\");\r\n        term.write(NEWLINE);\r\n        term.write(CURSOR.invisible);\r\n\r\n        // show ... if there are more items above\r\n        if (offset > 0) {\r\n            term.writeln(`  ${STYLE.dim}...${STYLE.reset_all}`);\r\n        } else {\r\n            term.write(NEWLINE);\r\n        }\r\n\r\n        const slice = provided.slice(offset, offset + ROWS);\r\n        for (const [index, name] of slice.entries()) {\r\n            // check for installed version\r\n            const installed_version = graph_query.get_pkg_version(name);\r\n\r\n            // highlight selected item\r\n            if (offset + index === selected_index) {\r\n                term.write(`${FG.cyan}${STYLE.dim}> ${STYLE.no_bold_or_dim}${STYLE.bold}`);\r\n            } else {\r\n                term.write(\"  \");\r\n            }\r\n\r\n            term.writeln(`${name} ${installed_version ? `${STYLE.italic}(installed: ${installed_version})` : \"\"}${STYLE.reset_all}`);\r\n        }\r\n\r\n        // show ... if there are more items below\r\n        if (offset + ROWS < provided.length) {\r\n            term.writeln(`  ${STYLE.dim}...${STYLE.reset_all}`);\r\n        } else {\r\n            term.write(NEWLINE);\r\n        }\r\n    }\r\n\r\n    // TODO: type to filter\r\n\r\n    let quit = false;\r\n    while (!quit) {\r\n        draw();\r\n\r\n        const key = await term.wait_for_keypress();\r\n        console.log(key);\r\n        switch (key.domEvent.key) {\r\n            case \"Escape\":\r\n                quit = true;\r\n                break;\r\n            case \"ArrowUp\":\r\n                if (selected_index > 0) {\r\n                    selected_index--;\r\n                    if (selected_index < offset) {\r\n                        offset--;\r\n                    }\r\n                }\r\n                break;\r\n            case \"ArrowDown\":\r\n                if (selected_index < provided.length - 1) {\r\n                    selected_index++;\r\n                    if (selected_index >= offset + ROWS) {\r\n                        offset++;\r\n                    }\r\n                }\r\n                break;\r\n            case \"Enter\": {\r\n                const pkg_name = provided[selected_index];\r\n                await view_pkg_info(pkg_name, term, kernel, shell);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    term.clear();\r\n    term.write(CURSOR.visible);\r\n    return 0;\r\n}\r\n","import {add_subcommand} from \"./add\";\r\nimport {remove_subcommand} from \"./remove\";\r\n\r\nimport {ANSI, type WrappedTerminal} from \"../../kernel/term_ctl\";\r\nimport type {Program} from \"../../types\";\r\nimport type {UserspaceFileSystem} from \"../../kernel/filesystem\";\r\nimport {list_subcommand} from \"./list\";\r\nimport {info_subcommand} from \"./info\";\r\nimport {browse_subcommand} from \"./browse\";\r\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\r\n\r\nimport type {UserspaceKernel, SpawnResult} from \"../../kernel\";\r\nimport type {AbstractShell} from \"../../abstract_shell\";\r\n\r\n\r\nconst REPO_URL = \"https://ollieg.codes/pkg_repo\";\r\nconst repo_url_obj = new URL(REPO_URL);\r\n// TODO: in future, this can be changed. it will also be a list of repos in priority order, and the first one that has the package will be used.\r\n\r\nconst GRAPH_DIR = \"/var/lib/pkg\";\r\nconst GRAPH_PATH = GRAPH_DIR + \"/graph.json\";\r\n\r\nconst BIN_DIR = \"/usr/bin\";\r\n\r\nconst TRIGGER_DIR = \"/var/lib/pkg/triggers\";\r\n\r\n// TODO: subcommand template / helper\r\n\r\nconst append_url_pathnames = (url: URL, pathnames: string[]) => {\r\n    const new_url = new URL(url.toString());\r\n    let urlpath = new_url.pathname;\r\n\r\n    // drop trailing /\r\n    if (urlpath.endsWith(\"/\")) {\r\n        urlpath = urlpath.slice(0, urlpath.length - 1);\r\n    }\r\n\r\n    for (const path of pathnames) {\r\n        if (path.includes(\"/\") || path.includes(\"\\\\\") || path.includes(\"..\")) {\r\n            throw new Error(\"Unsafe pathname: \" + path);\r\n        }\r\n\r\n        urlpath += (path === \"\" ? \"\" : \"/\" + path);\r\n    }\r\n\r\n    new_url.pathname = urlpath;\r\n    return new_url;\r\n    // TODO: safe?\r\n}\r\n\r\nexport type PkgAtVersion = `${string}@${string}`;\r\n// TODO: honestly handling of pakcage version sucks rn, need to test if even having deps = \"pkg@version\" works properly\r\n\r\ninterface PackageMeta {\r\n    files: string[];\r\n    version: string;\r\n    deps: Set<PkgAtVersion>;\r\n    triggers: { [trigger_name: string]: unknown };\r\n    build_timestamp: number;\r\n    externals: \"global\" | undefined;\r\n}\r\n\r\nexport const repo_query = {\r\n    // GETs a file path relative to the repo root\r\n    // TODO: why did i write this and not use it?? all other fetches are just this but returning null for a 404?? am i stupid?? it's being exported so maybe i had a reason\r\n    api_call: async (filepath: string) => {\r\n        const url = new URL(filepath, repo_url_obj);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n        return await response.text();\r\n    },\r\n\r\n    // returns null if not found, otherwise returns the contents of the file\r\n    get_pkg_json: async (pkg: string) => {\r\n        pkg = encodeURI(pkg);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, \"pkg.json\"]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        return await response.json();\r\n    },\r\n\r\n    // returns null if not found, otherwise returns the meta.json file as an object\r\n    get_pkg_meta: async (pkg: string, version: string): Promise<PackageMeta> => {\r\n        pkg = encodeURI(pkg);\r\n        version = encodeURI(version);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n        version = version.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/version/\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, version, \"meta.json\"]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        // TODO: validate meta\r\n\r\n        const data = await response.json();\r\n\r\n        // convert deps to set\r\n        data.deps = new Set(data.deps);\r\n\r\n        return data;\r\n    },\r\n\r\n    // gets a file within a package or returns null if not found\r\n    get_pkg_file: async (pkg: string, version: string, filepath: string) => {\r\n        pkg = encodeURI(pkg);\r\n        version = encodeURI(version);\r\n        filepath = encodeURI(filepath);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n        version = version.replace(/\\./g, \"%2E\");\r\n        filepath = filepath.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/version/filepath\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, version, filepath]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        return await response.text();\r\n    },\r\n\r\n    get_provided_list: async () => {\r\n        // repo/provided.txt\r\n        const url = append_url_pathnames(repo_url_obj, [\"provided.txt\"]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        // newline separated list of provided package names\r\n        const data = await response.text();\r\n        return data.split(\"\\n\").map((line) => line.trim()).filter((line) => line.length > 0);\r\n    },\r\n\r\n    get_pkg_versions: async (pkg: string) => {\r\n        pkg = encodeURI(pkg);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/versions.txt\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, \"versions.txt\"]);\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        // newline separated list of versions\r\n        const data = await response.text();\r\n        return data.split(\"\\n\").map((line) => line.trim()).filter((line) => line.length > 0);\r\n    }\r\n}\r\n\r\ninterface PkgGraphEntry {\r\n    version: string;\r\n    deps: Set<PkgAtVersion | string>;\r\n    dependents: Set<string>;\r\n    top_level: boolean; // as in, specified by the user at install time\r\n}\r\n\r\nexport const json_convert_dep_sets_to_arrs = (key: string, value: any) => {\r\n    if (key !== \"deps\" && key !== \"dependents\") {\r\n        return value;\r\n    }\r\n\r\n    if (value instanceof Set) {\r\n        return Array.from(value);\r\n    }\r\n\r\n    throw new Error(`${key} not a set in graph to be stringified!`);\r\n}\r\n\r\nexport const json_convert_dep_arrs_to_sets = (key: string, value: any) => {\r\n    if (key !== \"deps\" && key !== \"dependents\") {\r\n        return value;\r\n    }\r\n\r\n    if (Array.isArray(value)) {\r\n        return new Set(value);\r\n    }\r\n\r\n    throw new Error(`${key} not an array in graph to be parsed!`);\r\n}\r\n\r\nlet graph: { [pkg_name: string]: PkgGraphEntry } = {};\r\nexport const graph_query = {\r\n    // TODO: graph consistency checks / repair function\r\n    // TODO: dangling dep check\r\n\r\n    // gets the graph entry for a package\r\n    get_pkg_info: (pkg: string): PkgGraphEntry => {\r\n        return graph[pkg];\r\n    },\r\n\r\n    // lists names of all installed packages, optionally only top level\r\n    list_pkgs: (only_top_level = false) => {\r\n        const pkgs = Object.keys(graph);\r\n\r\n        if (only_top_level) {\r\n            return pkgs.filter((pkg) => graph[pkg].top_level);\r\n        }\r\n\r\n        return pkgs;\r\n    },\r\n\r\n    // checks if a package is installed, optionally with a specific version\r\n    pkg_is_installed: (pkg: string, version?: string) => {\r\n        if (!graph[pkg]) {\r\n            return false;\r\n        }\r\n\r\n        if (version) {\r\n            return graph[pkg].version === version;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    // gets the version of an installed package, or undefined if not installed\r\n    get_pkg_version: (pkg: string): string | undefined => {\r\n        return graph[pkg]?.version;\r\n    },\r\n\r\n    // gets the dependents of a package, or undefined if not installed\r\n    get_pkg_dependents: (pkg: string): Set<string> | undefined => {\r\n        return graph[pkg]?.dependents;\r\n    },\r\n\r\n    // gets the dependencies of a package, or undefined if not installed\r\n    get_pkg_dependencies: (pkg: string): Set<PkgAtVersion | string> | undefined => {\r\n        return graph[pkg]?.deps;\r\n    },\r\n\r\n    // installs a NEW package. if this is not a top level package, you must specify an initial dependent. you cannot modify an existing package unless you use the defined functions.\r\n    install_new_pkg: async (fs: UserspaceFileSystem, pkg: string, version: string, deps: Set<PkgAtVersion>, top_level: boolean, dependended_by?: string) => {\r\n        // TODO: resolve what to do if the package is already installed rather than exploding, makes using it a lot simpler\r\n\r\n        if (graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is already installed and cannot be modified.`);\r\n        }\r\n\r\n        // TODO: we could assume top level based on if dependended_by is provided, but that's not very precise. top level packages may be dependencies!\r\n        if (!top_level && !dependended_by) {\r\n            throw new Error(`Package ${pkg} is not installed as a top-level package but does not have a dependent it was installed by.`);\r\n        }\r\n\r\n        const dependents = new Set<string>();\r\n\r\n        if (dependended_by) {\r\n            dependents.add(dependended_by);\r\n        }\r\n\r\n        graph[pkg] = {\r\n            version,\r\n            deps,\r\n            top_level,\r\n            dependents\r\n        };\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // makes a package a top level package, no checks are performed as top level packages may have dependents\r\n    promote_pkg_to_top_level: async (fs: UserspaceFileSystem, pkg: string) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        graph[pkg].top_level = true;\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // makes a package not a top level package, but only if it has no dependents. use add_pkg_dependent FIRST before demoting if it has dependents now.\r\n    demote_pkg_from_top_level: async (fs: UserspaceFileSystem, pkg: string) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        if (graph[pkg].dependents.size > 0) {\r\n            throw new Error(`Package ${pkg} has no dependents and cannot be demoted. Use add_pkg_dependent FIRST.`);\r\n        }\r\n\r\n        graph[pkg].top_level = false;\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // adds a dependent to a package, provided the dependent is already installed. also adds the dependency to the dependent package.\r\n    add_pkg_dependent: async (fs: UserspaceFileSystem, pkg: string, dependent_pkg: string, add_to_deps = false) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        if (!graph[dependent_pkg]) {\r\n            throw new Error(`Dependent ${dependent_pkg} is not installed.`);\r\n        }\r\n\r\n        const pkg_at_version = `${pkg}@${graph[pkg].version}` as PkgAtVersion;\r\n\r\n        graph[pkg].dependents.add(dependent_pkg);\r\n\r\n        if (add_to_deps) {\r\n            graph[dependent_pkg].deps.add(pkg_at_version);\r\n        }\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // removes a dependent from a package, as well as clearing the dependency from the dependent package\r\n    remove_pkg_dependent: async (fs: UserspaceFileSystem, pkg: string, dependent_pkg: string, remove_from_deps = false) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        if (!graph[dependent_pkg]) {\r\n            throw new Error(`Dependent ${dependent_pkg} is not installed.`);\r\n        }\r\n\r\n        if (!graph[pkg].dependents.has(dependent_pkg)) {\r\n            throw new Error(`Package ${pkg} does not have dependent ${dependent_pkg}.`);\r\n        }\r\n\r\n        const pkg_at_version = `${pkg}@${graph[pkg].version}` as PkgAtVersion;\r\n\r\n        if (!graph[dependent_pkg].deps.has(pkg) && !graph[dependent_pkg].deps.has(pkg_at_version)) {\r\n            throw new Error(`Inconsistent graph! Dependent ${dependent_pkg} does not have dependency ${pkg}, but ${pkg} has dependent ${dependent_pkg}.`);\r\n        }\r\n\r\n        graph[pkg].dependents.delete(dependent_pkg);\r\n\r\n        if (remove_from_deps) {\r\n            graph[dependent_pkg].deps.delete(pkg_at_version);\r\n        }\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n\r\n        // uninstall if it has no dependents now? probably not, we can have a separate command for that\r\n    },\r\n\r\n    // removes a package from the graph, provided it has no dependents. you can skip this check, but this will leave dangling dependencies.\r\n    remove_pkg: async (fs: UserspaceFileSystem, pkg: string, skip_dep_check = false) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        // check if this package has any dependents\r\n        if (!skip_dep_check && graph[pkg].dependents.size > 0) {\r\n            throw new Error(`Package ${pkg} has dependents and cannot be removed.`);\r\n        }\r\n\r\n        // // remove this package from its dependents' dependencies\r\n        // no! don't do this! if they skip the dep check, we don't want to destroy the fact that there are hanging deps\r\n        // for (const dependent of graph[pkg].dependents) {\r\n        //     const dependent_name = dependent.split(\"@\")[0];\r\n        //     graph[dependent_name].deps = graph[dependent_name].deps.filter((dep) => dep !== pkg);\r\n        // }\r\n\r\n        // remove this package from its dependencies' dependents\r\n        for (const dep of graph[pkg].deps) {\r\n            const dep_name = dep.split(\"@\")[0];\r\n            graph[dep_name].dependents.delete(`${pkg}@${graph[pkg].version}` as PkgAtVersion);\r\n        }\r\n\r\n        // TODO: feels like something is missing? oh well, we'll find out when we test it\r\n\r\n        // remove this package from the graph\r\n        delete graph[pkg];\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // lists all packages that are not installed as top level and have no dependents\r\n    list_unused_pkgs: () => {\r\n        return Object.keys(graph).filter((pkg) => !graph[pkg].top_level && graph[pkg].dependents.size === 0);\r\n    },\r\n\r\n    get_file_path_in_pkg_bin: (fs: UserspaceFileSystem, pkg: string, filepath: string) => {\r\n        const pkg_dir = fs.join(BIN_DIR, pkg);\r\n        return fs.join(pkg_dir, filepath);\r\n    }\r\n}\r\n\r\ninterface TriggerFile {\r\n    install_exec?: string;\r\n    uninstall_exec?: string;\r\n}\r\n\r\nexport const triggers = {\r\n    load_trigger_file: async (fs: UserspaceFileSystem, trigger_name: string): Promise<TriggerFile | null> => {\r\n        const trigger_path = fs.join(TRIGGER_DIR, trigger_name + \".json\");\r\n        if (!(await fs.exists(trigger_path))) {\r\n            return null;\r\n        }\r\n\r\n        const data = await fs.read_file(trigger_path) as string;\r\n\r\n        try {\r\n            return JSON.parse(data) as TriggerFile;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    trigger_exists: async (fs: UserspaceFileSystem, trigger_name: string): Promise<boolean> => {\r\n        return (await triggers.load_trigger_file(fs, trigger_name)) !== null;\r\n    },\r\n\r\n    // returns boolean indicating if the trigger was found and processed\r\n    process_install_trigger: async (trigger_name: string, data: unknown, pkg_name: string, pkg_version: string, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\r\n        const fs = kernel.get_fs();\r\n\r\n        const trigger = await triggers.load_trigger_file(fs, trigger_name);\r\n        if (!trigger) {\r\n            return false;\r\n        }\r\n\r\n        if (!trigger.install_exec) {\r\n            // nothing to do\r\n            return true;\r\n        }\r\n\r\n        const data_str = JSON.stringify(data);\r\n\r\n        console.log(`Processing install trigger ${trigger_name} with exec ${trigger.install_exec} and args [${pkg_name}, ${pkg_version}, ${data_str}]`);\r\n\r\n        let spawn_result: SpawnResult;\r\n\r\n        try {\r\n            spawn_result =  kernel.spawn(trigger.install_exec, [pkg_name, pkg_version, data_str], shell);\r\n            const exit_code = await spawn_result.completion;\r\n            if (exit_code !== 0) {\r\n                term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} exited with code ${exit_code}.${ANSI.STYLE.reset_all}`);\r\n            }\r\n\r\n            spawn_result.process.kill(exit_code);\r\n        } catch (e) {\r\n            term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} failed: ${e}.${ANSI.STYLE.reset_all}`);\r\n\r\n            if (spawn_result) {\r\n                spawn_result.process.kill(-1);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    // returns boolean indicating if the trigger was found and processed\r\n    process_uninstall_trigger: async (trigger_name: string, data: unknown, pkg_name: string, pkg_version: string, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\r\n        const fs = kernel.get_fs();\r\n\r\n        const trigger = await triggers.load_trigger_file(fs, trigger_name);\r\n        if (!trigger) {\r\n            return false;\r\n        }\r\n\r\n        if (!trigger.uninstall_exec) {\r\n            // nothing to do\r\n            return true;\r\n        }\r\n\r\n        const data_str = JSON.stringify(data);\r\n\r\n        console.log(`Processing uninstall trigger ${trigger_name} with exec ${trigger.uninstall_exec} and args [${pkg_name}, ${pkg_version}, ${data_str}]`);\r\n\r\n        let spawn_result: SpawnResult;\r\n\r\n        try {\r\n            spawn_result =  kernel.spawn(trigger.uninstall_exec, [pkg_name, pkg_version, data_str], shell);\r\n            const exit_code = await spawn_result.completion;\r\n            if (exit_code !== 0) {\r\n                term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} exited with code ${exit_code}.${ANSI.STYLE.reset_all}`);\r\n            }\r\n\r\n            spawn_result.process.kill(exit_code)\r\n        } catch (e) {\r\n            term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} failed: ${e}.${ANSI.STYLE.reset_all}`);\r\n\r\n            if (spawn_result) {\r\n                spawn_result.process.kill(-1);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS} = ANSI;\r\n\r\n// TODO: update command (update all installed or specific packages)\r\n\r\nexport default {\r\n    name: \"pkg\",\r\n    description: \"The package manager for OllieOS.\",\r\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\r\n    arg_descriptions: {\r\n        \"Subcommands:\": {\r\n            \"add\": `Installs a list of packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} add <packages...>${STYLE.reset_all}`,\r\n            \"remove\": `Uninstalls a list of packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} remove <packages...>${STYLE.reset_all}`,\r\n            \"list\": `Lists all installed packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} list [-t]${STYLE.reset_all}`,\r\n            \"info\": `Displays information about a package: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} info [-r] <package>${STYLE.reset_all}`,\r\n            \"read\": `Reads the long description for a package if it has one: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} read [-r] <package>${STYLE.reset_all}`,\r\n            \"browse\": `Browse the repository for packages and versions: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} browse${STYLE.reset_all}`,\r\n            \"clean\": `Removes all packages that are not top level and have no dependents (and are therefore unused): ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} clean [-d]${STYLE.reset_all}`,\r\n        },\r\n        \"Arguments:\": {\r\n            \"-h\": \"Displays this help message.\",\r\n            \"For add:\": {\r\n                \"packages\": \"The packages to install, separated by spaces. If you wish to install a specific version, use the format 'package@version'.\",\r\n            },\r\n            \"For remove:\": {\r\n                \"packages\": \"The packages to uninstall, separated by spaces.\",\r\n            },\r\n            \"For list:\": {\r\n                \"-t\": \"List only top-level packages.\",\r\n            },\r\n            \"For info:\": {\r\n                \"-r\": \"Always fetch the latest information from the repository.\",\r\n                \"package\": \"The package to get information about.\",\r\n            },\r\n            \"For read:\": {\r\n                \"-r\": \"Always fetch the latest information from the repository.\",\r\n                \"package\": \"The package to read the long description of.\",\r\n            },\r\n            \"For clean:\": {\r\n                \"-d\": \"Dry run. Lists the packages that would be removed without actually removing them.\",\r\n            }\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // TODO: smarter completion that understands flags for subcommands\r\n        switch (data.arg_index) {\r\n            case 0:\r\n                return helper_completion_options([\"add\", \"remove\", \"list\", \"info\", \"read\", \"browse\", \"clean\"])(data);\r\n            case 1:\r\n                if ([\"info\", \"read\", \"remove\"].includes(data.args[0])) {\r\n                    // complete with installed package names\r\n                    const fs = data.kernel.get_fs();\r\n\r\n                    // load graph\r\n                    let local_graph: { [pkg_name: string]: PkgGraphEntry } = {};\r\n                    try {\r\n                        local_graph = JSON.parse(await fs.read_file(\"/var/lib/pkg/graph.json\") as string, json_convert_dep_arrs_to_sets);\r\n                    } catch (e) {\r\n                        return [];\r\n                    }\r\n\r\n                    const pkgs = Object.keys(local_graph);\r\n                    return helper_completion_options(pkgs)(data);\r\n                }\r\n                break;\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // TODO: safety prompt on first use\r\n\r\n        // extract from data to make code less verbose\r\n        const {args, term, kernel, shell} = data;\r\n        const fs = kernel.get_fs();\r\n\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\r\n            term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"pkg\"], shell).completion;\r\n        }\r\n\r\n        // create /var/lib/pkg if it doesn't exist so subcommands don't have to check\r\n        if (!(await fs.exists(GRAPH_DIR))) {\r\n            await fs.make_dir(GRAPH_DIR);\r\n        }\r\n\r\n        // create /var/lib/pkg/graph.json if it doesn't exist\r\n        if (!(await fs.exists(GRAPH_PATH))) {\r\n            await fs.write_file(GRAPH_PATH, \"{}\");\r\n        }\r\n\r\n        // create /var/lib/pkg/triggers if it doesn't exist\r\n        if (!(await fs.exists(TRIGGER_DIR))) {\r\n            await fs.make_dir(TRIGGER_DIR);\r\n        }\r\n\r\n        // write /var/lib/pkg/triggers/create_trigger.json if it doesn't exist\r\n        const create_trigger_path = fs.join(TRIGGER_DIR, \"create_trigger.json\");\r\n        if (!(await fs.exists(create_trigger_path))) {\r\n            const create_trigger_data: TriggerFile = {\r\n                install_exec: \"trigger_create_trigger\",\r\n                uninstall_exec: \"trigger_remove_trigger\"\r\n            };\r\n\r\n            await fs.write_file(create_trigger_path, JSON.stringify(create_trigger_data));\r\n        }\r\n\r\n        // load graph\r\n        try {\r\n            graph = JSON.parse(await fs.read_file(\"/var/lib/pkg/graph.json\") as string, json_convert_dep_arrs_to_sets);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Fatal error: could not load package graph.${STYLE.reset_all}`);\r\n            return 2;\r\n        }\r\n\r\n        switch (args[0]) {\r\n            case \"add\":\r\n                return await add_subcommand(data);\r\n            case \"remove\":\r\n                return await remove_subcommand(data);\r\n            case \"list\":\r\n                return await list_subcommand(data);\r\n            case \"info\":\r\n                return await info_subcommand(data);\r\n            case \"read\":\r\n                term.writeln(`${PREFABS.error}Not implemented yet.${STYLE.reset_all}`);\r\n                break;\r\n            case \"browse\":\r\n                return await browse_subcommand(data);\r\n            case \"clean\":\r\n                term.writeln(`${PREFABS.error}Not implemented yet.${STYLE.reset_all}`);\r\n                break;\r\n            default:\r\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\r\n                term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type {Program} from \"../types\";\r\nimport {ANSI} from \"../kernel/term_ctl\";\r\n\r\n// yes, the actual touch command is used to modify access time and has more flags, but this os doesn't have access times and this is meant to be simple\r\n\r\nexport default {\r\n    name: \"touch\",\r\n    description: \"Creates a file.\",\r\n    usage_suffix: \"file\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"file\": \"The file to create.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const {kernel, args, term} = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const {STYLE, PREFABS} = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // if no arguments, print error\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing file operand.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // if more than one argument, print error\r\n        // TODO: i think this is the only program that checks this, the others drop the extra arguments. do something about this!\r\n        if (args.length > 1) {\r\n            term.writeln(`${PREFABS.error}Too many arguments${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // if the file already exists, do nothing\r\n        const file = args[0];\r\n        const absolute_file = fs.absolute(file);\r\n\r\n        if (await fs.exists(absolute_file)) {\r\n            return 0;\r\n        }\r\n\r\n        // check if the directory exists\r\n        // TODO: should abstractfilesystem have basename and dirname functions? check other programs for similar code!\r\n        const dir = absolute_file.split(\"/\").slice(0, -1).join(\"/\");\r\n        if (!(await fs.dir_exists(dir))) {\r\n            term.writeln(`${PREFABS.error}No such directory: ${dir}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // create the file\r\n        await fs.write_file(absolute_file, \"\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport {ANSI} from \"../kernel/term_ctl\";\r\n\r\nexport default {\r\n    name: \"mkdir\",\r\n    description: \"Creates a directory.\",\r\n    usage_suffix: \"[-p] directory\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-p\": \"Create parent directories (recursive) if they don't exist.\"\r\n        },\r\n        \"Arguments:\": {\r\n            \"directory\": \"The directory to create.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n\r\n        // check if -p flag was passed\r\n        let recursive = false;\r\n        if (args[0] === \"-p\") {\r\n            recursive = true;\r\n            args.shift();\r\n        }\r\n\r\n        // check if there is only one argument after parsing flag\r\n        if (args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}Invalid arguments.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get directory\r\n        const dir = args[0];\r\n        const abs_dir = fs.absolute(dir);\r\n\r\n        // check if directory already exists\r\n        if (await fs.dir_exists(abs_dir)) {\r\n            return 0;\r\n        }\r\n\r\n        // create directory\r\n        // make_dir is recursive by default, so just check the directories exist already if NOT recursive\r\n        if (recursive) {\r\n            await fs.make_dir(abs_dir);\r\n        } else {\r\n            // check if the directory exists\r\n            const parent = abs_dir.split(\"/\").slice(0, -1).join(\"/\");\r\n            if (!(await fs.dir_exists(parent))) {\r\n                term.writeln(`${PREFABS.error}No such directory: ${parent}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            await fs.make_dir(abs_dir);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../kernel/term_ctl\";\r\n\r\nexport default {\r\n    name: \"mv\",\r\n    description: \"Moves files and directories.\",\r\n    usage_suffix: \"[-n] source destination\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"source\": \"The file or directory to move.\",\r\n            \"destination\": \"The new location for the file or directory.\",\r\n            \"-n\": \"Do not overwrite an existing file.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // check for -n\r\n        let no_overwrite = false;\r\n        //if (args.includes(\"-n\")) {\r\n            // TODO: why do programs care about flag order? should they?\r\n            //// remove -n from args\r\n            //args.splice(args.indexOf(\"-n\"), 1);\r\n        if (args[0] === \"-n\") {\r\n            no_overwrite = true;\r\n            args.shift();\r\n        }\r\n\r\n        // get source and destination\r\n        const source = fs.absolute(args[0]);\r\n        const raw_destination = args[1];\r\n        const ended_with_slash = raw_destination.endsWith(\"/\");\r\n        let destination = fs.absolute(raw_destination);\r\n\r\n        // check if source exists\r\n        if (!(await fs.exists(source))) {\r\n            term.writeln(`${PREFABS.error}No such file or directory: ${source}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        const dest_is_dir = await fs.dir_exists(destination);\r\n\r\n        // now handled by move_dir implementation\r\n        // // if destination is a directory and ending with a slash, append the basename of source to destination\r\n        // if (dest_is_dir && ended_with_slash) {\r\n        //     const basename = source.split(\"/\").pop() as string;\r\n        //     destination = fs.join(destination, basename);\r\n        // }\r\n\r\n        // check if destination exists if -n is passed OR we are moving a FILE (not a directory) into a DIRECTORY ending specifically with /\r\n        // TODO: there must be a way to adjust logic of the fs functions to make this check unnecessary or simpler. oh well.\r\n        const do_exists_check = no_overwrite || (dest_is_dir && !(await fs.dir_exists(source)) && ended_with_slash);\r\n        if (do_exists_check && await fs.exists(destination)) {\r\n            term.writeln(`${PREFABS.error}File or directory already exists: ${destination}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // move source to destination\r\n        // TODO: abstractfilesystem should have a file_exists function so we don't have to check if it's a directory first\r\n        if (await fs.dir_exists(source)) {\r\n            // force move inside if ended with slash\r\n            try {\r\n                await fs.move_dir(source, destination, ended_with_slash);\r\n            } catch (e) {\r\n                term.writeln(`${PREFABS.error}Error moving directory: ${(e as Error).message}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        } else if (await fs.exists(source)) {\r\n            await fs.move_file(source, destination);\r\n        } else {\r\n            term.writeln(`${PREFABS.error}Source is neither a file nor a directory: ${source}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG } = ANSI;\r\nexport const info_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    term.write(NEWLINE);\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const all_windows = wm!.get_all_windows();\r\n    const visible_windows = all_windows.filter(w => w.visible).length;\r\n\r\n    term.writeln(`Window manager: ${FG.cyan}${wm!.get_unique_manager_type_name()}${STYLE.reset_all}`);\r\n    term.writeln(`Total open windows: ${FG.cyan}${all_windows.length}${STYLE.reset_all}`);\r\n    term.writeln(`Visible windows: ${FG.cyan}${visible_windows}${STYLE.reset_all}`);\r\n    term.writeln(`Invisible windows: ${FG.cyan}${all_windows.length - visible_windows}${STYLE.reset_all}`);\r\n\r\n    return 0;\r\n}\r\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG } = ANSI;\r\nexport const list_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // check for presence of -v or -i flag\r\n    let only_visible = false;\r\n    let only_invisible = false;\r\n    if (args[0] === \"-v\") {\r\n        only_visible = true;\r\n        args.shift();\r\n    } else if (args[0] === \"-i\") {\r\n        only_invisible = true;\r\n        args.shift();\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const all_windows = wm!.get_all_windows();\r\n    for (const win of all_windows) {\r\n        if (only_visible && !win.visible) {\r\n            continue;\r\n        }\r\n\r\n        if (only_invisible && win.visible) {\r\n            continue;\r\n        }\r\n\r\n        // TODO: source process tracking to show which program opened the window\r\n        const visibility_text = win.visible ? `${FG.green}Visible${STYLE.reset_all}` : `${FG.red}Invisible${STYLE.reset_all}`;\r\n        term.writeln(`- [${win.id}] ${FG.cyan}${win.title}${STYLE.reset_all} : ${visibility_text} owned by PID ${FG.yellow}${win.owner_pid}${STYLE.reset_all}`);\r\n    }\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../kernel/term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const show_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel: userspace_kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to show\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // check window exists first with userspace kernel\r\n    const userspace_wm = userspace_kernel.get_window_manager();\r\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\r\n    if (!userspace_window) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // request elevation\r\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to show a window.\");\r\n    if (!kernel) {\r\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    // check again for safety\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    if (wind.visible) {\r\n        term.writeln(`Window with ID ${FG.cyan}${window_id}${STYLE.reset_all} is already visible.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    term.writeln(`Showing window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\r\n    wind.show();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../kernel/term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const hide_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel: userspace_kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to hide\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // check window exists first with userspace kernel\r\n    const userspace_wm = userspace_kernel.get_window_manager();\r\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\r\n    if (!userspace_window) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // request elevation\r\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to hide a window.\");\r\n    if (!kernel) {\r\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    // check again for safety\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    if (!wind.visible) {\r\n        term.writeln(`Window with ID ${FG.cyan}${window_id}${STYLE.reset_all} is already hidden.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    term.writeln(`Hiding window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\r\n    wind.hide();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../kernel/term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const close_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel: userspace_kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to close\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // check window exists first with userspace kernel\r\n    const userspace_wm = userspace_kernel.get_window_manager();\r\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\r\n    if (!userspace_window) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // request elevation\r\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to close a window.\");\r\n    if (!kernel) {\r\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    // check again for safety\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`Closing window with ID ${FG.cyan}${window_id}${STYLE.reset_all}. The process that opened this window may still be running.`);\r\n    wind.close();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../kernel/term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {Kernel} from \"../../kernel\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const center_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel: userspace_kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to center\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // check window exists first with userspace kernel\r\n    const userspace_wm = userspace_kernel.get_window_manager();\r\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\r\n    if (!userspace_window) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // request elevation\r\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to center a window.\");\r\n    if (!kernel) {\r\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    // check again for safety\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`Centering window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\r\n    wind.center();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../kernel/term_ctl\";\r\nimport type {Program} from \"../../types\";\r\n\r\nimport {info_subcommand} from \"./info\";\r\nimport {list_subcommand} from \"./list\";\r\nimport {show_subcommand} from \"./show\";\r\nimport {hide_subcommand} from \"./hide\";\r\nimport {close_subcommand} from \"./close\";\r\nimport {center_subcommand} from \"./center\";\r\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS} = ANSI;\r\n\r\n// TODO: maximise restore command, respecting maximisable property but providing a -f force flag\r\n\r\nexport default {\r\n    name: \"window\",\r\n    description: \"Interact with program windows.\",\r\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\r\n    arg_descriptions: {\r\n        \"Subcommands:\": {\r\n            \"info\": `Displays information about the window manager and open windows: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} info${STYLE.reset_all}`,\r\n            \"list\": `Lists all open windows: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} list [-vi]${STYLE.reset_all}`,\r\n            \"show\": `Shows a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} show <window_id>${STYLE.reset_all}`,\r\n            \"hide\": `Hides a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} hide <window_id>${STYLE.reset_all}`,\r\n            \"close\": `Closes a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} close <window_id>${STYLE.reset_all}. Note that this does not terminate the process that opened the window.`,\r\n            \"center\": `Centers a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} show <window_id>${STYLE.reset_all}`,\r\n        },\r\n        \"Arguments:\": {\r\n            \"-h\": \"Displays this help message.\",\r\n            \"For list:\": {\r\n                \"-v\": \"List only visible windows.\",\r\n                \"-i\": \"List only invisible (minimised/hidden) windows.\",\r\n            },\r\n            \"For show, hide, close, and center:\": {\r\n                \"<window_id>\": \"The ID of the window.\",\r\n            }\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        switch (data.arg_index) {\r\n            case 0:\r\n                return helper_completion_options([\"info\", \"list\", \"show\", \"hide\", \"close\", \"center\"])(data);\r\n            case 1:\r\n                // completing first argument of subcommand\r\n                if (data.raw_parts[1] === \"list\") {\r\n                    return helper_completion_options([\"-v\", \"-i\"])(data);\r\n                } else if ([\"show\", \"hide\", \"close\", \"center\"].includes(data.raw_parts[1])) {\r\n                    // complete window ids\r\n                    const wm = data.kernel.get_window_manager();\r\n                    if (!wm) {\r\n                        return [];\r\n                    }\r\n\r\n                    const window_ids = wm.get_all_windows().map((win) => win.id.toString());\r\n                    return helper_completion_options(window_ids)(data);\r\n                }\r\n                return [];\r\n            default:\r\n                return [];\r\n        }\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const {args, term, kernel, shell} = data;\r\n\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\r\n            term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"window\"], shell).completion;\r\n        }\r\n\r\n        if (!kernel.has_window_manager()) {\r\n            term.writeln(`${PREFABS.error}No window manager found.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        switch (args[0]) {\r\n            case \"info\":\r\n                return await info_subcommand(data);\r\n            case \"list\":\r\n                return await list_subcommand(data);\r\n            case \"show\":\r\n                return await show_subcommand(data);\r\n            case \"hide\":\r\n                return await hide_subcommand(data);\r\n            case \"close\":\r\n                return await close_subcommand(data);\r\n            case \"center\":\r\n                return await center_subcommand(data);\r\n            default:\r\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\r\n                term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n    }\r\n} as Program;\r\n","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"alias\",\r\n    description: \"Define or display aliases. (Use .ollierc to persist aliases)\",\r\n    usage_suffix: \"[name[=value] ...]\",\r\n    arg_descriptions: {\r\n        name: \"The name of the alias to define or display. If no arguments are given, all aliases are displayed. Multiple alias arguments can be provided.\",\r\n        \"name=value\": \"Defines an alias with the given name and value. End the value with a space to allow chaining.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, term } = data;\r\n\r\n        if (!shell) {\r\n            term.writeln(\"No shell available\");\r\n            return 1;\r\n        }\r\n\r\n        // TODO: move to shell builtin, not actual program\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = term.ansi;\r\n\r\n        if (data.args.length === 0) {\r\n            // display all aliases\r\n            const aliases = shell.memory.list_aliases();\r\n            for (const [name, value] of aliases.entries()) {\r\n                term.writeln(`alias ${name}='${value}'`);\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        for (const arg of data.args) {\r\n            if (arg.includes(\"=\")) {\r\n                // define alias\r\n                const [name, ...value_parts] = arg.split(\"=\");\r\n                const value = value_parts.join(\"=\");\r\n\r\n                // remove surrounding quotes if present\r\n                let final_value = value;\r\n                if ((final_value.startsWith(\"'\") && final_value.endsWith(\"'\")) ||\r\n                    (final_value.startsWith(\"\\\"\") && final_value.endsWith(\"\\\"\"))) {\r\n                    final_value = final_value.slice(1, -1);\r\n                }\r\n\r\n                shell.memory.set_alias(name, final_value);\r\n            } else {\r\n                // display alias\r\n                const value = shell.memory.get_alias(arg);\r\n                if (value) {\r\n                    term.writeln(`alias ${arg}='${value}'`);\r\n                } else {\r\n                    term.writeln(`${PREFABS.error}alias: ${arg}: not found${STYLE.reset_all}`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"unalias\",\r\n    description: \"Remove defined aliases.\",\r\n    usage_suffix: \"name [name ...]\",\r\n    arg_descriptions: {\r\n        name: \"The name of the alias to remove. Multiple alias names can be provided.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (!data.shell) {\r\n            return [];\r\n        }\r\n\r\n        const alias_names = [...data.shell.memory.list_aliases().keys()];\r\n        // TODO: check type to see why helper_completion_options wont work here\r\n        return alias_names.filter(name => name.startsWith(data.current_partial));\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, term } = data;\r\n\r\n        if (!shell) {\r\n            term.writeln(\"No shell available\");\r\n            return 1;\r\n        }\r\n\r\n        // TODO: move to shell builtin, not actual program\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = term.ansi;\r\n\r\n        if (data.args.length === 0) {\r\n            term.writeln(`${PREFABS.error}unalias: usage: unalias name [name ...]${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        for (const arg of data.args) {\r\n            const success = shell.memory.unset_alias(arg);\r\n            if (!success) {\r\n                term.writeln(`${PREFABS.error}unalias: ${arg}: not found${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import {ANSI, NEWLINE} from \"../kernel/term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"ps\",\r\n    description: \"Display currently running processes.\",\r\n    usage_suffix: \"[-p PID]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"-p PID\": \"Display information about the process with the given PID. If omitted, displays all running processes.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        console.log(data);\r\n        if (data.arg_index === 0) {\r\n            return helper_completion_options([\"-p\"])(data);\r\n        } else if (data.arg_index === 1 && data.args[0] === \"-p\") {\r\n            const pm = data.kernel.get_process_manager();\r\n            const pids = pm.list_pids().map((pid) => pid.toString());\r\n            return helper_completion_options(pids)(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // get process manager\r\n        const pm = kernel.get_process_manager();\r\n\r\n        if (data.args[0] === \"-p\") {\r\n            const pid = parseInt(data.args[1]);\r\n            if (isNaN(pid)) {\r\n                term.writeln(`${PREFABS.error}Invalid PID provided.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            const process = pm.get_process(pid);\r\n            if (!process) {\r\n                term.writeln(`${PREFABS.error}No process found with PID ${pid}.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            term.write(NEWLINE);\r\n            term.writeln(`${STYLE.bold}PID:${STYLE.no_bold_or_dim} ${process.pid}${STYLE.reset_all}`);\r\n            term.writeln(`${STYLE.bold}Command:${STYLE.no_bold_or_dim} ${process.source_command.command}${STYLE.reset_all}`);\r\n            term.writeln(`${STYLE.bold}Created:${STYLE.no_bold_or_dim} ${process.created_at.toLocaleString()}${STYLE.reset_all}`);\r\n\r\n            return 0;\r\n        }\r\n\r\n        const pids = pm.list_pids();\r\n\r\n        // get longest source command length for formatting\r\n        let longest_command_length = 7 // length of \"COMMAND\"\r\n        for (const pid of pids) {\r\n            const process = pm.get_process(pid)!;\r\n            if (process.source_command.command.length > longest_command_length) {\r\n                longest_command_length = process.source_command.command.length;\r\n            }\r\n        }\r\n\r\n        const get_command_space = (subtract = 0) => \" \".repeat(longest_command_length - subtract);\r\n\r\n        term.write(NEWLINE);\r\n        term.writeln(`${STYLE.bold}PID\\tCOMMAND${get_command_space(7)}\\t\\tCREATED${STYLE.reset_all}`);\r\n        for (const pid of pids) {\r\n            const process = pm.get_process(pid)!;\r\n            term.writeln(`${pid}\\t${process.source_command.command}${get_command_space(process.source_command.command.length)}\\t\\t${process.created_at.toLocaleString()}`);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import {ANSI} from \"../kernel/term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"kill\",\r\n    description: \"Kill a process by its PID.\",\r\n    usage_suffix: \"PID\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"PID\": \"The PID of the process to kill.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (data.arg_index === 0) {\r\n            const pm = data.kernel.get_process_manager();\r\n            const pids = pm.list_pids().map((pid) => pid.toString());\r\n            return helper_completion_options(pids)(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        if (data.args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}Exactly one argument (PID) expected.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // TODO: support more kill signals as arguments\r\n\r\n        // get process manager\r\n        const pm = kernel.get_process_manager();\r\n        const pid = parseInt(data.args[0]);\r\n\r\n        if (isNaN(pid)) {\r\n            term.writeln(`${PREFABS.error}Invalid PID provided.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        pm.kill(pid, 143); // SIGTERM\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: move this to be literal SIGTERM and SIGKILL signals sent to processes\r\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\r\nimport {ProgramMainData} from \"../../types\"\r\n\r\nimport type {IgnitionIPCReply} from \"../core/ignition\";\r\nimport type {ServiceStatus} from \"../core/ignition/services\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, FG, PREFABS} = ANSI;\r\n\r\nexport const service_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const {args, term, process, kernel} = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing action.`);\r\n        term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    if (args.length === 1) {\r\n        term.writeln(`${PREFABS.error}Missing service ID.`);\r\n        term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const action = args[0];\r\n    const service_id = args[1];\r\n\r\n    // open ipc with ignition\r\n    const ipc = kernel.get_ipc();\r\n    const channel_id = ipc.create_channel(\"init\");\r\n\r\n    if (!channel_id) {\r\n        term.writeln(`${PREFABS.error}Failed to communicate with ignition.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // function can be defined to handle response data, string responses and errors handled by default\r\n    let on_data: (msg_data: unknown) => void;\r\n    let reply_timeout: number;\r\n    let return_code = 0;\r\n\r\n    // listen for replies\r\n    ipc.channel_listen(channel_id, async (msg) => {\r\n        const payload = msg.data as IgnitionIPCReply;\r\n\r\n        if (payload.type === \"data\") {\r\n            if (on_data) {\r\n                on_data(payload.data);\r\n            } else {\r\n                term.writeln(`${FG.yellow}Warning: Unhandled data response: ${JSON.stringify(payload.data)}${STYLE.reset_all}`);\r\n            }\r\n        } else if (payload.type === \"response\") {\r\n            term.writeln(`${FG.green}${payload.message}${STYLE.reset_all}`);\r\n        } else if (payload.type === \"error\") {\r\n            term.writeln(`${PREFABS.error}${payload.message}${STYLE.reset_all}`);\r\n            return_code = 1;\r\n        }\r\n\r\n        if (reply_timeout) {\r\n            process.cancel_timeout(reply_timeout);\r\n        }\r\n    });\r\n\r\n    if (action === \"status\") {\r\n        // special handler for status data\r\n        on_data = (msg_data: unknown) => {\r\n            const status = msg_data as ServiceStatus;\r\n\r\n            term.write(NEWLINE);\r\n            term.writeln(`${FG.cyan}Service ID:${STYLE.reset_all} ${service_id}`);\r\n\r\n            term.write(`${FG.cyan}Status: ${STYLE.reset_all}`);\r\n            switch (status.state) {\r\n                case \"running\":\r\n                    term.writeln(`${FG.green}Running${STYLE.reset_all}`);\r\n                    term.writeln(`${FG.cyan}PID:${STYLE.reset_all} ${status.pid}`);\r\n                    break;\r\n                case \"stopped\":\r\n                    term.writeln(`${FG.yellow}Stopped${STYLE.reset_all}`);\r\n                    break;\r\n                case \"failed\":\r\n                    term.writeln(`${FG.red}Failed${STYLE.reset_all}`);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // wait up to 3 seconds for a reply before erroring\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    reply_timeout = process.create_timeout(() => {}, 3000);\r\n\r\n    // can just send the action and service id directly rather than needing additional checking as the action matches the ipc action names\r\n    ipc.channel_send(channel_id, {\r\n        type: \"service\",\r\n        action,\r\n        service_id\r\n    });\r\n\r\n    if (!process.has_timeout(reply_timeout)) {\r\n        // timeout already cleared, meaning we got a response\r\n        return return_code;\r\n    }\r\n\r\n    const got_no_reply = await process.wait_for_timeout(reply_timeout);\r\n\r\n    if (got_no_reply) {\r\n        term.writeln(`${PREFABS.error}No response from ignition.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    // TODO: all this logic is kinda jank, trying to be too clever with timeouts and async ipc\r\n\r\n    return return_code;\r\n}\r\n","import {ANSI} from \"../../kernel/term_ctl\";\r\nimport {ProgramMainData} from \"../../types\"\r\n\r\nimport type {IgnitionIPCReply} from \"../core/ignition\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, FG, PREFABS} = ANSI;\r\n\r\nexport const reload_services_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const {args, term, process, kernel} = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // TODO: make function to do this back and forth with ignition rather than duplicating code for each subcommand\r\n\r\n    // open ipc with ignition\r\n    const ipc = kernel.get_ipc();\r\n    const channel_id = ipc.create_channel(\"init\");\r\n\r\n    if (!channel_id) {\r\n        term.writeln(`${PREFABS.error}Failed to communicate with ignition.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    let reply_timeout: number;\r\n    let return_code = 0;\r\n\r\n    // listen for replies\r\n    ipc.channel_listen(channel_id, async (msg) => {\r\n        const payload = msg.data as IgnitionIPCReply;\r\n\r\n        if (payload.type === \"response\") {\r\n            term.writeln(`${FG.green}${payload.message}${STYLE.reset_all}`);\r\n        } else if (payload.type === \"error\") {\r\n            term.writeln(`${PREFABS.error}${payload.message}${STYLE.reset_all}`);\r\n            return_code = 1;\r\n        }\r\n\r\n        if (reply_timeout) {\r\n            process.cancel_timeout(reply_timeout);\r\n        }\r\n    });\r\n\r\n    // wait up to 3 seconds for a reply before erroring\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    reply_timeout = process.create_timeout(() => {}, 3000);\r\n\r\n    ipc.channel_send(channel_id, {\r\n        type: \"reload_services\"\r\n    });\r\n\r\n    if (!process.has_timeout(reply_timeout)) {\r\n        // timeout already cleared, meaning we got a response\r\n        return return_code;\r\n    }\r\n\r\n    const got_no_reply = await process.wait_for_timeout(reply_timeout);\r\n\r\n    if (got_no_reply) {\r\n        term.writeln(`${PREFABS.error}No response from ignition.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    // TODO: all this logic is kinda jank, trying to be too clever with timeouts and async ipc\r\n\r\n    return return_code;\r\n}\r\n","import {ANSI} from \"../../kernel/term_ctl\";\r\nimport type {Program} from \"../../types\";\r\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\r\n\r\nimport {service_subcommand} from \"./service\";\r\nimport {reload_services_subcommand} from \"./reload_services\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS} = ANSI;\r\n\r\n\r\nexport default {\r\n    name: \"spark\",\r\n    description: \"Manage your system with ignition.\",\r\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\r\n    arg_descriptions: {\r\n        \"Subcommands:\": {\r\n            \"service\": \"Manage running services.\",\r\n            \"reload-services\": \"Reload the service definition files.\",\r\n        },\r\n        \"Arguments:\": {\r\n            \"-h\": \"Displays this help message.\",\r\n            \"For service:\": {\r\n                \"action\": \"The action to perform (start, stop, restart, status).\",\r\n                \"service_id\": \"The ID of the service to manage.\",\r\n            },\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // TODO: smarter completion that understands flags for subcommands\r\n        switch (data.arg_index) {\r\n            case 0:\r\n                return helper_completion_options([\"service\"])(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const {args, term, kernel, shell} = data;\r\n\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\r\n            term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"spark\"], shell).completion;\r\n        }\r\n\r\n        switch (args[0]) {\r\n            case \"service\":\r\n                return await service_subcommand(data);\r\n            case \"reload-services\":\r\n                return await reload_services_subcommand(data);\r\n            default:\r\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\r\n                term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"ipc_bg_test\",\r\n    description: \"\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term, process } = data;\r\n\r\n        process.detach();\r\n\r\n        const ipc = kernel.get_ipc();\r\n        ipc.service_register(\"ipc_bg_test\", async (channel_id, from_pid) => {\r\n            ipc.channel_listen(channel_id, async (msg) => {\r\n                term.writeln(`Received message on channel ${channel_id} from PID ${msg.from}: ${JSON.stringify(msg.data)}`);\r\n            });\r\n        });\r\n\r\n        term.writeln(\"ipc_bg_test service started and listening for messages.\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"ipc_fg_test\",\r\n    description: \"\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        const ipc = kernel.get_ipc();\r\n        const channel = ipc.create_channel(\"ipc_bg_test\");\r\n        \r\n        if (!channel) {\r\n            term.writeln(\"Failed to create IPC channel to service 'ipc_bg_test'.\");\r\n            return 1;\r\n        }\r\n\r\n        ipc.channel_send(channel, { message: \"Hello from ipc_fg_test!\" });\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"taskbar_test\",\r\n    description: \"\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    hide_from_help: true,\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term, process, shell } = data;\r\n\r\n        if (!kernel.has_window_manager()) {\r\n            term.writeln(\"This program requires a window manager.\");\r\n            return 1;\r\n        }\r\n\r\n        const wind = process.create_window();\r\n\r\n        wind.title = \"Taskbar\";\r\n\r\n        wind.set_custom_flag(\"no-top-bar\", true);\r\n\r\n        wind.x = \"0vw\";\r\n        wind.y = \"92.5vh\";\r\n\r\n        wind.height = \"7.5vh\";\r\n        wind.width = \"100vw\";\r\n\r\n        const buttons = document.createElement(\"div\");\r\n        buttons.style.display = \"flex\";\r\n        buttons.style.height = \"100%\";\r\n        buttons.style.alignItems = \"center\";\r\n        buttons.style.gap = \"1vh\";\r\n        buttons.style.padding = \"0 1vh\";\r\n\r\n        wind.dom.appendChild(buttons);\r\n\r\n        const fsedit_button = document.createElement(\"button\");\r\n        fsedit_button.innerText = \"FSEdit\";\r\n        fsedit_button.style.height = \"100%\";\r\n        fsedit_button.style.fontSize = \"2vh\";\r\n        fsedit_button.onclick = () => {\r\n            kernel.spawn(\"fsedit\", [], shell);\r\n        };\r\n\r\n        buttons.appendChild(fsedit_button);\r\n\r\n        // if minecraft is installed, add a button for it\r\n        const prog_reg = kernel.get_program_registry();\r\n        if (prog_reg.getProgram(\"minecraft\")) {\r\n            const mc_button = document.createElement(\"button\");\r\n            mc_button.style.height = \"100%\";\r\n            mc_button.style.fontSize = \"2vh\";\r\n            mc_button.onclick = () => {\r\n                kernel.spawn(\"minecraft\", [], shell);\r\n            };\r\n\r\n            const mc_image = document.createElement(\"img\");\r\n            mc_image.src = \"https://brandlogos.net/wp-content/uploads/2022/07/minecraft-logo_brandlogos.net_faqdi-512x560.png\";\r\n            mc_image.style.height = \"100%\";\r\n            mc_image.style.objectFit = \"contain\";\r\n            mc_image.alt = \"Minecraft\";\r\n            mc_image.draggable = false;\r\n            mc_button.appendChild(mc_image);\r\n\r\n            buttons.appendChild(mc_button);\r\n        }\r\n\r\n        wind.show();\r\n\r\n        process.detach();\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../../../types\";\r\n\r\nexport default {\r\n    name: \"trigger_create_trigger\",\r\n    description: \"A trigger to create another trigger. Use this trigger to deploy custom triggers!\",\r\n    usage_suffix: \"pkg_name pkg_version trigger_file\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"pkg_name\": \"The name of the package creating the trigger, which will namespace the trigger. Passed automatically by the package manager.\",\r\n            \"pkg_version\": \"Ignored. Passed automatically by the package manager.\",\r\n            \"trigger_file\": \"The path to the trigger file to create. This is the string that you pass into the create_trigger trigger in your package's meta.json triggers section.\"\r\n        }\r\n    },\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        if (args.length !== 3) {\r\n            term.writeln(\"Usage: trigger_create_trigger pkg_name pkg_version trigger_file\");\r\n            return 1;\r\n        }\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        const pkg_name = args[0];\r\n        const trigger_file = JSON.parse(args[2]);\r\n\r\n        // trigger must end with .json\r\n        if (!trigger_file.endsWith(\".json\")) {\r\n            term.writeln(\"Error: Trigger file must end with .json\");\r\n            return 1;\r\n        }\r\n\r\n        // source path will be /usr/bin/PKG_NAME/TRIGGER_FILE\r\n        const source_path = fs.join(\"/usr/bin\", pkg_name, trigger_file);\r\n\r\n        // check the path is valid\r\n        if (!await fs.exists(source_path)) {\r\n            term.writeln(`Error: Trigger file not found at ${source_path}`);\r\n            return 1;\r\n        }\r\n\r\n        // destination path will be /var/lib/pkg/triggers/PKG_NAME/TRIGGER_FILE\r\n        const dest_path = fs.join(\"/var/lib/pkg/triggers\", pkg_name, trigger_file);\r\n\r\n        // check the destination path does not already exist\r\n        if (await fs.exists(dest_path)) {\r\n            term.writeln(`Error: Trigger file already exists at ${dest_path}.`);\r\n            return 1;\r\n        }\r\n\r\n        // copy the trigger file to the destination\r\n        // TODO: make fs support copy operation\r\n        const content = await fs.read_file(source_path);\r\n        await fs.write_file(dest_path, content);\r\n\r\n        term.writeln(`Trigger created at ${dest_path}`);\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: way to pass trigger data as json and identify it. then a way to pass just program name to use as both create and remove trigger?\r\n","import type { Program } from \"../../../types\";\r\n\r\nexport default {\r\n    name: \"trigger_remove_trigger\",\r\n    description: \"A trigger to remove a trigger.\",\r\n    usage_suffix: \"pkg_name pkg_version trigger_file\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"pkg_name\": \"The name of the package that created the trigger, which is used to namespace the trigger. Passed automatically by the package manager.\",\r\n            \"pkg_version\": \"Ignored. Passed automatically by the package manager.\",\r\n            \"trigger_file\": \"The path to the trigger file to remove. This is the string that you pass into the create_trigger trigger in your package's meta.json triggers section.\"\r\n        }\r\n    },\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        if (args.length !== 3) {\r\n            term.writeln(\"Usage: trigger_remove_trigger pkg_name pkg_version trigger_file\");\r\n            return 1;\r\n        }\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        const pkg_name = args[0];\r\n        const trigger_file = JSON.parse(args[2]);\r\n\r\n        // trigger must end with .json\r\n        if (!trigger_file.endsWith(\".json\")) {\r\n            term.writeln(\"Error: Trigger file must end with .json\");\r\n            return 1;\r\n        }\r\n\r\n        // destination path will be /var/lib/pkg/triggers/PKG_NAME/TRIGGER_FILE\r\n        const dest_path = fs.join(\"/var/lib/pkg/triggers\", pkg_name, trigger_file);\r\n\r\n        // check the destination path exists\r\n        if (!await fs.exists(dest_path)) {\r\n            return 0;\r\n        }\r\n\r\n        // remove the trigger file\r\n        await fs.delete_file(dest_path);\r\n\r\n        term.writeln(`Trigger removed from ${dest_path}`);\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: should triggers support using the same program as the uninstall trigger, an just passing different arguments?\r\n","import { AbstractFileSystem, FSEventType, NonRecursiveDirectoryError, PathNotFoundError } from \"../kernel/filesystem\";\r\n\r\n// TODO: may get laggy with large files and many files or dirs\r\n// NOTE: not using implements (TS) so the real methods can be used\r\n// indexeddb fs is superior\r\n// TODO: unsolveable prototype pollution without banning filenames. tried using map, but recursive traversal wont work as the instances are distinct (not writing to the original state dict)\r\nexport class LocalStorageFS extends AbstractFileSystem {\r\n    get_unique_fs_type_name(): string {\r\n        return \"localstorage\";\r\n    }\r\n\r\n    async is_ready() {\r\n        return true;\r\n    }\r\n\r\n    async erase_all() {\r\n        localStorage.removeItem(\"fs\");\r\n        localStorage.removeItem(\"fs_readonly_paths\");\r\n        localStorage.removeItem(\"fs_migrations\");\r\n    }\r\n\r\n    async make_dir(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // create directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            const absolute_path = parts.slice(0, parts.indexOf(part) + 1).join(\"/\");\r\n\r\n            if (!current_dir[part]) {\r\n                current_dir[part] = {};\r\n                this._call_callbacks(FSEventType.MADE_DIR, absolute_path);\r\n            }\r\n\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // save state\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async delete_dir_direct(path: string, recursive: boolean) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // delete innermost directory\r\n        for (let part_idx = 0; part_idx < parts.length; part_idx++) {\r\n            const part = parts[part_idx];\r\n            const absolute_path = parts.slice(0, parts.indexOf(part) + 1).join(\"/\");\r\n\r\n            if (!recursive && (await this.list_dir(absolute_path)).length > 0) {\r\n                throw new NonRecursiveDirectoryError(part);\r\n            }\r\n\r\n            // check if directory exists\r\n            if (!current_dir[part]) {\r\n                throw new PathNotFoundError(absolute_path);\r\n            }\r\n\r\n            // delete directory if it's the last part\r\n            if (part_idx === parts.length - 1) {\r\n                delete current_dir[part];\r\n                this._call_callbacks(FSEventType.DELETED_DIR, absolute_path);\r\n            }\r\n\r\n            // recurse into directory to discover the next part\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // save state\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async move_dir_direct(src: string, dest: string, move_inside: boolean) {\r\n        // (yes, this was ai generated, i just wanted to bring this very outdated fs_impl up to par with opfs. although its idea to make a helper was good, i should have done that years ago)\r\n\r\n        const state = JSON.parse(localStorage.getItem(\"fs\") || \"{}\");\r\n\r\n        // Helper to traverse to a path and return the parent and the target key\r\n        // This allows us to modify the parent (delete/assign) later\r\n        const get_node = (path: string) => {\r\n            const parts = path.split(\"/\").filter(p => p.length > 0);\r\n            const basename = parts[parts.length - 1];\r\n            let current = state;\r\n\r\n            // Traverse to parent\r\n            for (let i = 0; i < parts.length - 1; i++) {\r\n                const part = parts[i];\r\n                if (!current[part] || typeof current[part] !== \"object\") {\r\n                    throw new Error(`Path not found: ${path}`); // Simulates Linux \"No such file or directory\"\r\n                }\r\n                current = current[part];\r\n            }\r\n\r\n            return { parent: current, basename: basename, value: current[basename] };\r\n        };\r\n\r\n        // 1. Resolve Source\r\n        // We need the parent so we can 'delete' the entry later\r\n        const src_node = get_node(src);\r\n        if (!src_node.value) throw new PathNotFoundError(src);\r\n        if (typeof src_node.value !== \"object\") throw new PathNotFoundError(src);\r\n\r\n        // 2. Resolve Destination Parent\r\n        // Unlike your original code, we do NOT auto-create the destination path.\r\n        // Linux 'mv' fails if you try to move to 'a/b/c' and 'a/b' doesn't exist.\r\n        const dest_parts = dest.split(\"/\").filter(p => p.length > 0);\r\n        const dest_basename = dest_parts[dest_parts.length - 1];\r\n\r\n        // Check if the generic destination path exists (e.g. is 'dest' already there?)\r\n        let dest_exists = false;\r\n        let dest_is_dir = false;\r\n        let dest_parent_obj = state; // Default to root\r\n\r\n        // Traverse to the parent of the destination\r\n        for (let i = 0; i < dest_parts.length - 1; i++) {\r\n            const part = dest_parts[i];\r\n            if (!dest_parent_obj[part] || typeof dest_parent_obj[part] !== \"object\") {\r\n                throw new Error(`Destination parent path not found: ${dest}`);\r\n            }\r\n            dest_parent_obj = dest_parent_obj[part];\r\n        }\r\n\r\n        // Check the actual destination node\r\n        if (dest_parent_obj[dest_basename]) {\r\n            dest_exists = true;\r\n            dest_is_dir = typeof dest_parent_obj[dest_basename] === \"object\";\r\n        }\r\n\r\n        // 3. Apply Logic (Rename vs Move Into)\r\n        let final_parent;\r\n        let final_name;\r\n\r\n        if (move_inside || (dest_exists && dest_is_dir)) {\r\n            // RULE: Move 'src' INTO 'dest'\r\n\r\n            if (!dest_exists) {\r\n                // \"mv dir1 dir2/\" but dir2 missing -> Error\r\n                throw new Error(`Destination directory not found: ${dest}`);\r\n            }\r\n\r\n            // Our new parent is the destination folder itself\r\n            final_parent = dest_parent_obj[dest_basename];\r\n            final_name = src_node.basename; // Keep original name\r\n        } else {\r\n            // RULE: Rename 'src' TO 'dest'\r\n\r\n            if (dest_exists && !dest_is_dir) {\r\n                // Trying to overwrite a file with a directory -> Error\r\n                throw new Error(`Cannot overwrite non-directory '${dest}' with directory.`);\r\n            }\r\n\r\n            // Our new parent is the destination's parent\r\n            final_parent = dest_parent_obj;\r\n            final_name = dest_basename; // New name\r\n        }\r\n\r\n        // 4. Collision Check (Strict Linux: No Merging)\r\n        if (final_parent[final_name]) {\r\n            // In Linux, 'mv' fails if the target directory is not empty.\r\n            // Since we are moving a directory, we strictly fail here.\r\n            throw new Error(`Directory not empty: ${final_name} already exists in destination.`);\r\n        }\r\n\r\n        // 5. Execute Move (Atomic Reference Change)\r\n        // This is the beauty of LocalStorage/JSON: No recursive copy needed.\r\n        // Just point the new key to the old object.\r\n\r\n        final_parent[final_name] = src_node.value;\r\n\r\n        // 6. Delete Source\r\n        delete src_node.parent[src_node.basename];\r\n\r\n        // 7. Save State\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async list_dir(path: string, dirs_first = false) {\r\n        this._call_callbacks(FSEventType.LISTING_DIR, path);\r\n\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // trim trailing slash\r\n        if (parts[parts.length - 1] === \"\") {\r\n            parts.pop();\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            if (current_dir[part]) {\r\n                current_dir = current_dir[part];\r\n            } else {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n        }\r\n\r\n        // if this is the root we will have an empty parts array, so we need to access the root directory\r\n        // our whole fs is stored under an empty top level key because im stupid\r\n        // we might have to do this elsewhere\r\n        if (parts.length === 0) {\r\n            current_dir = state[\"\"];\r\n        }\r\n\r\n        // return list of files in directory\r\n        const keys = Object.keys(current_dir);\r\n\r\n        if (dirs_first) {\r\n            for (const key of keys) {\r\n                // promote directories to the front of the list\r\n                if (typeof current_dir[key] === \"object\") {\r\n                    keys.splice(keys.indexOf(key), 1);\r\n                    keys.unshift(key);\r\n                }\r\n            }\r\n        }\r\n\r\n        return keys;\r\n    }\r\n\r\n\r\n    async read_file_direct(path: string, as_uint = false) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n        let current_part = state;\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // if this is not the last part, check if it is a directory\r\n            if (parts.indexOf(part) !== parts.length - 1 && !current_part[part]) {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n\r\n            current_part = current_part[part];\r\n        }\r\n\r\n        // check if file exists\r\n        if (current_part !== undefined) {\r\n            // if file is empty, return empty string / uint8array (or else it will be read as null byte)\r\n            if (current_part.length === 0) {\r\n                if (as_uint) {\r\n                    return new Uint8Array();\r\n                } else {\r\n                    return \"\";\r\n                }\r\n            }\r\n\r\n            const binary_string = atob(current_part);\r\n            const bytes = Uint8Array.from(binary_string, m => m.charCodeAt(0));\r\n\r\n            if (as_uint) {\r\n                return bytes;\r\n            } else {\r\n                return new TextDecoder().decode(bytes);\r\n            }\r\n        }\r\n\r\n        throw new PathNotFoundError(path);\r\n    }\r\n\r\n    async write_file_direct(path: string, data: string | ArrayBuffer | Uint8Array) {\r\n        let uint: Uint8Array;\r\n\r\n        // convert string to uint8array\r\n        if (typeof data === \"string\") {\r\n            uint = new TextEncoder().encode(data);\r\n        }\r\n\r\n        // convert array buffer to uint8array\r\n        if (data instanceof ArrayBuffer) {\r\n            uint = new Uint8Array(data);\r\n        }\r\n\r\n        if (data instanceof Uint8Array) {\r\n            uint = data;\r\n        }\r\n\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n        const file_name = parts[parts.length - 1];\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // go until before the last part\r\n            if (parts.indexOf(part) !== parts.length - 1) {\r\n                if (!current_dir[part]) {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                current_dir = current_dir[part];\r\n            }\r\n        }\r\n\r\n        // convert uint8array to base64\r\n        // uint.toBase64() isnt mainstream yet\r\n        current_dir[file_name] = btoa(String.fromCharCode.apply(null, uint));\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async delete_file_direct(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n        const file_name = parts[parts.length - 1];\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // go until before the last part\r\n            if (parts.indexOf(part) !== parts.length - 1) {\r\n                if (!current_dir[part]) {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                current_dir = current_dir[part];\r\n            }\r\n        }\r\n\r\n        // delete file from directory\r\n        delete current_dir[file_name];\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n\r\n        // remove from readonly list if it is there\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        if (readonly_list.includes(path)) {\r\n            readonly_list.splice(readonly_list.indexOf(path), 1);\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n        }\r\n    }\r\n\r\n    async move_file_direct(src: string, dest: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n\r\n        // split paths into parts, if root, use single empty string to avoid doubling\r\n        const src_parts = src === this._root ? [\"\"] : src.split(\"/\");\r\n        const dest_parts = dest === this._root ? [\"\"] : dest.split(\"/\");\r\n        const file_name = src_parts[src_parts.length - 1];\r\n        const new_file_name = dest_parts[dest_parts.length - 1];\r\n\r\n        // get directory for each part inside the previous one\r\n        let current_dir = state;\r\n        for (const part of src_parts.slice(0, -1)) {\r\n            if (!current_dir[part]) {\r\n                throw new PathNotFoundError(src);\r\n            }\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // check if file exists\r\n        if (current_dir[file_name] === undefined) {\r\n            throw new PathNotFoundError(src);\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        let new_current_dir = state;\r\n        for (const part of dest_parts.slice(0, -1)) {\r\n            if (!new_current_dir[part]) {\r\n                throw new PathNotFoundError(dest);\r\n            }\r\n            new_current_dir = new_current_dir[part];\r\n        }\r\n\r\n        // if we have equivalent paths, do nothing (so we don't accidentally delete the file when calling delete after move)\r\n        if (file_name === new_file_name && current_dir === new_current_dir) {\r\n            console.warn(\"source and destination are the same\");\r\n            return;\r\n        }\r\n\r\n        // move file from source to destination\r\n        new_current_dir[new_file_name] = current_dir[file_name];\r\n        delete current_dir[file_name];\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n\r\n        // relocate in readonly list if it is there\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        if (readonly_list.includes(src)) {\r\n            readonly_list.splice(readonly_list.indexOf(src), 1);\r\n            readonly_list.push(dest);\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n        }\r\n    }\r\n\r\n    async set_readonly_direct(path: string, readonly: boolean) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n\r\n        if (readonly && !state.includes(path)) {\r\n            state.push(path);\r\n        } else if (!readonly && state.includes(path)) {\r\n            state.splice(state.indexOf(path), 1);\r\n        }\r\n\r\n        localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(state));\r\n    }\r\n\r\n    async is_readonly_direct(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        return state.includes(path);\r\n    }\r\n\r\n    async exists_direct(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_part = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // remove trailing /\r\n        if (parts[parts.length - 1] === \"\") {\r\n            parts.pop();\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // important! empty strings are falsy so we need to specifically check for undefined\r\n            if (current_part[part] !== undefined) {\r\n                current_part = current_part[part];\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async dir_exists(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_part = state;\r\n\r\n        // if path ends with /, remove it\r\n        if (path.endsWith(\"/\")) {\r\n            path = path.slice(0, -1);\r\n        }\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            if (current_part[part]) {\r\n                current_part = current_part[part];\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return typeof current_part === \"object\";\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        // initialise file system\r\n        if (!localStorage.getItem(\"fs\")) {\r\n            localStorage.setItem(\"fs\", JSON.stringify({}));\r\n        }\r\n\r\n        if (!localStorage.getItem(\"fs_readonly_paths\")) {\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify([]));\r\n        }\r\n\r\n        const existing_migrations = localStorage.getItem(\"fs_migrations\");\r\n        if (!existing_migrations) {\r\n            localStorage.setItem(\"fs_migrations\", JSON.stringify({\r\n                string_to_array: false,\r\n                array_to_b64: false,\r\n            }));\r\n        }\r\n\r\n        const migrations = JSON.parse(localStorage.getItem(\"fs_migrations\"));\r\n\r\n        if (!migrations.string_to_array) {\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            migrate_old_string_fs(JSON.parse(localStorage.getItem(\"fs\")), true);\r\n        }\r\n\r\n        if (!migrations.array_to_b64) {\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            migrate_old_array_fs(JSON.parse(localStorage.getItem(\"fs\")));\r\n        }\r\n\r\n        // mark all migrations as done\r\n        migrations.string_to_array = true;\r\n        migrations.array_to_b64 = true;\r\n        localStorage.setItem(\"fs_migrations\", JSON.stringify(migrations));\r\n\r\n        // initialise root and home directory\r\n        this.make_dir(this._home).then(() => {\r\n            this._initialised = true;\r\n        }).catch((err) => {\r\n            console.error(\"Failed to create home directory:\", err);\r\n        });\r\n    }\r\n}\r\n\r\nconst migrate_old_string_fs = (state: object, is_outer = false) => {\r\n    // migration step: we used to use a string but now we use an array for files\r\n    // need to iterate DEEPLY into nested objects and convert string values to arrays\r\n    // (so recurse)\r\n    // TODO make iterative\r\n\r\n    for (const key of Object.keys(state)) {\r\n        if (typeof state[key] === \"object\" && !Array.isArray(state[key])) {\r\n            migrate_old_string_fs(state[key]);\r\n        } else if (typeof state[key] === \"string\") {\r\n            console.log(`Migration: converting ${key} to array`);\r\n            state[key] = state[key].split(\",\").map((x) => parseInt(x));\r\n        }\r\n    }\r\n\r\n    if (is_outer) {\r\n        // only save if we are at the outermost level\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n}\r\n\r\nconst migrate_old_array_fs = (state: object) => {\r\n    // migration step: we used to use an array for files but now we use base64 strings\r\n    // need to iterate DEEPLY into nested objects and convert array values to strings\r\n\r\n    // use a stack to avoid recursion limit issues\r\n    const stack = [state];\r\n\r\n    while (stack.length > 0) {\r\n        // get the next object to process\r\n        const current_obj = stack.pop();\r\n\r\n        if (current_obj === null || typeof current_obj !== \"object\" || Array.isArray(current_obj)) {\r\n            continue;\r\n        }\r\n\r\n        // iterate over the keys of the current object\r\n        for (const key of Object.keys(current_obj)) {\r\n            const value = current_obj[key];\r\n\r\n            if (!value) {\r\n                continue;\r\n            } else if (typeof value === \"object\" && !Array.isArray(value)) {\r\n                // if the value is a nested object, add it to the stack to be processed later (depth first)\r\n                stack.push(value);\r\n            } else if (Array.isArray(value)) {\r\n                console.log(`Migration: converting ${key} to b64 string`);\r\n\r\n                try {\r\n                    const values = value.map((x: string) => parseInt(x));\r\n                    const uint = new Uint8Array(values);\r\n                    // uint.toBase64() isnt mainstream yet\r\n                    current_obj[key] = btoa(String.fromCharCode.apply(null, uint));\r\n                } catch (e) {\r\n                    console.error(`Migration failed for key \"${key}\":`, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // only save after the whole traversal\r\n    localStorage.setItem(\"fs\", JSON.stringify(state));\r\n}\r\n","import {\r\n    AbstractFileSystem,\r\n    MoveDestinationDirectoryNotEmptyError,\r\n    NonRecursiveDirectoryError,\r\n    PathNotFoundError\r\n} from \"../kernel/filesystem\";\r\n\r\nexport class OPFSFileSystem extends AbstractFileSystem {\r\n    private _opfs_handle: FileSystemDirectoryHandle | null = null;\r\n\r\n    get_unique_fs_type_name(): string {\r\n        return \"opfs\";\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        if (!localStorage.getItem(\"fs_readonly_paths\")) {\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify([]));\r\n        }\r\n\r\n        // get the root directory handle\r\n        navigator.storage.getDirectory().then((handle) => {\r\n            this._opfs_handle = handle;\r\n            this._initialised = true;\r\n        }).catch((err) => {\r\n            console.error(\"Failed to get OPFS directory handle:\", err);\r\n        });\r\n    }\r\n\r\n    async is_ready() {\r\n        return this._opfs_handle !== null;\r\n    }\r\n\r\n    private get_root_handle(): FileSystemDirectoryHandle {\r\n        if (!this._opfs_handle) {\r\n            throw new Error(\"OPFS directory handle is not initialised.\");\r\n        }\r\n\r\n        return this._opfs_handle;\r\n    }\r\n\r\n    async make_dir(path: string) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            current_handle = await current_handle.getDirectoryHandle(part, { create: true });\r\n        }\r\n    }\r\n\r\n    async dir_exists(path: string): Promise<boolean> {\r\n        // should return true only for directories\r\n\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(part);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && (err.name === \"NotFoundError\" || err.name === \"TypeMismatchError\")) {\r\n                    return false;\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async exists_direct(path: string) {\r\n        // should return true for both files and directories\r\n\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(part);\r\n            } catch (err) {\r\n                try {\r\n                    await current_handle.getFileHandle(part);\r\n                    return true;\r\n                } catch (err2) {\r\n                    if (err2 instanceof DOMException && err2.name === \"NotFoundError\") {\r\n                        return false;\r\n                    }\r\n                    throw err2;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async delete_dir_direct(path: string, recursive: boolean) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        try {\r\n            // recurse into directories\r\n            let current_handle = root;\r\n            for (let i = 0; i < parts.length - 1; i++) {\r\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\r\n            }\r\n\r\n            await current_handle.removeEntry(parts[parts.length - 1], { recursive });\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n\r\n            if (err instanceof DOMException && err.name === \"InvalidModificationError\" && !recursive) {\r\n                throw new NonRecursiveDirectoryError(path);\r\n            }\r\n\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    async list_dir(path: string) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(part);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        const entries: string[] = [];\r\n        for await (const [name, handle] of current_handle.entries()) {\r\n            entries.push(name);\r\n        }\r\n\r\n        return entries;\r\n    }\r\n\r\n    async is_readonly_direct(path: string) {\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\") || \"[]\");\r\n        return readonly_list.includes(path);\r\n    }\r\n\r\n    async set_readonly_direct(path: string, readonly: boolean) {\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\") || \"[]\");\r\n\r\n        if (readonly) {\r\n            if (!readonly_list.includes(path)) {\r\n                readonly_list.push(path);\r\n            }\r\n        } else {\r\n            if (readonly_list.includes(path)) {\r\n                readonly_list.splice(readonly_list.indexOf(path), 1);\r\n            }\r\n        }\r\n\r\n        localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n    }\r\n\r\n    async move_dir_direct(src: string, dest: string, force_move_inside: boolean) {\r\n        const root = this.get_root_handle();\r\n\r\n        // using unix style rules, i.e\r\n        // mv dir1 dir2 ->\r\n        // (if dir2 exists or force_move_inside) move dir1 into dir2\r\n        // (if dir2 doesn't exist) rename dir1 to dir2\r\n        // fail if dir2 exists and dir2/dir1 already exists\r\n\r\n        const src_parts = src.split(\"/\").filter(part => part.length > 0);\r\n        const dest_parts = dest.split(\"/\").filter(part => part.length > 0);\r\n\r\n        const src_basename = src_parts[src_parts.length - 1];\r\n        const dest_basename = dest_parts[dest_parts.length - 1];\r\n\r\n        // get handle for source's parent and source directory\r\n        let src_parent_handle = root;\r\n        for (let i = 0; i < src_parts.length - 1; i++) {\r\n            try {\r\n                src_parent_handle = await src_parent_handle.getDirectoryHandle(src_parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(src);\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        let src_handle: FileSystemDirectoryHandle;\r\n        try {\r\n            src_handle = await src_parent_handle.getDirectoryHandle(src_basename);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(src);\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        // get handle for destination's parent and try to get destination directory (but not an error yet if it doesn't exist)\r\n        let dest_parent_handle = root;\r\n        for (let i = 0; i < dest_parts.length - 1; i++) {\r\n            try {\r\n                dest_parent_handle = await dest_parent_handle.getDirectoryHandle(dest_parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(dest);\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        let dest_handle: FileSystemDirectoryHandle | null = null;\r\n        try {\r\n            dest_handle = await dest_parent_handle.getDirectoryHandle(dest_basename);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name !== \"NotFoundError\") {\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        // apply the rules to determine final destination\r\n        let final_dest_parent_handle: FileSystemDirectoryHandle;\r\n        let final_dest_name: string;\r\n\r\n        if (dest_handle || force_move_inside) {\r\n            // if destination already exists or force_move_inside is true, move source inside destination\r\n\r\n            if (!dest_handle) {\r\n                throw new PathNotFoundError(dest);\r\n            }\r\n\r\n            final_dest_parent_handle = dest_handle;\r\n            final_dest_name = src_basename;\r\n        } else {\r\n            // rename source to destination\r\n\r\n            final_dest_parent_handle = dest_parent_handle;\r\n            final_dest_name = dest_basename;\r\n        }\r\n\r\n        // ensure destination is empty\r\n        try {\r\n            await final_dest_parent_handle.getDirectoryHandle(final_dest_name);\r\n            throw new MoveDestinationDirectoryNotEmptyError(dest);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name !== \"NotFoundError\") {\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        // perform move, first check if the browser supports handle.move, and if not recursively copy and delete\r\n        if (\"move\" in src_handle) {\r\n            // @ts-ignore - not part of spec yet\r\n            await src_handle.move(final_dest_parent_handle, final_dest_name);\r\n        } else {\r\n            // copy recursively\r\n            const new_dest_handle = await final_dest_parent_handle.getDirectoryHandle(final_dest_name, { create: true });\r\n            await this.#copy_directory_recursive(src_handle, new_dest_handle);\r\n\r\n            // delete source directory\r\n            await src_parent_handle.removeEntry(src_basename, { recursive: true });\r\n        }\r\n    }\r\n\r\n    async #copy_directory_recursive(src_handle: FileSystemDirectoryHandle, dest_handle: FileSystemDirectoryHandle) {\r\n        for await (const [name, handle] of src_handle.entries()) {\r\n            if (handle.kind === \"file\") {\r\n                const file_handle = await src_handle.getFileHandle(name);\r\n                const file = await file_handle.getFile();\r\n                const array_buffer = await file.arrayBuffer();\r\n                const dest_file_handle = await dest_handle.getFileHandle(name, { create: true });\r\n                const writable = await dest_file_handle.createWritable();\r\n                await writable.write(array_buffer);\r\n                await writable.close();\r\n            } else if (handle.kind === \"directory\") {\r\n                const src_subdir_handle = await src_handle.getDirectoryHandle(name);\r\n                const dest_subdir_handle = await dest_handle.getDirectoryHandle(name, { create: true });\r\n                await this.#copy_directory_recursive(src_subdir_handle, dest_subdir_handle);\r\n            }\r\n        }\r\n    }\r\n\r\n    async read_file_direct(path: string, as_uint: boolean) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        // recurse into directories\r\n        let current_handle = root;\r\n        for (let i = 0; i < parts.length - 1; i++) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        let file_handle: FileSystemFileHandle;\r\n        try {\r\n            file_handle = await current_handle.getFileHandle(parts[parts.length - 1]);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        const file = await file_handle.getFile();\r\n        const array_buffer = await file.arrayBuffer();\r\n\r\n        if (as_uint) {\r\n            return new Uint8Array(array_buffer);\r\n        } else {\r\n            const decoder = new TextDecoder();\r\n            return decoder.decode(array_buffer);\r\n        }\r\n    }\r\n\r\n    async write_file_direct(path: string, data: string | Uint8Array) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n        \r\n        // recurse into directories\r\n        let current_handle = root;\r\n        for (let i = 0; i < parts.length - 1; i++) {\r\n            current_handle = await current_handle.getDirectoryHandle(parts[i], { create: true });\r\n        }\r\n\r\n        const file_handle = await current_handle.getFileHandle(parts[parts.length - 1], { create: true });\r\n        const writable = await file_handle.createWritable();\r\n\r\n        const data_to_write = (data instanceof Uint8Array) ? data : new TextEncoder().encode(data);\r\n\r\n        await writable.write(data_to_write.buffer as ArrayBuffer);\r\n        await writable.close();\r\n    }\r\n\r\n    async delete_file_direct(path: string) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        // recurse into directories\r\n        let current_handle = root;\r\n        for (let i = 0; i < parts.length - 1; i++) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        try {\r\n            await current_handle.removeEntry(parts[parts.length - 1]);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        // remove from readonly list if it is there\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        if (readonly_list.includes(path)) {\r\n            readonly_list.splice(readonly_list.indexOf(path), 1);\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n        }\r\n    }\r\n\r\n    async move_file_direct(src: string, dest: string) {\r\n        const root = this.get_root_handle();\r\n        const src_parts = src.split(\"/\").filter(part => part.length > 0);\r\n        const dest_parts = dest.split(\"/\").filter(part => part.length > 0);\r\n\r\n        // get source file handle\r\n        let current_handle = root;\r\n        for (let i = 0; i < src_parts.length - 1; i++) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(src_parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(src);\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        let file_handle: FileSystemFileHandle;\r\n        try {\r\n            file_handle = await current_handle.getFileHandle(src_parts[src_parts.length - 1]);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(src);\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        const file = await file_handle.getFile();\r\n        const array_buffer = await file.arrayBuffer();\r\n\r\n        // write to destination\r\n        current_handle = root;\r\n        for (let i = 0; i < dest_parts.length - 1; i++) {\r\n            current_handle = await current_handle.getDirectoryHandle(dest_parts[i], { create: true });\r\n        }\r\n\r\n        const dest_file_handle = await current_handle.getFileHandle(dest_parts[dest_parts.length - 1], { create: true });\r\n        const writable = await dest_file_handle.createWritable();\r\n        await writable.write(array_buffer);\r\n        await writable.close();\r\n\r\n        // delete source file\r\n        await this.delete_file_direct(src);\r\n    }\r\n\r\n    async erase_all() {\r\n        const root = this.get_root_handle();\r\n\r\n        for await (const [name, handle] of root.entries()) {\r\n            if (handle.kind === \"file\") {\r\n                await root.removeEntry(name);\r\n            } else if (handle.kind === \"directory\") {\r\n                await root.removeEntry(name, { recursive: true });\r\n            }\r\n        }\r\n\r\n        localStorage.removeItem(\"fs_readonly_paths\");\r\n    }\r\n}\r\n\r\n// TODO: emit events\r\n","import { AbstractFileSystem } from \"./kernel/filesystem\";\r\nimport { ANSI, NEWLINE } from \"./kernel/term_ctl\";\r\n\r\nconst setup_boot = async (fs: AbstractFileSystem) => {\r\n    // create boot directory if it doesn't exist\r\n    const absolute_boot = fs.absolute(\"/boot\");\r\n    if (!(await fs.dir_exists(absolute_boot))) {\r\n        await fs.make_dir(absolute_boot);\r\n    }\r\n\r\n    // create init file if it doesn't exist\r\n    const init_content = \"ignition\";\r\n    const absolute_init = fs.absolute(\"/boot/init\");\r\n    if (!(await fs.exists(absolute_init))) {\r\n        await fs.write_file(absolute_init, init_content);\r\n    }\r\n\r\n    // create etc directory if it doesn't exist\r\n    const absolute_etc = fs.absolute(\"/etc\");\r\n    if (!(await fs.dir_exists(absolute_etc))) {\r\n        await fs.make_dir(absolute_etc);\r\n    }\r\n\r\n    // create boot_target file if it doesn't exist\r\n    const boot_target_content = \"jetty\";\r\n    const absolute_boot_target = fs.absolute(\"/etc/boot_target\");\r\n    if (!(await fs.exists(absolute_boot_target))) {\r\n        await fs.write_file(absolute_boot_target, boot_target_content);\r\n    }\r\n\r\n    // create default_shell file if it doesn't exist\r\n    const default_shell_content = \"ash --login\";\r\n    const absolute_default_shell = fs.absolute(\"/etc/default_shell\");\r\n    if (!(await fs.exists(absolute_default_shell))) {\r\n        await fs.write_file(absolute_default_shell, default_shell_content);\r\n    }\r\n\r\n    // create sys directory if it doesn't exist\r\n    const absolute_sys = fs.absolute(\"/sys\");\r\n    if (!(await fs.dir_exists(absolute_sys))) {\r\n        await fs.make_dir(absolute_sys);\r\n    }\r\n\r\n    // create privilege_agent file if it doesn't exist\r\n    const privilege_agent_content = \"default_privilege_agent\";\r\n    const absolute_privilege_agent = fs.absolute(\"/sys/privilege_agent\");\r\n    if (!(await fs.exists(absolute_privilege_agent))) {\r\n        await fs.write_file(absolute_privilege_agent, privilege_agent_content);\r\n    }\r\n}\r\n\r\nconst setup_motd = async (fs: AbstractFileSystem) => {\r\n    // create etc directory if it doesn't exist\r\n    const absolute_etc = fs.absolute(\"/etc\");\r\n    if (!(await fs.dir_exists(absolute_etc))) {\r\n        await fs.make_dir(absolute_etc);\r\n    }\r\n\r\n    // create motd file if it doesn't exist\r\n    const motd_content = ` Welcome to ${ANSI.STYLE.italic + ANSI.STYLE.bold + ANSI.FG.magenta}OllieOS...${ANSI.STYLE.reset_all} \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}help${ANSI.STYLE.no_italic + ANSI.FG.blue} for a list of commands.${ANSI.STYLE.reset_all}        \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}mefetch${ANSI.STYLE.no_italic + ANSI.FG.blue} for info about me.${ANSI.STYLE.reset_all}          \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}cd projects${ANSI.STYLE.no_italic + ANSI.FG.blue} to view project info.${ANSI.STYLE.reset_all}   \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}bugreport${ANSI.STYLE.no_italic + ANSI.FG.blue} to open the bug reporter.${ANSI.STYLE.reset_all} \r\n`.replace(/\\n/g, NEWLINE);\r\n\r\n    const absolute_motd = fs.absolute(\"/etc/motd.txt\");\r\n    if (!(await fs.exists(absolute_motd))) {\r\n        await fs.write_file(absolute_motd, motd_content);\r\n    }\r\n};\r\n\r\nconst migrate_rc_profile = async (fs: AbstractFileSystem) => {\r\n    // if .ollie_profile exists, and .ash_profile doesn't, rename it to .ash_profile\r\n    const absolute_ollie_profile = fs.absolute(\"~/.ollie_profile\");\r\n    const absolute_ash_profile = fs.absolute(\"~/.ash_profile\");\r\n    if (await fs.exists(absolute_ollie_profile) && !(await fs.exists(absolute_ash_profile))) {\r\n        await fs.move_file(absolute_ollie_profile, absolute_ash_profile);\r\n    }\r\n\r\n    // if .ollierc exists, and .ashrc doesn't, rename it to .ashrc\r\n    const absolute_ollierc = fs.absolute(\"~/.ollierc\");\r\n    const absolute_ashrc = fs.absolute(\"~/.ashrc\");\r\n    if (await fs.exists(absolute_ollierc) && !(await fs.exists(absolute_ashrc))) {\r\n        await fs.move_file(absolute_ollierc, absolute_ashrc);\r\n    }\r\n};\r\n\r\nconst setup_credits = async (fs: AbstractFileSystem) => {\r\n    // create credits file\r\n    const credits_content = `\r\nCredits\r\n=======\r\n\r\nThis website was created by obfuscatedgenerated using the following technologies:\r\n\r\n- TypeScript\r\n- xterm.js\r\n- Handlebars.js\r\n- Webpack\r\n\r\nAs well as the following libraries:\r\n\r\n- imgToAscii (modified)\r\n- node-sixel\r\n- @xterm/addon-fit\r\n- @xterm/addon-web-links\r\n- @xterm/addon-image\r\n- xterm-link-provider\r\n- howler.js\r\n- html-to-text\r\n- some code from rss-parser (modified)\r\n\r\nPlease consult https://ollieg.codes/public/script/3rdpartylicenses.txt for full license information.\r\n\r\nAdditionally, fsedit uses:\r\n\r\n- Font Awesome\r\n\r\nThe source code is available on GitHub at https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io.\r\n`.replace(/\\n/g, NEWLINE);\r\n\r\n    // only overwrite the file if it doesn't exist or the content is different\r\n    const absolute_credits = fs.absolute(\"~/credits.txt\");\r\n    if (!(await fs.exists(absolute_credits)) || await fs.read_file(absolute_credits) !== credits_content) {\r\n        await fs.write_file(absolute_credits, credits_content, true);\r\n        await fs.set_readonly(absolute_credits, true);\r\n    }\r\n};\r\n\r\n// syncs the data repository from the data service (data.ollieg.codes)\r\nconst setup_data_repo = async (fs: AbstractFileSystem) => {\r\n    console.log(\"Syncing data repository...\");\r\n\r\n    // check if data dir exists locally\r\n    const data_dir = fs.absolute(\"/var/lib/data\");\r\n    let existing_rev = \"\";\r\n    if (!(await fs.dir_exists(data_dir))) {\r\n        await fs.make_dir(data_dir);\r\n    } else {\r\n        // read the existing revision from version.json\r\n        const version_file = fs.join(data_dir, \"version.json\");\r\n        if (await fs.exists(version_file)) {\r\n            const version_data = JSON.parse(await fs.read_file(version_file) as string);\r\n            existing_rev = version_data.rev;\r\n        }\r\n    }\r\n\r\n    try {\r\n        // fetch the latest revision from the data service\r\n        const svc_version = await fetch(\"https://data.ollieg.codes/version.json\").then(res => res.json());\r\n        const latest_rev = svc_version.rev;\r\n\r\n        // if the revisions match, no need to update\r\n        if (existing_rev === latest_rev) {\r\n            console.log(\"Data repository is already up to date.\");\r\n            return;\r\n        }\r\n\r\n        // back up existing data folder\r\n        const possible_backup_dir = fs.absolute(`/var/lib/.data.old_${existing_rev}`);\r\n        if (existing_rev) {\r\n            await fs.move_dir(data_dir, possible_backup_dir);\r\n            await fs.make_dir(data_dir);\r\n        }\r\n\r\n        // fetch the index file\r\n        const index = await fetch(\"https://data.ollieg.codes/index.json\").then(res => res.json());\r\n\r\n        // check if the index file has the optional \"groups\" field\r\n        if (!index.groups) {\r\n            throw new Error(\"Index file is missing 'groups' field.\");\r\n        }\r\n\r\n        // write the index and version file to the data folder\r\n        await fs.write_file(fs.join(data_dir, \"index.json\"), JSON.stringify(index, null, 2), true);\r\n        await fs.write_file(fs.join(data_dir, \"version.json\"), JSON.stringify(svc_version, null, 2), true);\r\n\r\n        // for each group, fetch the index and then fetch each file listed in its index\r\n        for (const group of index.groups) {\r\n            console.log(`Syncing data group: ${group}`);\r\n\r\n            // ensure the group directory exists\r\n            const group_dir = fs.join(data_dir, group);\r\n            if (!(await fs.dir_exists(group_dir))) {\r\n                await fs.make_dir(group_dir);\r\n            }\r\n\r\n            // fetch the group index\r\n            const group_index = await fetch(`https://data.ollieg.codes/${group}/index.json`).then(res => res.json());\r\n\r\n            // ensure the group index is an array\r\n            if (!Array.isArray(group_index)) {\r\n                throw new Error(`Group index for ${group} is not an array.`);\r\n            }\r\n\r\n            // write the group index to the group folder\r\n            await fs.write_file(fs.join(group_dir, \"index.json\"), JSON.stringify(group_index, null, 2), true);\r\n\r\n            // for each file in the group index, fetch the file and write it to the data folder\r\n            for (const entry of group_index) {\r\n                console.log(`  Fetching file: ${entry}.json`);\r\n\r\n                const file_data = await fetch(`https://data.ollieg.codes/${group}/${entry}.json`).then(res => res.text());\r\n                const file_path = fs.join(group_dir, `${entry}.json`);\r\n\r\n                await fs.write_file(file_path, file_data, true);\r\n            }\r\n        }\r\n\r\n        console.log(\"Data repository synced successfully.\");\r\n\r\n        // delete backup if exists\r\n        if (await fs.dir_exists(possible_backup_dir)) {\r\n            await fs.delete_dir(possible_backup_dir, true);\r\n        }\r\n\r\n        // return new rev\r\n        return latest_rev;\r\n    } catch (e) {\r\n        console.error(\"Failed to sync data repository:\");\r\n        console.error(e);\r\n\r\n        // restore backup if exists\r\n        const possible_backup_dir = fs.absolute(`/var/lib/.data.old_${existing_rev}`);\r\n        if (await fs.dir_exists(possible_backup_dir)) {\r\n            console.error(\"Restoring backup...\");\r\n            await fs.move_dir(data_dir, fs.absolute(\"/var/lib/data.discard\"));\r\n            await fs.move_dir(possible_backup_dir, data_dir);\r\n            await fs.delete_dir(fs.absolute(\"/var/lib/data.discard\"), true);\r\n        } else {\r\n            // just delete the data dir in progress to prevent partial data\r\n            await fs.delete_dir(data_dir, true);\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nconst fetch_file_with_ttl = async (url: string, skip_cache: boolean) => {\r\n    // check if url exists in TTL cache\r\n    const ttl_cache = localStorage.getItem(\"fetch_ttl_cache\");\r\n    const ttl_cache_obj = ttl_cache ? JSON.parse(ttl_cache) : {};\r\n\r\n    // if the url's TTL hasn't expired, don't fetch the file\r\n    // saves time acquiring heavy files at startup whilst still allowing for updates at some point\r\n    if (!skip_cache && ttl_cache_obj[url]) {\r\n        if (ttl_cache_obj[url] > Date.now()) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // fetch the file and convert it to a Uint8Array\r\n    const response = await fetch(url);\r\n    const array_buffer = await response.arrayBuffer();\r\n\r\n    // add the url to the TTL cache\r\n    ttl_cache_obj[url] = Date.now() + 1000 * 60 * 60 * 24 * 7; // 1 week\r\n    localStorage.setItem(\"fetch_ttl_cache\", JSON.stringify(ttl_cache_obj));\r\n\r\n    return new Uint8Array(array_buffer);\r\n};\r\n\r\nconst generate_project_folder = async (fs: AbstractFileSystem, base_dir: string, data_projects_dir: string, project_entry: string, project_data: any = null): Promise<boolean> => {\r\n    console.log(`Generating project folder for ${project_entry}...`);\r\n\r\n    const project_dir = fs.join(base_dir, project_entry);\r\n    await fs.make_dir(project_dir);\r\n\r\n    // generate info.txt\r\n    const info_content = `\r\n${project_data.name}\r\n=${\"=\".repeat(project_data.name.length)}\r\n\r\n${project_data.primary_language ? `Primary Language: ${project_data.primary_language}\\n\\n` : \"\"}${project_data.description}\r\n${project_data.live_url ? `\\nLive URL: ${project_data.live_url}` : \"\"}${project_data.repo_url ? `\\nRepository: ${project_data.repo_url}` : \"\"}\r\n`.replace(/\\n/g, NEWLINE).trim();\r\n\r\n    await fs.write_file(fs.join(project_dir, \"info.txt\"), NEWLINE + info_content + NEWLINE, true);\r\n\r\n    // download image with ttl if defined\r\n    // not a fatal failure so don't return false on failure\r\n    if (project_data.image) {\r\n        const file_ext_regex = /\\.([a-zA-Z0-9]+)(?:\\?|$)/;\r\n        const match = project_data.image.match(file_ext_regex);\r\n\r\n        // if theres no file extension, default to png bc why not :)\r\n        const image_ext = match ? match[1] : \"png\";\r\n        if (image_ext) {\r\n            const absolute_file = fs.join(project_dir, `image.${image_ext}`);\r\n            let content: Uint8Array | null;\r\n\r\n            try {\r\n                // if the file doesn't exist, skip the TTL cache\r\n                const skip_cache = !(await fs.exists(absolute_file));\r\n\r\n                // fetch the file if TTL cache is expired or doesn't exist\r\n                content = await fetch_file_with_ttl(project_data.image, skip_cache);\r\n\r\n                // write the file if content is not null\r\n                if (content) {\r\n                    await fs.write_file(absolute_file, content, true);\r\n                }\r\n            } catch (e) {\r\n                console.error(`Failed to fetch image for project ${project_entry}:`);\r\n                console.error(e);\r\n            }\r\n        } else {\r\n            console.warn(`Project image for ${project_entry} has unsupported file extension; skipping image.`);\r\n        }\r\n    }\r\n\r\n    console.log(`Project folder for ${project_entry} generated successfully.`);\r\n\r\n    // recurse for sub_projects\r\n    if (project_data.sub_projects && Array.isArray(project_data.sub_projects)) {\r\n        for (const sub_project_entry of project_data.sub_projects) {\r\n            const success = await generate_project_folder(fs, project_dir, data_projects_dir, sub_project_entry.name, sub_project_entry);\r\n            if (!success) {\r\n                console.error(`Failed to generate sub-project folder for ${sub_project_entry}`);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nconst setup_projects = async (fs: AbstractFileSystem, data_rev: string | null) => {\r\n    // if data_rev is null, try read it from the data repo\r\n    if (!data_rev) {\r\n        try {\r\n            const version_file = fs.absolute(\"/var/lib/data/version.json\");\r\n            if (await fs.exists(version_file)) {\r\n                const version_data = JSON.parse(await fs.read_file(version_file) as string);\r\n                data_rev = version_data.rev;\r\n            } else {\r\n                throw new Error(\"Version file does not exist.\");\r\n            }\r\n        } catch (e) {\r\n            console.error(\"Failed to read data revision from data repository:\");\r\n            console.error(e);\r\n            data_rev = null;\r\n        }\r\n    }\r\n\r\n    // if data rev is still null, skip project setup\r\n    if (!data_rev) {\r\n        console.warn(\"Data repo not synced; skipping project setup.\");\r\n        return;\r\n    }\r\n\r\n    // create projects directory if it doesn't exist\r\n    const absolute_projects = fs.absolute(\"~/projects\");\r\n    let project_rev = \"\";\r\n    if (!(await fs.dir_exists(absolute_projects))) {\r\n        await fs.make_dir(absolute_projects);\r\n    } else {\r\n        // read the existing revision from the hidden .rev file\r\n        const version_file = fs.join(absolute_projects, \".rev\");\r\n        if (await fs.exists(version_file)) {\r\n            project_rev = await fs.read_file(version_file) as string;\r\n        }\r\n    }\r\n\r\n    // if the revisions match, no need to update\r\n    if (project_rev === data_rev) {\r\n        console.log(\"Projects are already up to date.\");\r\n        return;\r\n    }\r\n\r\n    // back up existing projects folder\r\n    const possible_backup_dir = fs.absolute(`~/.projects.old_${project_rev}`);\r\n    if (project_rev) {\r\n        await fs.move_dir(absolute_projects, possible_backup_dir);\r\n        await fs.make_dir(absolute_projects);\r\n    }\r\n\r\n    try {\r\n        // for each project in the data repo, convert the json to the file structure in the projects folder\r\n        const data_projects_dir = fs.absolute(\"/var/lib/data/project\");\r\n        const project_index_file = fs.join(data_projects_dir, \"index.json\");\r\n\r\n        if (!(await fs.exists(project_index_file))) {\r\n            throw new Error(\"Project index file does not exist in data repository.\");\r\n        }\r\n\r\n        const projects = JSON.parse(await fs.read_file(project_index_file) as string);\r\n        if (!Array.isArray(projects)) {\r\n            throw new Error(\"Project index file is not an array.\");\r\n        }\r\n\r\n        for (const project_entry of projects) {\r\n            console.log(`Setting up project: ${project_entry}`);\r\n\r\n            const project_file = fs.join(data_projects_dir, `${project_entry}.json`);\r\n            if (!(await fs.exists(project_file))) {\r\n                console.warn(`Project file for ${project_entry} does not exist; skipping.`);\r\n                return false;\r\n            }\r\n\r\n            const project_data = JSON.parse(await fs.read_file(project_file) as string);\r\n\r\n            const success = await generate_project_folder(fs, absolute_projects, data_projects_dir, project_entry, project_data);\r\n            if (!success) {\r\n                // TODO: is it better to still keep partial data or throw an error?\r\n                throw new Error(`Failed to generate project folder for ${project_entry}`);\r\n            }\r\n        }\r\n\r\n        // write the new revision to the hidden .rev file\r\n        const version_file = fs.join(absolute_projects, \".rev\");\r\n        await fs.write_file(version_file, data_rev, true);\r\n\r\n        console.log(\"Projects set up successfully.\");\r\n    } catch (e) {\r\n        console.error(\"Failed to set up projects:\");\r\n        console.error(e);\r\n\r\n        // restore backup if exists\r\n        if (await fs.dir_exists(possible_backup_dir)) {\r\n            console.error(\"Restoring backup...\");\r\n            await fs.move_dir(absolute_projects, fs.absolute(\"~/projects.discard\"));\r\n            await fs.move_dir(possible_backup_dir, absolute_projects);\r\n            await fs.delete_dir(fs.absolute(\"~/projects.discard\"), true);\r\n        } else {\r\n            // just delete the projects dir in progress to prevent partial data\r\n            await fs.delete_dir(absolute_projects, true);\r\n        }\r\n\r\n        return;\r\n    }\r\n};\r\n\r\nexport const initial_fs_setup = async (fs: AbstractFileSystem) => {\r\n    await setup_boot(fs);\r\n    await setup_motd(fs);\r\n    await migrate_rc_profile(fs);\r\n    await setup_credits(fs);\r\n\r\n\r\n    const latest_rev = await setup_data_repo(fs);\r\n    await setup_projects(fs, latest_rev);\r\n};\r\n","export type WindowEvent = \"close\" | \"hide\" | \"show\" | \"focus\" | \"move\" | \"rename\" | \"resize\" | \"maximise\" | \"restore\";\r\n\r\nexport interface UserspaceOtherWindow {\r\n    readonly id: number;\r\n    readonly manager: UserspaceWindowManager;\r\n    readonly owner_pid: number;\r\n\r\n    readonly title: string;\r\n    readonly width: string;\r\n    readonly height: string;\r\n    readonly x: string | number;\r\n    readonly y: string | number;\r\n    readonly visible: boolean;\r\n    readonly maximised: boolean;\r\n}\r\n\r\nexport interface UserspaceWindow extends UserspaceOtherWindow {\r\n    readonly manager: UserspaceWindowManager;\r\n    readonly dom: ShadowRoot;\r\n\r\n    title: string;\r\n    width: string;\r\n    height: string;\r\n    x: string | number;\r\n    y: string | number;\r\n\r\n    visible: boolean;\r\n    maximised: boolean;\r\n\r\n    center(): void;\r\n    focus(): void;\r\n    show(): void;\r\n    hide(): void;\r\n    toggle(): void;\r\n    close(): void;\r\n\r\n    add_event_listener(event: WindowEvent, callback: () => void): void;\r\n    wait_for_event(event: WindowEvent): Promise<void>;\r\n}\r\n\r\nexport abstract class AbstractWindow {\r\n    abstract readonly id: number;\r\n\r\n    // TODO: more generic type somehow? depends if we ever need implementations that dont use shadow DOM\r\n    abstract readonly dom: ShadowRoot;\r\n\r\n    abstract readonly manager: AbstractWindowManager;\r\n\r\n    abstract moveable: boolean;\r\n\r\n    abstract resizable: boolean;\r\n\r\n    abstract maximisable: boolean;\r\n    abstract maximised: boolean;\r\n\r\n    private readonly _owner_pid: number;\r\n\r\n    protected constructor(owner_pid: number) {\r\n        this._owner_pid = owner_pid;\r\n    }\r\n\r\n    get owner_pid(): number {\r\n        return this._owner_pid;\r\n    }\r\n\r\n    abstract get title(): string;\r\n    abstract set title(new_title: string);\r\n\r\n    abstract get width(): string;\r\n    abstract set width(css_width: string);\r\n\r\n    abstract get height(): string;\r\n    abstract set height(css_height: string);\r\n\r\n    // number to be interpreted as pixels\r\n    abstract get x(): string | number;\r\n    abstract set x(css_pos: string | number);\r\n\r\n    // number to be interpreted as pixels\r\n    abstract get y(): string | number;\r\n    abstract set y(css_pos: string | number);\r\n\r\n    abstract center(): void;\r\n\r\n    abstract get visible(): boolean;\r\n    abstract set visible(is_visible: boolean);\r\n\r\n    abstract add_event_listener(event: WindowEvent, callback: () => Promise<void> | void): void;\r\n\r\n    abstract remove_event_listener(event: WindowEvent, callback: () => Promise<void> | void): void;\r\n\r\n    abstract dispose(): void;\r\n\r\n    abstract close(): void;\r\n\r\n    abstract focus(): void;\r\n\r\n    abstract show(): void;\r\n    abstract hide(): void;\r\n    abstract toggle(): void;\r\n\r\n    // best effort flags, may not be supported by all implementations (e.g. transparent flag)\r\n    abstract get_custom_flag(flag: string): boolean;\r\n    abstract set_custom_flag(flag: string, value: boolean): void;\r\n\r\n    abstract wait_for_event(event: WindowEvent): Promise<void>;\r\n\r\n    create_userspace_proxy_as_other_window(): UserspaceOtherWindow {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        Object.defineProperties(proxy, {\r\n            id: { get: () => self.id, enumerable: true },\r\n            manager: { get: () => self.manager.create_userspace_proxy(), enumerable: true },\r\n            owner_pid: { get: () => self.owner_pid, enumerable: true },\r\n            title: { get: () => self.title, enumerable: true },\r\n            width: { get: () => self.width, enumerable: true },\r\n            height: { get: () => self.height, enumerable: true },\r\n            x: { get: () => self.x, enumerable: true },\r\n            y: { get: () => self.y, enumerable: true },\r\n            visible: { get: () => self.visible, enumerable: true },\r\n            maximised: { get: () => self.maximised, enumerable: true }\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n\r\n    create_userspace_proxy_as_full_window(): UserspaceWindow {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        const manager_proxy = self.manager.create_userspace_proxy();\r\n\r\n        Object.defineProperties(proxy, {\r\n            id: { get: () => self.id, enumerable: true },\r\n            manager: { get: () => manager_proxy, enumerable: true },\r\n            owner_pid: { get: () => self.owner_pid, enumerable: true },\r\n            dom: { get: () => self.dom, enumerable: true },\r\n            title: {\r\n                get: () => self.title,\r\n                set: (new_title: string) => { self.title = new_title; },\r\n                enumerable: true\r\n            },\r\n            width: {\r\n                get: () => self.width,\r\n                set: (css_width: string) => { self.width = css_width; },\r\n                enumerable: true\r\n            },\r\n            height: {\r\n                get: () => self.height,\r\n                set: (css_height: string) => { self.height = css_height; },\r\n                enumerable: true\r\n            },\r\n            x: {\r\n                get: () => self.x,\r\n                set: (css_pos: string | number) => { self.x = css_pos; },\r\n                enumerable: true\r\n            },\r\n            y: {\r\n                get: () => self.y,\r\n                set: (css_pos: string | number) => { self.y = css_pos; },\r\n                enumerable: true\r\n            },\r\n            visible: {\r\n                get: () => self.visible,\r\n                set: (is_visible: boolean) => { self.visible = is_visible; },\r\n                enumerable: true\r\n            },\r\n            maximised: { get: () => self.maximised, enumerable: true },\r\n            center: { value: () => { self.center(); }, enumerable: true },\r\n            focus: { value: () => { self.focus(); }, enumerable: true },\r\n            show: { value: () => { self.show(); }, enumerable: true },\r\n            hide: { value: () => { self.hide(); }, enumerable: true },\r\n            toggle: { value: () => { self.toggle(); }, enumerable: true },\r\n            close: { value: () => { self.close(); }, enumerable: true },\r\n            add_event_listener: { value: (event: WindowEvent, callback: () => void) => { self.add_event_listener(event, callback); }, enumerable: true },\r\n            wait_for_event: { value: (event: WindowEvent) => self.wait_for_event(event), enumerable: true }\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\nexport interface UserspaceWindowManager {\r\n    get_unique_manager_type_name(): string;\r\n    get_all_windows(): UserspaceOtherWindow[];\r\n    get_window_by_id(id: number): UserspaceOtherWindow | null;\r\n}\r\n\r\nexport abstract class AbstractWindowManager {\r\n    abstract get_unique_manager_type_name(): string;\r\n\r\n    abstract get Window(): new (owner_pid: number) => AbstractWindow;\r\n\r\n    abstract get_all_windows(): AbstractWindow[];\r\n\r\n    abstract get_window_by_id(id: number): AbstractWindow | null;\r\n\r\n    abstract dispose_all(): void;\r\n\r\n    create_userspace_proxy(): UserspaceWindowManager {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        Object.defineProperties(proxy, {\r\n            get_unique_manager_type_name: { value: () => self.get_unique_manager_type_name(), enumerable: true },\r\n            get_all_windows: {\r\n                value: () => self.get_all_windows().map((win) => win.create_userspace_proxy_as_other_window()),\r\n                enumerable: true\r\n            },\r\n            get_window_by_id: {\r\n                value: (id: number) => {\r\n                    const win = self.get_window_by_id(id);\r\n                    return win ? win.create_userspace_proxy_as_other_window() : null;\r\n                },\r\n                enumerable: true\r\n            }\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\n// TODO: use separate interfaces so that only the process registry can create windows\r\n","import {AbstractWindow, AbstractWindowManager, WindowEvent} from \"../kernel/windowing\";\r\n\r\nexport class DOMWindowManager extends AbstractWindowManager {\r\n    #top_z_index = 10;\r\n\r\n    #window_id_counter = 1;\r\n    readonly #window_map: Map<number, AbstractWindow> = new Map();\r\n\r\n    readonly #WindowClass: new (owner_pid: number) => AbstractWindow;\r\n\r\n    get_unique_manager_type_name(): string {\r\n        return \"DOM\";\r\n    }\r\n\r\n    get Window() {\r\n        return this.#WindowClass;\r\n    }\r\n\r\n    get_all_windows = () => {\r\n        return Array.from(this.#window_map.values());\r\n    }\r\n\r\n    get_window_by_id = (id: number) => {\r\n        return this.#window_map.get(id) || null;\r\n    }\r\n\r\n    dispose_all() {\r\n        for (const window of this.#window_map.values()) {\r\n            window.dispose();\r\n        }\r\n\r\n        this.#window_map.clear();\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const manager = this;\r\n\r\n        class DOMWindow extends AbstractWindow {\r\n            private readonly _manager = manager;\r\n\r\n            private readonly _window_id: number;\r\n\r\n            private readonly _window_root: HTMLDivElement;\r\n            private readonly _window_top_bar: HTMLDivElement;\r\n            private readonly _window_top_bar_title: HTMLSpanElement;\r\n            private readonly _window_top_bar_maximise_button: HTMLButtonElement;\r\n\r\n            private readonly _content_host: HTMLDivElement;\r\n            private readonly _shadow_dom: ShadowRoot;\r\n\r\n            private readonly _event_listeners: Map<WindowEvent, Array<() => Promise<void>>> = new Map();\r\n\r\n            private _title_text = \"New Window\";\r\n\r\n            moveable = true;\r\n            resizable = true;\r\n\r\n            private _maximisable = true;\r\n            private _maximised = false;\r\n\r\n            private readonly _custom_flags: Set<string> = new Set();\r\n\r\n            get manager() {\r\n                return this._manager;\r\n            }\r\n\r\n            constructor(owner_pid: number) {\r\n                super(owner_pid);\r\n\r\n                this._window_id = manager.#window_id_counter++;\r\n\r\n                // contains the entire window\r\n                this._window_root = document.createElement(\"div\");\r\n                this._window_root.classList.add(\"window\");\r\n                this._window_root.role = \"dialog\";\r\n                this._window_root.ariaHidden = \"true\";\r\n                this._window_root.id = `window-${this._window_id}`;\r\n                document.body.appendChild(this._window_root);\r\n\r\n                this._window_root.style.zIndex = manager.#top_z_index.toString();\r\n                this._window_root.addEventListener(\"mousedown\", () => this.focus(), { capture: true });\r\n                window.addEventListener(\"blur\", () => this._handle_window_blur());\r\n\r\n                // draggable top bar containing title and controls\r\n                this._window_top_bar = document.createElement(\"div\");\r\n                this._window_top_bar.classList.add(\"window-top-bar\");\r\n                this._window_root.appendChild(this._window_top_bar);\r\n\r\n                this._window_top_bar_title = document.createElement(\"span\");\r\n                this._window_top_bar_title.classList.add(\"window-top-bar-title\");\r\n                this._window_top_bar_title.innerText = this._title_text;\r\n                this._window_top_bar_title.id = `${this._window_root.id}-title`;\r\n                this._window_top_bar.appendChild(this._window_top_bar_title);\r\n                this._window_root.setAttribute(\"aria-labelledby\", this._window_top_bar_title.id);\r\n\r\n                const top_bar_controls = document.createElement(\"div\");\r\n                top_bar_controls.classList.add(\"window-top-bar-controls\");\r\n                top_bar_controls.addEventListener(\"mousedown\", (e) => e.stopPropagation());\r\n                this._window_top_bar.appendChild(top_bar_controls);\r\n\r\n                const minimise_button = document.createElement(\"button\");\r\n                minimise_button.title = \"Minimise window\";\r\n                minimise_button.classList.add(\"window-button\", \"window-minimise-button\");\r\n                minimise_button.innerText = \"\";\r\n                minimise_button.addEventListener(\"click\", () => this.hide());\r\n\r\n                this._window_top_bar_maximise_button = document.createElement(\"button\");\r\n                this._window_top_bar_maximise_button.title = \"Maximise window\";\r\n                this._window_top_bar_maximise_button.classList.add(\"window-button\", \"window-maximise-button\");\r\n                this._window_top_bar_maximise_button.innerText = \"\";\r\n                this._window_top_bar_maximise_button.addEventListener(\"click\", (ev) => {\r\n                    if (!this.maximisable) {\r\n                        return;\r\n                    }\r\n\r\n                    this.maximised = !this.maximised;\r\n                });\r\n\r\n                const close_button = document.createElement(\"button\");\r\n                close_button.title = \"Close window\";\r\n                close_button.classList.add(\"window-button\", \"window-close-button\");\r\n                close_button.innerText = \"\";\r\n                close_button.addEventListener(\"click\", this.close.bind(this));\r\n\r\n                top_bar_controls.appendChild(minimise_button);\r\n                top_bar_controls.appendChild(this._window_top_bar_maximise_button);\r\n                top_bar_controls.appendChild(close_button);\r\n\r\n                this._window_top_bar.addEventListener(\"mousedown\", (e) => this._start_drag(e));\r\n\r\n                // hosts the shadow dom where programs can add their content\r\n                this._content_host = document.createElement(\"div\");\r\n                this._content_host.classList.add(\"window-content-host\");\r\n\r\n                this._shadow_dom = this._content_host.attachShadow({ mode: \"closed\" });\r\n\r\n                this._window_root.appendChild(this._content_host);\r\n\r\n                // TODO: resize handles\r\n                // TODO: way to prevent windows existing when the program that created them exits? or is that not needed? theyll have to run background tasks to allow multitasking anyway\r\n\r\n                manager.#window_map.set(this._window_id, this);\r\n            }\r\n\r\n            get id() {\r\n                return this._window_id;\r\n            }\r\n\r\n            dispose() {\r\n                this._window_root.remove();\r\n                manager.#window_map.delete(this._window_id);\r\n            }\r\n\r\n            close() {\r\n                this._window_root.classList.add(\"animating-close\");\r\n                this._window_root.ariaHidden = \"true\";\r\n\r\n                this._emit_event(\"close\");\r\n\r\n                setTimeout(() => {\r\n                    this.dispose();\r\n                }, 200);\r\n            }\r\n\r\n            focus() {\r\n                this._emit_event(\"focus\");\r\n\r\n                manager.#top_z_index += 1;\r\n                this._window_root.style.zIndex = manager.#top_z_index.toString();\r\n            }\r\n\r\n            private _handle_window_blur() {\r\n                // TODO: fix for when focus jumps between iframes inside the window, this doesnt fire in that case\r\n\r\n                setTimeout(() => {\r\n                    if (document.activeElement === this._content_host) {\r\n                        this.focus();\r\n                    }\r\n                }, 0);\r\n            }\r\n\r\n            private async _emit_event(event: WindowEvent) {\r\n                if (!this._event_listeners.has(event)) {\r\n                    return;\r\n                }\r\n\r\n                const listeners = this._event_listeners.get(event)!;\r\n                await Promise.all(listeners.map(callback => callback()));\r\n            }\r\n\r\n            private _start_drag(start_event: MouseEvent) {\r\n                if (!this.moveable) {\r\n                    return;\r\n                }\r\n\r\n                this._content_host.classList.add(\"dragging\");\r\n\r\n                start_event.preventDefault();\r\n\r\n                const rect = this._window_root.getBoundingClientRect();\r\n                let offset_x = start_event.clientX - rect.left;\r\n                const offset_y = start_event.clientY - rect.top;\r\n\r\n                const mouse_move = (move_event: MouseEvent) => {\r\n                    move_event.preventDefault();\r\n\r\n                    if (this._maximised) {\r\n                        // break out of maximised, restoring size but not position\r\n                        this.maximised = false;\r\n\r\n                        // adjust offset_x to account for new window size\r\n                        const new_rect = this._window_root.getBoundingClientRect();\r\n                        const width_ratio = offset_x / rect.width;\r\n                        offset_x = new_rect.width * width_ratio;\r\n                    }\r\n\r\n                    this._window_root.style.left = `${move_event.clientX - offset_x}px`;\r\n                    this._window_root.style.top = `${move_event.clientY - offset_y}px`;\r\n\r\n                    this._emit_event(\"move\");\r\n                };\r\n\r\n                const mouse_up = (up_event: MouseEvent) => {\r\n                    document.removeEventListener(\"mousemove\", mouse_move);\r\n                    document.removeEventListener(\"mouseup\", mouse_up);\r\n\r\n                    this._content_host.classList.remove(\"dragging\");\r\n\r\n                    if (!this._maximised) {\r\n                        // if the mouse is at the top of the screen, maximise the window\r\n                        if (up_event.clientY <= 0 && this._maximisable) {\r\n                            this.maximised = true;\r\n                        }\r\n                    }\r\n\r\n                    // TODO: right and left side snapping to half the screen\r\n\r\n                    // if the rect is out of the top when released, snap it back in\r\n                    if (this._window_root.getBoundingClientRect().top < 0) {\r\n                        this._window_root.style.top = \"0px\";\r\n                    }\r\n                };\r\n\r\n                document.addEventListener(\"mousemove\", mouse_move);\r\n                document.addEventListener(\"mouseup\", mouse_up);\r\n            }\r\n\r\n            add_event_listener(event: WindowEvent, callback: () => Promise<void>) {\r\n                if (!this._event_listeners.has(event)) {\r\n                    this._event_listeners.set(event, []);\r\n                }\r\n\r\n                this._event_listeners.get(event)!.push(callback);\r\n            }\r\n\r\n            remove_event_listener(event: WindowEvent, callback: () => Promise<void>) {\r\n                if (!this._event_listeners.has(event)) {\r\n                    return;\r\n                }\r\n\r\n                const listeners = this._event_listeners.get(event)!;\r\n                const index = listeners.indexOf(callback);\r\n                if (index !== -1) {\r\n                    listeners.splice(index, 1);\r\n                }\r\n            }\r\n\r\n            get title() {\r\n                return this._title_text;\r\n            }\r\n\r\n            set title(new_title: string) {\r\n                this._window_top_bar_title.innerText = new_title;\r\n                this._title_text = new_title;\r\n\r\n                this._emit_event(\"rename\");\r\n            }\r\n\r\n            get width() {\r\n                return this._window_root.style.width;\r\n            }\r\n\r\n            set width(css_width: string) {\r\n                this._window_root.style.width = css_width;\r\n            }\r\n\r\n            get height() {\r\n                return this._window_root.style.height;\r\n            }\r\n\r\n            set height(css_height: string) {\r\n                this._window_root.style.height = css_height;\r\n            }\r\n\r\n            get maximisable() {\r\n                return this._maximisable;\r\n            }\r\n\r\n            set maximisable(value: boolean) {\r\n                this._maximisable = value;\r\n                this._window_top_bar_maximise_button.disabled = !value;\r\n            }\r\n\r\n            get maximised() {\r\n                return this._maximised;\r\n            }\r\n\r\n            set maximised(value: boolean) {\r\n                this._maximised = value;\r\n                this._window_root.classList.toggle(\"maximised\", value);\r\n\r\n                if (value) {\r\n                    this._window_top_bar_maximise_button.innerText = \"\";\r\n                    this._window_top_bar_maximise_button.title = \"Restore window\";\r\n\r\n                    this._emit_event(\"maximise\");\r\n                } else {\r\n                    this._window_top_bar_maximise_button.innerText = \"\";\r\n                    this._window_top_bar_maximise_button.title = \"Maximise window\";\r\n\r\n                    this._emit_event(\"restore\");\r\n                }\r\n            }\r\n\r\n            get x() {\r\n                return this._window_root.style.left;\r\n            }\r\n\r\n            set x(css_pos: string | number) {\r\n                if (typeof css_pos === \"number\") {\r\n                    css_pos = `${css_pos}px`;\r\n                }\r\n\r\n                this._window_root.style.left = css_pos;\r\n            }\r\n\r\n            get y() {\r\n                return this._window_root.style.top;\r\n            }\r\n\r\n            set y(css_pos: string | number) {\r\n                if (typeof css_pos === \"number\") {\r\n                    css_pos = `${css_pos}px`;\r\n                }\r\n\r\n                this._window_root.style.top = css_pos;\r\n            }\r\n\r\n            center() {\r\n                this.x = `calc(calc(100vw - ${this.width}) / 2)`;\r\n                this.y = `calc(calc(100vh - ${this.height}) / 2)`;\r\n            }\r\n\r\n            get dom() {\r\n                return this._shadow_dom;\r\n            }\r\n\r\n            show() {\r\n                this._window_root.classList.remove(\"animating-out\");\r\n                this._window_root.classList.add(\"visible\", \"animating-in\");\r\n                this._window_root.ariaHidden = \"false\";\r\n\r\n                setTimeout(() => {\r\n                    this._window_root.classList.remove(\"animating-in\");\r\n                }, 200);\r\n\r\n                this._emit_event(\"show\");\r\n            }\r\n\r\n            hide() {\r\n                this._window_root.classList.remove(\"animating-in\");\r\n                this._window_root.classList.add(\"animating-out\");\r\n                this._window_root.ariaHidden = \"true\";\r\n\r\n                setTimeout(() => {\r\n                    this._window_root.classList.remove(\"visible\", \"animating-out\");\r\n                }, 200);\r\n\r\n                this._emit_event(\"hide\");\r\n            }\r\n\r\n            toggle() {\r\n                this._window_root.classList.toggle(\"visible\");\r\n\r\n                if (this.visible) {\r\n                    this._emit_event(\"show\");\r\n                } else {\r\n                    this._emit_event(\"hide\");\r\n                }\r\n            }\r\n\r\n            get visible() {\r\n                return this._window_root.classList.contains(\"visible\");\r\n            }\r\n\r\n            set visible(is_visible: boolean) {\r\n                if (is_visible) {\r\n                    this.show();\r\n                } else {\r\n                    this.hide();\r\n                }\r\n            }\r\n\r\n            get_custom_flag(flag: string) {\r\n                return this._custom_flags.has(flag);\r\n            }\r\n\r\n            set_custom_flag(flag: string, value: boolean) {\r\n                if (value) {\r\n                    this._custom_flags.add(flag);\r\n                } else {\r\n                    this._custom_flags.delete(flag);\r\n                }\r\n\r\n                switch (flag) {\r\n                    case \"transparent\":\r\n                        if (value) {\r\n                            this._content_host.classList.add(\"transparent\");\r\n                        } else {\r\n                            this._content_host.classList.remove(\"transparent\");\r\n                        }\r\n                        break;\r\n                    case \"no-top-bar\":\r\n                        if (value) {\r\n                            this._window_top_bar.classList.add(\"hidden\");\r\n                        } else {\r\n                            this._window_top_bar.classList.remove(\"hidden\");\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n\r\n            wait_for_event(event: WindowEvent): Promise<void> {\r\n                return new Promise((resolve) => {\r\n                    const callback = async () => {\r\n                        this.remove_event_listener(event, callback);\r\n                        resolve();\r\n                    };\r\n\r\n                    this.add_event_listener(event, callback);\r\n                });\r\n            }\r\n        }\r\n\r\n        this.#WindowClass = DOMWindow;\r\n    }\r\n}\r\n","// provides expected externals of pkgbuild programs into global\r\n\r\nimport * as howler from \"howler\";\r\nimport * as htmlToText from \"html-to-text\";\r\nimport * as sixel from \"sixel\";\r\nimport * as xterm from \"@xterm/xterm\";\r\n\r\nglobalThis.ollieos = {};\r\nglobalThis.howler = howler;\r\nglobalThis[\"html-to-text\"] = htmlToText;\r\nglobalThis.sixel = sixel;\r\nglobalThis[\"@xterm/xterm\"] = xterm;\r\n\r\n// support old xterm names\r\nglobalThis[\"xterm\"] = xterm;\r\n\r\nif (typeof window !== \"undefined\") {\r\n    console.log(\"Loading browser-specific global externals...\");\r\n\r\n    (async() => {\r\n        const fitAddon = await import(\"@xterm/addon-fit\");\r\n        const webLinksAddon = await import(\"@xterm/addon-web-links\");\r\n        const imageAddon = await import(\"@xterm/addon-image\");\r\n        const xtermLinkProvider = await import(\"xterm-link-provider\");\r\n\r\n        const sweetalert2 = await import(\"sweetalert2\");\r\n\r\n        globalThis[\"@xterm/addon-fit\"] = fitAddon;\r\n        globalThis[\"@xterm/addon-web-links\"] = webLinksAddon;\r\n        globalThis[\"@xterm/addon-image\"] = imageAddon;\r\n        globalThis[\"xterm-link-provider\"] = xtermLinkProvider;\r\n\r\n        globalThis.sweetalert2 = sweetalert2;\r\n\r\n        globalThis[\"xterm-addon-fit\"] = fitAddon;\r\n        globalThis[\"xterm-addon-web-links\"] = webLinksAddon;\r\n        globalThis[\"xterm-addon-image\"] = imageAddon;\r\n\r\n        console.log(\"Browser-specific global externals loaded successfully.\");\r\n    })();\r\n}\r\n","import { FitAddon } from \"@xterm/addon-fit\";\r\nimport { WebLinksAddon } from \"@xterm/addon-web-links\";\r\nimport { ImageAddon } from \"@xterm/addon-image\";\r\n\r\nimport {ANSI, NEWLINE, WrappedTerminal} from \"./kernel/term_ctl\";\r\n\r\nimport {Kernel} from \"./kernel\";\r\n\r\nimport {ProgramRegistry} from \"./kernel/prog_registry\";\r\nimport * as programs from \"./programs/@ALL\";\r\n\r\nimport { SoundRegistry } from \"./kernel/sfx_registry\";\r\n\r\nimport type {AbstractFileSystem} from \"./kernel/filesystem\";\r\nimport { LocalStorageFS } from \"./fs_impl/localstorage\";\r\nimport { OPFSFileSystem } from \"./fs_impl/opfs\";\r\nimport { initial_fs_setup } from \"./initial_fs_setup\";\r\n\r\nimport {DOMWindowManager} from \"./window_impl/dom\";\r\n\r\nimport \"./load_global_externals\";\r\n\r\nexport const boot_os = async (on_init_spawned?: (kernel: Kernel) => Promise<void>) => {\r\n    // create a program registry by importing all programs\r\n    const prog_reg = new ProgramRegistry();\r\n    for (const prog of Object.values(programs)) {\r\n        await prog_reg.registerProgram({\r\n            program: prog,\r\n            built_in: true,\r\n        });\r\n    }\r\n\r\n\r\n    // create a sound registry\r\n    const sfx_reg = new SoundRegistry();\r\n    sfx_reg.register_file(\"reader_on\", \"public/sfx/reader_on.mp3\");\r\n    sfx_reg.register_file(\"reader_off\", \"public/sfx/reader_off.mp3\");\r\n\r\n\r\n    // create a filesystem\r\n    // try opfs but use localstorage if not available, or already in use\r\n    // TODO migrate from localstorage to opfs automatically\r\n    let fs: AbstractFileSystem;\r\n    if (!localStorage.getItem(\"fs\") && navigator.storage && \"getDirectory\" in navigator.storage) {\r\n        fs = new OPFSFileSystem();\r\n    } else {\r\n        fs = new LocalStorageFS();\r\n    }\r\n\r\n    if (!(await fs.is_ready())) {\r\n        // poll every 10ms until ready\r\n        await new Promise<void>((resolve) => {\r\n            const interval = setInterval(async () => {\r\n                if (await fs.is_ready()) {\r\n                    clearInterval(interval);\r\n                    resolve();\r\n                }\r\n            }, 10);\r\n        });\r\n    }\r\n\r\n    // create initial files\r\n    await initial_fs_setup(fs);\r\n\r\n    // create a dom window manager\r\n    const wm = new DOMWindowManager();\r\n\r\n    // create a terminal using the registry and filesystem\r\n    const term = new WrappedTerminal({\r\n        screenReaderMode: false,\r\n        cursorBlink: true,\r\n    });\r\n\r\n    // load addons\r\n    const fit = new FitAddon();\r\n    term.loadAddon(fit);\r\n\r\n    term.loadAddon(new WebLinksAddon());\r\n\r\n    term.loadAddon(new ImageAddon());\r\n\r\n\r\n    // open the terminal\r\n    const render = <HTMLElement>document.querySelector(\"#terminal\");\r\n    term.open(render);\r\n    fit.fit();\r\n\r\n\r\n    // if this is a small screen, show a message\r\n    if (window.innerWidth < 600) {\r\n        const wrapped = term.word_wrap(`${ANSI.BG.red + ANSI.FG.white}Warning: The screen that the terminal is running on is rather small!${NEWLINE + NEWLINE}Some programs may not display correctly, consider using a larger screen such as a computer or tablet.${NEWLINE + NEWLINE}An alternative interface is in the works. You can also use the command \"legacy\" to view the old (outdated) site.${ANSI.STYLE.reset_all}`, term.cols);\r\n        term.writeln(wrapped);\r\n    }\r\n\r\n\r\n    // disable F1 help\r\n    window.addEventListener(\"keydown\", function (e) {\r\n        if (e.code === \"F1\") {\r\n            e.preventDefault();\r\n        }\r\n    });\r\n\r\n\r\n    // on resize, resize the terminal\r\n    window.addEventListener(\"resize\", () => {\r\n        fit.fit();\r\n    });\r\n\r\n\r\n    // bind right click to copy/paste\r\n    window.addEventListener(\"contextmenu\", (e) => {\r\n        e.preventDefault();\r\n        term.copy_or_paste();\r\n    });\r\n\r\n    // create the kernel\r\n    const kernel = new Kernel(term, fs, prog_reg, sfx_reg, wm);\r\n    kernel.set_env_info(document.body.dataset.version, \"web\");\r\n\r\n    // boot the kernel and check for a false return (indicating boot failure). should probably never return true as the os should hopefully always run!\r\n    return await kernel.boot(on_init_spawned);\r\n}\r\n"],"names":["NEWLINE","NON_PRINTABLE_REGEX","ANSI_ESCAPE_REGEX","ANSI_UNESCAPED_REGEX","FG","reset","black","red","green","yellow","blue","magenta","cyan","white","gray","STYLE","reset_all","bold","dim","no_bold_or_dim","italic","no_italic","underline","double_underline","no_underline","inverse","no_inverse","hidden","no_hidden","strikethrough","no_strikethrough","negative","positive","CURSOR","invisible","visible","ANSI","BG","PREFABS","program_name","error","variable_name","file_path","dir_name","secret","WrappedTerminal","Terminal","Map","ansi","newline","non_printable_regex","ansi_escape_regex","ansi_unescaped_regex","read_line","async","custom_key_handlers","custom_printable_handler","buffer","current_line","current_index","set_current_line","new_line","set_current_index","new_index","handler_dispose","Promise","resolve","handlers","_e","term","write","length","before","slice","after","repeat","this","register_key_event_handler","e","key","match","before_cursor","after_cursor","console","warn","block","high_priority","_search_handlers","domEventCode","strict","pair","entries","identfier","handler","props","identifier","keyString","entry","existing_entries","set","unshift","push","get","splice","indexOf","delete","_handle_key_event","all_key_entries","undefined","domEvent","code","register_on_printable_key_event_handler","_enqueue_key_event","_handle_key_event_queue","shift","wait_for_keypress","dispose","onKey","get_text","max_length","text","unregister_handler","word_wrap","width","lines","split","wrapped_lines","line","words","word","join","copy","navigator","clipboard","writeText","getSelection","then","clearSelection","paste","readText","char","dom_event_code","toUpperCase","copy_or_paste","hasSelection","handle_kernel_panic","message","process_info","debug_info","textarea","disabled","writeln","Date","toISOString","window","location","origin","constructor","xterm_opts","super","build_registrant_from_js","js_code","built_in","warn_deprecation","startsWith","data_url","encodeURIComponent","encode_js_to_url","program","import","default","Error","name","globalThis","OLLIEOS_NODE","node_opt_out","description","usage_suffix","arg_descriptions","main","async_main","old_main","data","determine_program_name_from_js","mount_and_register_with_output","filename","content","prog_reg","output_success","reg","endsWith","registerProgram","recurse_mount_and_register_with_output","fs","dir_path","prog_registry","list_dir","entry_path","dir_exists","read_file","ProgramRegistry","program_reg","has","getProgramRegistrant","getProgram","listProgramRegistrants","includes_builtin","includes_mounted","arr","Array","from","values","filter","listProgramNames","keys","listPrograms","map","forceUnregister","unregister","create_userspace_proxy","init_program","self","proxy","Object","create","check_protected","privilege_agent_program","trim","defineProperties","value","enumerable","inc_builtin","inc_mounted","freeze","PathNotFoundError","path","NonRecursiveDirectoryError","MoveDestinationDirectoryNotEmptyError","ReadOnlyError","FSEventType","AbstractFileSystem","_initialised","_root","_home","_cwd","purge_cache","smart","exists_direct","clear","force_remove_from_cache","remote_purge_cache","localStorage","setItem","toString","remote_remove_from_cache","getItem","removeItem","remove_from_cache","register_callback","event_type","callback","_call_callbacks","as_uint","READING_FILE","cached","exists","read_file_direct","readonly","is_readonly","write_file","force","Uint8Array","write_file_direct","WROTE_FILE","delete_file","delete_file_direct","DELETED_FILE","move_file","new_path","move_file_direct","MOVED_FILE","set_readonly","set_readonly_direct","SET_READONLY","is_readonly_direct","delete_dir","recursive","delete_dir_direct","move_dir","src","dest","force_move_inside","move_dir_direct","get_cwd","GETTING_CWD","set_cwd","SET_CWD","get_home","GETTING_HOME","set_home","SET_HOME","get_root","GETTING_ROOT","set_root","SET_ROOT","CHECKING_EXISTS","absolute","includes","effective_cwd","lastIndexOf","base_dir","paths","setInterval","check_path","absolute_path","get_unique_fs_type_name","erase_all","dirs_first","base","make_dir","move_inside","ProcessAttachment","SoundRegistry","register_howl","howl","ready","register_file","file","Howl","onload","await_ready","interval","reject","timer","clearInterval","play","is_ready","wait_to_play","log","IPCManager","process_manager","service","get_process","pid","channel_id","channel","initiator_process","initiator","peer_process","peer","dispose_all","service_register","on_connection","service_unregister","service_lookup","create_direct_channel","initiator_pid","peer_pid","initiator_to_peer_queue","peer_to_initiator_queue","listeners","create_channel","service_name","catch","err","reserve_kernel_channel","assign_kernel_channel","destroy_channel","channel_listen","listening_pid","listener","Set","add","channel_unlisten","channel_send","from_pid","msg","to","to_pid","process_pid","ProcessContext","FOREGROUND","source_command","registry","shell","run_in_bg","BACKGROUND","created_at","is_detached","DETACHED","is_background","is_foreground","attachment","detaches_silently","detach","silently","dispose_resources","forEach","id","clearTimeout","win","kill","exit_code","mark_terminated","add_exit_listener","create_timeout","delay","on_cancel","setTimeout","resolvers","cancel_timeout","cancel_callback","has_timeout","create_interval","has_interval","clear_interval","wait_for_timeout","create_window","wm","window_manager","Window","add_event_listener","create_userspace_proxy_as_other_process","ProcessManager","ipc_manager","process","create_process","context","list_pids","ipc_mgr_proxy","Kernel","version","env","privileged","panicked","get_program_registry","get_sound_registry","get_fs","get_window_manager","has_window_manager","get_process_manager","get_ipc","get_env_info","set_env_info","spawn","cmd_or_parse","explicit_args","start_privileged","parsed_line","command","args","unsubbed_args","raw_parts","compat","result_promise","kernel","completion","panic","proc_mgr","pids","proc","trimEnd","boot","on_init_spawned","usr_bin","init_args","init_parts","init","focus","request_privilege","reason","agent_program","ipc","agent_proc","handling_request","approved","handling","granted","process_proxy","start_time","now","sound_registry","kernel_fs","proc_mgr_proxy","prog_reg_proxy","fs_proxy","SERVICES_DIR","CLEAN_EXIT_CODES","ServiceManager","load_service_files","service_files","file_name","file_content","service_data","JSON","parse","service_id","substring","existing_service_id","_calculate_service_start_order","visited","temp_mark","result","visit","dependencies","dep","start_initial_services","start_order","start_service","spawn_result","exec","_handle_service_exit","stop_service","restart_service","get_service_status","state","restart_policy","restart","on","delay_ms","hide_from_help","boot_target","boot_args","boot_target_parts","svc_mgr","payload","type","service_msg","action","status","current_tty_process","running","final_code","window_start","deaths_in_window","boot_target_proc","toLowerCase","recovery_proc","recovery_exit_code","default_shell","default_shell_args","default_shell_parts","current_shell_process","shell_proc","AshMemory","current_history_index","clear_history","get_previous_history_entry","get_next_history_entry","add_history_entry","list_variables","get_variable","set_variable","unset_variable","list_aliases","get_alias","set_alias","unset_alias","VAR_ASSIGNMENT_REGEX","parse_line","memory","sub","i","part","alias_value","alias_parts","pop","skip_variable_sub_idxs","arg","var_name","var_value","arg_idx","replace","var1","var2","AshShell","_discard_cached_matches","execute","edit_doc_title","program_final_completion_callback","old_title","document","title","on_execute_completion","color","insert_prompt","run_script","get_prompt_suffix","set_prompt_suffix","suffix","get_prompt_string","RegExp","cached_matches","current_cached_match_index","tab_complete","discard_cached_matches","updated_discard","completeable_arguments","completion_data","current_partial","arg_index","completion_result","obj","Symbol","asyncIterator","results","get_completeable_arguments","complete_argument","parts","current_arg_partial","fill_completed_argument","programs","complete_command","fill_completed_command","helper_completion_options","options","option","env_info","absolute_profile","absolute_rc","profile_content","rc_content","read_line_key_handlers","make_read_line_key_handlers","read_line_printable_handler","make_read_line_printable_handler","input","my_process","channel_id_str","parseInt","isNaN","finished","event","timeout_id","reload","header","single_column","visible_programs","programs_fmt","sort","max_allowable_length","Math","floor","cols","column1","_","column2","longest_program_length","max","new_args","paired_programs","program1","program2","program1_real_length","program2_real_length","recurse","descs","nest_level","output","time","time_arg","parsed_time","show_hidden","dir","max_width","setup","h_padding_l","ceil","h_padding_r","rows","footer","f_padding_l","f_padding_r","split_content","saved","cursor_y","normal","cursorY","line_length","cursor_x","cursorX","before_newline","after_newline","newline_content","left","right","test","url","proc_url","URL","protocol","overwrite","binary","method","headers","body","next_arg","abs_path","response","headers_obj","fetch","ok","arrayBuffer","filepath","hex","byte","padStart","idx","padded","concat","fill","MY_USERNAME","GH_USERNAME_REGEX","version_str","max_columns","asc_width","username","gh_info","res","json","bio","blog","followers","following","twitter","twitter_username","get_github_info","avatar_url","username_to_avatar_url","ascii_pfp","size","img","round","loadImage","stringANSI8BitColor","convert_to_ascii","known_data","data_index_str","user_data_str","pronouns","subject","object_or_alt","possessive","interests","websites","extra","known_info","stranger_info","txt_line_prefix","txt_line_suffix","asc_lines","txt_lines","max_lines","max_asc_line_length","max_txt_line_length","center_padding_size","side_padding_size","center_padding","side_padding","asc_line","txt_line","asc_line_padding","sfx_reg","screenReaderMode","sound_name","hint","querySelector","remove","pad","str","invis_codes","y_count","mime","width_arg","head_req","get_req","createObjectURL","Blob","data_out","canvas","createElement","ctx","getContext","Image","crossOrigin","onerror","height","drawImage","img_data","getImageData","array","convert_to_image_data","img_width","img_height","width_scale","new_height","scaled_img_data","x","y","scaled_x","scaled_i","sixel","image2sixel","blob","createImageBitmap","trusted_formats","ext","directory","fs_name","encoded_dir","open","iframe","style","border","wind","dom","appendChild","show","other_fsedit_running","processes","message_handler","source","contentWindow","close","removeEventListener","addEventListener","rimraf","type_suffixes","bug","feature","other","HTML_TAG_REGEX","fields","feed","item","DocType","author","publisher","date","link","summary","get_field","doc","doc_type","field","as_html","dict","FEED","field_value","isArray","sub_field","sub_field_doc","getElementsByTagName","sub_value","innerHTML","textContent","max_items","index","no_content","parser","DOMParser","parseFromString","feed_title","site_link","site_description","items","item_idx","item_title","ITEM","convert","formatters","elem","walk","builder","openBlock","addInline","opener","children","closeBlock","img_fmt","a_fmt","selectors","selector","format","_data","assign","wait_block","run_cmd","cmd","welcome","end","remove_subcommand","unique_args","error_count","total_pkgs","pkg","pkg_dir","meta_triggers","meta_version","meta_deps","meta_raw","meta","triggers","deps","dep_pkg","dep_pkg_name","graph_query","remove_pkg_dependent","remove_pkg","files","trigger_name","trigger_data","trigger_exists","process_uninstall_trigger","add_subcommand","depended_by","pkg_at_version","pkg_split","pkg_name","pkg_version","pkg_json","repo_query","get_pkg_json","latest_version","get_pkg_meta","externals","pkg_is_installed","get_pkg_version","remove_data","virtual_args","virtual_data","content_list","file_map","file_contents","get_pkg_file","stringify","json_convert_dep_sets_to_arrs","install_new_pkg","dep_name","add_pkg_dependent","process_install_trigger","print_info","pkg_data","installed","license","homepage_url","repo_url","long_desc","view_pkg_info","pkg_versions","get_pkg_versions","installed_version","printed_link_header","repo_url_obj","GRAPH_DIR","GRAPH_PATH","TRIGGER_DIR","append_url_pathnames","pathnames","new_url","urlpath","pathname","api_call","encodeURI","get_provided_list","json_convert_dep_arrs_to_sets","graph","get_pkg_info","list_pkgs","only_top_level","pkgs","top_level","get_pkg_dependents","dependents","get_pkg_dependencies","dependended_by","promote_pkg_to_top_level","demote_pkg_from_top_level","dependent_pkg","add_to_deps","remove_from_deps","skip_dep_check","list_unused_pkgs","get_file_path_in_pkg_bin","load_trigger_file","trigger_path","trigger","install_exec","data_str","uninstall_exec","local_graph","create_trigger_path","create_trigger_data","pkg_names","info","list_subcommand","always_fetch","installed_pkg","requested_version_installed","pkg_json_path","info_subcommand","provided","offset","selected_index","draw","quit","browse_subcommand","absolute_file","abs_dir","parent","no_overwrite","raw_destination","ended_with_slash","destination","dest_is_dir","window_ids","get_all_windows","all_windows","visible_windows","w","get_unique_manager_type_name","only_visible","only_invisible","visibility_text","owner_pid","userspace_kernel","window_id","get_window_by_id","show_subcommand","hide","hide_subcommand","close_subcommand","center","center_subcommand","aliases","value_parts","final_value","pm","toLocaleString","longest_command_length","get_command_space","subtract","on_data","reply_timeout","return_code","msg_data","service_subcommand","reload_services_subcommand","set_custom_flag","buttons","display","alignItems","gap","padding","fsedit_button","innerText","fontSize","onclick","mc_button","mc_image","objectFit","alt","draggable","trigger_file","source_path","dest_path","LocalStorageFS","current_dir","MADE_DIR","part_idx","DELETED_DIR","src_node","p","basename","current","get_node","dest_parts","dest_basename","final_parent","final_name","dest_exists","dest_parent_obj","LISTING_DIR","current_part","binary_string","atob","bytes","m","charCodeAt","TextDecoder","decode","uint","TextEncoder","encode","ArrayBuffer","btoa","String","fromCharCode","apply","readonly_list","src_parts","new_file_name","new_current_dir","string_to_array","array_to_b64","migrations","migrate_old_string_fs","migrate_old_array_fs","is_outer","stack","current_obj","OPFSFileSystem","_opfs_handle","storage","getDirectory","handle","get_root_handle","root","current_handle","getDirectoryHandle","DOMException","getFileHandle","err2","removeEntry","src_basename","src_handle","src_parent_handle","dest_parent_handle","final_dest_parent_handle","final_dest_name","dest_handle","move","new_dest_handle","kind","file_handle","getFile","array_buffer","dest_file_handle","writable","createWritable","src_subdir_handle","dest_subdir_handle","data_to_write","generate_project_folder","data_projects_dir","project_entry","project_data","project_dir","info_content","primary_language","live_url","image","file_ext_regex","image_ext","skip_cache","ttl_cache","ttl_cache_obj","fetch_file_with_ttl","sub_projects","sub_project_entry","AbstractWindow","_owner_pid","create_userspace_proxy_as_other_window","manager","maximised","create_userspace_proxy_as_full_window","manager_proxy","new_title","css_width","css_height","css_pos","is_visible","toggle","wait_for_event","AbstractWindowManager","DOMWindowManager","_manager","_window_id","_window_root","_window_top_bar","_window_top_bar_title","_window_top_bar_maximise_button","_content_host","_shadow_dom","_event_listeners","_title_text","moveable","resizable","_maximisable","_maximised","_custom_flags","classList","role","ariaHidden","zIndex","capture","_handle_window_blur","setAttribute","top_bar_controls","stopPropagation","minimise_button","ev","maximisable","close_button","bind","_start_drag","attachShadow","mode","_emit_event","activeElement","all","start_event","preventDefault","rect","getBoundingClientRect","offset_x","clientX","offset_y","clientY","top","mouse_move","move_event","new_rect","width_ratio","mouse_up","up_event","remove_event_listener","contains","get_custom_flag","flag","ollieos","howler","xterm","fitAddon","webLinksAddon","imageAddon","xtermLinkProvider","sweetalert2","boot_os","prog","absolute_boot","absolute_init","absolute_etc","absolute_boot_target","absolute_default_shell","absolute_sys","absolute_privilege_agent","setup_boot","motd_content","absolute_motd","setup_motd","absolute_ollie_profile","absolute_ash_profile","absolute_ollierc","absolute_ashrc","migrate_rc_profile","credits_content","absolute_credits","setup_credits","latest_rev","data_dir","existing_rev","version_file","rev","svc_version","possible_backup_dir","groups","group","group_dir","group_index","file_data","setup_data_repo","data_rev","absolute_projects","project_rev","project_index_file","projects","project_file","setup_projects","initial_fs_setup","cursorBlink","fit","FitAddon","loadAddon","WebLinksAddon","ImageAddon","render","innerWidth","wrapped","dataset"],"sourceRoot":""}