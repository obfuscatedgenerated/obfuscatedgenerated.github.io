{"version":3,"file":"882.bundle.js","mappings":"qJAAO,MAAMA,EAST,WAAAC,CAAYC,EAAWC,EAAQC,EAAUC,EAAW,CAAC,EAAGC,EAAc,GAClEC,KAAKL,UAAYA,EACjBK,KAAKJ,OAASA,EACdI,KAAKH,SAAWA,EAChBG,KAAKF,SAAWA,EAChBE,KAAKD,YAAcA,CACvB,CACA,YAAAE,CAAaC,EAAGC,GAEZA,EADcC,EAAYF,EAAGF,KAAKJ,OAAQI,KAAKL,UAAWK,KAAKD,aAAaM,KAAKC,GAAWC,OAAOC,OAAO,CAAEC,MAAOH,EAAMG,MAAOC,KAAMJ,EAAMI,KAAMC,SAAUX,KAAKH,UAAYG,KAAKF,YAEtL,EASG,MAAMM,EAAc,CAACF,EAAGU,EAAOC,EAAUC,EAAa,KACzD,MAAMC,EAAM,IAAIC,OAAOJ,EAAMK,SAAUL,EAAMM,OAAS,IAAM,KACvDC,MAAM,IACNC,QAAO,CAACC,EAAOC,EAAOC,IAAQA,EAAIC,QAAQH,KAAWC,IACrDG,KAAK,MACHC,EAAMC,GAAkBC,EAAoC1B,EAAI,EAAGW,GAC1E,IAAIgB,EACAC,GAAe,EACnB,MAAMC,EAAS,GACf,KAAoC,QAA5BF,EAAQd,EAAIiB,KAAKN,KAAiB,CACtC,MAAMhB,EAAOmB,EAAMf,GACnB,IAAKJ,EAAM,CAGPuB,QAAQC,IAAI,gDACZ,KACJ,CAOA,GAFAJ,EAAcJ,EAAKF,QAAQd,EAAMoB,EAAc,GAC/Cf,EAAIoB,UAAYL,EAAcpB,EAAK0B,OAC/BN,EAAc,EAEd,MAEJ,MAAMrB,EAAQ,CACV4B,MAAOC,EAA4BzB,EAAUc,EAAgBG,GAC7DS,IAAKD,EAA4BzB,EAAUc,EAAgBG,EAAcpB,EAAK0B,OAAS,GAAG,IAE9FL,EAAOS,KAAK,CAAE/B,QAAOC,QACzB,CACA,OAAOqB,CAAM,EAEXH,EAAsC,CAACa,EAAW5B,KACpD,IACI6B,EACAC,EAFAC,EAAa,GAGjB,EAAG,CACC,MAAMlB,EAAOb,EAASgC,OAAOC,OAAOC,QAAQN,GAC5C,IAAKf,EACD,MAEAA,EAAKsB,WACLP,IAEJE,EAAkBjB,EAAKsB,SAC3B,OAASL,GACT,MAAMhB,EAAiBc,EACvB,EAAG,CACC,MAAMQ,EAAWpC,EAASgC,OAAOC,OAAOC,QAAQN,EAAY,GAC5DC,IAAkBO,GAAWA,EAASD,UACtC,MAAMtB,EAAOb,EAASgC,OAAOC,OAAOC,QAAQN,GAC5C,IAAKf,EACD,MAEJkB,GAAclB,EAAKwB,mBAAkB,GAAMC,UAAU,EAAGtC,EAASuC,MACjEX,GACJ,OAASC,GACT,MAAO,CAACE,EAAYjB,EAAe,EAEjCW,EAA8B,CAACzB,EAAU4B,EAAWX,EAAauB,GAAiB,KACpF,MAAMC,EAAOzC,EAASgC,OAAOC,OAAOS,cACpC,KAAOzB,GAAa,CAChB,MAAMJ,EAAOb,EAASgC,OAAOC,OAAOC,QAAQN,GAC5C,IAAKf,EACD,MAAO,CAAE8B,EAAG,EAAGtD,EAAG,GAEtB,MAAMkC,EAASV,EAAKU,OACpB,IAAK,IAAIqB,EAAI,EAAGA,EAAIrB,GAAS,CAGzB,GAFAV,EAAKgC,QAAQD,EAAGH,IAChBxB,GAAewB,EAAKK,WAAWvB,QACb,EACd,MAAO,CAAEoB,EAAGC,GAAKJ,EAAiBC,EAAKM,WAAa,GAAI1D,EAAGuC,EAAY,GAE3EgB,GAAKH,EAAKM,UACd,CACAnB,GACJ,CACA,MAAO,CAAEe,EAAG,EAAGtD,EAAGuC,EAAY,EAAG,C","sources":["webpack://ollieos/./node_modules/xterm-link-provider/lib/esm/index.js"],"sourcesContent":["export class LinkProvider {\n    /**\n     * Create a Link Provider for xterm.js\n     * @param _terminal The terminal instance\n     * @param _regex The regular expression to use for matching\n     * @param _handler Callback for when link is clicked\n     * @param _options Further hooks, eg. hover, leave and decorations\n     * @param _matchIndex The index to use from regexp.exec result, default 1\n     */\n    constructor(_terminal, _regex, _handler, _options = {}, _matchIndex = 1) {\n        this._terminal = _terminal;\n        this._regex = _regex;\n        this._handler = _handler;\n        this._options = _options;\n        this._matchIndex = _matchIndex;\n    }\n    provideLinks(y, callback) {\n        const links = computeLink(y, this._regex, this._terminal, this._matchIndex).map((_link) => (Object.assign({ range: _link.range, text: _link.text, activate: this._handler }, this._options)));\n        callback(links);\n    }\n}\n/**\n * Find link range and text for the given line and regex\n * @param y The line number to process\n * @param regex The regular expression to use for matching\n * @param terminal The terminal instance\n * @param matchIndex The index to use from regexp.exec result, default 1\n */\nexport const computeLink = (y, regex, terminal, matchIndex = 1) => {\n    const rex = new RegExp(regex.source, ((regex.flags || '') + 'g')\n        .split('')\n        .filter((value, index, arr) => arr.indexOf(value) === index)\n        .join(''));\n    const [line, startLineIndex] = translateBufferLineToStringWithWrap(y - 1, terminal);\n    let match;\n    let stringIndex = -1;\n    const result = [];\n    while ((match = rex.exec(line)) !== null) {\n        const text = match[matchIndex];\n        if (!text) {\n            // something matched but does not comply with the given matchIndex\n            // since this is most likely a bug the regex itself we simply do nothing here\n            console.log('match found without corresponding matchIndex');\n            break;\n        }\n        // Get index, match.index is for the outer match which includes negated chars\n        // therefore we cannot use match.index directly, instead we search the position\n        // of the match group in text again\n        // also correct regex and string search offsets for the next loop run\n        stringIndex = line.indexOf(text, stringIndex + 1);\n        rex.lastIndex = stringIndex + text.length;\n        if (stringIndex < 0) {\n            // invalid stringIndex (should not have happened)\n            break;\n        }\n        const range = {\n            start: stringIndexToBufferPosition(terminal, startLineIndex, stringIndex),\n            end: stringIndexToBufferPosition(terminal, startLineIndex, stringIndex + text.length - 1, true)\n        };\n        result.push({ range, text });\n    }\n    return result;\n};\nconst translateBufferLineToStringWithWrap = (lineIndex, terminal) => {\n    let lineString = '';\n    let lineWrapsToNext;\n    let prevLinesToWrap;\n    do {\n        const line = terminal.buffer.active.getLine(lineIndex);\n        if (!line) {\n            break;\n        }\n        if (line.isWrapped) {\n            lineIndex--;\n        }\n        prevLinesToWrap = line.isWrapped;\n    } while (prevLinesToWrap);\n    const startLineIndex = lineIndex;\n    do {\n        const nextLine = terminal.buffer.active.getLine(lineIndex + 1);\n        lineWrapsToNext = nextLine ? nextLine.isWrapped : false;\n        const line = terminal.buffer.active.getLine(lineIndex);\n        if (!line) {\n            break;\n        }\n        lineString += line.translateToString(true).substring(0, terminal.cols);\n        lineIndex++;\n    } while (lineWrapsToNext);\n    return [lineString, startLineIndex];\n};\nconst stringIndexToBufferPosition = (terminal, lineIndex, stringIndex, reportLastCell = false) => {\n    const cell = terminal.buffer.active.getNullCell();\n    while (stringIndex) {\n        const line = terminal.buffer.active.getLine(lineIndex);\n        if (!line) {\n            return { x: 0, y: 0 };\n        }\n        const length = line.length;\n        for (let i = 0; i < length;) {\n            line.getCell(i, cell);\n            stringIndex -= cell.getChars().length;\n            if (stringIndex < 0) {\n                return { x: i + (reportLastCell ? cell.getWidth() : 1), y: lineIndex + 1 };\n            }\n            i += cell.getWidth();\n        }\n        lineIndex++;\n    }\n    return { x: 1, y: lineIndex + 1 };\n};\n//# sourceMappingURL=index.js.map"],"names":["LinkProvider","constructor","_terminal","_regex","_handler","_options","_matchIndex","this","provideLinks","y","callback","computeLink","map","_link","Object","assign","range","text","activate","regex","terminal","matchIndex","rex","RegExp","source","flags","split","filter","value","index","arr","indexOf","join","line","startLineIndex","translateBufferLineToStringWithWrap","match","stringIndex","result","exec","console","log","lastIndex","length","start","stringIndexToBufferPosition","end","push","lineIndex","lineWrapsToNext","prevLinesToWrap","lineString","buffer","active","getLine","isWrapped","nextLine","translateToString","substring","cols","reportLastCell","cell","getNullCell","x","i","getCell","getChars","getWidth"],"sourceRoot":""}