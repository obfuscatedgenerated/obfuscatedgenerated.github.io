{"version":3,"file":"631.bundle.js","mappings":"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","sources":["webpack://ollieos/./src/term_ctl.ts","webpack://ollieos/./src/prog_registry.ts","webpack://ollieos/./src/processes.ts","webpack://ollieos/./src/sfx_registry.ts","webpack://ollieos/./src/kernel.ts","webpack://ollieos/./src/programs/core/ignition/services.ts","webpack://ollieos/./src/programs/core/ignition/index.ts","webpack://ollieos/./src/programs/core/jetty.ts","webpack://ollieos/./src/programs/core/ash/memory.ts","webpack://ollieos/./src/programs/core/ash/parser.ts","webpack://ollieos/./src/programs/core/ash/core.ts","webpack://ollieos/./src/programs/core/ash/tab_completion.ts","webpack://ollieos/./src/programs/core/ash/index.ts","webpack://ollieos/./src/programs/core/ash/key_handlers.ts","webpack://ollieos/./src/programs/help.ts","webpack://ollieos/./src/programs/shutdown.ts","webpack://ollieos/./src/programs/clear.ts","webpack://ollieos/./src/programs/echo.ts","webpack://ollieos/./src/programs/unset.ts","webpack://ollieos/./src/programs/ls.ts","webpack://ollieos/./src/programs/cd.ts","webpack://ollieos/./src/programs/pwd.ts","webpack://ollieos/./src/programs/edit.ts","webpack://ollieos/./src/programs/webget.ts","webpack://ollieos/./src/programs/cat.ts","webpack://ollieos/./src/programs/hex.ts","webpack://ollieos/./src/programs/mefetch.ts","webpack://ollieos/./src/programs/reader.ts","webpack://ollieos/./src/programs/selfdestruct.ts","webpack://ollieos/./src/programs/imagine.ts","webpack://ollieos/./src/programs/ascmagine.ts","webpack://ollieos/./src/programs/fsedit.ts","webpack://ollieos/./src/filesystem.ts","webpack://ollieos/./src/programs/rm.ts","webpack://ollieos/./src/programs/bugreport.ts","webpack://ollieos/./src/programs/repo.ts","webpack://ollieos/./src/programs/rss.ts","webpack://ollieos/./src/programs/legacy.ts","webpack://ollieos/./src/programs/tour.ts","webpack://ollieos/./src/programs/pkg/remove.ts","webpack://ollieos/./src/programs/pkg/add.ts","webpack://ollieos/./src/programs/pkg/list.ts","webpack://ollieos/./src/programs/pkg/info.ts","webpack://ollieos/./src/programs/pkg/browse.ts","webpack://ollieos/./src/programs/pkg/index.ts","webpack://ollieos/./src/programs/touch.ts","webpack://ollieos/./src/programs/mkdir.ts","webpack://ollieos/./src/programs/mv.ts","webpack://ollieos/./src/programs/window/info.ts","webpack://ollieos/./src/programs/window/list.ts","webpack://ollieos/./src/programs/window/show.ts","webpack://ollieos/./src/programs/window/hide.ts","webpack://ollieos/./src/programs/window/close.ts","webpack://ollieos/./src/programs/window/center.ts","webpack://ollieos/./src/programs/window/index.ts","webpack://ollieos/./src/programs/alias.ts","webpack://ollieos/./src/programs/unalias.ts","webpack://ollieos/./src/programs/ps.ts","webpack://ollieos/./src/programs/kill.ts","webpack://ollieos/./src/programs/spark/service.ts","webpack://ollieos/./src/programs/spark/reload_services.ts","webpack://ollieos/./src/programs/spark/index.ts","webpack://ollieos/./src/programs/ipc_bg_test.ts","webpack://ollieos/./src/programs/ipc_fg_test.ts","webpack://ollieos/./src/programs/taskbar_test.ts","webpack://ollieos/./src/programs/pkg/triggers/create_trigger.ts","webpack://ollieos/./src/programs/pkg/triggers/remove_trigger.ts","webpack://ollieos/./src/fs_impl/localstorage.ts","webpack://ollieos/./src/fs_impl/opfs.ts","webpack://ollieos/./src/initial_fs_setup.ts","webpack://ollieos/./src/windowing.ts","webpack://ollieos/./src/window_impl/dom.ts","webpack://ollieos/./src/load_global_externals.ts","webpack://ollieos/./src/bootloader.ts"],"sourcesContent":["import {IDisposable, ITerminalOptions, Terminal} from \"@xterm/xterm\";\r\nimport type {KeyEvent, KeyEventHandler, RegisteredKeyEventIdentifier} from \"./types\";\r\n\r\nexport const NEWLINE = \"\\r\\n\";\r\n/* eslint-disable-next-line no-control-regex, no-misleading-character-class */\r\nexport const NON_PRINTABLE_REGEX = /[\\0-\\x1F\\x7F-\\x9F\\xAD\\u0378\\u0379\\u037F-\\u0383\\u038B\\u038D\\u03A2\\u0528-\\u0530\\u0557\\u0558\\u0560\\u0588\\u058B-\\u058E\\u0590\\u05C8-\\u05CF\\u05EB-\\u05EF\\u05F5-\\u0605\\u061C\\u061D\\u06DD\\u070E\\u070F\\u074B\\u074C\\u07B2-\\u07BF\\u07FB-\\u07FF\\u082E\\u082F\\u083F\\u085C\\u085D\\u085F-\\u089F\\u08A1\\u08AD-\\u08E3\\u08FF\\u0978\\u0980\\u0984\\u098D\\u098E\\u0991\\u0992\\u09A9\\u09B1\\u09B3-\\u09B5\\u09BA\\u09BB\\u09C5\\u09C6\\u09C9\\u09CA\\u09CF-\\u09D6\\u09D8-\\u09DB\\u09DE\\u09E4\\u09E5\\u09FC-\\u0A00\\u0A04\\u0A0B-\\u0A0E\\u0A11\\u0A12\\u0A29\\u0A31\\u0A34\\u0A37\\u0A3A\\u0A3B\\u0A3D\\u0A43-\\u0A46\\u0A49\\u0A4A\\u0A4E-\\u0A50\\u0A52-\\u0A58\\u0A5D\\u0A5F-\\u0A65\\u0A76-\\u0A80\\u0A84\\u0A8E\\u0A92\\u0AA9\\u0AB1\\u0AB4\\u0ABA\\u0ABB\\u0AC6\\u0ACA\\u0ACE\\u0ACF\\u0AD1-\\u0ADF\\u0AE4\\u0AE5\\u0AF2-\\u0B00\\u0B04\\u0B0D\\u0B0E\\u0B11\\u0B12\\u0B29\\u0B31\\u0B34\\u0B3A\\u0B3B\\u0B45\\u0B46\\u0B49\\u0B4A\\u0B4E-\\u0B55\\u0B58-\\u0B5B\\u0B5E\\u0B64\\u0B65\\u0B78-\\u0B81\\u0B84\\u0B8B-\\u0B8D\\u0B91\\u0B96-\\u0B98\\u0B9B\\u0B9D\\u0BA0-\\u0BA2\\u0BA5-\\u0BA7\\u0BAB-\\u0BAD\\u0BBA-\\u0BBD\\u0BC3-\\u0BC5\\u0BC9\\u0BCE\\u0BCF\\u0BD1-\\u0BD6\\u0BD8-\\u0BE5\\u0BFB-\\u0C00\\u0C04\\u0C0D\\u0C11\\u0C29\\u0C34\\u0C3A-\\u0C3C\\u0C45\\u0C49\\u0C4E-\\u0C54\\u0C57\\u0C5A-\\u0C5F\\u0C64\\u0C65\\u0C70-\\u0C77\\u0C80\\u0C81\\u0C84\\u0C8D\\u0C91\\u0CA9\\u0CB4\\u0CBA\\u0CBB\\u0CC5\\u0CC9\\u0CCE-\\u0CD4\\u0CD7-\\u0CDD\\u0CDF\\u0CE4\\u0CE5\\u0CF0\\u0CF3-\\u0D01\\u0D04\\u0D0D\\u0D11\\u0D3B\\u0D3C\\u0D45\\u0D49\\u0D4F-\\u0D56\\u0D58-\\u0D5F\\u0D64\\u0D65\\u0D76-\\u0D78\\u0D80\\u0D81\\u0D84\\u0D97-\\u0D99\\u0DB2\\u0DBC\\u0DBE\\u0DBF\\u0DC7-\\u0DC9\\u0DCB-\\u0DCE\\u0DD5\\u0DD7\\u0DE0-\\u0DF1\\u0DF5-\\u0E00\\u0E3B-\\u0E3E\\u0E5C-\\u0E80\\u0E83\\u0E85\\u0E86\\u0E89\\u0E8B\\u0E8C\\u0E8E-\\u0E93\\u0E98\\u0EA0\\u0EA4\\u0EA6\\u0EA8\\u0EA9\\u0EAC\\u0EBA\\u0EBE\\u0EBF\\u0EC5\\u0EC7\\u0ECE\\u0ECF\\u0EDA\\u0EDB\\u0EE0-\\u0EFF\\u0F48\\u0F6D-\\u0F70\\u0F98\\u0FBD\\u0FCD\\u0FDB-\\u0FFF\\u10C6\\u10C8-\\u10CC\\u10CE\\u10CF\\u1249\\u124E\\u124F\\u1257\\u1259\\u125E\\u125F\\u1289\\u128E\\u128F\\u12B1\\u12B6\\u12B7\\u12BF\\u12C1\\u12C6\\u12C7\\u12D7\\u1311\\u1316\\u1317\\u135B\\u135C\\u137D-\\u137F\\u139A-\\u139F\\u13F5-\\u13FF\\u169D-\\u169F\\u16F1-\\u16FF\\u170D\\u1715-\\u171F\\u1737-\\u173F\\u1754-\\u175F\\u176D\\u1771\\u1774-\\u177F\\u17DE\\u17DF\\u17EA-\\u17EF\\u17FA-\\u17FF\\u180F\\u181A-\\u181F\\u1878-\\u187F\\u18AB-\\u18AF\\u18F6-\\u18FF\\u191D-\\u191F\\u192C-\\u192F\\u193C-\\u193F\\u1941-\\u1943\\u196E\\u196F\\u1975-\\u197F\\u19AC-\\u19AF\\u19CA-\\u19CF\\u19DB-\\u19DD\\u1A1C\\u1A1D\\u1A5F\\u1A7D\\u1A7E\\u1A8A-\\u1A8F\\u1A9A-\\u1A9F\\u1AAE-\\u1AFF\\u1B4C-\\u1B4F\\u1B7D-\\u1B7F\\u1BF4-\\u1BFB\\u1C38-\\u1C3A\\u1C4A-\\u1C4C\\u1C80-\\u1CBF\\u1CC8-\\u1CCF\\u1CF7-\\u1CFF\\u1DE7-\\u1DFB\\u1F16\\u1F17\\u1F1E\\u1F1F\\u1F46\\u1F47\\u1F4E\\u1F4F\\u1F58\\u1F5A\\u1F5C\\u1F5E\\u1F7E\\u1F7F\\u1FB5\\u1FC5\\u1FD4\\u1FD5\\u1FDC\\u1FF0\\u1FF1\\u1FF5\\u1FFF\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u2072\\u2073\\u208F\\u209D-\\u209F\\u20BB-\\u20CF\\u20F1-\\u20FF\\u218A-\\u218F\\u23F4-\\u23FF\\u2427-\\u243F\\u244B-\\u245F\\u2700\\u2B4D-\\u2B4F\\u2B5A-\\u2BFF\\u2C2F\\u2C5F\\u2CF4-\\u2CF8\\u2D26\\u2D28-\\u2D2C\\u2D2E\\u2D2F\\u2D68-\\u2D6E\\u2D71-\\u2D7E\\u2D97-\\u2D9F\\u2DA7\\u2DAF\\u2DB7\\u2DBF\\u2DC7\\u2DCF\\u2DD7\\u2DDF\\u2E3C-\\u2E7F\\u2E9A\\u2EF4-\\u2EFF\\u2FD6-\\u2FEF\\u2FFC-\\u2FFF\\u3040\\u3097\\u3098\\u3100-\\u3104\\u312E-\\u3130\\u318F\\u31BB-\\u31BF\\u31E4-\\u31EF\\u321F\\u32FF\\u4DB6-\\u4DBF\\u9FCD-\\u9FFF\\uA48D-\\uA48F\\uA4C7-\\uA4CF\\uA62C-\\uA63F\\uA698-\\uA69E\\uA6F8-\\uA6FF\\uA78F\\uA794-\\uA79F\\uA7AB-\\uA7F7\\uA82C-\\uA82F\\uA83A-\\uA83F\\uA878-\\uA87F\\uA8C5-\\uA8CD\\uA8DA-\\uA8DF\\uA8FC-\\uA8FF\\uA954-\\uA95E\\uA97D-\\uA97F\\uA9CE\\uA9DA-\\uA9DD\\uA9E0-\\uA9FF\\uAA37-\\uAA3F\\uAA4E\\uAA4F\\uAA5A\\uAA5B\\uAA7C-\\uAA7F\\uAAC3-\\uAADA\\uAAF7-\\uAB00\\uAB07\\uAB08\\uAB0F\\uAB10\\uAB17-\\uAB1F\\uAB27\\uAB2F-\\uABBF\\uABEE\\uABEF\\uABFA-\\uABFF\\uD7A4-\\uD7AF\\uD7C7-\\uD7CA\\uD7FC-\\uF8FF\\uFA6E\\uFA6F\\uFADA-\\uFAFF\\uFB07-\\uFB12\\uFB18-\\uFB1C\\uFB37\\uFB3D\\uFB3F\\uFB42\\uFB45\\uFBC2-\\uFBD2\\uFD40-\\uFD4F\\uFD90\\uFD91\\uFDC8-\\uFDEF\\uFDFE\\uFDFF\\uFE1A-\\uFE1F\\uFE27-\\uFE2F\\uFE53\\uFE67\\uFE6C-\\uFE6F\\uFE75\\uFEFD-\\uFF00\\uFFBF-\\uFFC1\\uFFC8\\uFFC9\\uFFD0\\uFFD1\\uFFD8\\uFFD9\\uFFDD-\\uFFDF\\uFFE7\\uFFEF-\\uFFFB\\uFFFE\\uFFFF]/g;\r\nexport const ANSI_ESCAPE_REGEX = /(\\\\u001b|\\\\x1b)(8|7|H|>|\\[(\\?\\d+(h|l)|[0-2]?(K|J)|\\d*(A|B|C|D\\D|E|F|G|g|i|m|n|S|s|T|u)|1000D\\d+|\\d*;\\d*(f|H|r|m)|\\d+;\\d+;\\d+m))/g;\r\n\r\n// eslint-disable-next-line no-control-regex, no-misleading-character-class\r\nexport const ANSI_UNESCAPED_REGEX = /(\\u001b|\\x1b)\\[(\\d+)?(;\\d+)*m/g;\r\n\r\n\r\nconst FG = {\r\n    reset: \"\\x1B[39m\",\r\n    black: \"\\x1B[30m\",\r\n    red: \"\\x1B[31m\",\r\n    green: \"\\x1B[32m\",\r\n    yellow: \"\\x1B[33m\",\r\n    blue: \"\\x1B[34m\",\r\n    magenta: \"\\x1B[35m\",\r\n    cyan: \"\\x1B[36m\",\r\n    white: \"\\x1B[37m\",\r\n    gray: \"\\x1B[90m\"\r\n};\r\n\r\nconst BG = {\r\n    reset: \"\\x1B[49m\",\r\n    black: \"\\x1B[40m\",\r\n    red: \"\\x1B[41m\",\r\n    green: \"\\x1B[42m\",\r\n    yellow: \"\\x1B[44m\",\r\n    blue: \"\\x1B[44m\",\r\n    magenta: \"\\x1B[45m\",\r\n    cyan: \"\\x1B[46m\",\r\n    white: \"\\x1B[47m\",\r\n    gray: \"\\x1B[100m\"\r\n}\r\n\r\nconst STYLE = {\r\n    reset_all: \"\\x1B[0m\",\r\n    bold: \"\\x1B[1m\",\r\n    dim: \"\\x1B[2m\",\r\n    no_bold_or_dim: \"\\x1B[22m\",\r\n    italic: \"\\x1B[3m\",\r\n    no_italic: \"\\x1B[23m\",\r\n    underline: \"\\x1B[4m\",\r\n    double_underline: \"\\x1B[21m\",\r\n    no_underline: \"\\x1B[24m\",\r\n    inverse: \"\\x1B[7m\",\r\n    no_inverse: \"\\x1B[27m\",\r\n    hidden: \"\\x1B[8m\",\r\n    no_hidden: \"\\x1B[28m\",\r\n    strikethrough: \"\\x1B[9m\",\r\n    no_strikethrough: \"\\x1B[29m\",\r\n    negative: \"\\x1B[7m\",\r\n    positive: \"\\x1B[27m\"\r\n}\r\n\r\nconst CURSOR = {\r\n    // TODO: move cursor manipulation from edit to substitution functions here\r\n    invisible: \"\\x1B[?25l\",\r\n    visible: \"\\x1B[?25h\",\r\n}\r\n\r\nconst PREFABS = {\r\n    program_name: FG.cyan + STYLE.italic + STYLE.bold,\r\n    error: FG.red + STYLE.bold,\r\n    variable_name: FG.yellow + STYLE.bold,\r\n    file_path: FG.green + STYLE.bold,\r\n    dir_name: FG.blue + STYLE.bold,\r\n    secret: STYLE.hidden + CURSOR.invisible,\r\n}\r\n\r\nexport const ANSI = {\r\n    FG,\r\n    BG,\r\n    STYLE,\r\n    CURSOR,\r\n    PREFABS\r\n}\r\n\r\n\r\n// TODO: docstrings everywhere\r\n\r\nexport interface ReadLineBuffer {\r\n    current_line: string;\r\n    current_index: number;\r\n    set_current_line: (new_line: string) => void;\r\n    set_current_index: (new_index: number) => void;\r\n}\r\n\r\nexport type ReadLineKeyHandler = (event: KeyEvent, term: WrappedTerminal, buffer: ReadLineBuffer) => void | Promise<void> | boolean | Promise<boolean>;\r\n\r\nexport class WrappedTerminal extends Terminal {\r\n    _disposable_onkey: IDisposable;\r\n\r\n    _key_handlers: Map<RegisteredKeyEventIdentifier, { handler: KeyEventHandler, block: boolean }[]> = new Map();\r\n    _on_printable_handlers: KeyEventHandler[] = [];\r\n    _key_event_queue: KeyEvent[] = [];\r\n    _is_handling_key_events = false;\r\n\r\n    _kernel_has_panicked = false;\r\n\r\n    // TODO: this exporting is a bit lazy, but it works for now\r\n\r\n    get ansi() {\r\n        return ANSI;\r\n    }\r\n\r\n    get newline() {\r\n        return NEWLINE;\r\n    }\r\n\r\n    get non_printable_regex() {\r\n        return NON_PRINTABLE_REGEX;\r\n    }\r\n\r\n    get ansi_escape_regex() {\r\n        return ANSI_ESCAPE_REGEX;\r\n    }\r\n\r\n    get ansi_unescaped_regex() {\r\n        return ANSI_UNESCAPED_REGEX;\r\n    }\r\n\r\n    // line discipline now completely handled by read_line, no global event loop\r\n    read_line = async (custom_key_handlers: { [key_string: string]: ReadLineKeyHandler } = {}, custom_printable_handler?: ReadLineKeyHandler): Promise<string> => {\r\n        const buffer: ReadLineBuffer = {\r\n            current_line: \"\",\r\n            current_index: 0,\r\n\r\n            set_current_line: (new_line: string) => {\r\n                buffer.current_line = new_line;\r\n            },\r\n\r\n            set_current_index: (new_index: number) => {\r\n                buffer.current_index = new_index;\r\n            }\r\n        };\r\n\r\n        let handler_dispose: (() => void) | null = null;\r\n\r\n        return new Promise<string>((resolve) => {\r\n            const handlers: { [key_string: string]: KeyEventHandler } = {\r\n                // arrow left - move cursor left\r\n                \"\\x1b[D\": (_e, term) => {\r\n                    if (buffer.current_index > 0) {\r\n                        term.write(\"\\b\");\r\n                        buffer.current_index--;\r\n                    }\r\n                },\r\n\r\n                // arrow right - move cursor right\r\n                \"\\x1b[C\": (_e, term) => {\r\n                    if (buffer.current_index < buffer.current_line.length) {\r\n                        term.write(buffer.current_line[buffer.current_index]);\r\n                        buffer.current_index++;\r\n                    }\r\n                },\r\n\r\n                // backspace - delete character\r\n                \"\\x7F\": (_e, term) => {\r\n                    if (buffer.current_line.length > 0 && buffer.current_index > 0) {\r\n                        // get everything before the cursor\r\n                        const before = buffer.current_line.slice(0, buffer.current_index - 1);\r\n\r\n                        // get everything after the cursor\r\n                        const after = buffer.current_line.slice(buffer.current_index);\r\n\r\n                        // update current line\r\n                        buffer.current_line = before + after;\r\n\r\n                        // move cursor back one\r\n                        term.write(\"\\b\");\r\n\r\n                        // overwrite with after content and a space (remove last character)\r\n                        term.write(after + \" \");\r\n\r\n                        // move cursor back to original position\r\n                        term.write(\"\\b\".repeat(after.length + 1));\r\n                        buffer.current_index--;\r\n                    }\r\n                },\r\n\r\n                // enter - finish line\r\n                \"\\r\": (_e, term) => {\r\n                    if (handler_dispose) {\r\n                        handler_dispose();\r\n                    }\r\n\r\n                    term.write(NEWLINE);\r\n                    resolve(buffer.current_line);\r\n                }\r\n            }\r\n\r\n            // register blocking catch all key handler which handles all keys during read_line\r\n            handler_dispose = this.register_key_event_handler(\r\n                async (e) => {\r\n                    // check for custom handlers first\r\n                    if (e.key in custom_key_handlers) {\r\n                        const block = await custom_key_handlers[e.key](e, this, buffer);\r\n\r\n                        if (block) {\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    // check for builtin handlers\r\n                    if (e.key in handlers) {\r\n                        await handlers[e.key](e, this);\r\n                        return;\r\n                    }\r\n\r\n                    // check for printable characters\r\n                    if (e.key.match(NON_PRINTABLE_REGEX) === null) {\r\n                        if (custom_printable_handler) {\r\n                            const block = await custom_printable_handler(e, this, buffer);\r\n\r\n                            if (block) {\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        // if at the end of the line, just append the character\r\n                        if (buffer.current_index === buffer.current_line.length) {\r\n                            buffer.current_line += e.key;\r\n                            this.write(e.key);\r\n                            buffer.current_index++;\r\n                            return;\r\n                        }\r\n\r\n                        // insert the character at the cursor, shift the rest of the line to the right\r\n                        const before_cursor = buffer.current_line.slice(0, buffer.current_index);\r\n                        const after_cursor = buffer.current_line.slice(buffer.current_index);\r\n                        buffer.current_line = before_cursor + e.key + after_cursor;\r\n\r\n                        // write the new right of the line over the old one\r\n                        this.write(e.key + after_cursor);\r\n\r\n                        // move back to the cursor position\r\n                        this.write(`\\x1b[${after_cursor.length}D`);\r\n\r\n                        // increment the cursor position\r\n                        buffer.current_index++;\r\n                    } else {\r\n                        console.warn(\"Ignored key event:\", e);\r\n                        // TODO: handle more special keys and sequences (probably in shells)\r\n                    }\r\n                },\r\n                {\r\n                    block: true,\r\n                    high_priority: true\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    _search_handlers = (key: string | undefined, domEventCode: string | undefined, strict = false): { handler: KeyEventHandler, block: boolean }[] => {\r\n        for (const pair of this._key_handlers.entries()) {\r\n            const identfier = pair[0] as RegisteredKeyEventIdentifier;\r\n\r\n            // if strict matching is required, both key and domEventCode must match\r\n            if (strict) {\r\n                if (identfier.key === key && identfier.domEventCode === domEventCode) {\r\n                    return pair[1] as { handler: KeyEventHandler, block: boolean }[];\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // if the identifier matches, return the entries\r\n            if (identfier.key === key || identfier.domEventCode === domEventCode) {\r\n                return pair[1] as { handler: KeyEventHandler, block: boolean }[];\r\n            }\r\n        }\r\n\r\n        // if no match is found, return an empty array\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Registers a key event handler.\r\n     * Handlers with no filter run BEFORE filtered handlers.\r\n     *\r\n     * @param {KeyEventHandler} handler The handler to register\r\n     * @param {{ keyString?: string, domEventCode?: string, block: boolean, high_priority: boolean }} props The properties of the handler. Key is the key as a string to filter by, domEventCode is the DOM event code to filter by. Block determines whether the event should be blocked from bubbling up to following handlers and/or the terminal display. High priority determines whether the handler should be placed at the beginning of the handler list.\r\n     * @returns {() => () => void} A function to unregister the handler\r\n     */\r\n    register_key_event_handler = (handler: KeyEventHandler, props: { keyString?: string, domEventCode?: string, block?: boolean, high_priority?: boolean }) => {\r\n        // build the identifier\r\n        const identifier: RegisteredKeyEventIdentifier = {\r\n            key: props.keyString,\r\n            domEventCode: props.domEventCode\r\n        };\r\n\r\n        const entry = { handler, block: props.block ?? false };\r\n\r\n        // if the identifier has not already been registered, create a new array for it\r\n        const existing_entries = this._search_handlers(props.keyString, props.domEventCode, true);\r\n        if (existing_entries.length === 0) {\r\n            this._key_handlers.set(identifier, [entry]);\r\n        } else {\r\n            // otherwise, add the handler to the existing array\r\n            // NOTE: reference is retained so no need to search\r\n            if (props.high_priority) {\r\n                existing_entries.unshift(entry);\r\n            } else {\r\n                existing_entries.push(entry);\r\n            }\r\n        }\r\n\r\n        // return a function to unregister the handler\r\n        // NOTE: reference is retained so no need to search\r\n        return () => {\r\n            const handlers = this._key_handlers.get(identifier);\r\n            if (!handlers) {\r\n                return;\r\n            }\r\n\r\n            handlers.splice(handlers.indexOf(entry), 1);\r\n\r\n            // if there are no more handlers for the identifier, remove the identifier from the map\r\n            if (handlers.length === 0) {\r\n                this._key_handlers.delete(identifier);\r\n            }\r\n        }\r\n    }\r\n\r\n    _handle_key_event = async (e: KeyEvent): Promise<void> => {\r\n        // TODO: supress builtin key events when program is running, create ctrl+c handler\r\n\r\n        // look for any handlers against all keys\r\n        const all_key_entries = this._search_handlers(undefined, undefined, true);\r\n        if (all_key_entries) {\r\n            for (const entry of all_key_entries) {\r\n                // await if the handler is async\r\n                await entry.handler(e, this);\r\n\r\n                if (entry.block) {\r\n                    // if the handler is blocking, don't go to next handler or display logic\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // search the handlers for the key\r\n        const entries = this._search_handlers(e.key, e.domEvent.code);\r\n\r\n        // if there are any handlers, run them\r\n        for (const entry of entries) {\r\n            // await if the handler is async\r\n            await entry.handler(e, this);\r\n\r\n            if (entry.block) {\r\n                // if the handler is blocking, don't go to next handler or display logic\r\n                return;\r\n            }\r\n        }\r\n\r\n        // check if the key is printable\r\n        if (e.key.match(NON_PRINTABLE_REGEX) === null) {\r\n            // call any registered printable key handlers\r\n            for (const handler of this._on_printable_handlers) {\r\n                await handler(e, this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers a handler that is called when any printable key is pressed.\r\n     * @param handler  - The handler to register\r\n     * @param high_priority - If true, the handler will be placed at the beginning of the handler list (cannot run before the default printable key handler)\r\n     */\r\n    register_on_printable_key_event_handler = (handler: KeyEventHandler, high_priority = false) => {\r\n        if (high_priority) {\r\n            this._on_printable_handlers.unshift(handler);\r\n        } else {\r\n            this._on_printable_handlers.push(handler);\r\n        }\r\n    }\r\n\r\n    _enqueue_key_event = (e: KeyEvent) => {\r\n        this._key_event_queue.push(e);\r\n\r\n        // if the queue is not being handled, handle it\r\n        if (!this._is_handling_key_events) {\r\n            this._is_handling_key_events = true;\r\n            this._handle_key_event_queue();\r\n        }\r\n    }\r\n\r\n    _handle_key_event_queue = async () => {\r\n        // if there are no events in the queue, return\r\n        if (this._key_event_queue.length === 0) {\r\n            this._is_handling_key_events = false;\r\n            return;\r\n        }\r\n\r\n        if (this._is_handling_key_events) {\r\n            // handle the first event in the queue\r\n            await this._handle_key_event(this._key_event_queue.shift()!);\r\n\r\n            // handle the rest of the events in the queue\r\n            this._handle_key_event_queue();\r\n        }\r\n    }\r\n\r\n\r\n    // note that this does not recieve pasted input, use a key event handler for that\r\n    wait_for_keypress = async (): Promise<KeyEvent> => {\r\n        // dispose of the current key handler (block bubbling)\r\n        this._disposable_onkey.dispose();\r\n\r\n        return new Promise((resolve) => {\r\n            this._disposable_onkey = this.onKey((e) => {\r\n                // dispose of this handler\r\n                this._disposable_onkey.dispose();\r\n\r\n                // re-register the original handler\r\n                this._disposable_onkey = this.onKey(this._enqueue_key_event);\r\n\r\n                // resolve the promise\r\n                resolve(e);\r\n            });\r\n        });\r\n    }\r\n\r\n    get_text = async (max_length?: number): Promise<string> => {\r\n        let text = \"\";\r\n\r\n        return new Promise((resolve) => {\r\n            const unregister_handler = this.register_key_event_handler(\r\n                (e) => {\r\n                    if (e.key === \"\\r\") {\r\n                        // if the key is enter, return the text\r\n                        unregister_handler();\r\n                        resolve(text);\r\n                    } else if (e.key === \"\\x7F\") {\r\n                        // if the key is backspace, remove the last character\r\n                        if (text.length > 0) {\r\n                            text = text.slice(0, -1);\r\n                            this.write(\"\\b \\b\");\r\n                        }\r\n                    } else if (e.key.match(NON_PRINTABLE_REGEX) === null) {\r\n                        // if the key is printable, add it to the text\r\n                        if (max_length === undefined || text.length < max_length) {\r\n                            text += e.key;\r\n                            this.write(e.key);\r\n                        }\r\n                    }\r\n                },\r\n                {\r\n                    block: true,\r\n                    high_priority: true\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    word_wrap(text: string, width: number): string {\r\n        const lines = text.split(NEWLINE);\r\n        const wrapped_lines: string[] = [];\r\n\r\n        for (const line of lines) {\r\n            const words = line.split(\" \");\r\n            let current_line = \"\";\r\n\r\n            for (const word of words) {\r\n                if (current_line.length + word.length + 1 > width) {\r\n                    // push word by word until the line is full\r\n                    wrapped_lines.push(current_line);\r\n                    current_line = word;\r\n                } else {\r\n                    // if the current line is empty, don't add a space\r\n                    if (current_line.length === 0) {\r\n                        current_line = word;\r\n                    } else {\r\n                        current_line += \" \" + word;\r\n                    }\r\n                }\r\n            }\r\n\r\n            wrapped_lines.push(current_line);\r\n        }\r\n\r\n        return wrapped_lines.join(NEWLINE);\r\n    }\r\n\r\n    copy() {\r\n        // copy the selected text to the clipboard\r\n        navigator.clipboard.writeText(this.getSelection()).then(() => {\r\n            // clear the selection\r\n            this.clearSelection();\r\n        });\r\n    }\r\n\r\n    paste() {\r\n        if (this._kernel_has_panicked) {\r\n            return;\r\n        }\r\n\r\n        // TODO: sometimes has issues with large text (queue consumption not restarted properly after execution)\r\n        // read the clipboard\r\n        navigator.clipboard.readText().then((text) => {\r\n            // simulate key events for each character (lazy but it works great, no need to rewrite the key handler)\r\n            for (const char of text) {\r\n                let dom_event_code = `Key${char.toUpperCase()}`;\r\n                let key = char;\r\n\r\n                if (char === \"\\r\") {\r\n                    // skip, its CRLF\r\n                    continue;\r\n                }\r\n\r\n                if (char === \"\\n\") {\r\n                    key = \"\\r\";\r\n                    dom_event_code = \"Enter\";\r\n                }\r\n\r\n                if (char === \" \") {\r\n                    dom_event_code = \"Space\";\r\n                }\r\n\r\n                this._key_event_queue.push(({ key, domEvent: { code: dom_event_code } } as KeyEvent));\r\n            }\r\n\r\n            // if the queue is not being handled, handle it\r\n            if (!this._is_handling_key_events) {\r\n                this._is_handling_key_events = true;\r\n                this._handle_key_event_queue();\r\n            }\r\n        });\r\n    }\r\n\r\n    copy_or_paste() {\r\n        // if there is a selection, copy it\r\n        if (this.hasSelection()) {\r\n            this.copy();\r\n        } else {\r\n            this.paste();\r\n        }\r\n    }\r\n\r\n    handle_kernel_panic = (message: string, process_info: string, debug_info?: string) => {\r\n        if (this._kernel_has_panicked) {\r\n            return;\r\n        }\r\n\r\n        this._kernel_has_panicked = true;\r\n\r\n        this.reset();\r\n\r\n        // stop reading key events\r\n        this._disposable_onkey.dispose();\r\n        this.write(ANSI.CURSOR.invisible);\r\n\r\n        if (this.textarea) {\r\n            this.textarea.disabled = true;\r\n        }\r\n\r\n        this.writeln(`${ANSI.BG.red + ANSI.FG.white}Panic: ${message}`);\r\n        this.writeln(`at time: ${new Date().toISOString()}`);\r\n\r\n        this.write(NEWLINE);\r\n        this.writeln(\"Debug info:\");\r\n        if (debug_info) {\r\n            this.writeln(debug_info);\r\n        } else {\r\n            this.writeln(\"No debug info provided.\");\r\n        }\r\n\r\n        this.write(NEWLINE);\r\n        this.writeln(\"Processes running at time of panic:\");\r\n        this.writeln(process_info || \"None.\");\r\n\r\n        if (typeof window !== \"undefined\") {\r\n            this.write(NEWLINE);\r\n            this.writeln(\"OS unrecoverable?\")\r\n            this.writeln(`Visit ${window.location.origin}/recover_fs if stuck.`);\r\n        }\r\n\r\n        this.writeln(ANSI.STYLE.reset_all);\r\n    }\r\n\r\n    constructor(xterm_opts?: ITerminalOptions) {\r\n        super(xterm_opts);\r\n        this._disposable_onkey = this.onKey(this._enqueue_key_event);\r\n    }\r\n}\r\n\r\n// as of 09/01/2026, the god class of WrappedTerminal is no more!\r\n// this used to be the kernel, shell, tty, and bootstrap all in one\r\n","import type { Program, ProgramRegistrant } from \"./types\";\r\nimport type { AbstractFileSystem } from \"./filesystem\";\r\nimport { ANSI, WrappedTerminal } from \"./term_ctl\";\r\n\r\nconst encode_js_to_url = (js_code: string): string => {\r\n    const encoded = encodeURIComponent(js_code);\r\n    return `data:text/javascript;charset=utf-8,${encoded}`;\r\n}\r\n\r\nexport const build_registrant_from_js = async (js_code: string, built_in = false): Promise<ProgramRegistrant> => {\r\n    // inspect the js code to see if it starts with \"import\". if so, this is outdated, put a deprecation warning\r\n    let warn_deprecation = false;\r\n    if (js_code.startsWith(\"import\")) {\r\n        // delay the warning as we might find out the program name later\r\n        warn_deprecation = true;\r\n    }\r\n\r\n    // note: the webpackIgnore bypasses webpack's import() function and uses the browser's native import() function\r\n    // this is because webpack's import() function does not support data urls\r\n\r\n    const data_url = encode_js_to_url(js_code);\r\n    // note: risk to user, show warning\r\n    const imp = await import(/* webpackIgnore: true */data_url);\r\n    let program = imp.default;\r\n\r\n    if (program === undefined) {\r\n        if (warn_deprecation) {\r\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\r\n        }\r\n\r\n        throw new Error(\"Program is not the default export.\");\r\n    }\r\n\r\n    // validate program\r\n    if (typeof program !== \"object\") {\r\n        if (warn_deprecation) {\r\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\r\n        }\r\n\r\n        throw new Error(\"Program is not an object.\");\r\n    }\r\n\r\n    program = program as object;\r\n\r\n    if (typeof program.name !== \"string\") {\r\n        if (warn_deprecation) {\r\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\r\n        }\r\n\r\n        throw new Error(\"Program does not have a name.\");\r\n    }\r\n\r\n    if (warn_deprecation) {\r\n        console.warn(`Program ${program.name} has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.`);\r\n    }\r\n\r\n    // not warning about compat here to make it more obvious to end users when they try to run an incompatible program\r\n\r\n    if (globalThis.OLLIEOS_NODE && program.node_opt_out) {\r\n        throw new Error(`Program ${program.name} is not compatible with Node.js.`);\r\n    }\r\n\r\n    if (typeof program.description !== \"string\") {\r\n        throw new Error(`Program ${program.name} does not have a description.`);\r\n    }\r\n\r\n    if (typeof program.usage_suffix !== \"string\") {\r\n        throw new Error(`Program ${program.name} does not have a usage suffix.`);\r\n    }\r\n\r\n    if (typeof program.arg_descriptions !== \"object\") {\r\n        throw new Error(`Program ${program.name} does not have argument descriptions.`);\r\n    }\r\n\r\n    // migration: we got rid of syncprogram (with main) and asyncprogram (async_main)\r\n    // now there is a single async type called program\r\n    // problem: older packages have a field called async_main, and some have main that doesn't return a promise\r\n    if (!program.main) {\r\n        if (!program.async_main) {\r\n            throw new Error(`Program ${program.name} does not have a main function.`);\r\n        }\r\n\r\n        console.warn(`Program ${program.name} has an async_main function. This is deprecated and will be removed in the future. Please use main instead.`);\r\n\r\n        // migrate: rename async_main to main\r\n        program.main = program.async_main;\r\n        delete program.async_main;\r\n    }\r\n\r\n    if (program.main !== undefined && program.async_main !== undefined) {\r\n        throw new Error(`Program ${program.name} has both a main and async_main (deprecated) function.`);\r\n    }\r\n\r\n    // check if main is async\r\n    if (program.main !== undefined && program.main.constructor.name !== \"AsyncFunction\") {\r\n        console.warn(`Program ${program.name} has a main function that is not async. This is deprecated and will be removed in the future. Please make main async.`);\r\n\r\n        // migrate: wrap main in an async function\r\n        const old_main = program.main;\r\n        program.main = async (data) => {\r\n            return old_main(data);\r\n        }\r\n    }\r\n\r\n    program = program as Program;\r\n\r\n    // can't check what it takes and returns because javascript!\r\n    // just register it and the user can deal with the error if it doesn't work\r\n\r\n    return {\r\n        program,\r\n        built_in,\r\n    };\r\n}\r\n\r\nexport const determine_program_name_from_js = async (js_code: string): Promise<string> => {\r\n    const reg = await build_registrant_from_js(js_code);\r\n    return reg.program.name;\r\n}\r\n\r\n\r\n// mounts and registers a program and outputs errors to the terminal\r\nexport const mount_and_register_with_output = async (filename: string, content: string, prog_reg: ProgramRegistry, term: WrappedTerminal, output_success = false) => {\r\n    const { PREFABS, FG, STYLE } = ANSI;\r\n\r\n    let reg: ProgramRegistrant;\r\n\r\n    try {\r\n        reg = await build_registrant_from_js(content);\r\n    } catch (e) {\r\n        if (e.message.endsWith(\"is not compatible with Node.js.\")) {\r\n            // silently skip node.js incompatible programs\r\n            // yes this is a weird way to do it, but better than changing how build_registrant works\r\n            return;\r\n        }\r\n\r\n        term.writeln(`${PREFABS.error}Failed to prepare program from '${filename}'.${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}${e}${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}Skipping mount...${STYLE.reset_all}`);\r\n        return;\r\n    }\r\n\r\n    try {\r\n        prog_reg.registerProgram(reg);\r\n\r\n        if (output_success) {\r\n            term.writeln(`${FG.cyan}(+) ${reg.program.name}${STYLE.reset_all}`);\r\n        }\r\n    } catch (e) {\r\n        term.writeln(`${PREFABS.error}Failed to mount program '${reg.program.name}'.${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}${e}${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}Skipping mount...${STYLE.reset_all}`);\r\n    }\r\n}\r\n\r\n// recurses through a directory and mounts and registers all programs in it as well as its subdirectories\r\nexport const recurse_mount_and_register_with_output = async (fs: AbstractFileSystem, dir_path: string, prog_registry: ProgramRegistry, term: WrappedTerminal) => {\r\n    const entries = await fs.list_dir(dir_path);\r\n\r\n    for (const entry of entries) {\r\n        const entry_path = fs.join(dir_path, entry);\r\n\r\n        if (await fs.dir_exists(entry_path)) {\r\n            await recurse_mount_and_register_with_output(fs, entry_path, prog_registry, term);\r\n        } else {\r\n            if (!entry.endsWith(\".js\")) {\r\n                continue;\r\n            }\r\n\r\n            const content = await fs.read_file(entry_path) as string;\r\n            await mount_and_register_with_output(entry, content, prog_registry, term);\r\n        }\r\n    }\r\n}\r\n\r\n// TODO: these 2 methods are a bit messy! perhaps remove the output stuff and just have the user deal with it\r\n\r\n\r\nexport class ProgramRegistry {\r\n    _program_regs: Map<string, ProgramRegistrant> = new Map();\r\n\r\n\r\n    registerProgram(program_reg: ProgramRegistrant) {\r\n        const program = program_reg.program;\r\n\r\n        if (this._program_regs.has(program.name)) {\r\n            throw new Error(`Program with name ${program.name} already exists.`);\r\n        }\r\n\r\n        if (globalThis.OLLIEOS_NODE && program.node_opt_out) {\r\n            // don't register this program if it is not compatible with node.js\r\n            return;\r\n        }\r\n\r\n        this._program_regs.set(program.name, program_reg);\r\n    }\r\n\r\n\r\n    getProgramRegistrant(name: string): ProgramRegistrant | undefined {\r\n        return this._program_regs.get(name);\r\n    }\r\n\r\n    getProgram(name: string): Program | undefined {\r\n        const program_reg = this.getProgramRegistrant(name);\r\n        if (program_reg === undefined) {\r\n            return undefined;\r\n        }\r\n\r\n        return program_reg.program;\r\n    }\r\n\r\n\r\n    listProgramRegistrants(includes_builtin = true, includes_mounted = false): ProgramRegistrant[] {\r\n        const arr = Array.from(this._program_regs.values());\r\n\r\n        if (includes_builtin && includes_mounted) {\r\n            return arr;\r\n        }\r\n\r\n        if (includes_builtin && !includes_mounted) {\r\n            return arr.filter((program_reg) => program_reg.built_in);\r\n        }\r\n\r\n        if (!includes_builtin && includes_mounted) {\r\n            return arr.filter((program_reg) => !program_reg.built_in);\r\n        }\r\n    }\r\n\r\n    listProgramNames(includes_builtin = true, includes_mounted = false): string[] {\r\n        const arr = Array.from(this._program_regs.keys());\r\n\r\n        if (includes_builtin && includes_mounted) {\r\n            return arr;\r\n        }\r\n\r\n        if (includes_builtin && !includes_mounted) {\r\n            return arr.filter((program_name) => this.getProgramRegistrant(program_name)?.built_in);\r\n        }\r\n\r\n        if (!includes_builtin && includes_mounted) {\r\n            return arr.filter((program_name) => !this.getProgramRegistrant(program_name)?.built_in);\r\n        }\r\n    }\r\n\r\n    listPrograms(includes_builtin = true, includes_mounted = false): Program[] {\r\n        return this.listProgramRegistrants(includes_builtin, includes_mounted).map((program_reg) => program_reg.program);\r\n    }\r\n\r\n\r\n    forceUnregister(name: string) {\r\n        this._program_regs.delete(name);\r\n    }\r\n\r\n    unregister(name: string) {\r\n        if (!this._program_regs.has(name)) {\r\n            throw new Error(`Program with name ${name} does not exist.`);\r\n        }\r\n\r\n        this.forceUnregister(name);\r\n    }\r\n\r\n    // TODO: move usage of above methods to use class methods instead of the standalone functions\r\n\r\n    static async build_registrant_from_js(js_code: string, built_in = false): Promise<ProgramRegistrant> {\r\n        return build_registrant_from_js(js_code, built_in);\r\n    }\r\n\r\n    static async determine_program_name_from_js(js_code: string): Promise<string> {\r\n        return determine_program_name_from_js(js_code);\r\n    }\r\n\r\n    async mount_and_register_with_output(filename: string, content: string, term: WrappedTerminal, output_success = false) {\r\n        return mount_and_register_with_output(filename, content, this, term, output_success);\r\n    }\r\n\r\n    async recurse_mount_and_register_with_output(fs: AbstractFileSystem, dir_path: string, term: WrappedTerminal) {\r\n        return recurse_mount_and_register_with_output(fs, dir_path, this, term);\r\n    }\r\n}\r\n","import type {AbstractWindow, AbstractWindowManager} from \"./windowing\";\r\nimport {LineParseResultCommand} from \"./programs/core/ash/parser\";\r\n\r\nexport interface IPCMessage {\r\n    from: number;\r\n    to: number;\r\n\r\n    data: unknown;\r\n}\r\n\r\nexport type IPCChannelListener = (msg: IPCMessage) => Promise<void>;\r\n\r\ninterface IPCChannel {\r\n    initiator: number;\r\n    peer: number;\r\n\r\n    initiator_to_peer_queue: IPCMessage[];\r\n    peer_to_initiator_queue: IPCMessage[];\r\n\r\n    // pid -> set of listeners\r\n    listeners: Map<number, Set<IPCChannelListener>>;\r\n}\r\n\r\nexport type IPCServiceOnConnectionCallback = (channel_id: number, from_pid: number) => Promise<void>;\r\n\r\ninterface IPCService {\r\n    pid: number;\r\n    on_connection: IPCServiceOnConnectionCallback;\r\n}\r\n\r\nexport class IPCManager {\r\n    private readonly _process_manager: ProcessManager;\r\n\r\n    // service name -> IPCService\r\n    private readonly _services: Map<string, IPCService> = new Map();\r\n\r\n    // channel id -> IPCChannel\r\n    private readonly _channels: Map<number, IPCChannel> = new Map();\r\n    private _next_channel_id = 1;\r\n\r\n    constructor(process_manager: ProcessManager) {\r\n        this._process_manager = process_manager;\r\n\r\n        // clean up dead services and channels periodically\r\n        // TODO: add a global exit listener to process manager to be immediately notified of process exits\r\n        setInterval(() => {\r\n            // clean up services\r\n            for (const [name, service] of this._services) {\r\n                const process = this._process_manager.get_process(service.pid);\r\n                if (!process) {\r\n                    this._services.delete(name);\r\n                }\r\n            }\r\n\r\n            // clean up channels\r\n            for (const [channel_id, channel] of this._channels) {\r\n                const initiator_process = this._process_manager.get_process(channel.initiator);\r\n                const peer_process = this._process_manager.get_process(channel.peer);\r\n\r\n                if (!initiator_process || !peer_process) {\r\n                    this._channels.delete(channel_id);\r\n                }\r\n            }\r\n        }, 10000);\r\n    }\r\n\r\n    dispose_all(): void {\r\n        this._services.clear();\r\n        this._channels.clear();\r\n    }\r\n\r\n    service_register(name: string, pid: number, on_connection: IPCServiceOnConnectionCallback): void {\r\n        this._services.set(name, { pid, on_connection });\r\n    }\r\n\r\n    // TODO: disconnect callback? or change the on_connection to on_event with different event types\r\n\r\n    service_unregister(name: string): void {\r\n        this._services.delete(name);\r\n    }\r\n\r\n    service_lookup(name: string): number | undefined {\r\n        const service = this._services.get(name);\r\n\r\n        if (!service) {\r\n            return undefined;\r\n        }\r\n\r\n        // check if process is still running\r\n        const process = this._process_manager.get_process(service.pid);\r\n        if (!process) {\r\n            this._services.delete(name);\r\n            return undefined;\r\n        }\r\n\r\n        return service.pid;\r\n    }\r\n\r\n    create_channel(initiator_pid: number, service_name: string): number | null {\r\n        const channel_id = this._next_channel_id++;\r\n        const peer_pid = this.service_lookup(service_name);\r\n\r\n        if (!peer_pid) {\r\n            return null;\r\n        }\r\n\r\n        this._channels.set(channel_id, {\r\n            initiator: initiator_pid,\r\n            peer: peer_pid,\r\n\r\n            initiator_to_peer_queue: [],\r\n            peer_to_initiator_queue: [],\r\n\r\n            listeners: new Map(),\r\n        });\r\n\r\n        // notify service of new connection without blocking\r\n        const service = this._services.get(service_name)!;\r\n        service.on_connection(channel_id, initiator_pid).catch((err) => {\r\n            console.error(\"IPC service on_connection error:\", err);\r\n        });\r\n\r\n        return channel_id;\r\n    }\r\n\r\n    destroy_channel(channel_id: number): void {\r\n        this._channels.delete(channel_id);\r\n    }\r\n\r\n    channel_listen(channel_id: number, listening_pid: number, listener: IPCChannelListener): boolean {\r\n        const channel = this._channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        if (channel.initiator !== listening_pid && channel.peer !== listening_pid) {\r\n            return false;\r\n        }\r\n\r\n        if (!channel.listeners.has(listening_pid)) {\r\n            channel.listeners.set(listening_pid, new Set());\r\n        }\r\n\r\n        channel.listeners.get(listening_pid)!.add(listener);\r\n        return true;\r\n    }\r\n\r\n    channel_unlisten(channel_id: number, listening_pid: number, listener: IPCChannelListener): boolean {\r\n        const channel = this._channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        if (channel.initiator !== listening_pid && channel.peer !== listening_pid) {\r\n            return false;\r\n        }\r\n\r\n        const listeners = channel.listeners.get(listening_pid);\r\n        if (!listeners) {\r\n            return false;\r\n        }\r\n\r\n        listeners.delete(listener);\r\n        return true;\r\n    }\r\n\r\n    channel_send(channel_id: number, from_pid: number, data: unknown): boolean {\r\n        const channel = this._channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        let msg: IPCMessage;\r\n        if (channel.initiator === from_pid) {\r\n            msg = {\r\n                from: from_pid,\r\n                to: channel.peer,\r\n                data,\r\n            };\r\n\r\n            channel.initiator_to_peer_queue.push(msg);\r\n        } else if (channel.peer === from_pid) {\r\n            msg = {\r\n                from: from_pid,\r\n                to: channel.initiator,\r\n                data,\r\n            };\r\n\r\n            channel.peer_to_initiator_queue.push(msg);\r\n        } else {\r\n            return false;\r\n        }\r\n\r\n        // notify listeners on the receiving end without blocking\r\n        const to_pid = msg.to;\r\n        const listeners = channel.listeners.get(to_pid);\r\n        if (listeners) {\r\n            for (const listener of listeners) {\r\n                listener(msg).catch((err) => {\r\n                    console.error(\"IPC channel listener error:\", err);\r\n                });\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// TODO: could migrate the stuff where programs grab \"scary\" stuff like WindowManager and ProcessManager to be services\r\n\r\nenum ProcessAttachment {\r\n    FOREGROUND,\r\n    BACKGROUND,\r\n    DETACHED,\r\n}\r\n\r\nexport class ProcessContext {\r\n    private readonly _pid: number;\r\n    private readonly _manager: ProcessManager;\r\n\r\n    private readonly _source_command: LineParseResultCommand;\r\n    private readonly _created_at: Date = new Date();\r\n\r\n    private readonly _exit_listeners: Set<(exit_code: number) => Promise<void> | void> = new Set();\r\n\r\n    private _attachment: ProcessAttachment = ProcessAttachment.FOREGROUND;\r\n    private _detach_silently = false;\r\n\r\n    private readonly _timeouts: Set<number> = new Set();\r\n    private readonly _timeout_promises: Map<number, Set<{resolve: (finished: boolean) => void}>> = new Map(); // timeout id -> promise resolvers (for waiting on timeouts but listening to cancellation)\r\n    private readonly _timeout_cancel_callbacks: Map<number, () => void> = new Map(); // timeout id -> cancel callback\r\n\r\n    private readonly _intervals: Set<number> = new Set();\r\n\r\n    private readonly _windows: Set<AbstractWindow> = new Set();\r\n\r\n    constructor(pid: number, source_command: LineParseResultCommand, registry: ProcessManager) {\r\n        this._pid = pid;\r\n        this._source_command = source_command;\r\n        this._manager = registry;\r\n\r\n        if (source_command.run_in_bg) {\r\n            this._attachment = ProcessAttachment.BACKGROUND;\r\n        }\r\n    }\r\n\r\n    get pid(): number {\r\n        return this._pid;\r\n    }\r\n\r\n    get source_command(): LineParseResultCommand {\r\n        return this._source_command;\r\n    }\r\n\r\n    get created_at(): Date {\r\n        return this._created_at;\r\n    }\r\n\r\n    get is_detached(): boolean {\r\n        return this._attachment === ProcessAttachment.DETACHED;\r\n    }\r\n\r\n    get is_background(): boolean {\r\n        return this._attachment === ProcessAttachment.BACKGROUND;\r\n    }\r\n\r\n    get is_foreground(): boolean {\r\n        return this._attachment === ProcessAttachment.FOREGROUND;\r\n    }\r\n\r\n    get attachment(): ProcessAttachment {\r\n        return this._attachment;\r\n    }\r\n\r\n    get detaches_silently(): boolean {\r\n        return this._detach_silently;\r\n    }\r\n\r\n    detach(silently = false): void {\r\n        this._attachment = ProcessAttachment.DETACHED;\r\n        this._detach_silently = silently;\r\n    }\r\n\r\n    dispose_resources(): void {\r\n        this._intervals.forEach((id) => {\r\n            clearInterval(id);\r\n        });\r\n\r\n        this._timeouts.forEach((id) => {\r\n            clearTimeout(id);\r\n        });\r\n\r\n        this._timeout_promises.clear();\r\n        this._timeout_cancel_callbacks.clear();\r\n\r\n        this._windows.forEach((win) => {\r\n            win.dispose();\r\n        });\r\n    }\r\n\r\n    kill(exit_code = 0): void {\r\n        this.dispose_resources();\r\n\r\n        this._manager.mark_terminated(this._pid);\r\n\r\n        for (const listener of this._exit_listeners) {\r\n            listener(exit_code);\r\n        }\r\n    }\r\n\r\n    add_exit_listener(listener: (exit_code: number) => Promise<void> | void): void {\r\n        this._exit_listeners.add(listener);\r\n    }\r\n\r\n    create_timeout(callback: () => void, delay: number, on_cancel? : () => void): number {\r\n        const id = window.setTimeout(() => {\r\n            this._timeouts.delete(id);\r\n\r\n            // resolve any waiters\r\n            if (this._timeout_promises.has(id)) {\r\n                const resolvers = this._timeout_promises.get(id)!;\r\n                for (const { resolve } of resolvers) {\r\n                    resolve(true);\r\n                }\r\n                this._timeout_promises.delete(id);\r\n            }\r\n\r\n            callback();\r\n\r\n            if (on_cancel) {\r\n                this._timeout_cancel_callbacks.delete(id);\r\n            }\r\n        }, delay);\r\n\r\n        this._timeouts.add(id);\r\n\r\n        if (on_cancel) {\r\n            this._timeout_cancel_callbacks.set(id, on_cancel);\r\n        }\r\n\r\n        return id;\r\n    }\r\n\r\n    cancel_timeout(id: number): void {\r\n        if (this._timeouts.has(id)) {\r\n            clearTimeout(id);\r\n            this._timeouts.delete(id);\r\n\r\n            // resolve any waiters as cancelled\r\n            if (this._timeout_promises.has(id)) {\r\n                const resolvers = this._timeout_promises.get(id)!;\r\n                for (const {resolve} of resolvers) {\r\n                    resolve(false);\r\n                }\r\n                this._timeout_promises.delete(id);\r\n            }\r\n\r\n            // call cancel callback if exists\r\n            if (this._timeout_cancel_callbacks.has(id)) {\r\n                const cancel_callback = this._timeout_cancel_callbacks.get(id)!;\r\n                cancel_callback();\r\n                this._timeout_cancel_callbacks.delete(id);\r\n            }\r\n        }\r\n    }\r\n\r\n    has_timeout(id: number): boolean {\r\n        return this._timeouts.has(id);\r\n    }\r\n\r\n    create_interval(callback: () => void, interval: number): number {\r\n        const id = window.setInterval(callback, interval);\r\n        this._intervals.add(id);\r\n        return id;\r\n    }\r\n\r\n    has_interval(id: number): boolean {\r\n        return this._intervals.has(id);\r\n    }\r\n\r\n    clear_interval(id: number): void {\r\n        if (this._intervals.has(id)) {\r\n            clearInterval(id);\r\n            this._intervals.delete(id);\r\n        }\r\n    }\r\n\r\n    async wait_for_timeout(id: number): Promise<boolean> {\r\n        if (!this._timeouts.has(id)) {\r\n            throw new Error(`Timeout ID ${id} does not exist.`);\r\n        }\r\n\r\n        return new Promise<boolean>((resolve) => {\r\n            if (!this._timeout_promises.has(id)) {\r\n                this._timeout_promises.set(id, new Set());\r\n            }\r\n\r\n            this._timeout_promises.get(id)!.add({ resolve });\r\n        });\r\n    }\r\n\r\n    create_window(): AbstractWindow | null {\r\n        const wm = this._manager.window_manager;\r\n        if (!wm) {\r\n            return null;\r\n        }\r\n\r\n        const win = new wm.Window(this._pid);\r\n        this._windows.add(win);\r\n\r\n        // clean up on close\r\n        win.add_event_listener(\"close\", () => {\r\n            this._windows.delete(win);\r\n        });\r\n\r\n        return win;\r\n    }\r\n}\r\n\r\nexport class ProcessManager {\r\n    private readonly _processes: Map<number, ProcessContext> = new Map();\r\n    private _next_pid = 1;\r\n\r\n    private readonly _wm: AbstractWindowManager | null;\r\n    private readonly _ipc_manager: IPCManager = new IPCManager(this);\r\n\r\n    constructor(wm: AbstractWindowManager | null = null) {\r\n        this._wm = wm;\r\n    }\r\n\r\n    get window_manager(): AbstractWindowManager | null {\r\n        return this._wm;\r\n    }\r\n\r\n    get ipc_manager(): IPCManager {\r\n        return this._ipc_manager;\r\n    }\r\n\r\n    dispose_all(): void {\r\n        this._ipc_manager.dispose_all();\r\n\r\n        for (const process of this._processes.values()) {\r\n            process.dispose_resources();\r\n        }\r\n\r\n        this._processes.clear();\r\n    }\r\n\r\n    create_process(source_command: LineParseResultCommand): ProcessContext {\r\n        const pid = this._next_pid++;\r\n        const context = new ProcessContext(pid, source_command, this);\r\n        this._processes.set(pid, context);\r\n        return context;\r\n    }\r\n\r\n    get_process(pid: number): ProcessContext | undefined {\r\n        return this._processes.get(pid);\r\n    }\r\n\r\n    list_pids(): number[] {\r\n        return Array.from(this._processes.keys());\r\n    }\r\n\r\n    mark_terminated(pid: number): void {\r\n        this._processes.delete(pid);\r\n    }\r\n}\r\n","import { Howl } from \"howler\";\r\n\r\nexport class SoundRegistry {\r\n    _registry: Map<string, { ready: boolean, howl: Howl }> = new Map();\r\n\r\n    register_howl(name: string, howl: Howl, ready = false) {\r\n        this._registry.set(name, { ready, howl });\r\n    }\r\n\r\n    register_file(name: string, file: string) {\r\n        const howl = new Howl({\r\n            src: [file],\r\n            onload: () => {\r\n                const entry = this._registry.get(name);\r\n                entry.ready = true;\r\n                this._registry.set(name, entry);\r\n            },\r\n        });\r\n\r\n        this.register_howl(name, howl);\r\n    }\r\n\r\n    async await_ready(name: string, interval = 100): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            const timer = setInterval(() => {\r\n                if (this._registry.get(name).ready) {\r\n                    clearInterval(timer);\r\n                    resolve();\r\n                }\r\n            }, interval);\r\n        });\r\n    }\r\n\r\n    play(name: string) {\r\n        if (!this._registry.has(name)) {\r\n            throw new Error(`Sound \"${name}\" is not registered.`);\r\n        }\r\n\r\n        if (!this._registry.get(name).ready) {\r\n            throw new Error(`Sound \"${name}\" is not ready yet.`);\r\n        }\r\n\r\n        this._registry.get(name).howl.play();\r\n    }\r\n\r\n    get(name: string) {\r\n        if (!this._registry.has(name)) {\r\n            throw new Error(`Sound \"${name}\" is not registered.`);\r\n        }\r\n\r\n        return this._registry.get(name).howl;\r\n    }\r\n\r\n    is_ready(name: string) {\r\n        return this._registry.get(name).ready;\r\n    }\r\n\r\n    wait_to_play(name: string, interval = 100) {\r\n        if (this.is_ready(name)) {\r\n            this.play(name);\r\n        } else {\r\n            console.log(`Sound ${name} is not ready yet, waiting...`);\r\n            this.await_ready(name, interval).then(() => {\r\n                this.play(name);\r\n            });\r\n        }\r\n    }\r\n}","import {ProgramRegistry, recurse_mount_and_register_with_output} from \"./prog_registry\";\r\nimport type {AbstractFileSystem} from \"./filesystem\";\r\n\r\n// TODO: organise this stuff to a kernel directory?\r\nimport {SoundRegistry} from \"./sfx_registry\";\r\nimport {AbstractWindowManager} from \"./windowing\";\r\nimport {IPCManager, ProcessContext, ProcessManager} from \"./processes\";\r\nimport type {AbstractShell} from \"./abstract_shell\";\r\n\r\n// TODO: decouple, either make generic interface or dont use at all\r\nimport type {LineParseResultCommand} from \"./programs/core/ash/parser\";\r\n\r\nimport {NEWLINE, type WrappedTerminal} from \"./term_ctl\";\r\n\r\nimport semver_validate from \"semver/functions/valid\";\r\nimport semver_compare from \"semver/functions/compare\"\r\n\r\nconst CURRENT_API_COMPAT = \"2.0.0\";\r\n\r\nexport interface SpawnResult {\r\n    process: ProcessContext;\r\n    completion: Promise<number>;\r\n}\r\n\r\nexport class Kernel {\r\n    _term: WrappedTerminal;\r\n    _process_manager: ProcessManager;\r\n    _prog_registry: ProgramRegistry;\r\n    _sfx_registry: SoundRegistry;\r\n    _fs: AbstractFileSystem;\r\n    _wm: AbstractWindowManager | null = null;\r\n\r\n    _panicked = false;\r\n\r\n    _env_info = {\r\n        version: \"unknown\",\r\n        env: \"unknown\"\r\n    }\r\n\r\n    get panicked(): boolean {\r\n        return this._panicked;\r\n    }\r\n\r\n    get_program_registry(): ProgramRegistry {\r\n        return this._prog_registry;\r\n    }\r\n\r\n    get_sound_registry(): SoundRegistry {\r\n        return this._sfx_registry;\r\n    }\r\n\r\n    get_fs(): AbstractFileSystem {\r\n        return this._fs;\r\n    }\r\n\r\n    get_window_manager(): AbstractWindowManager | null {\r\n        return this._wm;\r\n    }\r\n\r\n    has_window_manager(): boolean {\r\n        return this._wm !== null;\r\n    }\r\n\r\n    get_process_manager(): ProcessManager {\r\n        return this._process_manager;\r\n    }\r\n\r\n    get_ipc(): IPCManager {\r\n        return this._process_manager.ipc_manager;\r\n    }\r\n\r\n    get_env_info(): {version: string, env: string} {\r\n        return this._env_info;\r\n    }\r\n\r\n    set_env_info(version: string, env: string) {\r\n        this._env_info.version = version;\r\n        this._env_info.env = env;\r\n    }\r\n\r\n    spawn = (command: string, args: string[] = [], shell?: AbstractShell, original_line_parse?: LineParseResultCommand): SpawnResult => {\r\n        // search for the command in the registry\r\n        const program = this._prog_registry.getProgram(command);\r\n        if (program === undefined) {\r\n            throw new Error(`Command not found: ${command}`);\r\n        }\r\n\r\n        let compat = \"1.0.0\";\r\n        if (typeof program.compat === \"string\") {\r\n            compat = program.compat;\r\n        }\r\n\r\n        if (!semver_validate(compat)) {\r\n            throw new Error(`Program ${program.name} has an invalid compat SemVer: ${compat}`);\r\n        }\r\n\r\n        if (semver_compare(compat, CURRENT_API_COMPAT) < 0) {\r\n            throw new Error(`Program ${program.name} is not compatible with OllieOS 2. (Add compat: \"2.0.0\" to the program object to mark it as ported.)`);\r\n        }\r\n\r\n        // we may not be provided a parsed line (if this is a direct call, not from execute()), but we can create one by assumption\r\n        const parsed_line: LineParseResultCommand = original_line_parse ?? {\r\n            type: \"command\",\r\n            command,\r\n            args,\r\n            unsubbed_args: args,\r\n            raw_parts: [command, ...args],\r\n            run_in_bg: false\r\n        };\r\n\r\n        // create new process context\r\n        const process = this._process_manager.create_process(parsed_line);\r\n\r\n        // if the command is found, run it\r\n        const data = {\r\n            kernel: this,\r\n            term: this._term,\r\n            args,\r\n            shell,\r\n            unsubbed_args: parsed_line.unsubbed_args,\r\n            raw_parts: parsed_line.raw_parts,\r\n            process\r\n        };\r\n\r\n        // TODO: is passing shell around annoying? how can it be alleviated without affecting separation of concerns?\r\n\r\n        // create a promise that resolves when the program completes\r\n        let result_promise: Promise<number>;\r\n        if (\"main\" in program) {\r\n            result_promise = Promise.resolve(program.main(data));\r\n        } else {\r\n            throw new Error(\"Invalid program type\");\r\n        }\r\n\r\n        return {\r\n            process,\r\n            completion: result_promise\r\n        };\r\n    }\r\n\r\n    panic(message: string, debug_info?: string) {\r\n        if (this._panicked) {\r\n            return;\r\n        }\r\n\r\n        this._panicked = true;\r\n\r\n        // print formatted panic to js console\r\n        console.error(`%cPANIC: ${message}\\n${debug_info || \"\"}`, \"background: red; color: white; font-weight: bold;\");\r\n\r\n        const proc_mgr = this.get_process_manager();\r\n        const pids = proc_mgr.list_pids();\r\n\r\n        let process_info = \"\"\r\n\r\n        for (const pid of pids) {\r\n            const proc = proc_mgr.get_process(pid);\r\n\r\n            if (proc) {\r\n                process_info += `- PID ${proc.pid}: ${proc.source_command.command} (started at ${proc.created_at.toISOString()})${NEWLINE}`;\r\n            }\r\n        }\r\n\r\n        // remove last NEWLINE\r\n        process_info = process_info.trimEnd();\r\n\r\n        proc_mgr.dispose_all();\r\n        this._term.handle_kernel_panic(message, process_info, debug_info);\r\n    }\r\n\r\n    async boot(on_init_spawned?: (kernel: Kernel) => Promise<void>): Promise<boolean> {\r\n        const fs = this.get_fs();\r\n\r\n        // mount all programs in any subdirectory of /usr/bin\r\n        // TODO: get rid of the concept of a programregistry being the sole way to run programs. mounting is a bad concept. it should be a cache, not the sole execution method. may need to redesign how programs are stored to have it be more part of the filesystem\r\n        // TODO: smarter system that has files to be mounted so any stray js files don't get mounted? or maybe it doesn't matter and is better mounting everything for hackability!\r\n        const usr_bin = fs.absolute(\"/usr/bin\");\r\n        if (await fs.exists(usr_bin)) {\r\n            await recurse_mount_and_register_with_output(fs, usr_bin, this.get_program_registry(), this._term);\r\n        }\r\n\r\n        // read /boot/init to determine init system\r\n        let init_program: string;\r\n        let init_args: string[] = [];\r\n\r\n        try {\r\n            const init_data = await fs.read_file(\"/boot/init\") as string;\r\n            init_program = init_data.trim();\r\n        } catch {\r\n            this.panic(\"Failed to read /boot/init to determine init system!\");\r\n            return false;\r\n        }\r\n\r\n        if (!init_program) {\r\n            this.panic(\"No init program specified in /boot/init!\");\r\n            return false;\r\n        }\r\n\r\n        // separate args if any\r\n        const init_parts = init_program.split(\" \");\r\n        init_program = init_parts[0];\r\n\r\n        if (init_parts.length > 1) {\r\n            init_args = init_parts.slice(1);\r\n        }\r\n\r\n        // run init program\r\n        try {\r\n            const init = this.spawn(init_program, init_args);\r\n\r\n            if (on_init_spawned) {\r\n                on_init_spawned(this).catch((e) => {\r\n                    console.error(e);\r\n                });\r\n            }\r\n\r\n            if (init.process.pid !== 1) {\r\n                this.panic(`init program ${init_program} did not start as PID 1!`);\r\n                return false;\r\n            }\r\n\r\n            try {\r\n                const exit_code = await init.completion;\r\n\r\n                this.panic(`init program ${init_program} exited ${exit_code === 0 ? \"unexpectedly\" : \"with an error\"}!`, `Exit code: ${exit_code}`);\r\n                return false;\r\n            } catch (e) {\r\n                console.error(e);\r\n                this.panic(`init program ${init_program} error!`, e.toString());\r\n                return false;\r\n            }\r\n        } catch (e) {\r\n            console.error(e);\r\n            this.panic(`Failed to start init program ${init_program}!`, e.toString());\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    constructor(term: WrappedTerminal, fs: AbstractFileSystem, prog_registry?: ProgramRegistry, sound_registry?: SoundRegistry, wm?: AbstractWindowManager) {\r\n        this._term = term;\r\n        this._fs = fs;\r\n        this._prog_registry = prog_registry || new ProgramRegistry();\r\n        this._sfx_registry = sound_registry || new SoundRegistry();\r\n        this._wm = wm || null;\r\n        this._process_manager = new ProcessManager(this._wm);\r\n    }\r\n}\r\n","import type {Kernel, SpawnResult} from \"../../../kernel\";\r\n\r\nconst SERVICES_DIR = \"/etc/services/\";\r\n\r\ninterface ServiceRestartPolicyBase {\r\n    on: \"failure\" | \"always\" | \"never\";\r\n}\r\n\r\ninterface ServiceRestartPolicyWithRules extends ServiceRestartPolicyBase {\r\n    on: \"failure\" | \"always\";\r\n    max_retries?: number;\r\n    delay_ms?: number;\r\n}\r\n\r\ntype ServiceRestartPolicy = ServiceRestartPolicyBase | ServiceRestartPolicyWithRules;\r\n\r\ninterface ServiceFile {\r\n    name?: string;\r\n    dependencies?: string[];\r\n    exec: string;\r\n    args?: string[];\r\n    oneshot?: boolean;\r\n    restart?: ServiceRestartPolicy;\r\n}\r\n\r\n// TODO: support oneshot\r\n// TODO: do something with name\r\n// TODO: do something with max_retries\r\n\r\ninterface ServiceFileWithId extends ServiceFile {\r\n    id: string;\r\n}\r\n\r\nconst CLEAN_EXIT_CODES = new Set([0, 143]); // 0 = success, 143 = SIGTERM\r\n\r\ninterface ServiceStatusBase {\r\n    state: \"running\" | \"stopped\" | \"failed\";\r\n}\r\n\r\ninterface ServiceStatusNotRunning extends ServiceStatusBase {\r\n    state: \"stopped\" | \"failed\";\r\n}\r\n\r\ninterface ServiceStatusRunning extends ServiceStatusBase {\r\n    state: \"running\";\r\n    pid: number;\r\n}\r\n\r\n// TODO: store stop code for failed services\r\n// TODO: store start time for running services\r\n\r\nexport type ServiceStatus = ServiceStatusRunning | ServiceStatusNotRunning;\r\n\r\nexport class ServiceManager {\r\n    private readonly _kernel: Kernel;\r\n\r\n    private readonly _service_files: Map<string, ServiceFileWithId> = new Map();\r\n    private readonly _running_services: Map<string, SpawnResult> = new Map(); // service ID to spawn result\r\n    private readonly _should_be_running_services: Set<string> = new Set();\r\n    private readonly _failed_services: Set<string> = new Set();\r\n\r\n    constructor(kernel: Kernel) {\r\n        this._kernel = kernel;\r\n    }\r\n\r\n    async load_service_files() {\r\n        const fs = this._kernel.get_fs();\r\n\r\n        if (!await fs.exists(SERVICES_DIR)) {\r\n            console.warn(`Services directory ${SERVICES_DIR} does not exist. Skipping service loading.`);\r\n            return;\r\n        }\r\n\r\n        const service_files = await fs.list_dir(SERVICES_DIR);\r\n\r\n        // load each service file\r\n        for (const file_name of service_files) {\r\n            if (file_name.endsWith(\".service.json\")) {\r\n                const file_path = fs.join(SERVICES_DIR, file_name);\r\n                const file_content = await fs.read_file(file_path) as string;\r\n\r\n                try {\r\n                    const service_data = JSON.parse(file_content) as ServiceFile;\r\n                    const service_id = file_name.substring(0, file_name.length - \".service.json\".length);\r\n\r\n                    // TODO: validate service_data here\r\n\r\n                    const service: ServiceFileWithId = {\r\n                        id: service_id,\r\n                        ...service_data\r\n                    };\r\n\r\n                    // add or update service file\r\n                    this._service_files.set(service_id, service);\r\n                } catch (e) {\r\n                    console.error(`Failed to parse service file ${file_name}:`, e);\r\n                }\r\n            }\r\n        }\r\n\r\n        // remove any services that no longer exist\r\n        for (const existing_service_id of this._service_files.keys()) {\r\n            if (!service_files.includes(existing_service_id + \".service.json\")) {\r\n                this._service_files.delete(existing_service_id);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _calculate_service_start_order(): string[] {\r\n        const visited: Set<string> = new Set();\r\n        const temp_mark: Set<string> = new Set();\r\n        const result: string[] = [];\r\n\r\n        const visit = (service_id: string) => {\r\n            if (visited.has(service_id)) {\r\n                return;\r\n            }\r\n            if (temp_mark.has(service_id)) {\r\n                throw new Error(`Circular dependency detected involving service: ${service_id}`);\r\n            }\r\n\r\n            temp_mark.add(service_id);\r\n\r\n            const service = this._service_files.get(service_id);\r\n            if (service && service.dependencies) {\r\n                for (const dep of service.dependencies) {\r\n                    visit(dep);\r\n                }\r\n            }\r\n\r\n            temp_mark.delete(service_id);\r\n            visited.add(service_id);\r\n            result.push(service_id);\r\n        };\r\n\r\n        for (const service_id of this._service_files.keys()) {\r\n            visit(service_id);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    start_initial_services() {\r\n        const start_order = this._calculate_service_start_order();\r\n        for (const service_id of start_order) {\r\n            this.start_service(service_id);\r\n        }\r\n    }\r\n\r\n    start_service(service_id: string) {\r\n        // TODO: check dependencies are running\r\n\r\n        if (this._running_services.has(service_id)) {\r\n            console.warn(`Service ${service_id} is already running.`);\r\n            return;\r\n        }\r\n\r\n        const service = this._service_files.get(service_id);\r\n        if (!service) {\r\n            console.error(`Service ${service_id} not found.`);\r\n            return;\r\n        }\r\n\r\n        // mark service as should be running, so exit handlers know to restart it\r\n        this._should_be_running_services.add(service_id);\r\n\r\n        let spawn_result: SpawnResult;\r\n        try {\r\n            spawn_result = this._kernel.spawn(service.exec, service.args || []);\r\n        } catch (e) {\r\n            console.error(`Failed to start service ${service_id}:`, e);\r\n            return;\r\n        }\r\n\r\n        this._running_services.set(service_id, spawn_result);\r\n        this._failed_services.delete(service_id);\r\n\r\n        const { process, completion } = spawn_result;\r\n\r\n        // mark process as detached\r\n        process.detach(true);\r\n\r\n        // check for errors\r\n        completion.catch((e) => {\r\n            console.error(`Service ${service_id} encountered an error:`, e);\r\n            this._running_services.delete(service_id);\r\n            this._failed_services.add(service_id);\r\n            this._handle_service_exit(service_id, -1);\r\n        });\r\n\r\n        // handle normal exit\r\n        process.add_exit_listener((exit_code) => {\r\n            this._running_services.delete(service_id);\r\n            this._handle_service_exit(service_id, exit_code);\r\n        });\r\n    }\r\n\r\n    stop_service(service_id: string) {\r\n        if (!this._running_services.has(service_id)) {\r\n            console.warn(`Service ${service_id} is not running.`);\r\n            return;\r\n        }\r\n\r\n        const spawn_result = this._running_services.get(service_id);\r\n        if (!spawn_result) {\r\n            console.error(`Service ${service_id} spawn result not found.`);\r\n            return;\r\n        }\r\n\r\n        const { process } = spawn_result;\r\n\r\n        // mark service as should not be running\r\n        this._should_be_running_services.delete(service_id);\r\n\r\n        // send SIGTERM\r\n        process.kill(143);\r\n\r\n        // removal from running services will be handled in exit listener\r\n    }\r\n\r\n    restart_service(service_id: string) {\r\n        this.stop_service(service_id);\r\n        this.start_service(service_id); // TODO: will this conflict with the exit listener?\r\n    }\r\n\r\n    get_service_status(service_id: string): ServiceStatus | null {\r\n        if (!this._service_files.has(service_id)) {\r\n            return null;\r\n        }\r\n\r\n        if (this._running_services.has(service_id)) {\r\n            const spawn_result = this._running_services.get(service_id);\r\n            if (spawn_result) {\r\n                return {\r\n                    state: \"running\",\r\n                    pid: spawn_result.process.pid\r\n                };\r\n            }\r\n        } else {\r\n            if (this._failed_services.has(service_id)) {\r\n                return {\r\n                    state: \"failed\"\r\n                };\r\n            } else {\r\n                return {\r\n                    state: \"stopped\"\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private _handle_service_exit(service_id: string, exit_code: number) {\r\n        console.warn(`Service ${service_id} exited with code ${exit_code}.`);\r\n\r\n        if (!this._should_be_running_services.has(service_id)) {\r\n            return;\r\n        }\r\n\r\n        const service = this._service_files.get(service_id);\r\n        if (!service) {\r\n            return;\r\n        }\r\n\r\n        const restart_policy = service.restart;\r\n        if (!restart_policy || restart_policy.on === \"never\") {\r\n            return;\r\n        }\r\n\r\n        if (restart_policy.on === \"always\" || (restart_policy.on === \"failure\" && !CLEAN_EXIT_CODES.has(exit_code))) {\r\n            console.log(`Restarting service ${service_id} as per restart policy.`);\r\n\r\n            let delay_ms = 0;\r\n            if (\"delay_ms\" in restart_policy && restart_policy.delay_ms) {\r\n                delay_ms = restart_policy.delay_ms;\r\n            }\r\n\r\n            setTimeout(() => {\r\n                this.start_service(service_id);\r\n            }, delay_ms);\r\n        }\r\n    }\r\n}\r\n","import type { Program } from \"../../../types\";\r\n\r\nimport {ServiceManager} from \"./services\";\r\nimport type {ProcessContext} from \"../../../processes\";\r\n\r\ninterface IgnitionIPCMessageBase {\r\n    type: string;\r\n}\r\n\r\ninterface IgnitionIPCPowerMessage extends IgnitionIPCMessageBase {\r\n    type: \"power\";\r\n    action: \"shutdown\" | \"reboot\";\r\n    hard?: boolean;\r\n}\r\n\r\ninterface IgnitionIPCServiceMessage extends IgnitionIPCMessageBase {\r\n    type: \"service\";\r\n    action: \"start\" | \"stop\" | \"restart\" | \"status\";\r\n    service_id: string;\r\n}\r\n\r\ninterface IgnitionIPCReloadServicesMessage extends IgnitionIPCMessageBase {\r\n    type: \"reload_services\";\r\n}\r\n\r\nexport type IgnitionIPCMessage =\r\n    IgnitionIPCPowerMessage |\r\n    IgnitionIPCServiceMessage |\r\n    IgnitionIPCReloadServicesMessage;\r\n\r\ninterface IgnitionIPCResponse extends IgnitionIPCMessageBase {\r\n    type: \"response\";\r\n    message: string;\r\n}\r\n\r\ninterface IgnitionIPCDataResponse extends IgnitionIPCMessageBase {\r\n    type: \"data\";\r\n    data: unknown;\r\n}\r\n\r\ninterface IgnitionIPCError extends IgnitionIPCMessageBase {\r\n    type: \"error\";\r\n    message: string;\r\n}\r\n\r\nexport type IgnitionIPCReply =\r\n    IgnitionIPCResponse |\r\n    IgnitionIPCDataResponse |\r\n    IgnitionIPCError;\r\n\r\n// TODO: split ipc handling etc into files\r\n\r\nexport default {\r\n    name: \"ignition\",\r\n    description: \"System init process\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const { kernel, term, process } = data;\r\n\r\n        // check if ignition is already running (only allowed to be PID 1)\r\n        if (process.pid !== 1) {\r\n            term.writeln(\"Cannot run ignition.\");\r\n            return 1;\r\n        }\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        // determine boot target from /etc/boot_target\r\n        let boot_target = \"jetty\";\r\n        let boot_args: string[] = [];\r\n\r\n        try {\r\n            const boot_target_data = await fs.read_file(\"/etc/boot_target\") as string;\r\n            boot_target = boot_target_data.trim();\r\n        } catch (e) {\r\n            term.writeln(\"Warning: /etc/boot_target not found, defaulting to 'jetty' target!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        if (!boot_target) {\r\n            term.writeln(\"Warning: /etc/boot_target is empty, defaulting to 'jetty' target!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        // separate args if any\r\n        const boot_target_parts = boot_target.split(\" \");\r\n        boot_target = boot_target_parts[0];\r\n\r\n        if (boot_target_parts.length > 1) {\r\n            boot_args = boot_target_parts.slice(1);\r\n        }\r\n\r\n        // create service manager\r\n        const svc_mgr = new ServiceManager(kernel);\r\n\r\n        // load service files but don't start them yet\r\n        await svc_mgr.load_service_files();\r\n\r\n        // open and handle ipc communication\r\n        const ipc = kernel.get_ipc();\r\n\r\n        ipc.service_register(\"init\", process.pid, async (channel_id) => {\r\n            ipc.channel_listen(channel_id, process.pid, async (msg) => {\r\n                const payload = msg.data as IgnitionIPCMessage;\r\n\r\n                // TODO: clean up when it gets more complex\r\n\r\n                switch (payload.type) {\r\n                    case \"reload_services\": {\r\n                        await svc_mgr.load_service_files();\r\n                        ipc.channel_send(channel_id, process.pid, {\r\n                            type: \"response\",\r\n                            message: \"Service files reloaded.\"\r\n                        });\r\n                        break;\r\n                    }\r\n                    case \"service\": {\r\n                        const service_msg = payload as IgnitionIPCServiceMessage;\r\n                        switch (service_msg.action) {\r\n                            case \"start\": {\r\n                                svc_mgr.start_service(service_msg.service_id);\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"response\",\r\n                                    message: `Service ${service_msg.service_id} started.`\r\n                                });\r\n                                break;\r\n                            }\r\n                            case \"stop\": {\r\n                                svc_mgr.stop_service(service_msg.service_id);\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"response\",\r\n                                    message: `Service ${service_msg.service_id} stopped.`\r\n                                });\r\n                                break;\r\n                            }\r\n                            case \"restart\": {\r\n                                svc_mgr.restart_service(service_msg.service_id);\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"response\",\r\n                                    message: `Service ${service_msg.service_id} restarted.`\r\n                                });\r\n                                break;\r\n                            }\r\n                            case \"status\": {\r\n                                const status = svc_mgr.get_service_status(service_msg.service_id);\r\n\r\n                                if (!status) {\r\n                                    ipc.channel_send(channel_id, process.pid, {\r\n                                        type: \"error\",\r\n                                        message: `Service ${service_msg.service_id} not found.`\r\n                                    });\r\n                                    break;\r\n                                }\r\n\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"data\",\r\n                                    data: status\r\n                                });\r\n                                break;\r\n                            }\r\n                            default:\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"error\",\r\n                                    message: `Unknown service action: ${service_msg.action}`\r\n                                });\r\n                        }\r\n                    }\r\n                        break;\r\n                    default:\r\n                        ipc.channel_send(channel_id, process.pid, {\r\n                            type: \"error\",\r\n                            message: `Unknown message type: ${payload.type}`\r\n                        });\r\n                }\r\n            });\r\n        });\r\n\r\n        let running = true;\r\n        let final_code = 0;\r\n        let current_tty_process: ProcessContext;\r\n\r\n        // on exit, force boot target to exit too\r\n        // TODO: add process ownership to automatically kill child processes\r\n        const proc_mgr = kernel.get_process_manager();\r\n        process.add_exit_listener(async (exit_code) => {\r\n            if (current_tty_process && proc_mgr.get_process(current_tty_process.pid)) {\r\n                current_tty_process.kill(exit_code);\r\n            }\r\n\r\n            final_code = exit_code;\r\n            running = false;\r\n        });\r\n\r\n        // start initial services\r\n        svc_mgr.start_initial_services();\r\n\r\n        // execute boot target in a respawn loop\r\n        while (running) {\r\n            const boot_target_proc = kernel.spawn(boot_target, boot_args);\r\n            current_tty_process = boot_target_proc.process;\r\n\r\n            const exit_code = await boot_target_proc.completion;\r\n            console.log(`boot target ${boot_target} exited with code ${exit_code}`);\r\n\r\n            // TODO: error recovery logic if boot target fails multiple times in a row\r\n        }\r\n\r\n        return final_code;\r\n    }\r\n} as Program;\r\n","import type {Program} from \"../../types\";\r\nimport type {ProcessContext} from \"../../processes\";\r\nimport {ANSI} from \"../../term_ctl\";\r\n\r\nexport default {\r\n    name: \"jetty\",\r\n    description: \"TTY init process\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const {kernel, term, process} = data;\r\n\r\n        term.reset();\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        // determine default shell from /etc/default_shell\r\n        let default_shell = \"ash\";\r\n        let default_shell_args: string[] = [];\r\n\r\n        try {\r\n            const default_shell_data = await fs.read_file(\"/etc/default_shell\") as string;\r\n            default_shell = default_shell_data.trim();\r\n        } catch (e) {\r\n            term.writeln(\"Warning: /etc/default_shell not found, defaulting to 'ash' shell!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        if (!default_shell) {\r\n            term.writeln(\"Warning: /etc/default_shell is empty, defaulting to 'ash' shell!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        // separate shell args if any\r\n        const default_shell_parts = default_shell.split(\" \");\r\n        default_shell = default_shell_parts[0];\r\n\r\n        if (default_shell_parts.length > 1) {\r\n            default_shell_args = default_shell_parts.slice(1);\r\n        }\r\n\r\n        let running = true;\r\n        let final_code = 0;\r\n        let current_shell_process: ProcessContext;\r\n\r\n        // on exit, force shell to exit too\r\n        // TODO: add process ownership to automatically kill child processes\r\n        const proc_mgr = kernel.get_process_manager();\r\n        process.add_exit_listener(async (exit_code) => {\r\n            if (current_shell_process && proc_mgr.get_process(current_shell_process.pid)) {\r\n                current_shell_process.kill(exit_code);\r\n            }\r\n\r\n            final_code = exit_code;\r\n            running = false;\r\n        });\r\n\r\n        // execute shell in a respawn loop\r\n        while (running) {\r\n            const shell_proc = kernel.spawn(default_shell, default_shell_args);\r\n            current_shell_process = shell_proc.process;\r\n\r\n            const exit_code = await shell_proc.completion;\r\n            // TODO: why is this needed? is spawn not managing process death correctly?\r\n            shell_proc.process.kill(exit_code);\r\n\r\n            console.log(`default shell ${default_shell} exited with code ${exit_code}`);\r\n\r\n            // early break in case jetty is being killed\r\n            if (!running) {\r\n                break;\r\n            }\r\n\r\n            term.reset();\r\n\r\n            term.writeln(exit_code === 0 ? \"Logged out.\" : `Shell exited with code ${exit_code}!`);\r\n            term.writeln(`Press any key to log back in.${ANSI.CURSOR.invisible}`);\r\n\r\n            await term.wait_for_keypress();\r\n            term.write(ANSI.CURSOR.visible);\r\n\r\n            term.reset();\r\n        }\r\n\r\n        return final_code;\r\n    }\r\n} as Program;\r\n","import type {AbstractShellMemory} from \"../../../abstract_shell\";\r\n\r\nexport class AshMemory implements AbstractShellMemory {\r\n    // TODO: backup history in a file\r\n    _history: string[] = [];\r\n    _current_history_index = 0;\r\n\r\n    _vars: Map<string, string> = new Map();\r\n    _aliases: Map<string, string> = new Map();\r\n\r\n    clear_history(): void {\r\n        this._history = [];\r\n        this._current_history_index = 0;\r\n    }\r\n\r\n    get_previous_history_entry(): string | undefined {\r\n        if (this._history.length === 0 || this._current_history_index >= this._history.length) {\r\n            return undefined;\r\n        }\r\n\r\n        const entry = this._history[this._history.length - 1 - this._current_history_index];\r\n        this._current_history_index += 1;\r\n        return entry;\r\n    }\r\n\r\n    get_next_history_entry(): string | undefined {\r\n        if (this._history.length === 0 || this._current_history_index <= 0) {\r\n            return undefined;\r\n        }\r\n\r\n        this._current_history_index -= 1;\r\n        if (this._current_history_index === 0) {\r\n            return \"\";\r\n        }\r\n\r\n        return this._history[this._history.length - 1 - this._current_history_index];\r\n    }\r\n\r\n    add_history_entry(entry: string): void {\r\n        this._history.push(entry);\r\n        this._current_history_index = 0;\r\n    }\r\n\r\n    list_variables(): Map<string, string> {\r\n        return this._vars;\r\n    }\r\n\r\n    get_variable(name: string): string | undefined {\r\n        return this._vars.get(name);\r\n    }\r\n\r\n    set_variable(name: string, value: string): void {\r\n        this._vars.set(name, value);\r\n    }\r\n\r\n    unset_variable(name: string): boolean {\r\n        return this._vars.delete(name);\r\n    }\r\n\r\n    list_aliases(): Map<string, string> {\r\n        return this._aliases;\r\n    }\r\n\r\n    get_alias(name: string): string | undefined {\r\n        return this._aliases.get(name);\r\n    }\r\n\r\n    set_alias(name: string, value: string): void {\r\n        this._aliases.set(name, value);\r\n    }\r\n\r\n    unset_alias(name: string): boolean {\r\n        return this._aliases.delete(name);\r\n    }\r\n}\r\n","import {AshMemory} from \"./memory\";\r\n\r\nexport interface LineParseResultCommand {\r\n    type: \"command\";\r\n\r\n    command: string;\r\n    args: string[];\r\n    unsubbed_args: string[];\r\n    raw_parts: string[];\r\n    run_in_bg: boolean;\r\n}\r\n\r\nexport interface LineParseResultVarAssignment {\r\n    type: \"var\";\r\n\r\n    var_name: string;\r\n    var_value: string;\r\n}\r\n\r\nexport type LineParseResult = LineParseResultCommand | LineParseResultVarAssignment | null;\r\n\r\nconst VAR_ASSIGNMENT_REGEX = /^([a-zA-Z0-9_]+)=(.+)$/;\r\n\r\nexport const parse_line = (line: string, memory?: AshMemory): LineParseResult => {\r\n    if (line.length === 0) {\r\n        // if the line is empty, nothing to parse\r\n        return null;\r\n    }\r\n\r\n    // TODO: handle multiple commands separated by semicolons\r\n\r\n    // remove leading and trailing whitespace and split by spaces, unless contained in single or double quotes\r\n    // TODO: use a proper stack based parser for readability and maintainability\r\n    const raw_parts = line.split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\r\n    const sub = line.trim().split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\r\n\r\n    // handle aliases\r\n    // for each part, check if it's an alias, and if so, replace it with the value\r\n    // if the value ends with a space, check the next part as well\r\n    for (let i = 0; i < sub.length; i++) {\r\n        const part = sub[i];\r\n        const alias_value = memory ? memory.get_alias(part) : undefined;\r\n\r\n        if (!alias_value) {\r\n            // not an alias, abort (alias only applies to the first word unless chaining)\r\n            break;\r\n        }\r\n\r\n        // split the alias value into parts\r\n        const alias_parts = alias_value.split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\r\n\r\n        // if ends with a space, remove the trailing empty part\r\n        if (alias_value.endsWith(\" \")) {\r\n            alias_parts.pop();\r\n        }\r\n\r\n        // remove the current part and insert the alias parts\r\n        sub.splice(i, 1, ...alias_parts);\r\n\r\n        // adjust the index to account for the new parts\r\n        i += alias_parts.length - 1;\r\n\r\n        // if the alias value ends with a space, check the next part as well\r\n        if (!alias_value.endsWith(\" \")) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    const skip_variable_sub_idxs = [];\r\n\r\n    // remove quotes from arguments if starting and ending with quotes\r\n    // if they are single quotes then disable substitution\r\n    for (let i = 0; i < sub.length; i++) {\r\n        if (i === 0) {\r\n            // skip the first argument (the command)\r\n            continue;\r\n        }\r\n\r\n        const arg = sub[i];\r\n\r\n        if (arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\")) {\r\n            sub[i] = arg.slice(1, -1);\r\n        }\r\n\r\n        if (arg.startsWith(\"'\") && arg.endsWith(\"'\")) {\r\n            sub[i] = arg.slice(1, -1);\r\n            skip_variable_sub_idxs.push(i - 1); // skip variable substitution for this argument (adjust for slice)\r\n        }\r\n    }\r\n\r\n    // the first word is the command, the rest are arguments\r\n    const command = sub[0];\r\n\r\n    if (command === \"#\") {\r\n        // if the command is a comment, just ignore\r\n        return null;\r\n    }\r\n\r\n    // determine if the line is a variable assignment with regex\r\n    if (command.includes(\"=\")) {\r\n        const match = line.match(VAR_ASSIGNMENT_REGEX);\r\n\r\n        if (match) {\r\n            const var_name = match[1];\r\n            let var_value = match[2];\r\n\r\n            // remove single or double quotes from the value\r\n            // TODO: make this more unixy when we add semicolons\r\n            if (var_value.startsWith(\"'\") || var_value.startsWith(\"\\\"\")) {\r\n                var_value = var_value.slice(1, -1);\r\n            }\r\n\r\n            // this is a variable assignment\r\n            return {\r\n                type: \"var\",\r\n\r\n                var_name,\r\n                var_value\r\n            }\r\n        }\r\n    }\r\n\r\n    const args = sub.slice(1);\r\n\r\n    // if the last arg value is &, run in bg and remove it from args BEFORE variable substitution\r\n    let run_in_bg = false;\r\n    if (args.length > 0 && args[args.length - 1] === \"&\") {\r\n        run_in_bg = true;\r\n        args.pop();\r\n    }\r\n\r\n    const unsubbed_args = args.slice();\r\n\r\n    // substitute args with variables\r\n    for (let arg_idx = 0; arg_idx < args.length; arg_idx++) {\r\n        if (skip_variable_sub_idxs.includes(arg_idx)) {\r\n            // skip variable substitution for this argument\r\n            continue;\r\n        }\r\n\r\n        let arg = args[arg_idx];\r\n\r\n        // replaces any instance of $VAR or ${VAR} with the value of the variable VAR (alphabetical only except special var $?)\r\n        // TODO: backslash to escape dollar sign without using single quotes\r\n        arg = arg.replace(/\\$(\\w+|\\?)|\\$\\{([^}]+)\\}/g, (match, var1, var2) => {\r\n            const var_name = var1 || var2;\r\n            const var_value = memory ? memory.get_variable(var_name) : undefined;\r\n\r\n            if (!var_value) {\r\n                // if the variable is not set, return the original match\r\n                return match;\r\n            }\r\n\r\n            return var_value;\r\n        });\r\n\r\n        args[arg_idx] = arg;\r\n    }\r\n\r\n    // this is a command\r\n    return {\r\n        type: \"command\",\r\n\r\n        command,\r\n        args,\r\n        unsubbed_args,\r\n        raw_parts,\r\n        run_in_bg\r\n    };\r\n}\r\n","import type {AbstractShell} from \"../../../abstract_shell\";\r\nimport type {Kernel, SpawnResult} from \"../../../kernel\";\r\n\r\nimport {ANSI, NEWLINE, type WrappedTerminal} from \"../../../term_ctl\";\r\n\r\nimport {AshMemory} from \"./memory\";\r\nimport {parse_line} from \"./parser\";\r\n\r\nconst {PREFABS, FG, STYLE} = ANSI;\r\n\r\nexport class AshShell implements AbstractShell {\r\n    _kernel: Kernel;\r\n    _term: WrappedTerminal;\r\n    _memory = new AshMemory();\r\n\r\n    _prompt_suffix = \"$ \";\r\n\r\n    // TODO: find a better place/way to handle this, maybe tab completion should be a class that stores its own state\r\n    _discard_cached_matches = false;\r\n\r\n    constructor(term: WrappedTerminal, kernel: Kernel) {\r\n        this._term = term;\r\n        this._kernel = kernel;\r\n    }\r\n\r\n    get memory(): AshMemory {\r\n        return this._memory;\r\n    }\r\n\r\n    // returns success flag (or error if critical)\r\n    execute = async (line: string, edit_doc_title = true, program_final_completion_callback?: (exit_code?: number) => void): Promise<boolean> => {\r\n        const kernel = this._kernel;\r\n        const term = this._term;\r\n        const memory = this._memory;\r\n\r\n        if (kernel.panicked) {\r\n            return false;\r\n        }\r\n\r\n        // TODO: semicolon to run multiple commands regardless of success\r\n        // TODO: double ampersand to run multiple commands only if previous succeeded\r\n        // TODO: double pipe to run multiple commands only if previous failed\r\n        // TODO: single pipe to pipe output of previous command to next command\r\n        // TODO: allow certain control characters to be escaped e.g. $\r\n        // TODO: support sh files\r\n\r\n        if (line.length === 0) {\r\n            // if the line is empty, just move to the next line (additional check if called from external source)\r\n            return true;\r\n        }\r\n\r\n        const parsed_line = parse_line(line, memory);\r\n\r\n        if (parsed_line === null) {\r\n            // if the line is a comment or empty, do nothing\r\n            return true;\r\n        }\r\n\r\n        // handle variable assignment\r\n        if (parsed_line.type === \"var\") {\r\n            memory.set_variable(parsed_line.var_name, parsed_line.var_value);\r\n            return true;\r\n        }\r\n\r\n        // otherwise, it's a command. destructure it\r\n        const { command } = parsed_line;\r\n\r\n        // check if the command exists\r\n        const prog_reg = kernel.get_program_registry();\r\n        if (!prog_reg.getProgram(command)) {\r\n            term.writeln(`${PREFABS.error}Command not found: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n            return false;\r\n        }\r\n\r\n        let old_title = \"\";\r\n        if (edit_doc_title) {\r\n            old_title = document.title;\r\n            document.title = command;\r\n        }\r\n\r\n        // spawn the process\r\n        let spawn_result: SpawnResult;\r\n        try {\r\n            spawn_result = kernel.spawn(command, parsed_line.args, this, parsed_line);\r\n        } catch (e) {\r\n            if (edit_doc_title) {\r\n                document.title = old_title;\r\n            }\r\n\r\n            term.writeln(`${PREFABS.error}Failed to execute command: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}.`);\r\n            term.writeln(`${FG.red + STYLE.italic}${(e as Error).message}${STYLE.reset_all}`);\r\n\r\n            console.error(e);\r\n\r\n            return false;\r\n        }\r\n\r\n        const { process, completion } = spawn_result;\r\n\r\n        const on_execute_completion = (exit_code?: number) => {\r\n            if (exit_code === undefined) {\r\n                exit_code = -2;\r\n                console.warn(`Program ${command} did not return an exit code. Defaulting to -2.`)\r\n            }\r\n\r\n            memory._current_history_index = 0;\r\n\r\n            if (edit_doc_title) {\r\n                document.title = old_title;\r\n            }\r\n\r\n            if (process.is_detached) {\r\n                process.add_exit_listener((code) => {\r\n                    if (program_final_completion_callback) {\r\n                        try {\r\n                            program_final_completion_callback(code);\r\n                        } catch (e) {\r\n                            console.error(\"Error in program final completion callback for detached process:\", e);\r\n                        }\r\n                    }\r\n\r\n                    if (process.detaches_silently) {\r\n                        return;\r\n                    }\r\n\r\n                    const status = code === 0 ? \"Done\" : `Exit ${code}`;\r\n                    const color = code === 0 ? FG.green : FG.red;\r\n\r\n                    // TODO: erase existing prompt and line\r\n                    term.writeln(\"\");\r\n                    term.writeln(`${FG.gray}[${process.pid}] + ${color}${status}${FG.gray} \\t ${command}${STYLE.reset_all}`);\r\n\r\n                    // reinsert the prompt and current line\r\n                    // TODO: respect running programs, maybe need a notification queue\r\n                    this.insert_prompt(false);\r\n                });\r\n\r\n                // don't kill the process\r\n                return;\r\n            }\r\n\r\n            process.kill(exit_code);\r\n\r\n            if (program_final_completion_callback) {\r\n                try {\r\n                    program_final_completion_callback(exit_code);\r\n                } catch (e) {\r\n                    console.error(\"Error in program final completion callback:\", e);\r\n                }\r\n            }\r\n\r\n            if (process.is_background) {\r\n                term.writeln(`\\n${FG.gray}[${process.pid}] + Done \\t ${command}${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        // now handle awaiting program completion\r\n        try {\r\n            if (process.is_detached) {\r\n                if (!process.detaches_silently) {\r\n                    term.writeln(`${FG.gray}[${process.pid}] process detached${STYLE.reset_all}`);\r\n                }\r\n\r\n                completion.then((exit_code) => {\r\n                    on_execute_completion(exit_code);\r\n                }).catch((e) => {\r\n                    term.writeln(`${PREFABS.error}An unhandled error occurred in detached process [${process.pid}]: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n                    console.error(e);\r\n                    on_execute_completion(-1);\r\n                });\r\n            } else if (process.is_foreground) {\r\n                const exit_code = await completion;\r\n                on_execute_completion(exit_code);\r\n\r\n                // set the exit code variable\r\n                memory.set_variable(\"?\", exit_code.toString());\r\n            } else {\r\n                this._term.writeln(`${FG.gray}[${process.pid}] ${STYLE.italic}running in background${STYLE.reset_all}`);\r\n\r\n                completion.then((exit_code) => {\r\n                    on_execute_completion(exit_code);\r\n                }).catch((e) => {\r\n                    this._term.writeln(`${PREFABS.error}An unhandled error occurred in background process [${process.pid}]: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n                    console.error(e);\r\n\r\n                    on_execute_completion(-1);\r\n                });\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}An unhandled error occurred while running the command: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            on_execute_completion(-1);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async run_script(path: string) {\r\n        const fs = this._kernel.get_fs();\r\n\r\n        if (await fs.exists(path)) {\r\n            // iter through the lines of the file and execute them\r\n            const content = await fs.read_file(path) as string;\r\n            for (const line of content.split(NEWLINE)) {\r\n                // TODO: catch errors\r\n                await this.execute(line);\r\n            }\r\n        }\r\n    }\r\n\r\n    get_prompt_suffix(): string {\r\n        return this._prompt_suffix;\r\n    }\r\n\r\n    set_prompt_suffix(suffix: string): void {\r\n        this._prompt_suffix = suffix;\r\n    }\r\n\r\n    get_prompt_string(): string {\r\n        const fs = this._kernel.get_fs();\r\n\r\n        let path = fs.get_cwd();\r\n\r\n        if (path.startsWith(fs.get_home())) {\r\n            // replace home with ~ at start of path only\r\n            path = path.replace(new RegExp(`^${fs.get_home()}`), \"~\");\r\n        }\r\n\r\n        // build result e.g. ~$\r\n        return `${PREFABS.dir_name}${path}${STYLE.reset_all}${this._prompt_suffix}`;\r\n    }\r\n\r\n    async insert_prompt(newline = true) {\r\n        const kernel = this._kernel;\r\n        const term = this._term;\r\n\r\n        if (kernel.panicked) {\r\n            return;\r\n        }\r\n\r\n        if (newline) {\r\n            term.write(NEWLINE);\r\n        }\r\n\r\n        // resolve a promise when writing is complete\r\n        await new Promise<void>((resolve) => {\r\n            term.write(this.get_prompt_string(), () => {\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n}\r\n","import type {Kernel} from \"../../../kernel\";\r\nimport type {ReadLineBuffer, WrappedTerminal} from \"../../../term_ctl\";\r\nimport type {CompletionData} from \"../../../types\";\r\n\r\nimport {parse_line} from \"./parser\";\r\nimport {AbstractShell} from \"../../../abstract_shell\";\r\n\r\n// TODO this is really poor OOP\r\nlet cached_matches: string[] = [];\r\nlet current_cached_match_index = 0;\r\n\r\nconst complete_command = (buffer: ReadLineBuffer, discard_cached_matches: boolean, kernel: Kernel) => {\r\n    // get the program registry\r\n    const registry = kernel.get_program_registry();\r\n    const programs = registry.listProgramNames(true, true);\r\n\r\n    // check for existing matches\r\n    let match: string;\r\n    if (!discard_cached_matches && cached_matches.length > 0) {\r\n        // if the current line hasn't changed, just get the next match\r\n        current_cached_match_index = (current_cached_match_index + 1) % cached_matches.length;\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n    } else {\r\n        // if the current line has changed, refresh the matches\r\n        cached_matches = programs.filter((program) => program.startsWith(buffer.current_line));\r\n        current_cached_match_index = 0;\r\n\r\n        // get the first match\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n\r\n        // mark as unmodified\r\n        discard_cached_matches = false;\r\n    }\r\n\r\n    return {match, discard_cached_matches};\r\n}\r\n\r\nconst is_async_generator = (obj: unknown): obj is AsyncGenerator<string> => {\r\n    return obj && typeof obj[Symbol.asyncIterator] === \"function\";\r\n}\r\n\r\nconst get_completeable_arguments = async (buffer: ReadLineBuffer, term: WrappedTerminal, kernel: Kernel, shell?: AbstractShell) => {\r\n    // parse the line\r\n\r\n    const parsed_line = parse_line(buffer.current_line);\r\n    if (parsed_line.type !== \"command\") {\r\n        console.warn(\"Tab completion for non-command lines is not yet implemented\");\r\n        return null;\r\n    }\r\n\r\n    // destructure parsed line\r\n    const {command, args, unsubbed_args, raw_parts} = parsed_line;\r\n\r\n    // get the command from the registry\r\n    const registry = kernel.get_program_registry();\r\n    const program = registry.getProgram(command);\r\n    if (!program) {\r\n        console.warn(`Tab completion for unknown command \"${command}\"`);\r\n        return null;\r\n    }\r\n\r\n    // if the program has no completion generator, complete based on file paths\r\n    if (!program.completion) {\r\n        // TODO need to change data structure first\r\n        console.warn(`Tab completion for command \"${command}\" with no completion generator is not yet implemented`);\r\n        return null;\r\n    }\r\n\r\n    const completion_data = {\r\n        term,\r\n        kernel,\r\n        shell,\r\n        command,\r\n        args,\r\n        raw_parts: raw_parts,\r\n        unsubbed_args,\r\n        current_partial: raw_parts[raw_parts.length - 1] || \"\",\r\n        arg_index: raw_parts.length - 2, // -1 for current arg, -1 for program name\r\n    };\r\n\r\n    const completion_result = await program.completion(completion_data);\r\n\r\n    // if the result is an async generator, get all values for now\r\n    // in future this will be done incrementally, but the current data structure doesn't support that yet\r\n    if (is_async_generator(completion_result)) {\r\n        const results: string[] = [];\r\n        for await (const value of completion_result) {\r\n            results.push(value);\r\n        }\r\n        return results;\r\n    } else {\r\n        if (completion_result === null) {\r\n            // TODO fall back to file path completion\r\n            console.warn(`Tab completion for command \"${command}\" with null completion result is not yet implemented`);\r\n            return null;\r\n        }\r\n\r\n        return completion_result;\r\n    }\r\n}\r\n\r\nconst complete_argument = async (buffer: ReadLineBuffer, discard_cached_matches: boolean, kernel: Kernel, term: WrappedTerminal, shell?: AbstractShell) => {\r\n    // get the completeable arguments\r\n    const completeable_arguments = await get_completeable_arguments(buffer, term, kernel, shell);\r\n    if (!completeable_arguments) {\r\n        return {match: \"\", discard_cached_matches};\r\n    }\r\n\r\n    // check for existing matches\r\n    let match: string;\r\n    if (!discard_cached_matches && cached_matches.length > 0) {\r\n        // if the current line hasn't changed, just get the next match\r\n        current_cached_match_index = (current_cached_match_index + 1) % cached_matches.length;\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n    } else {\r\n        // if the current line has changed, refresh the matches\r\n        cached_matches = completeable_arguments.filter((arg) => arg.startsWith(buffer.current_line.split(\" \").pop() || \"\"));\r\n        current_cached_match_index = 0;\r\n\r\n        // get the first match\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n\r\n        // mark as unmodified\r\n        discard_cached_matches = false;\r\n    }\r\n\r\n    return {match, discard_cached_matches};\r\n}\r\n\r\nconst fill_completed_command = (term: WrappedTerminal, buffer: ReadLineBuffer, match: string) => {\r\n    // erase the current line\r\n    term.write(\"\\b \\b\".repeat(buffer.current_index));\r\n\r\n    // write the match\r\n    term.write(match);\r\n\r\n    // NOTE: above is done rather than filling what is remaining because if tab is hit again, the next match will be written\r\n\r\n    // update current line and index\r\n    buffer.set_current_line(match);\r\n    buffer.set_current_index(match.length);\r\n}\r\n\r\nconst fill_completed_argument = (term: WrappedTerminal, buffer: ReadLineBuffer, match: string) => {\r\n    // get the current line parts\r\n    const parts = buffer.current_line.split(\" \");\r\n    const current_arg_partial = parts.pop() || \"\";\r\n\r\n    // erase the current argument partial\r\n    term.write(\"\\b \\b\".repeat(current_arg_partial.length));\r\n\r\n    // write the match\r\n    term.write(match);\r\n\r\n    // NOTE: above is done rather than filling what is remaining because if tab is hit again, the next match will be written\r\n\r\n    // update current line and index\r\n    parts.push(match);\r\n    buffer.set_current_line(parts.join(\" \"));\r\n    buffer.set_current_index(buffer.current_line.length);\r\n}\r\n\r\n// TODO: how does this work? would be good to make it linked to the terminal instance. what is discard_cached_matches even for?\r\nexport const tab_complete = async (buffer: ReadLineBuffer, term: WrappedTerminal, kernel: Kernel, shell?: AbstractShell, discard_cached_matches = false): Promise<boolean> => {\r\n    // if the current line is empty, do nothing\r\n    if (buffer.current_line.length === 0) {\r\n        return;\r\n    }\r\n\r\n    // if the current line has no spaces, tab complete the command\r\n    if (!buffer.current_line.includes(\" \")) {\r\n        const {match, discard_cached_matches: updated_discard} = complete_command(buffer, discard_cached_matches, kernel);\r\n        discard_cached_matches = updated_discard;\r\n\r\n        // if there is a match, tab complete\r\n        if (match) {\r\n            fill_completed_command(term, buffer, match);\r\n        }\r\n    } else {\r\n        // otherwise, tab complete the argument\r\n        const {match, discard_cached_matches: updated_discard} = await complete_argument(buffer, discard_cached_matches, kernel, term, shell);\r\n        discard_cached_matches = updated_discard;\r\n\r\n        // if there is a match, tab complete\r\n        if (match) {\r\n            fill_completed_argument(term, buffer, match);\r\n        }\r\n    }\r\n\r\n    return discard_cached_matches;\r\n}\r\n\r\n// TODO: the discard cache arg is janky. come up with a better solution. should also be using generators directly instead of arrays for completions\r\n// TODO: would be much better as a class that maintains its own state and remembers term, kernel etc.\r\n\r\nexport const helper_completion_options = (options: string[]) => {\r\n    return async function* (data: CompletionData): AsyncGenerator<string> {\r\n        const {current_partial} = data;\r\n        for (const option of options) {\r\n            if (option.startsWith(current_partial)) {\r\n                yield option;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nexport const helper_completion_options_ordered = (options: string[][]) => {\r\n    return async function* (data: CompletionData): AsyncGenerator<string> {\r\n        const {current_partial, raw_parts} = data;\r\n        const index = raw_parts.length - 1;\r\n        const options_at_index = options[index] || [];\r\n        for (const option of options_at_index) {\r\n            if (option.startsWith(current_partial)) {\r\n                yield option;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// TODO: make these helpers available to 3rd party programs","import type {Program} from \"../../../types\";\r\nimport {NEWLINE} from \"../../../term_ctl\";\r\n\r\nimport {AshShell} from \"./core\";\r\nimport {make_read_line_key_handlers, make_read_line_printable_handler} from \"./key_handlers\";\r\n\r\nexport default {\r\n    name: \"ash\",\r\n    description: \"A shell.\",\r\n    usage_suffix: \"[--login]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"--login\": \"Start the shell as a login shell. Don't pass this flag manually, it's handled by the system.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const {kernel, term, process, args} = data;\r\n\r\n        const shell = new AshShell(term, kernel);\r\n\r\n        const env_info = kernel.get_env_info();\r\n        shell.memory.set_variable(\"VERSION\", env_info.version);\r\n        shell.memory.set_variable(\"ENV\", env_info.env);\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        const absolute_profile = fs.absolute(\"~/.ash_profile\");\r\n        const absolute_rc = fs.absolute(\"~/.ashrc\");\r\n\r\n        // create .ash_profile file if it doesn't exist\r\n        const profile_content = `# ash configuration file${NEWLINE}# This file is run at login.${NEWLINE}${NEWLINE}cat /etc/motd.txt${NEWLINE}echo \"OllieOS v$VERSION ($ENV)\"${NEWLINE}`;\r\n        if (!(await fs.exists(absolute_profile))) {\r\n            await fs.write_file(absolute_profile, profile_content);\r\n        }\r\n\r\n        // create .ashrc file if it doesn't exist\r\n        const rc_content = `# ash configuration file${NEWLINE}# This file is run when a shell is created.${NEWLINE}${NEWLINE}`;\r\n        if (!(await fs.exists(absolute_rc))) {\r\n            await fs.write_file(absolute_rc, rc_content);\r\n        }\r\n\r\n        if (args.includes(\"--login\")) {\r\n            // enable screen reader mode if stored in local storage\r\n            if (localStorage.getItem(\"reader\") === \"true\") {\r\n                await shell.execute(\"reader -s on\");\r\n            }\r\n\r\n            // run .ash_profile, checking it exists again just in case (because why not)\r\n            if (await fs.exists(absolute_profile)) {\r\n                await shell.run_script(absolute_profile);\r\n            }\r\n        }\r\n\r\n        // run .ashrc, checking it exists again just in case (could be deleted in profile)\r\n        if (await fs.exists(absolute_rc)) {\r\n            await shell.run_script(absolute_rc);\r\n        }\r\n\r\n        let running = true;\r\n        let final_code = 0;\r\n        process.add_exit_listener((exit_code) => {\r\n            final_code = exit_code;\r\n            running = false;\r\n        });\r\n\r\n        const read_line_key_handlers = make_read_line_key_handlers(shell, kernel);\r\n        const read_line_printable_handler = make_read_line_printable_handler(shell);\r\n\r\n        term.focus();\r\n\r\n        while (running) {\r\n            await shell.insert_prompt(true);\r\n\r\n            const input = await term.read_line(read_line_key_handlers, read_line_printable_handler);\r\n            if (!input.trim()) {\r\n                continue;\r\n            }\r\n\r\n            // TODO: have an actual builtin processor instead of just reading input here\r\n            if (input === \"exit\") {\r\n                running = false;\r\n                break;\r\n            }\r\n\r\n            shell.memory.add_history_entry(input);\r\n            await shell.execute(input);\r\n        }\r\n\r\n        return final_code;\r\n    }\r\n} as Program;\r\n","import type {ReadLineKeyHandler} from \"../../../term_ctl\";\r\n\r\nimport type {AshShell} from \"./core\";\r\nimport type {Kernel} from \"../../../kernel\";\r\nimport {tab_complete} from \"./tab_completion\";\r\n\r\nexport const make_read_line_key_handlers = (shell: AshShell, kernel: Kernel): { [key: string]: ReadLineKeyHandler } => ({\r\n    // arrow up - previous history\r\n    \"\\x1b[A\": (_e, term, buffer) => {\r\n        const command = shell.memory.get_previous_history_entry();\r\n\r\n        if (command) {\r\n            shell._discard_cached_matches = true;\r\n\r\n            // bring cursor to end of line\r\n            term.write(\" \".repeat(buffer.current_line.length - buffer.current_index));\r\n\r\n            // clear current line (and move cursor back to start)\r\n            term.write(\"\\b \\b\".repeat(buffer.current_line.length));\r\n\r\n            // write command\r\n            term.write(command);\r\n\r\n            // update current line and index\r\n            buffer.set_current_line(command);\r\n            buffer.set_current_index(command.length);\r\n        }\r\n    },\r\n\r\n    // arrow down - next history\r\n    \"\\x1b[B\": (_e, term, buffer) => {\r\n        const command = shell.memory.get_next_history_entry();\r\n\r\n        shell._discard_cached_matches = true;\r\n\r\n        // bring cursor to end of line\r\n        term.write(\" \".repeat(buffer.current_line.length - buffer.current_index));\r\n\r\n        // clear current line (and move cursor back to start)\r\n        term.write(\"\\b \\b\".repeat(buffer.current_line.length));\r\n\r\n        if (command) {\r\n            // write command\r\n            term.write(command);\r\n\r\n            // update current line and index\r\n            buffer.set_current_line(command);\r\n            buffer.set_current_index(command.length);\r\n        } else {\r\n            // end of history, just clear line\r\n            buffer.set_current_line(\"\");\r\n            buffer.set_current_index(0);\r\n        }\r\n    },\r\n\r\n    // tab - tab completion\r\n    \"\\t\": async (_e, term, buffer) => {\r\n        shell._discard_cached_matches = await tab_complete(buffer, term, kernel, shell, shell._discard_cached_matches);\r\n    },\r\n\r\n    // backspace - discard cached matches\r\n    \"\\x7f\": () => {\r\n        // TODO: doesnt work quite the same, if they tab with nothing and hit backspace it will reset. need a way to check current line discipline\r\n        shell._discard_cached_matches = true;\r\n    }\r\n});\r\n\r\nexport const make_read_line_printable_handler = (shell: AshShell) => () => {\r\n    shell._discard_cached_matches = true;\r\n};\r\n","import { ANSI, NEWLINE, ANSI_ESCAPE_REGEX } from \"../term_ctl\";\r\nimport type { Program, ArgDescriptions } from \"../types\";\r\n\r\n\r\n// deferred to prevent double printing of header if program has to re-execute itself\r\nconst header = (term, includes_mounted: boolean) => {\r\n    // write header\r\n\r\n    if (!includes_mounted) {\r\n        term.writeln(`${ANSI.STYLE.italic}(Only built-in programs are included. Use the -m flag to include only mounted programs, or the -a flag to include all.)${ANSI.STYLE.reset_all}`);\r\n    }\r\n\r\n    term.writeln(`For help on a specific command, type ${ANSI.PREFABS.program_name}help${ANSI.STYLE.reset_all} [command].`)\r\n    term.writeln(`The exit code of the most recently executed program is stored in the ${ANSI.PREFABS.variable_name}$?${ANSI.STYLE.reset_all} variable.`)\r\n    term.writeln(`You can set variables with the syntax ${ANSI.PREFABS.variable_name}variable${ANSI.STYLE.reset_all}=value and unset them with ${ANSI.PREFABS.program_name}unset${ANSI.STYLE.reset_all}.`)\r\n    term.writeln(`To persist the variables, define them in the ${ANSI.PREFABS.file_path}.ollierc${ANSI.STYLE.reset_all} file in your ${ANSI.PREFABS.dir_name}home${ANSI.STYLE.reset_all} directory.`)\r\n    term.writeln(`You can run commands in the background by appending ${ANSI.STYLE.bold}${ANSI.FG.magenta}&${ANSI.STYLE.reset_all} to the end of the command.`)\r\n    term.write(NEWLINE);\r\n}\r\n\r\n// TODO: this should also probably be part of the shell rather than a program? i guess it doesn't matter much, it just acts more like man\r\nexport default {\r\n    name: \"help\",\r\n    description: \"List programs or get help for a specific program.\",\r\n    usage_suffix: \"[command | -s] [-a | -m]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"command\": \"The name of the program to get help for.\",\r\n        },\r\n        \"Flags:\": {\r\n            \"-s\": \"Single-column mode. Forces the program list to be displayed in a single column.\",\r\n            \"-a\": \"All programs. Includes all programs, built-in and mounted.\",\r\n            \"-m\": \"Mounted programs. Includes only mounted programs.\",\r\n        },\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // TODO smarter completion to handle number of args and flags\r\n        const programs = data.kernel.get_program_registry().listProgramNames();\r\n        return programs.filter((program) => program.startsWith(data.current_partial));\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        const registry = kernel.get_program_registry();\r\n\r\n        let single_column = false;\r\n        let includes_mounted = false;\r\n        let includes_builtin = true;\r\n\r\n        // parse and remove flags from args\r\n        for (let i = 0; i < args.length; i++) {\r\n            switch (args[i]) {\r\n                case \"-s\":\r\n                    single_column = true;\r\n                    args.splice(i, 1);\r\n                    i--;\r\n                    break;\r\n                case \"-a\":\r\n                    includes_mounted = true;\r\n                    includes_builtin = true;\r\n                    args.splice(i, 1);\r\n                    i--;\r\n                    break;\r\n                case \"-m\":\r\n                    includes_mounted = true;\r\n                    includes_builtin = false;\r\n                    args.splice(i, 1);\r\n                    i--;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // if no arguments remain, use list mode\r\n        if (args.length === 0) {\r\n            // get program names\r\n            const programs = registry.listProgramNames(includes_builtin, includes_mounted);\r\n\r\n            // remove hidden programs\r\n            const visible_programs = programs.filter((program_name) => {\r\n                const program = registry.getProgram(program_name);\r\n                return program !== undefined && !program.hide_from_help;\r\n            });\r\n\r\n            // add usage suffix and styling to each program name\r\n            const programs_fmt = visible_programs.map((program) => {\r\n                return `${PREFABS.program_name}${program}${STYLE.reset_all} ${registry.getProgram(program).usage_suffix}`;\r\n            });\r\n\r\n            // sort the programs alphabetically (usually already sorted alphabetically by Object.keys, but not guaranteed)\r\n            programs_fmt.sort();\r\n\r\n\r\n            if (single_column) {\r\n                // FORMAT THE PROGRAMS INTO 1 COLUMN\r\n\r\n                header(term, includes_mounted);\r\n                term.writeln(programs_fmt.join(NEWLINE));\r\n            } else {\r\n                // FORMAT THE PROGRAMS INTO 2 COLUMNS\r\n\r\n\r\n                // get the maximum length of a column\r\n                const max_allowable_length = Math.floor(term.cols / 2) - 1;\r\n\r\n\r\n                // split the programs into 2 columns\r\n                const column1 = programs_fmt.filter((_, i) => i <= programs_fmt.length / 2);\r\n                const column2 = programs_fmt.filter((_, i) => i > programs_fmt.length / 2);\r\n\r\n\r\n                // compute the length of the longest program name\r\n                const longest_program_length = Math.max(...programs_fmt.map((program) => program.replace(ANSI_ESCAPE_REGEX, \"\").length));\r\n\r\n                // compute the smallest padding length\r\n                const min_padding_length = max_allowable_length - longest_program_length;\r\n\r\n                // if there is negative padding (overlap, terminal too small), re-execute the program in single-column mode\r\n                if (min_padding_length < 0) {\r\n                    term.writeln(\"Terminal too small to display programs in 2 columns. Re-executing in single-column mode.\");\r\n                    term.write(NEWLINE);\r\n                    \r\n                    const new_args = [\"-s\"];\r\n\r\n                    if (includes_mounted) {\r\n                        new_args.push(\"-m\");\r\n                    }\r\n\r\n                    if (includes_builtin) {\r\n                        new_args.push(\"-a\");\r\n                    }\r\n                    \r\n                    return await kernel.spawn(\"help\", new_args, shell).completion;\r\n                }\r\n\r\n\r\n                // pair the programs in the 2 columns\r\n                const paired_programs = column1.map((program1, i) => {\r\n                    let program2 = column2[i] ?? \"\";\r\n\r\n                    const program1_real_length = program1.replace(ANSI_ESCAPE_REGEX, \"\").length;\r\n                    const program2_real_length = program2.replace(ANSI_ESCAPE_REGEX, \"\").length;\r\n\r\n                    // if the program name is too long, truncate it\r\n                    if (program1_real_length > max_allowable_length) {\r\n                        program1 = program1.slice(0, max_allowable_length / 2 - 3) + \"...\";\r\n                    }\r\n                    if (program2_real_length > max_allowable_length) {\r\n                        program2 = program2.slice(0, max_allowable_length / 2 - 3) + \"...\";\r\n                    }\r\n\r\n                    // pad the programs so that they are both left-aligned\r\n                    const padding = \" \".repeat(max_allowable_length - program1_real_length);\r\n                    return program1 + padding + program2;\r\n                });\r\n\r\n\r\n                // write the programs to the terminal\r\n                header(term, includes_mounted);\r\n                term.writeln(paired_programs.join(NEWLINE));\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        // if an argument remains, get help for it\r\n        const program = registry.getProgram(args[0]);\r\n\r\n        if (program === undefined) {\r\n            term.writeln(`${PREFABS.error}Could not resolve help for ${args[0]}.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        term.writeln(`${NEWLINE}${PREFABS.program_name}${program.name}${STYLE.reset_all}`);\r\n        term.writeln(`${program.description}`);\r\n        term.write(NEWLINE);\r\n        term.writeln(`Usage: ${PREFABS.program_name}${program.name}${STYLE.reset_all} ${program.usage_suffix}`);\r\n\r\n        if (Object.keys(program.arg_descriptions).length > 0) {\r\n            // recurse each level of nesting\r\n            // each level is a section title, until the innermost object, in which they are pairs of argument name and description.\r\n            // add indents depending on the level of nesting\r\n            const recurse = (descs: ArgDescriptions, nest_level: number): string => {\r\n                let output = \"\";\r\n\r\n                for (const [key, value] of Object.entries(descs)) {\r\n                    if (typeof value === \"string\") {\r\n                        // argument, innermost nest\r\n                        output += `${\" \".repeat(nest_level * 4)}${key} - ${value}${NEWLINE}`;\r\n                    } else {\r\n                        // title, deeper nest\r\n                        output += `${NEWLINE}${\" \".repeat(nest_level * 4)}${STYLE.bold + STYLE.italic}${key}${STYLE.reset_all}${NEWLINE}`;\r\n                        output += recurse(value, nest_level + 1);\r\n                    }\r\n                }\r\n\r\n                return output;\r\n            }\r\n\r\n\r\n            term.write(NEWLINE);\r\n            term.write(recurse(program.arg_descriptions, 0));\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"shutdown\",\r\n    description: \"Stops the OS.\",\r\n    usage_suffix: \"[-h] [-r] [-t ms]\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-r\": \"Reboot the terminal.\",\r\n            \"-t\": \"Set the time before shutdown in milliseconds. Default is 1000.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { FG, STYLE } = ANSI;\r\n\r\n        let time = 1000;\r\n        let restart = false;\r\n\r\n        for (const arg of args) {\r\n            switch (arg) {\r\n                case \"-h\":\r\n                    return await kernel.spawn(\"help\", [\"shutdown\"], shell).completion;\r\n                case \"-r\":\r\n                    restart = true;\r\n                    break;\r\n                case \"-t\": {\r\n                    // get the next argument\r\n                    const time_arg = args[args.indexOf(arg) + 1];\r\n                    if (time_arg === undefined) {\r\n                        term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    // parse the time\r\n                    const parsed_time = parseInt(time_arg);\r\n                    if (isNaN(parsed_time)) {\r\n                        term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    time = parsed_time;\r\n\r\n                    // skip the next argument\r\n                    args.splice(args.indexOf(arg) + 1, 1);\r\n                    break;\r\n                }\r\n                default:\r\n                    term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\r\n                    return 1;\r\n            }\r\n        }\r\n\r\n        if (restart) {\r\n            term.writeln(`${FG.red}Restarting...${STYLE.reset_all}`);\r\n        } else {\r\n            term.writeln(`${FG.red}Shutting down...${STYLE.reset_all}`);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            if (restart) {\r\n                window.location.reload();\r\n            } else {\r\n                term.dispose();\r\n            }\r\n        }, time);\r\n\r\n        // hang the terminal until it is shut down or restarted (dont allow any more commands)\r\n        // await an event that will never happen\r\n        await new Promise(() => {});\r\n    }\r\n} as Program;\r\n\r\n// TODO: move this to talk to ignition to perform a soft (or hard) shutdown via IPC\r\n","import { ANSI } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"clear\",\r\n    description: \"Clears the screen, and/or the scrollback.\",\r\n    usage_suffix: \"[-h | -s | -so]\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-s\": \"Clear the screen and the scrollback.\",\r\n            \"-so\": \"Only clear the scrollback.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: helper_completion_options([\"-h\", \"-s\", \"-so\"]),\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { FG, STYLE, PREFABS } = ANSI;\r\n\r\n        switch (args[0]) {\r\n            case undefined:\r\n                term.reset();\r\n                break;\r\n            case \"-s\":\r\n                term.reset();\r\n\r\n                if (shell) {\r\n                    shell.memory.clear_history();\r\n                } else {\r\n                    term.writeln(`${PREFABS.error}Cannot clear scrollback: no shell available.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                break;\r\n            case \"-so\":\r\n                if (!shell) {\r\n                    term.writeln(`${PREFABS.error}Cannot clear scrollback: no shell available.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                shell.memory.clear_history();\r\n                term.writeln(`${STYLE.bold + FG.gray}Scrollback cleared.${STYLE.reset_all}`);\r\n                break;\r\n            case \"-h\":\r\n                return await kernel.spawn(\"help\", [\"clear\"], shell).completion;\r\n            default:\r\n                term.writeln(`${FG.red}Invalid argument: ${args[0]}${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"echo\",\r\n    description: \"Echos a string to the terminal.\",\r\n    usage_suffix: \"string\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"string\": \"The string to echo.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { args, term } = data;\r\n\r\n        const content = args.join(\" \");\r\n        term.writeln(content);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"unset\",\r\n    description: \"Unsets a list of variables.\",\r\n    usage_suffix: \"[names...]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"names\": \"The names of each variable to unset.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (!data.shell) {\r\n            return [];\r\n        }\r\n\r\n        const var_names = [...data.shell.memory.list_variables().keys()];\r\n        // TODO: check type to see why helper_completion_options wont work here\r\n        return var_names.filter(name => name.startsWith(data.current_partial));\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, args, term } = data;\r\n\r\n        if (!shell) {\r\n            term.writeln(\"No shell available\");\r\n            return 1;\r\n        }\r\n\r\n        // TODO: move to shell builtin, not actual program\r\n\r\n        // for each variable name, unset it, with no regards to whether it exists or not\r\n        for (const name of args) {\r\n            shell.memory.unset_variable(name);\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI, ANSI_ESCAPE_REGEX, ANSI_UNESCAPED_REGEX } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"ls\",\r\n    description: \"List files in the current or another directory.\",\r\n    usage_suffix: \"[-h] [-a] [path]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the directory to list. Defaults to the current directory.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-a\": \"Show hidden files.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // parse arguments\r\n        let show_hidden = false;\r\n        let path = fs.get_cwd();\r\n\r\n        for (const arg of args) {\r\n            switch (arg) {\r\n                case \"-a\":\r\n                    show_hidden = true;\r\n                    break;\r\n                case \"-h\":\r\n                    return await kernel.spawn(\"help\", [\"ls\"], shell).completion;\r\n                default:\r\n                    path = fs.absolute(arg);\r\n            }\r\n        }\r\n\r\n        // check if path is a directory and exists\r\n        if (!(await fs.dir_exists(path))) {\r\n            term.writeln(`${PREFABS.error}No such directory: ${path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // list dir\r\n        let dir = await fs.list_dir(path);\r\n\r\n        // sort alphabetically (usually already sorted by Object.keys but just in case)\r\n        dir.sort();\r\n\r\n        // filter out hidden files\r\n        if (!show_hidden) {\r\n            dir = dir.filter((file) => !file.startsWith(\".\"));\r\n        }\r\n\r\n        // fit as many files as possible on one line, with a space between each, otherwise wrap\r\n        const max_width = term.cols;\r\n        let line = \"\";\r\n\r\n        for (const file of dir) {\r\n            // check if file will fit on current line\r\n            const real_length = line.replace(ANSI_ESCAPE_REGEX, \"\").replace(ANSI_UNESCAPED_REGEX, \"\").length;\r\n            if (real_length + file.length + 1 > max_width) {\r\n                // write line and reset\r\n                term.writeln(line);\r\n                line = \"\";\r\n            }\r\n\r\n            // add to line\r\n            if (await fs.dir_exists(fs.join(path, file))) {\r\n                line += `${PREFABS.dir_name}${file}${STYLE.reset_all} `;\r\n            } else {\r\n                line += `${PREFABS.file_path}${file}${STYLE.reset_all} `;\r\n            }\r\n        }\r\n\r\n        // write last line\r\n        term.writeln(line);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"cd\",\r\n    description: \"Change directory.\",\r\n    usage_suffix: \"[path]\",\r\n    arg_descriptions: {\r\n        path: \"Path to directory to change to. If no path is given, change to home directory.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n        \r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        \r\n        // if no arguments, go to home directory\r\n        if (args.length === 0) {\r\n            fs.set_cwd(fs.get_home());\r\n            return 0;\r\n        }\r\n\r\n        // if more than one argument, print error\r\n        if (args.length > 1) {\r\n            term.writeln(`${PREFABS.error}Too many arguments${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // check if path is a directory and exists\r\n        const path = args[0];\r\n        const absolute_path = fs.absolute(path);\r\n\r\n        if (!(await fs.dir_exists(absolute_path))) {\r\n            term.writeln(`${PREFABS.error}No such directory: ${path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // change directory\r\n        fs.set_cwd(absolute_path);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"pwd\",\r\n    description: \"Print working directory.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n        \r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // print working directory\r\n        term.writeln(PREFABS.dir_name + fs.get_cwd() + STYLE.reset_all);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE, WrappedTerminal, NON_PRINTABLE_REGEX } from \"../term_ctl\";\r\n\r\nconst HEADER = 2;\r\n\r\nconst setup = (term: WrappedTerminal, content: string, path: string, readonly: boolean) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, BG, FG } = ANSI;\r\n\r\n    // clear the screen\r\n    term.clear();\r\n\r\n    // write the file name centered in the header, showing the read-only status if the file is read-only\r\n    const filename = path.split(\"/\").pop() || \"\";\r\n    const header = readonly ? `Viewing read-only file: ${filename}` : `Editing file: ${filename}`;\r\n    const h_padding_l = \" \".repeat(Math.ceil((term.cols - header.length) / 2));\r\n    const h_padding_r = \" \".repeat(Math.floor((term.cols - header.length) / 2));\r\n\r\n    term.write(BG.white + FG.black + STYLE.bold);\r\n    term.write(h_padding_l);\r\n    term.write(header);\r\n    term.write(h_padding_r);\r\n    term.write(STYLE.reset_all)\r\n\r\n    // go to the bottom of the screen with ansi\r\n    term.write(`\\x1b[${term.rows - 1};0H`);\r\n\r\n    // write the footer, showing the save and exit key if the file is not read-only\r\n    const footer = `${readonly ? \"\" : \"F1: Save & Exit | \"}ESC: Exit without saving | F2: Debug Redraw`;\r\n    const f_padding_l = \" \".repeat(Math.ceil((term.cols - footer.length) / 2));\r\n    const f_padding_r = \" \".repeat(Math.floor((term.cols - footer.length) / 2));\r\n\r\n    term.write(BG.white + FG.black + STYLE.bold);\r\n    term.write(f_padding_l);\r\n    term.write(footer);\r\n    term.write(f_padding_r);\r\n    term.write(STYLE.reset_all)\r\n\r\n    // reset the cursor position to under the header\r\n    term.write(\"\\x1b[2;0H\");\r\n    term.write(NEWLINE);\r\n\r\n    // write the content\r\n    term.write(content);\r\n\r\n    // reset the cursor position to under the header\r\n    term.write(\"\\x1b[2;0H\");\r\n    term.write(NEWLINE);\r\n}\r\n\r\n\r\n// TODO: expose ANSI cursor control codes as functions in term_ctl\r\n// TODO: consider instead using a hidden textarea to store the character buffer, or using a queue and reimplementing the terminal's keypress handler\r\n// TODO: provide method in terminal to set up the above ^^^\r\n// TODO: none of this accounts for scrolling!! use of cursorPos will not function properly if the terminal is scrolled\r\n// TODO: it would be nice to not \"cheat\" at enter and backspace, but to actually handle them properly. this is fine for now i guess\r\n\r\nexport default {\r\n    name: \"edit\",\r\n    description: \"Edits the specified file.\",\r\n    usage_suffix: \"path\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // parse argument\r\n        if (args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}A single argument, the path, is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        const path = fs.absolute(args[0]);\r\n\r\n\r\n        let content = \"\";\r\n\r\n        // if the file exists, load it in. otherwise, keep the content empty\r\n        let readonly = false;\r\n        if (await fs.exists(path)) {\r\n            content = await fs.read_file(path) as string;\r\n            readonly = await fs.is_readonly(path);\r\n\r\n            // lock the file by making it read-only\r\n            // TODO: the user can lock the file permanently if edit crashes, they close the tab, reload, or their computer loses power! perhaps use a separate flag for this and have the os erase the lock on boot, not the same as readonly\r\n            // TODO: i'm disabling this for now for my own sanity (when it crashes and dies). its incredibly unlikely the user will concurrent write with fsedit and if they do they're stupid\r\n            //fs.set_readonly(path, true);\r\n        }\r\n\r\n        // temporary note\r\n        // TODO: remove when scrolling is implemented properly\r\n        term.writeln(`${FG.yellow}Note: This program is still in development and has numerous issues, including no scrolling!${NEWLINE}Pressing F2 to redraw may help some visual issues, but not any file writing related issues.${NEWLINE}Consider using ${PREFABS.program_name}cat${STYLE.reset_all + FG.yellow} or the ${PREFABS.program_name}fsedit${STYLE.reset_all + FG.yellow} UI for your purposes.${NEWLINE}Please don't report issues in this program unless you know a fix :)${NEWLINE}Press any key to proceed.${STYLE.reset_all}`);\r\n        await term.wait_for_keypress();\r\n\r\n        // setup the screen\r\n        setup(term, content, path, readonly);\r\n\r\n        const split_content = content.split(NEWLINE);\r\n\r\n        // wait for keypresses\r\n        let exit_code: number | null = null;\r\n        let saved = false;\r\n        while (exit_code === null) {\r\n            const key = await term.wait_for_keypress();\r\n\r\n            switch (key.domEvent.code) {\r\n                case \"Escape\":\r\n                    // revert the file to its original read-only status\r\n                    if (await fs.exists(path)) {\r\n                        await fs.set_readonly(path, readonly);\r\n                    }\r\n\r\n                    exit_code = 0;\r\n                    break;\r\n                case \"F1\":\r\n                    // if readonly, don't allow saving\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n                    await fs.write_file(path, split_content.join(NEWLINE));\r\n                    saved = true;\r\n\r\n                    // revert the file to its original read-only status\r\n                    await fs.set_readonly(path, readonly);\r\n\r\n                    exit_code = 0;\r\n                    break;\r\n                case \"F2\":\r\n                    term.reset();\r\n                    setup(term, split_content.join(NEWLINE), path, readonly);\r\n                    console.log(split_content.join(\"\\n\"));\r\n                    break;\r\n                case \"ArrowUp\": {\r\n                    // determine the current cursor position\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    if (cursor_y === 2) {\r\n                        // TODO: scroll file\r\n                        // we're at the top of the file, so we can't move up\r\n                        break;\r\n                    }\r\n\r\n                    // pass through to the terminal\r\n                    term.write(key.key);\r\n\r\n                    // determine the current line's length (sub 2 for header, sub 1 for moving up)\r\n                    const line_length = split_content[cursor_y - HEADER - 1].length;\r\n\r\n                    // determine the cursor's x position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n\r\n                    // move cursor to the end of the line, typing backspaces if it is past the end or the right arrow code if it is not\r\n                    if (cursor_x >= line_length) {\r\n                        term.write(\"\\b\".repeat(cursor_x - line_length));\r\n                    } else {\r\n                        term.write(\"\\x1b[C\".repeat(line_length - cursor_x));\r\n                    }\r\n                }\r\n                    break;\r\n                case \"ArrowDown\": {\r\n                    // determine the current cursor position\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    if (cursor_y === term.rows - 4) {\r\n                        // TODO: scroll file\r\n                        // we're at the bottom of the screen, so we can't move down\r\n                        break;\r\n                    }\r\n\r\n                    if (cursor_y === split_content.length + HEADER - 1) { // (add 2 for header, sub 1 for 0-indexing)\r\n                        // we're at the bottom of the file, so we can't move down\r\n                        break;\r\n                    }\r\n\r\n                    // pass through to the terminal\r\n                    term.write(key.key);\r\n\r\n                    // determine the current line's length (sub 2 for header, add 1 for moving down)\r\n                    const line_length = split_content[cursor_y - HEADER + 1].length;\r\n\r\n                    // determine the cursor's x position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n\r\n                    // move cursor to the end of the line, typing backspaces if it is past the end or the right arrow code if it is not\r\n                    if (cursor_x >= line_length) {\r\n                        term.write(\"\\b\".repeat(cursor_x - line_length));\r\n                    } else {\r\n                        term.write(\"\\x1b[C\".repeat(line_length - cursor_x));\r\n                    }\r\n                }\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    // left arrow can always be passed through to the terminal as the terminal will handle the left margin\r\n                    term.write(key.key);\r\n                    break;\r\n                case \"ArrowRight\": {\r\n                    // determine cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // determine the current line's length (sub 2 for header)\r\n                    const line_length = split_content[cursor_y - HEADER].length;\r\n\r\n                    if (cursor_x < line_length) {\r\n                        // pass through to the terminal\r\n                        // NOTE: no need to check right margin, because the terminal will handle that\r\n                        term.write(key.key);\r\n                    }\r\n                }\r\n                    break;\r\n                case \"Enter\": {\r\n                    // if readonly, don't allow editing\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n\r\n                    // determine cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    let cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // split the current line at the cursor position\r\n                    const line = split_content[cursor_y - HEADER];\r\n\r\n                    const before_newline = line.slice(0, cursor_x);\r\n                    const after_newline = line.slice(cursor_x);\r\n\r\n                    const old_split_content = split_content.slice();\r\n\r\n                    // insert the new line into the content, between the before_newline and after_newline\r\n                    split_content.splice(cursor_y - HEADER, 1, before_newline, after_newline);\r\n\r\n                    // the code below to redraw selectively is a mess and doesn't work properly for all cases, but is improving\r\n                    // for now, just to get edit in a somewhat working state, we'll just clear the screen and redraw everything (debug redraw but restoring cursor position)\r\n\r\n                    // debug redraw\r\n                    term.reset();\r\n                    setup(term, split_content.join(NEWLINE), path, readonly);\r\n\r\n                    // move the cursor to the start of the new line\r\n                    term.write(`\\x1b[${cursor_y + 2};1H`);\r\n\r\n                    break;\r\n\r\n                    // clear text past the cursor\r\n                    term.write(\" \".repeat(line.length - cursor_x));\r\n\r\n                    // move the cursor down one line and to the beginning of the line\r\n                    term.write(\"\\x1b[1B\\x1b[1G\");\r\n\r\n                    // we are now on the new line. clear it using the old line length and write the new content from after_newline\r\n                    // TODO: could just clear what overruns the new content, but the logic is more confusing. clearing everything is simpler but less efficient\r\n                    term.write(\" \".repeat(old_split_content[cursor_y - HEADER].length)); // doesnt work for all cases, sometime leaves longer line stray\r\n                    term.write(\"\\x1b[1G\")\r\n                    term.write(after_newline);\r\n\r\n                    // adjust cursor y to reflect the real newline being handled\r\n                    cursor_y++;\r\n\r\n                    // clear all the lines below the new cursor position, then write the new content into them\r\n                    // TODO: could just clear what overruns the new content, but the logic is more confusing. clearing everything is simpler but less efficient\r\n                    let lines_redrawn = 0;\r\n                    for (let i = cursor_y - HEADER + 1; i < split_content.length; i++) {\r\n                        term.write(\"\\x1b[1B\\x1b[1G\");\r\n                        if (old_split_content[i]) {\r\n                            term.write(\" \".repeat(old_split_content[i].length));\r\n                            term.write(\"\\x1b[1G\");\r\n                        }\r\n                        term.write(split_content[i]);\r\n                        lines_redrawn++;\r\n                    }\r\n\r\n                    // move the cursor back to the original line at the start of the new line\r\n                    term.write(\"\\x1b[1G\");\r\n                    if (lines_redrawn > 0) {\r\n                        term.write(`\\x1b[${lines_redrawn}A`);\r\n                    }\r\n                }\r\n                    break;\r\n                case \"Backspace\": {\r\n                    // if readonly, don't allow editing\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n                    // get the current cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // do nothing at the start of the file\r\n                    if (cursor_x === 0 && cursor_y === 2) {\r\n                        break;\r\n                    }\r\n\r\n                    // if at the beginning of the line, remove the newline\r\n                    if (cursor_x === 0) {\r\n                        // move previous line's content to the end of the current line\r\n                        const newline_content = split_content[cursor_y - HEADER];\r\n                        split_content[cursor_y - HEADER - 1] += newline_content;\r\n\r\n                        split_content.splice(cursor_y - HEADER, 1);\r\n\r\n                        // the code below to handle backspacing a newline ever only partly worked\r\n                        // for now, just to get edit in a somewhat working state, we'll just clear the screen and redraw everything (debug redraw but restoring cursor position)\r\n\r\n                        // debug redraw\r\n                        term.reset();\r\n                        setup(term, split_content.join(NEWLINE), path, readonly);\r\n\r\n                        // move the cursor to the previous line to the right length across (N from the end where N is the length of the line we just merged, newline_content)\r\n                        // TODO: why isn't this working in all cases??????????????????????????????????\r\n                        term.write(`\\x1b[${cursor_y};${split_content[cursor_y - HEADER - 1].length - newline_content.length + 1}G`);\r\n\r\n                        break;\r\n\r\n                        // move the cursor up one line\r\n                        term.write(\"\\x1b[1A\");\r\n\r\n                        // move the cursor to the end of the line\r\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER - 1].length + 1}G`);\r\n\r\n                        // write the rest of the line\r\n                        term.write(split_content[cursor_y - HEADER]);\r\n\r\n                        // move the cursor back to the original position\r\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER].length + 1}D`);\r\n\r\n                        // TODO: redraw following lines properly\r\n\r\n                        break;\r\n                    }\r\n\r\n\r\n                    // otherwise, remove the character to the left of the cursor\r\n                    const left = split_content[cursor_y - HEADER].slice(0, cursor_x - 1);\r\n                    const right = split_content[cursor_y - HEADER].slice(cursor_x);\r\n\r\n                    split_content[cursor_y - HEADER] = left + right;\r\n\r\n                    // move the cursor back one space\r\n                    term.write(\"\\b\");\r\n\r\n                    // write the rest of the line\r\n                    term.write(right + \" \");\r\n\r\n                    // move the cursor back to the original position\r\n                    term.write(`\\x1b[${right.length + 1}D`);\r\n\r\n                    // if the line is now empty, remove it, unless it's the first line\r\n                    if (cursor_y !== 2 && split_content[cursor_y - HEADER] === \"\") {\r\n                        split_content.splice(cursor_y - HEADER, 1);\r\n                        term.write(\"\\x1b[1M\");\r\n                        break;\r\n                    }\r\n\r\n                    // if the cursor is now past the end of the line, move it to the end of the line\r\n                    if (cursor_x > split_content[cursor_y - HEADER].length) {\r\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER].length + 1}G`);\r\n                    }\r\n                }\r\n                    break;\r\n                default: {\r\n                    // if readonly, don't allow editing\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n                    // get the current cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // if the key is a printable character, write it in\r\n                    if (!NON_PRINTABLE_REGEX.test(key.key)) {\r\n                        // if at the end of the line, append to the line\r\n                        if (cursor_x === split_content[cursor_y - HEADER].length + 1) {\r\n                            split_content[cursor_y - HEADER] += key.key;\r\n                            term.write(key.key);\r\n                        } else {\r\n                            // otherwise, insert it and shift the rest of the line\r\n                            const left = split_content[cursor_y - HEADER].slice(0, cursor_x);\r\n                            const right = split_content[cursor_y - HEADER].slice(cursor_x);\r\n\r\n                            split_content[cursor_y - HEADER] = left + key.key + right;\r\n\r\n                            // overwrite the line\r\n                            term.write(key.key + right);\r\n\r\n                            // move the cursor back to the correct position + 1\r\n                            term.write(`\\x1b[${cursor_x + 2}G`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        term.reset();\r\n\r\n        if (saved) {\r\n            term.writeln(`${FG.green}File saved!${STYLE.reset_all}`);\r\n        } else {\r\n            // TODO: cant exit without saving, crashes the program when trying to set readonly status\r\n            term.writeln(`${FG.red}Exited without saving!${STYLE.reset_all}`);\r\n        }\r\n\r\n        return exit_code;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE } from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"webget\",\r\n    description: \"Downloads a file from the World Wide Web.\",\r\n    usage_suffix: \"url filepath [-o] [-n] [-X method] [-H header] [-B body]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"url\": \"The URL to download from.\",\r\n            \"filepath\": \"The path to save the file to.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"System flags:\": {\r\n                \"-h\": \"Print this help message.\",\r\n                \"-o\": \"Overwrite existing files.\",\r\n                \"-n\": \"Do not replace newlines with the current system's newline character, store as a binary (binary mode).\",\r\n            },\r\n            \"Request flags:\": {\r\n                \"-X\": \"Specify a custom HTTP method. (default: GET)\",\r\n                \"-H\": \"Add a custom header to the request.\",\r\n                \"-B\": \"Specify a custom request body. (only works with POST and PUT methods)\"\r\n            }\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // TODO: replace filename with using piping and send content to stdout\r\n        // TODO: automatically guess binary mode based on file extension or recieved header\r\n\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        if (args[0] === \"-h\") {\r\n            return await kernel.spawn(\"help\", [\"webget\"], shell).completion;\r\n        }\r\n\r\n        // check if the user provided a URL\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}A URL is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // parse url\r\n        const url = args.shift();\r\n\r\n        // validate url\r\n        try {\r\n            const proc_url = new URL(url);\r\n\r\n            if (proc_url.protocol !== \"http:\" && proc_url.protocol !== \"https:\") {\r\n                throw new Error(\"Invalid protocol\");\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Invalid URL. Expected a valid HTTP or HTTPS protocol URL.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        let file_path = \"\";\r\n        let overwrite = false;\r\n        let binary = false;\r\n        let method = \"GET\";\r\n        const headers: Map<string, string> = new Map();\r\n        let body = null;\r\n\r\n        for (let arg_idx = 0; arg_idx < args.length; arg_idx++) {\r\n            const arg = args[arg_idx];\r\n\r\n            switch (arg) {\r\n                case \"-X\": {\r\n                    // consume next argument\r\n                    const next_arg = args[arg_idx + 1];\r\n\r\n                    if (next_arg === undefined) {\r\n                        term.writeln(`${PREFABS.error}Expected a method after -X.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    method = next_arg;\r\n                    args.splice(arg_idx + 1, 1);\r\n                }\r\n                    break;\r\n                case \"-H\": {\r\n                    // consume next argument\r\n                    const header = args[arg_idx + 1];\r\n\r\n                    if (header === undefined) {\r\n                        term.writeln(`${PREFABS.error}Expected a header after -H.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    const split = header.split(\": \");\r\n\r\n                    if (split.length !== 2 || split[0].includes(\" \")) {\r\n                        term.writeln(`${PREFABS.error}Invalid header. Expected a header in the format \"Header-Name: Header-Value\".${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    headers.set(split[0], split[1]);\r\n                    args.splice(arg_idx + 1, 1);\r\n                }\r\n                    break;\r\n                case \"-B\": {\r\n                    // consume next argument\r\n                    const next_arg = args[arg_idx + 1];\r\n\r\n                    if (next_arg === undefined) {\r\n                        term.writeln(`${PREFABS.error}Expected a body after -B.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    body = next_arg;\r\n                    args.splice(arg_idx + 1, 1);\r\n                }\r\n                    break;\r\n                case \"-o\":\r\n                    overwrite = true;\r\n                    break;\r\n                case \"-n\":\r\n                    binary = true;\r\n                    break;\r\n                default:\r\n                    if (file_path === \"\") {\r\n                        file_path = arg;\r\n                    } else {\r\n                        term.writeln(`${PREFABS.error}Unexpected string argument.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n            }\r\n        }\r\n\r\n        // check if the user provided a filename and i it is not a directory\r\n        if (file_path === \"\") {\r\n            term.writeln(`${PREFABS.error}A file path is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (file_path.endsWith(\"/\")) {\r\n            term.writeln(`${PREFABS.error}Cannot write to a directory.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // check if the file already exists\r\n        const abs_path = fs.absolute(file_path);\r\n\r\n        if (await fs.exists(abs_path) && !overwrite) {\r\n            term.writeln(`${PREFABS.error}File already exists.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // if overwriting, run initial check of readonly status\r\n        if (overwrite) {\r\n            if (await fs.is_readonly(abs_path)) {\r\n                term.writeln(`${PREFABS.error}File is readonly.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        // lock the file, creating it if it does not exist\r\n        if (!(await fs.exists(abs_path))) {\r\n            await fs.write_file(abs_path, \"\");\r\n        }\r\n        await fs.set_readonly(abs_path, true);\r\n\r\n        // fetch the file\r\n        let response: Response;\r\n\r\n        term.writeln(`${FG.green}Downloading file...${STYLE.reset_all}`);\r\n\r\n        try {\r\n            // convert headers to object\r\n            const headers_obj: Record<string, string> = {};\r\n            headers.forEach((value, key) => {\r\n                headers_obj[key] = value;\r\n            });\r\n\r\n            response = await fetch(url, { method, headers: headers_obj, body });\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to fetch file.${STYLE.reset_all}`);\r\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            // reset readonly state\r\n            await fs.set_readonly(abs_path, false);\r\n\r\n            //  if this wasn't an overwrite, delete the file that was created\r\n            if (!overwrite) {\r\n                await fs.delete_file(abs_path);\r\n            }\r\n\r\n            return 1;\r\n        }\r\n\r\n        if (!response.ok) {\r\n            term.writeln(`${PREFABS.error}Request not OK.${STYLE.reset_all}`);\r\n\r\n            // get the error message\r\n            const text = await response.text();\r\n\r\n            if (text !== \"\") {\r\n                term.writeln(`${PREFABS.error}${text}${STYLE.reset_all}`);\r\n            }\r\n\r\n            // reset readonly state\r\n            await fs.set_readonly(abs_path, false);\r\n\r\n            //  if this wasn't an overwrite, delete the file that was created\r\n            if (!overwrite) {\r\n                await fs.delete_file(abs_path);\r\n            }\r\n\r\n            return 1;\r\n        }\r\n\r\n        if (binary) {\r\n            // write the file as binary\r\n            const buffer = await response.arrayBuffer();\r\n\r\n            await fs.write_file(abs_path, new Uint8Array(buffer), true);\r\n        } else {\r\n            // write the file as text\r\n            const text = await response.text();\r\n\r\n            await fs.write_file(abs_path, text.replace(/\\r?\\n/g, NEWLINE), true);\r\n        }\r\n\r\n        // reset readonly state (must've be writable or else this wouldn't be reached)\r\n        await fs.set_readonly(abs_path, false);\r\n\r\n        term.writeln(`${FG.green}File downloaded successfully.${STYLE.reset_all}`);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"cat\",\r\n    description: \"Reads files and prints their contents to the terminal.\",\r\n    usage_suffix: \"[filepaths...]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"filepaths\": \"The paths of the files to read.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // get each file's content and print it to the terminal\r\n        for (const filepath of args) {\r\n            const abs_path = fs.absolute(filepath);\r\n\r\n            // check if the file exists and is a file\r\n            if (await fs.dir_exists(abs_path)) {\r\n                term.writeln(`${PREFABS.error}Cannot read a directory: ${abs_path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            if (!(await fs.exists(abs_path))) {\r\n                term.writeln(`${PREFABS.error}File not found: ${abs_path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // get file\r\n            const content = await fs.read_file(abs_path);\r\n\r\n            // print file content to terminal\r\n            term.writeln(content);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\n// TODO: when edit is done, add a flag to edit the file in the editor\r\n\r\nexport default {\r\n    name: \"hex\",\r\n    description: \"Reads a file as hexadecimal.\",\r\n    usage_suffix: \"[-h] path [-i]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the file to read.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-h\": \"Print this help message.\",\r\n            \"-i\": \"Print indexes.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // use default logic for first argument\r\n        if (data.arg_index === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (data.arg_index === 1) {\r\n            if (\"-i\".startsWith(data.current_partial)) {\r\n                return [\"-i\"];\r\n            }\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // check if the user provided a filepath\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}A file path is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args[0] === \"-h\") {\r\n            await kernel.spawn(\"help\", [\"hex\"], shell).completion;\r\n        }\r\n\r\n        // get filepath\r\n        const filepath = args[0];\r\n\r\n        // get absolute path\r\n        const abs_path = fs.absolute(filepath);\r\n\r\n        // check if the file exists and is a file\r\n        if (abs_path.endsWith(\"/\")) {\r\n            term.writeln(`${PREFABS.error}Cannot read a directory: ${abs_path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (!(await fs.exists(abs_path))) {\r\n            term.writeln(`${PREFABS.error}File not found: ${abs_path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get file\r\n        const content = await fs.read_file(abs_path, true) as Uint8Array;\r\n\r\n        // convert uint8array to hex string\r\n        const hex = Array.from(content).map((byte) => byte.toString(16).toUpperCase().padStart(2, \"0\"));\r\n\r\n        // if printing indexes, print the header\r\n        if (args[1] === \"-i\") {\r\n            term.writeln(`         ${FG.blue}00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F${STYLE.reset_all}`);\r\n        }\r\n\r\n        // print hex bytes to terminal up to 16 bytes per line, padding the end with .. in place of the missing bytes\r\n        // if printing indexes, print the index of the first byte on the line, in hexadecimal up to 8 bytes\r\n        for (let i = 0; i < hex.length; i += 16) {\r\n            const line = hex.slice(i, i + 16);\r\n\r\n            if (args[1] === \"-i\") {\r\n                const idx = i <= 0xffffffff ? i.toString(16).toUpperCase() : \"........\";\r\n\r\n\r\n                term.write(`${FG.blue}${idx.padStart(8, \"0\")}${STYLE.reset_all} `);\r\n            }\r\n\r\n            const padded = line.concat(Array(16 - line.length).fill(`${FG.gray}..${STYLE.reset_all}`));\r\n            term.writeln(padded.join(\" \"));\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { NEWLINE, ANSI, ANSI_UNESCAPED_REGEX } from \"../term_ctl\";\r\n\r\nimport { default as img2ascii } from \"imgToAscii\";\r\n\r\n\r\nconst MY_USERNAME = \"obfuscatedgenerated\";\r\nconst GH_USERNAME_REGEX = /^[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}$/i;\r\n\r\nconst username_to_avatar_url = (username: string): string => {\r\n    return `https://avatars.githubusercontent.com/${username}`;\r\n}\r\n\r\ntype GHInfo = { name: string, bio: string, location: string, blog: string, followers: number, following: number, twitter: string };\r\nconst get_github_info = async (username: string): Promise<GHInfo> => {\r\n    const url = `https://api.github.com/users/${username}`;\r\n    const res = await fetch(url);\r\n\r\n    if (!res.ok) {\r\n        return null;\r\n    }\r\n\r\n    const json = await res.json();\r\n\r\n    return {\r\n        name: json.name,\r\n        bio: json.bio,\r\n        location: json.location,\r\n        blog: json.blog,\r\n        followers: json.followers,\r\n        following: json.following,\r\n        twitter: json.twitter_username\r\n    };\r\n}\r\n\r\nconst convert_to_ascii = async (url: string, size: number): Promise<string> => {\r\n    const img = new img2ascii(url, size, Math.round(size / 2));\r\n    await img.loadImage;\r\n\r\n    // convert newlines in string\r\n    const ascii = img.stringANSI8BitColor.replace(/\\n/g, NEWLINE);\r\n    return ascii;\r\n}\r\n\r\n\r\nconst known_info = (username: string, data: { [key: string]: any }, gh_info: GHInfo | null, version_str: string) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, FG, PREFABS } = ANSI;\r\n\r\n    return `\r\n${STYLE.bold}${username}\r\n-------------------\r\n${STYLE.bold}OS${STYLE.reset_all + FG.cyan}: OllieOS v${version_str}\r\n\r\n${STYLE.bold}Name${STYLE.reset_all + FG.cyan}: ${data.name || gh_info?.name || \"Unknown\"}\r\n${STYLE.bold}Pronouns${STYLE.reset_all + FG.cyan}: ${data.pronouns.subject}/${data.pronouns.object_or_alt}${data.pronouns.possessive ? `/${data.pronouns.possessive}` : \"\"}\r\n${STYLE.bold}Location${STYLE.reset_all + FG.cyan}: ${data.location || gh_info?.location || \"Unknown\"}\r\n${STYLE.bold}Interests${STYLE.reset_all + FG.cyan}: ${data.interests.join(\", \") || \"None listed\"}\r\n\r\n${data.websites ? Object.entries(data.websites).map(\r\n    ([name, url]) => `${STYLE.bold}${name}${STYLE.reset_all + FG.cyan}: ${url}`\r\n).join(NEWLINE) : \"\"}\r\n\r\n${STYLE.bold}GitHub Followers${STYLE.reset_all + FG.cyan}: ${gh_info.followers || 0}\r\n${STYLE.bold}GitHub Following${STYLE.reset_all + FG.cyan}: ${gh_info.following || 0}\r\n\r\n${data.extra ? Object.entries(data.extra).map(\r\n    ([name, value]) => `${STYLE.bold}${name}${STYLE.reset_all + FG.cyan}: ${value}`\r\n).join(NEWLINE) : \"\"}\r\n        `.replace(/\\n/g, NEWLINE);\r\n}\r\n\r\nconst stranger_info = (username: string, gh_info: GHInfo | null, cols: number, version_str: string) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, FG } = ANSI;\r\n\r\n    // line wrap the bio and make sure newlines ARE NOT CRLF (to retain columns)\r\n    if (gh_info.bio) {\r\n        gh_info.bio = gh_info.bio.replace(/\\r\\n/g, \"\\n\").replace(new RegExp(`(.{${Math.floor(cols * 0.25)}})\\\\s`, \"g\"), \"$1\\n\");\r\n    }\r\n\r\n    // TODO: messy, clean up\r\n    // insert known data or move up a line if not known (to undo the newline added by the ternary operator)\r\n    return `\r\n${STYLE.bold}${username}\r\n${\"-\".repeat(username.length)}\r\n${STYLE.bold}OS${STYLE.reset_all + FG.cyan}: OllieOS v${version_str}\r\n\r\n${gh_info.name ? `${STYLE.bold}Name${STYLE.reset_all + FG.cyan}: ${gh_info.name}` : \"\\x1b[1A\"}\r\n${gh_info.location ? `${STYLE.bold}Location${STYLE.reset_all + FG.cyan}: ${gh_info.location}` : \"\\x1b[1A\"}\r\n${gh_info.bio ? `${STYLE.bold}Bio${STYLE.reset_all + FG.cyan}: ${gh_info.bio}` : \"\\x1b[1A\"}\r\n\r\n${gh_info.blog ? `${STYLE.bold}Website${STYLE.reset_all + FG.cyan}: ${gh_info.blog}` : \"\\x1b[1A\"}\r\n\r\n${STYLE.bold}GitHub${STYLE.reset_all + FG.cyan}: https://github.com/${username}\r\n${gh_info.twitter ? `${STYLE.bold}Twitter${STYLE.reset_all + FG.cyan}: https://twitter.com/${gh_info.twitter}` : \"\\x1b[1A\"}\r\n\r\n${STYLE.bold}GitHub Followers${STYLE.reset_all + FG.cyan}: ${gh_info.followers || 0}\r\n${STYLE.bold}GitHub Following${STYLE.reset_all + FG.cyan}: ${gh_info.following || 0}\r\n    `.replace(/\\n/g, NEWLINE);\r\n}\r\n\r\nexport default {\r\n    name: \"mefetch\",\r\n    description: \"Shows information about me (or you!)\",\r\n    usage_suffix: \"[username]\",\r\n    arg_descriptions: {\r\n        \"username\": \"The GitHub username to show basic info about. Defaults to my username, with the special info shown.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term, args } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, FG } = ANSI;\r\n\r\n        // get version string\r\n        const version_str = kernel.get_env_info().version;\r\n\r\n        // restrict to first 3 quarters of screen\r\n        const max_columns = Math.floor(term.cols * 0.75);\r\n\r\n        // set image size\r\n        const asc_width = Math.floor(max_columns / 3);\r\n\r\n        // get username\r\n        const username = args[0] || MY_USERNAME;\r\n\r\n        // check if username is valid\r\n        if (!username.match(GH_USERNAME_REGEX)) {\r\n            term.write(`${STYLE.bold}${FG.red}Invalid username.${STYLE.reset_all}\\n`);\r\n            return 1;\r\n        }\r\n\r\n        // get info from GitHub\r\n        const gh_info = await get_github_info(username);\r\n\r\n        // if info is null, then the user doesn't exist\r\n        if (gh_info === null) {\r\n            term.write(`${STYLE.bold}${FG.red}User not found.${STYLE.reset_all}\\n`);\r\n            return 1;\r\n        }\r\n\r\n        // use local logo for efficiency if username is mine\r\n        const avatar_url = MY_USERNAME === username ? \"https://ollieg.codes/public/logo.png\" : username_to_avatar_url(username);\r\n\r\n        // convert image to ascii\r\n        const ascii_pfp = await convert_to_ascii(avatar_url, asc_width);\r\n\r\n        // check synced data if username exists in data repo\r\n        let known_data = null;\r\n        const fs = kernel.get_fs();\r\n        if (await fs.exists(\"/var/lib/data/person/index.json\")) {\r\n            const data_index_str = await fs.read_file(\"/var/lib/data/person/index.json\") as string;\r\n            const data_index = JSON.parse(data_index_str) as string[];\r\n\r\n            if (data_index.includes(username)) {\r\n                const user_data_str = await fs.read_file(`/var/lib/data/person/${username}.json`) as string;\r\n                known_data = JSON.parse(user_data_str);\r\n            }\r\n        }\r\n\r\n        // text is written with \\n as newlines for simplicity, replaced with NEWLINE\r\n        let text: string;\r\n        if (known_data) {\r\n            text = known_info(username, known_data, gh_info, version_str);\r\n        } else {\r\n            text = stranger_info(username, gh_info, term.cols, version_str);\r\n        }\r\n\r\n        // reapply style each line as image will override it\r\n        const txt_line_prefix = FG.cyan;\r\n        const txt_line_suffix = STYLE.reset_all;\r\n\r\n        // go line by line through both text and ascii\r\n        const asc_lines = ascii_pfp.split(NEWLINE);\r\n        const txt_lines = text.split(NEWLINE);\r\n\r\n        // get the greater of the two lengths\r\n        const max_lines = Math.max(asc_lines.length, txt_lines.length);\r\n\r\n        // get the longest length of a line of ascii ignoring ansi characters, and the longest length of a line of text\r\n        const max_asc_line_length = Math.max(...asc_lines.map(line => line.replace(ANSI_UNESCAPED_REGEX, \"\").length));\r\n        const max_txt_line_length = Math.max(...txt_lines.map(line => line.length));\r\n\r\n        // determine padding around and between text and ascii\r\n        const center_padding_size = Math.floor(max_columns / 15);\r\n        const side_padding_size = Math.floor((max_columns - max_txt_line_length - (max_asc_line_length / 2) - center_padding_size) / 2);\r\n\r\n        // generate padding strings, if positive\r\n        const center_padding = \" \".repeat(center_padding_size > 0 ? center_padding_size : 0);\r\n        const side_padding = \" \".repeat(side_padding_size > 0 ? side_padding_size : 0);\r\n\r\n        // print each line\r\n        for (let i = 0; i < max_lines; i++) {\r\n            const asc_line = asc_lines[i] || \"\";\r\n            const txt_line = txt_lines[i] || \"\";\r\n\r\n            // add additional padding so the width of the ascii line is always the same\r\n            const asc_line_padding = \" \".repeat(max_asc_line_length - asc_line.replace(ANSI_UNESCAPED_REGEX, \"\").length);\r\n\r\n            // print side by side with padding\r\n            term.writeln(side_padding + asc_line + asc_line_padding + center_padding + txt_line_prefix + txt_line + txt_line_suffix);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import { ANSI } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"reader\",\r\n    description: \"Toggles screen reader mode. Due to a technical limitation, on-screen links will not be clickable in screen reader mode.\",\r\n    usage_suffix: \"[-h] [-q] [-s on|off]\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-q\": \"Query the current screen reader mode.\",\r\n            \"-s\": \"Explicitly set the screen reader mode to on or off, rather than toggling it.\"\r\n        }\r\n    },\r\n    node_opt_out: true,\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (data.arg_index === 0) {\r\n            return helper_completion_options([\"-h\", \"-q\", \"-s\"])(data);\r\n        }\r\n\r\n        if (data.arg_index === 1 && data.args[0] === \"-s\") {\r\n            return helper_completion_options([\"on\", \"off\"])(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get sound registry\r\n        const sfx_reg = kernel.get_sound_registry();\r\n\r\n        switch (args[0]) {\r\n            case \"-h\":\r\n                return await kernel.spawn(\"help\", [\"clear\"], shell).completion;\r\n            case \"-q\":\r\n                // query screen reader mode\r\n                term.writeln(`Screen reader mode is currently ${term.options.screenReaderMode ? \"on\" : \"off\"}.`);\r\n                return 0;\r\n            case \"-s\":\r\n                // set screen reader mode\r\n                switch (args[1]) {\r\n                    case \"on\":\r\n                        term.options.screenReaderMode = true;\r\n                        break;\r\n                    case \"off\":\r\n                        term.options.screenReaderMode = false;\r\n                        break;\r\n                    default:\r\n                        term.writeln(\"Invalid argument. Expected \\\"on\\\" or \\\"off\\\".\");\r\n                        return 1;\r\n                }\r\n                break;\r\n            default:\r\n                // toggle screen reader mode\r\n                term.options.screenReaderMode = !term.options.screenReaderMode;\r\n        }\r\n\r\n        const state = term.options.screenReaderMode ? \"on\" : \"off\";\r\n\r\n        // play sound\r\n        const sound_name = `reader_${state}`;\r\n        sfx_reg.wait_to_play(sound_name);\r\n\r\n        // print message\r\n        term.writeln(`Screen reader mode was turned ${state}. This setting is saved in your browser's local storage. Use the ${PREFABS.program_name}reader${STYLE.reset_all} command to toggle it.`);\r\n\r\n        // remove hint element if screen reader mode is on\r\n        if (term.options.screenReaderMode) {\r\n            const hint = document.querySelector(\"#screenreader_hint\");\r\n\r\n            if (hint) {\r\n                hint.remove();\r\n            }\r\n        }\r\n\r\n        // save into local storage\r\n        localStorage.setItem(\"reader\", term.options.screenReaderMode.toString());\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE } from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"selfdestruct\",\r\n    description: \"Permanently erases the filesystem and other data, then restarts the terminal.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { FG, BG, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        const pad = (str: string, invis_codes = \"\") => {\r\n            if (str.length >= term.cols) {\r\n                return str;\r\n            }\r\n\r\n            return str + \" \".repeat(term.cols - str.length + invis_codes.length);\r\n        }\r\n\r\n        // make sure the user really wants to do this\r\n        term.writeln(BG.red + FG.white + STYLE.bold);\r\n        term.write(pad(\"WARNING: This will permanently erase the filesystem and other data, and restart the terminal.\"));\r\n        term.writeln(pad(\"This data cannot be recovered. Are you sure you want to do this?\"));\r\n        term.writeln(pad(`Press ${BG.blue}Y${BG.red} 3 times to continue, or anything else to cancel.`, BG.blue + BG.red));\r\n        term.write(STYLE.reset_all);\r\n\r\n        // wait for the user to press Y 3 times\r\n        let y_count = 0;\r\n        while (y_count < 3) {\r\n            const key = await term.wait_for_keypress();\r\n            if (key.key === \"y\" || key.key === \"Y\") {\r\n                y_count++;\r\n            } else {\r\n                term.writeln(\"Cancelled.\");\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        // clear the screen and erase the filesystem\r\n        term.reset();\r\n\r\n        term.writeln(\"Erasing filesystem and other data...\");\r\n        await fs.erase_all();\r\n        localStorage.removeItem(\"fetch_ttl_cache\");\r\n\r\n        term.writeln(`${NEWLINE}Thank you for using OllieOS!${NEWLINE}`);\r\n\r\n        // TODO: talk to ignition instead of using shutdown command\r\n        return await kernel.spawn(\"shutdown\", [\"-r\", \"-t\", \"3000\"], shell).completion;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\n\r\nimport { image2sixel } from \"sixel\";\r\n\r\n\r\n// returns null if image is invalid\r\nconst convert_to_image_data = async (url: string) => {\r\n    // create a canvas to draw the image on\r\n    const canvas = document.createElement(\"canvas\");\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    // create an image to draw the png data on\r\n    const img = new Image();\r\n    img.crossOrigin = \"anonymous\";\r\n    img.src = url;\r\n\r\n    // wait for the image to load via promise\r\n    try {\r\n        await new Promise((resolve, reject) => {\r\n            img.onload = () => {\r\n                resolve(null);\r\n            };\r\n\r\n            img.onerror = () => {\r\n                reject(null);\r\n            };\r\n        });\r\n    } catch (e) {\r\n        return null;\r\n    }\r\n\r\n    // draw the image on the canvas\r\n    canvas.width = img.width;\r\n    canvas.height = img.height;\r\n    ctx.drawImage(img, 0, 0);\r\n\r\n    // get the image data\r\n    const img_data = ctx.getImageData(0, 0, img.width, img.height);\r\n\r\n    // convert image data to uint8array\r\n    const data_arr = new Uint8Array(img_data.data);\r\n\r\n    return { array: data_arr, width: img.width, height: img.height };\r\n};\r\n\r\nexport default {\r\n    name: \"imagine\",\r\n    description: \"Views images natively in the terminal.\",\r\n    usage_suffix: \"path [-w width] [-u]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the image to view.\"\r\n        },\r\n        \"Options:\": {\r\n            \"-w\": \"The width of the image in PIXELS. Defaults to the width of the image.\",\r\n            \"-u\": \"Path is an web URL instead of a local filesystem path.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // get the path to the image\r\n        const path = args[0];\r\n\r\n        if (!path) {\r\n            term.writeln(`${PREFABS.error}No path specified.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get the width of the image specified or the terminal width\r\n        let width_arg = args.includes(\"-w\") ? parseInt(args[args.indexOf(\"-w\") + 1]) : undefined;\r\n        const is_web_url = args.includes(\"-u\");\r\n\r\n        let url: string;\r\n        let mime: string;\r\n        if (!is_web_url) {\r\n            // process the path\r\n            url = fs.absolute(path);\r\n            if (!(await fs.exists(url))) {\r\n                term.writeln(`${PREFABS.error}No such file or directory: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // get the extension\r\n            const ext = url.slice(-4).toLowerCase();\r\n\r\n            // get the mime type\r\n            switch (ext) {\r\n                case \".png\":\r\n                    mime = \"image/png\";\r\n                    break;\r\n                case \".jpg\":\r\n                case \"jpeg\":\r\n                    mime = \"image/jpeg\";\r\n                    break;\r\n                case \".gif\":\r\n                    mime = \"image/gif\";\r\n                    break;\r\n                default:\r\n                    term.writeln(`${PREFABS.error}File is not known to be a .png, .jpg/.jpeg or .gif: ${url}${STYLE.reset_all}`);\r\n                    return 1;\r\n            }\r\n\r\n\r\n            // convert to blob URL\r\n            const content = await fs.read_file(url, true) as Uint8Array;\r\n            //@ts-expect-error\r\n            url = URL.createObjectURL(new Blob([content]));\r\n\r\n        } else {\r\n            // check path is a valid URL\r\n            try {\r\n                new URL(path);\r\n                url = path;\r\n            } catch (e) {\r\n                term.writeln(`${PREFABS.error}Invalid URL: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // do a HEAD request to get the mime type\r\n            try {\r\n                const head_req = await fetch(url, { method: \"HEAD\" });\r\n\r\n                // if the HEAD request failed, try a GET request\r\n                if (!head_req.ok) {\r\n                    console.log(\"HEAD request failed, trying GET request\");\r\n                    const get_req = await fetch(url);\r\n\r\n                    // if the GET request failed, error\r\n                    if (!get_req.ok) {\r\n                        term.writeln(`${PREFABS.error}URL is not accessible: ${url}${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    mime = get_req.headers.get(\"content-type\");\r\n                } else {\r\n                    mime = head_req.headers.get(\"content-type\");\r\n                }\r\n\r\n                // check the mime type is valid\r\n                if ([\"image/png\", \"image/jpeg\", \"image/gif\"].indexOf(mime) === -1) {\r\n                    term.writeln(`${PREFABS.error}URL does not point to a .png, .jpg/.jpeg or .gif: ${url}${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n            } catch (e) {\r\n                term.writeln(`${PREFABS.error}Error accessing URL: ${url}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        const data_out = await convert_to_image_data(url);\r\n\r\n        if (!data_out) {\r\n            term.writeln(`${PREFABS.error}Failed to convert image to data. Did you download it as a binary file?${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        const { array: img_data, width: img_width, height: img_height } = data_out\r\n\r\n        if (!width_arg) {\r\n            width_arg = img_width;\r\n        }\r\n\r\n        // scale the height to fit the width\r\n        const width_scale = width_arg / img_width;\r\n        const new_height = img_height * width_scale;\r\n\r\n        // scale the image data by chopping every nth pixel\r\n        const scaled_img_data = new Uint8Array(width_arg * new_height * 4);\r\n        for (let i = 0; i < scaled_img_data.length; i++) {\r\n            const x = Math.floor(i / 4) % width_arg;\r\n            const y = Math.floor(Math.floor(i / 4) / width_arg);\r\n\r\n            const scaled_x = Math.floor(x / width_scale);\r\n            const scaled_y = Math.floor(y / width_scale);\r\n\r\n            const scaled_i = (scaled_y * img_width + scaled_x) * 4 + (i % 4);\r\n\r\n            scaled_img_data[i] = img_data[scaled_i];\r\n        }\r\n\r\n        try {\r\n            // convert the Uint8Array to a sixel image\r\n            const sixel = image2sixel(scaled_img_data, width_arg, new_height);\r\n\r\n            // write the sixel image to the terminal\r\n            term.write(sixel);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to convert image to sixel.${STYLE.reset_all}`);\r\n            console.error(e);\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE } from \"../term_ctl\";\r\n\r\nimport { default as img2ascii } from \"imgToAscii\";\r\n\r\n\r\n// TODO: DRY with mefetch\r\nconst convert_to_ascii = async (url: string, size: number): Promise<string> => {\r\n    const img = new img2ascii(url, size, Math.round(size / 2));\r\n    await img.loadImage;\r\n\r\n    // convert newlines in string\r\n    const ascii = img.stringANSI8BitColor.replace(/\\n/g, NEWLINE);\r\n    return ascii;\r\n}\r\n\r\nexport default {\r\n    name: \"ascmagine\",\r\n    description: \"Views images as ANSI/ASCII art.\",\r\n    usage_suffix: \"path [-w width] [-u]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the image to view.\"\r\n        },\r\n        \"Options:\": {\r\n            \"-w\": \"The width of the image in COLUMNS. Defaults to the width of the terminal.\",\r\n            \"-u\": \"Path is an web URL instead of a local filesystem path.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // get the path to the image\r\n        const path = args[0];\r\n\r\n        if (!path) {\r\n            term.writeln(`${PREFABS.error}No path specified.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get the width of the image specified or the terminal width\r\n        const width_arg = args.includes(\"-w\") ? parseInt(args[args.indexOf(\"-w\") + 1]) : undefined;\r\n        const is_web_url = args.includes(\"-u\");\r\n\r\n        let url: string;\r\n        if (!is_web_url) {\r\n            // process the path\r\n            url = fs.absolute(path);\r\n            if (!(await fs.exists(url))) {\r\n                term.writeln(`${PREFABS.error}No such file or directory: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // convert to blob\r\n            const content = await fs.read_file(url, true) as Uint8Array;\r\n            //@ts-expect-error\r\n            const blob = new Blob([content]);\r\n\r\n            // attempt createImageBitmap on the file to determine if it's a canvas-compatible image in the browser\r\n            if (typeof createImageBitmap === \"function\") {\r\n                try {\r\n                    // using tiny region at low res for efficiency\r\n                    await createImageBitmap(blob, 0, 0, 1, 1);\r\n                } catch (e) {\r\n                    term.writeln(`${PREFABS.error}File is not a valid image: ${path}. Did you download it as a binary file?${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n            } else {\r\n                term.writeln(`${FG.yellow}Warning: ${STYLE.reset_all}createImageBitmap is not supported in this browser. Falling back to list of trusted image formats.${STYLE.reset_all}`)\r\n                \r\n                const trusted_formats = [\".png\", \".jpg\", \".jpeg\", \".gif\", \".bmp\", \".ico\", \".svg\"];\r\n                const ext = url.slice(-4).toLowerCase();\r\n\r\n                if (!(trusted_formats.includes(ext))) {\r\n                    term.writeln(`${PREFABS.error}File is not a valid image: ${path}. Did you download it as a binary file?${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n            }\r\n\r\n            // create a blob URL\r\n            //@ts-expect-error\r\n            url = URL.createObjectURL(new Blob([content]));\r\n\r\n        } else {\r\n            // check path is a valid URL\r\n            try {\r\n                new URL(path);\r\n                url = path;\r\n            } catch (e) {\r\n                term.writeln(`${PREFABS.error}Invalid URL: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // do a HEAD request to check the mime type\r\n            const head_req = await fetch(url, { method: \"HEAD\" });\r\n            let mime: string;\r\n\r\n            // if the HEAD request failed, try a GET request\r\n            if (!head_req.ok) {\r\n                console.log(\"HEAD request failed, trying GET request\");\r\n                const get_req = await fetch(url);\r\n\r\n                // if the GET request failed, error\r\n                if (!get_req.ok) {\r\n                    term.writeln(`${PREFABS.error}URL is not accessible: ${url}${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                mime = get_req.headers.get(\"content-type\");\r\n            } else {\r\n                mime = head_req.headers.get(\"content-type\");\r\n            }\r\n\r\n            // check the mime type is valid\r\n            if (!mime.startsWith(\"image/\")) {\r\n                term.writeln(`${PREFABS.error}URL is not an image: ${url}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        // get the image\r\n        const img = await convert_to_ascii(url, width_arg || term.cols - 1);\r\n\r\n        // write the image\r\n        term.write(img);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"fsedit\",\r\n    description: \"Opens the fsedit program to edit the filesystem.\",\r\n    usage_suffix: \"[directory]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            directory: \"The directory to open fsedit in. Defaults to the current working directory.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term, process } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // get fs name\r\n        const fs_name = fs.get_unique_fs_type_name();\r\n\r\n        // check args\r\n        let dir = fs.get_cwd();\r\n        if (args.length > 1) {\r\n            term.writeln(`${PREFABS.error}Too many arguments.${STYLE.reset_all}`);\r\n            return 1;\r\n        } else if (args.length === 1) {\r\n            // set dir\r\n            dir = fs.absolute(args[0]);\r\n        }\r\n\r\n        // check if directory exists\r\n        if (!(await fs.dir_exists(dir))) {\r\n            term.writeln(`${PREFABS.error}Directory '${args[0]}' does not exist.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // url encode the directory\r\n        const encoded_dir = encodeURIComponent(dir);\r\n\r\n        if (!kernel.has_window_manager()) {\r\n            // fallback to opening in a popup window\r\n            window.open(`./fsedit?type=${fs_name}&dir=${encoded_dir}`, \"_blank\", \"popup=true\");\r\n            term.writeln(\"Opened fsedit in a new popup window.\");\r\n            return 0;\r\n        }\r\n\r\n        const iframe = document.createElement(\"iframe\");\r\n        iframe.src = `./fsedit?type=${fs_name}&dir=${encoded_dir}`;\r\n        iframe.style.border = \"none\";\r\n        iframe.style.width = \"100%\";\r\n        iframe.style.height = \"100%\";\r\n\r\n        const wind = process.create_window();\r\n        wind.title = \"fsedit\";\r\n\r\n        wind.width = \"75vw\";\r\n        wind.height = \"75vh\";\r\n\r\n        wind.x = \"12.5vw\";\r\n        wind.y = \"12.5vh\";\r\n\r\n        wind.dom.appendChild(iframe);\r\n        wind.show();\r\n\r\n        // send message\r\n        term.writeln(\"Opened fsedit in a new window.\");\r\n\r\n        wind.add_event_listener(\"close\", async () => {\r\n            // backup unlock logic TODO improve the design of fsedit in general\r\n            if (await fs.exists(\"/.fs.lock\")) {\r\n                // check that no other fsedit processes are running\r\n                let other_fsedit_running = false;\r\n                const processes = kernel.get_process_manager().list_pids();\r\n                for (const pid of processes) {\r\n                    if (pid === process.pid) {\r\n                        continue;\r\n                    }\r\n\r\n                    const proc = kernel.get_process_manager().get_process(pid);\r\n                    if (proc && proc.source_command.command === \"fsedit\") {\r\n                        other_fsedit_running = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!other_fsedit_running) {\r\n                    await fs.delete_file(\"/.fs.lock\");\r\n                }\r\n            }\r\n\r\n            process.kill(0);\r\n        });\r\n\r\n        // listen for message from iframe to close window\r\n        const message_handler = (event: MessageEvent) => {\r\n            if (event.source === iframe.contentWindow && event.data === \"closing-fsedit\") {\r\n                wind.close();\r\n                window.removeEventListener(\"message\", message_handler);\r\n            }\r\n        };\r\n        window.addEventListener(\"message\", message_handler);\r\n\r\n        process.detach();\r\n        return 0;\r\n    }\r\n} as Program;","export class PathNotFoundError extends Error {\r\n    constructor(path: string) {\r\n        super(`Path not found: ${path}`);\r\n    }\r\n}\r\n\r\nexport class NonRecursiveDirectoryError extends Error {\r\n    constructor(path: string) {\r\n        super(`Refusing to delete non-empty directory: ${path}`);\r\n    }\r\n}\r\n\r\nexport class ReadOnlyError extends Error {\r\n    constructor(path: string) {\r\n        super(`Path is read-only: ${path}`);\r\n    }\r\n}\r\n\r\nexport enum FSEventType {\r\n    READING_FILE,\r\n    WROTE_FILE,\r\n    DELETED_FILE,\r\n    MOVED_FILE,\r\n    SET_READONLY,\r\n\r\n    LISTING_DIR,\r\n    MADE_DIR,\r\n    DELETED_DIR,\r\n    MOVED_DIR,\r\n\r\n    SET_CWD,\r\n    GETTING_CWD,\r\n    SET_HOME,\r\n    GETTING_HOME,\r\n    SET_ROOT,\r\n    GETTING_ROOT,\r\n\r\n    CHECKING_EXISTS,\r\n    CHECKING_DIR_EXISTS,\r\n}\r\n\r\n// TODO: ensure all functions fire these events... or do we even need this system other than for cwd changing?\r\n\r\nexport type FSEventHandler = (data: string, fs: AbstractFileSystem) => void;\r\n\r\nexport abstract class AbstractFileSystem {\r\n    //TODO: dry\r\n    _initialised = false;\r\n\r\n    _cache: Map<string, { readonly: boolean, content: string | Uint8Array, as_uint: boolean }> = new Map();\r\n    _callbacks: Map<FSEventType, FSEventHandler[]> = new Map();\r\n\r\n    _root = \"/\";\r\n    _home = \"/home\";\r\n    _cwd = this._home;\r\n\r\n    abstract get_unique_fs_type_name(): string;\r\n    abstract erase_all(): Promise<void>;\r\n\r\n    abstract is_ready(): Promise<boolean>;\r\n\r\n    purge_cache(smart = false): void {\r\n        if (smart) {\r\n            for (const path in this._cache) {\r\n                if (!this.exists_direct(path)) {\r\n                    this._cache.delete(path);\r\n                }\r\n            }\r\n        } else {\r\n            this._cache = new Map();\r\n        }\r\n    }\r\n\r\n    force_remove_from_cache(path: string): void {\r\n        this._cache.delete(path);\r\n    }\r\n\r\n    remote_purge_cache(smart: boolean): void {\r\n        localStorage.setItem(\"purge_cache\", smart.toString());\r\n    }\r\n\r\n    remote_remove_from_cache(path: string): void {\r\n        localStorage.setItem(\"remove_from_cache\", path);\r\n    }\r\n\r\n    _remote_listener(): void {\r\n        const purge_cache = localStorage.getItem(\"purge_cache\");\r\n        if (purge_cache) {\r\n            this.purge_cache(purge_cache === \"true\");\r\n            localStorage.removeItem(\"purge_cache\");\r\n        }\r\n\r\n        const remove_from_cache = localStorage.getItem(\"remove_from_cache\");\r\n        if (remove_from_cache) {\r\n            this.force_remove_from_cache(remove_from_cache);\r\n            localStorage.removeItem(\"remove_from_cache\");\r\n        }\r\n    }\r\n\r\n\r\n    register_callback(event_type: FSEventType, callback: FSEventHandler): () => void {\r\n        // if there are no callbacks for this event type, create an empty array\r\n        if (!this._callbacks.has(event_type)) {\r\n            this._callbacks.set(event_type, []);\r\n        }\r\n\r\n        // add callback to array\r\n        this._callbacks.get(event_type).push(callback);\r\n\r\n        // return function to remove callback\r\n        return () => {\r\n            this._callbacks.get(event_type).splice(this._callbacks.get(event_type).indexOf(callback), 1);\r\n        }\r\n    }\r\n\r\n    _call_callbacks(event_type: FSEventType, data: string): void {\r\n        // call all callbacks\r\n        for (const callback of this._callbacks.get(event_type) ?? []) {\r\n            callback(data, this);\r\n        }\r\n    }\r\n\r\n\r\n    abstract read_file_direct(path: string, as_uint: boolean): Promise<string | Uint8Array>;\r\n    abstract write_file_direct(path: string, data: string | Uint8Array): Promise<void>;\r\n    abstract delete_file_direct(path: string): Promise<void>;\r\n    // does not check if destination exists\r\n    abstract move_file_direct(src: string, new_path: string): Promise<void>;\r\n    abstract set_readonly_direct(path: string, readonly: boolean): Promise<void>;\r\n    abstract is_readonly_direct(path: string): Promise<boolean>;\r\n\r\n\r\n    async read_file(path: string, as_uint = false): Promise<string | Uint8Array> {\r\n        // prevent prototype pollution\r\n\r\n        this._call_callbacks(FSEventType.READING_FILE, path);\r\n\r\n        // check if file is in cache and still exists, as well as if it's the correct type\r\n        const cached = this._cache.get(path);\r\n        if (cached && await this.exists(path) && cached.as_uint === as_uint) {\r\n            return this._cache.get(path).content;\r\n        }\r\n\r\n        // if not, read it from disk and cache it\r\n        const content = await this.read_file_direct(path, as_uint);\r\n        this._cache.set(path, { readonly: await this.is_readonly(path), content, as_uint });\r\n        return content;\r\n    }\r\n\r\n    async write_file(path: string, data: string | Uint8Array, force = false): Promise<void> {\r\n        // check if file is readonly\r\n        let readonly = false;\r\n        if (await this.exists(path)) {\r\n            readonly = await this.is_readonly(path);\r\n            \r\n            if (!force && readonly) {\r\n                throw new ReadOnlyError(path);\r\n            }\r\n        }\r\n\r\n        // write to disk and cache\r\n        this._cache.set(path, { readonly, content: data, as_uint: data instanceof Uint8Array });\r\n        await this.write_file_direct(path, data);\r\n        this._call_callbacks(FSEventType.WROTE_FILE, path);\r\n    }\r\n\r\n    async delete_file(path: string): Promise<void> {\r\n        // delete from cache and disk\r\n        if (this._cache.has(path)) {\r\n            this._cache.delete(path);\r\n        }\r\n        await this.delete_file_direct(path);\r\n        this._call_callbacks(FSEventType.DELETED_FILE, path);\r\n    }\r\n\r\n    // does not check if destination exists\r\n    async move_file(path: string, new_path: string): Promise<void> {\r\n        // move in cache and disk\r\n        this._cache.set(new_path, this._cache.get(path));\r\n        this._cache.delete(path);\r\n        await this.move_file_direct(path, new_path);\r\n        this._call_callbacks(FSEventType.MOVED_FILE, path);\r\n    }\r\n\r\n    async set_readonly(path: string, readonly: boolean): Promise<void> {\r\n        // check if file exists\r\n        if (!await this.exists(path)) {\r\n            throw new PathNotFoundError(path);\r\n        }\r\n\r\n        // set readonly in cache and disk\r\n        const entry = this._cache.get(path);\r\n        if (entry) {\r\n            entry.readonly = readonly;\r\n            this._cache.set(path, entry);\r\n        } else {\r\n            this._cache.set(path, {readonly, content: await this.read_file(path), as_uint: false});\r\n        }\r\n\r\n        await this.set_readonly_direct(path, readonly);\r\n        this._call_callbacks(FSEventType.SET_READONLY, path);\r\n    }\r\n\r\n    async is_readonly(path: string): Promise<boolean> {\r\n        // check if file exists\r\n        if (!await this.exists(path)) {\r\n            throw new PathNotFoundError(path);\r\n        }\r\n\r\n        // check if file is in cache\r\n        const cached = this._cache.get(path);\r\n        if (cached) {\r\n            return cached.readonly;\r\n        }\r\n\r\n        // if not, check on disk (cannot cache as would need to read content, causes recursive call)\r\n        return this.is_readonly_direct(path);\r\n    }\r\n\r\n\r\n    abstract list_dir(path: string, dirs_first?: boolean): Promise<string[]>;\r\n    // (recursive)\r\n    abstract make_dir(path: string): Promise<void>;\r\n    abstract delete_dir_direct(path: string, recursive: boolean): Promise<void>;\r\n    abstract move_dir_direct(src: string, dest: string, no_overwrite: boolean, move_inside: boolean): Promise<void>;\r\n\r\n    async delete_dir(path: string, recursive = false): Promise<void> {\r\n        await this.delete_dir_direct(path, recursive);\r\n\r\n        // smart purge cache\r\n        this.purge_cache(true);\r\n    }\r\n\r\n    async move_dir(src: string, dest: string, no_overwrite = false, move_inside = false): Promise<void> {\r\n        await this.move_dir_direct(src, dest, no_overwrite, move_inside);\r\n\r\n        // smart purge cache\r\n        this.purge_cache(true);\r\n    }\r\n\r\n    get_cwd(): string {\r\n        this._call_callbacks(FSEventType.GETTING_CWD, this._cwd);\r\n        return this._cwd;\r\n    }\r\n\r\n    set_cwd(path: string): void {\r\n        // if path ends with /, remove it\r\n        if (path.endsWith(\"/\")) {\r\n            path = path.slice(0, -1);\r\n        }\r\n\r\n        // if path is empty, set to root\r\n        if (path === \"\") {\r\n            path = this._root;\r\n        }\r\n\r\n        this._cwd = path;\r\n        this._call_callbacks(FSEventType.SET_CWD, path);\r\n    }\r\n\r\n\r\n    get_home(): string {\r\n        this._call_callbacks(FSEventType.GETTING_HOME, this._home);\r\n        return this._home;\r\n    }\r\n\r\n    set_home(path: string): void {\r\n        this._home = path;\r\n        this._call_callbacks(FSEventType.SET_HOME, path);\r\n    }\r\n\r\n    get_root(): string {\r\n        this._call_callbacks(FSEventType.GETTING_ROOT, this._root);\r\n        return this._root;\r\n    }\r\n\r\n    set_root(path: string): void {\r\n        this._root = path;\r\n        this._call_callbacks(FSEventType.SET_ROOT, path);\r\n    }\r\n\r\n\r\n    abstract exists_direct(path: string): Promise<boolean>;\r\n    abstract dir_exists(path: string): Promise<boolean>;\r\n\r\n    async exists(path: string): Promise<boolean> {\r\n        // check if file is in cache\r\n        if (this._cache.has(path)) {\r\n            return true;\r\n        }\r\n\r\n        // if not, check if it exists on disk\r\n        this._call_callbacks(FSEventType.CHECKING_EXISTS, path);\r\n        return this.exists_direct(path);\r\n    }\r\n\r\n    absolute(path: string): string {\r\n        // if path is blank, path is root\r\n        if (path === \"\") {\r\n            return this._root;\r\n        }\r\n\r\n        // if path is ., return cwd\r\n        // TODO: is it safer to run this assumption then do the rest of the code rather than do the following root/cwd checks?\r\n        if (path === \".\") {\r\n            return this._cwd;\r\n        }\r\n\r\n        // if path is ~, return home\r\n        // TODO: again, same for this and the later ~/ check\r\n        if (path === \"~\") {\r\n            return this._home;\r\n        }\r\n\r\n        // if path starts with cwd and doesn't contain .., it is absolute\r\n        if (path.startsWith(this._cwd) && !path.includes(\"..\")) {\r\n            return path;\r\n        }\r\n\r\n        // if path starts with root and doesn't contain .., it is absolute\r\n        if (path.startsWith(this._root) && !path.includes(\"..\")) {\r\n            return path;\r\n        }\r\n\r\n        // drop leading ./\r\n        if (path.startsWith(\"./\")) {\r\n            path = path.slice(2);\r\n        }\r\n\r\n\r\n        let effective_cwd = this._cwd;\r\n\r\n        // if path starts with .., step up the cwd\r\n        while (path.startsWith(\"..\") && effective_cwd !== this._root) {\r\n            path = path.slice(2);\r\n\r\n            // drop leading /\r\n            if (path.startsWith(\"/\")) {\r\n                path = path.slice(1);\r\n            }\r\n\r\n            effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\r\n        }\r\n\r\n        // TODO: doesn't support middle of path ..\r\n        // if path ends with .., remove the last part of the full path\r\n        while (path.endsWith(\"..\")) {\r\n            path = path.slice(0, path.lastIndexOf(\"..\"));\r\n\r\n            // drop trailing /\r\n            if (path.endsWith(\"/\")) {\r\n                path = path.slice(0, path.length - 1);\r\n            }\r\n\r\n            // slice path, slicing effective_cwd if path is empty\r\n            if (path === \"\") {\r\n                effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\r\n            } else {\r\n                path = path.slice(0, path.lastIndexOf(\"/\"));\r\n\r\n                if (path === \"\") {\r\n                    effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\r\n                }\r\n            }\r\n        }\r\n\r\n        // if path starts with ~/, replace it with home\r\n        if (path.startsWith(\"~/\")) {\r\n            path = path.slice(2);\r\n            effective_cwd = this._home;\r\n        }\r\n\r\n        // if path still starts with /, drop it\r\n        if (path.startsWith(\"/\")) {\r\n            path = path.slice(1);\r\n        }\r\n\r\n        return this.join(effective_cwd, path);\r\n    }\r\n\r\n    join(base_dir: string, ...paths: string[]): string {\r\n        // drop trailing /\r\n        if (base_dir.endsWith(\"/\")) {\r\n            base_dir = base_dir.slice(0, base_dir.length - 1);\r\n        }\r\n\r\n        // join base_dir and path, using slash if path is not empty\r\n        for (let path of paths) {\r\n            if (path.startsWith(\"/\")) {\r\n                path = path.slice(1);\r\n            }\r\n\r\n            if (path === \"\") {\r\n                continue;\r\n            }\r\n\r\n            base_dir += \"/\" + path;\r\n        }\r\n\r\n        return base_dir;\r\n    }\r\n\r\n    protected constructor() {\r\n        // check if the cache should be purged from remote changes\r\n        setInterval(() => this._remote_listener(), 100);\r\n    }\r\n}\r\n","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\nimport { NonRecursiveDirectoryError, PathNotFoundError } from \"../filesystem\";\r\n\r\nexport default {\r\n    name: \"rm\",\r\n    description: \"Deletes a file or directory.\",\r\n    usage_suffix: \"[-rf | -f] path\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the file or directory to delete.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-rf\": \"Recursively and forcibly delete directories (ignoring if directory has content, treated as -f if a file is passed).\",\r\n            \"-f\": \"Forcibly delete files (ignoring readonly state, NOT treated as -rf if a directory is passed).\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // determine if -rf OR -f was passed\r\n        let rimraf = false;\r\n        let force = false;\r\n\r\n        if (args[0] === \"-rf\") {\r\n            rimraf = true;\r\n            force = true;\r\n            args.shift();\r\n        } else if (args[0] === \"-f\") {\r\n            force = true;\r\n            args.shift();\r\n        }\r\n\r\n        // check if there is only one argument after parsing flag\r\n        if (args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}Invalid arguments.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get path\r\n        const path = args[0];\r\n        const abs_path = fs.absolute(path);\r\n\r\n        // check if path exists\r\n        if (!(await fs.exists(abs_path))) {\r\n            term.writeln(`${PREFABS.error}Path does not exist.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // check if path is a directory\r\n        const is_dir = await fs.dir_exists(abs_path);\r\n\r\n        // perform deletion\r\n        if (is_dir) {\r\n            try {\r\n                await fs.delete_dir(abs_path, rimraf);\r\n            } catch (e) {\r\n                if (e instanceof NonRecursiveDirectoryError) {\r\n                    term.writeln(`${PREFABS.error}Directory is not empty. Refusing to delete without -rf flag.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                if (e instanceof PathNotFoundError) {\r\n                    term.writeln(`${PREFABS.error}Path no longer exists.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                throw e;\r\n            }\r\n        } else {\r\n            // if not forcing, check if file is readonly\r\n            if (!force && await fs.is_readonly(abs_path)) {\r\n                term.writeln(`${PREFABS.error}File is readonly. Refusing to delete without -f flag.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            await fs.delete_file(abs_path);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nconst type_suffixes = {\r\n    bug: \"?assignees=&labels=awaiting+effort+estimate%2C+awaiting+triage%2C+bug%2C+unreviewed&template=bug-report-%F0%9F%90%9B.md&title=%5B%F0%9F%90%9B%5D+-+Descriptive%2C+short+title\",\r\n    feature: \"?assignees=&labels=awaiting+effort+estimate%2C+awaiting+triage%2C+feature%2C+unreviewed&template=feature-request-%F0%9F%92%A1.md&title=%5B%F0%9F%92%A1%5D+-+Descriptive%2C+short+title\",\r\n    other: \"/choose\",\r\n}\r\n\r\nexport default {\r\n    name: \"bugreport\",\r\n    description: \"Opens the bug reporter.\",\r\n    usage_suffix: \"[bug|feature|other]\",\r\n    arg_descriptions: {\r\n        bug: \"Opens the bug reporter with the bug report template.\",\r\n        feature: \"Opens the bug reporter with the feature request template.\",\r\n        other: \"Opens the bug reporter with the template chooser (default).\",\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: helper_completion_options([\"bug\", \"feature\", \"other\"]),\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { term, args } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // if no arguments are provided, default to bug\r\n        let type = \"other\";\r\n        if (args.length > 0) {\r\n            type = args[0].toLowerCase();\r\n\r\n            // check if the type is valid (don't use in, it won't filter __proto__ etc.)\r\n            if (!Object.keys(type_suffixes).includes(type)) {\r\n                term.writeln(`${PREFABS.error} Invalid type: ${type}. Please choose bug, feature, or other.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        window.open(`https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io/issues/new${type_suffixes[type]}`, \"_blank\", \"\");\r\n\r\n        term.writeln(\"Opened bug reporter in a new tab.\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"repo\",\r\n    description: \"Opens the GitHub repository for OllieOS.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { term } = data;\r\n\r\n        window.open(\"https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io\", \"_blank\", \"\");\r\n\r\n        term.writeln(\"Opened repo in a new tab.\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import type { Program } from \"../types\";\r\n\r\nimport { ANSI, NEWLINE } from \"../term_ctl\";\r\n\r\nimport { convert as convert_html_to_text } from \"html-to-text\";\r\n\r\nconst HTML_TAG_REGEX = /<\\/?[a-z][\\s\\S]*>/i;\r\n\r\n// modified from source: https://github.com/rbren/rss-parser/blob/master/lib/fields.js\r\nconst fields = { feed: {}, item: {} };\r\n\r\n// known feed fields\r\nfields.feed = {\r\n    author: [\"author\", \"creator\"],\r\n    publisher: [\"dc:publisher\", \"publisher\"],\r\n    title: [\"dc:title\", \"title\"],\r\n    description: \"description\",\r\n    date: \"pubDate\",\r\n    link: \"link\",\r\n};\r\n\r\n// known item fields\r\nfields.item = {\r\n    author: [\"author\", \"creator\"],\r\n    date: [\"dc:date\", \"date\", \"pubDate\"],\r\n    title: [\"dc:title\", \"title\"],\r\n    link: \"link\",\r\n    summary: \"summary\",\r\n    description: [\"content:encoded\", \"content\", \"description\"],\r\n};\r\n// end source: https://github.com/rbren/rss-parser/blob/master/lib/fields.js\r\n\r\nenum DocType {\r\n    FEED,\r\n    ITEM\r\n}\r\n\r\nconst get_field = (doc: Document | Element, doc_type: DocType, field: string, as_html = false) => {\r\n    // get the fields object\r\n    const dict = doc_type === DocType.FEED ? fields.feed : fields.item;\r\n\r\n    // check if the field is known (don't use in, it won't filter out __proto__ etc.)\r\n    if (!Object.keys(dict).includes(field)) {\r\n        return undefined;\r\n    }\r\n\r\n    // get the field\r\n    const field_value = dict[field];\r\n\r\n    // if the field is an array, concatenate the values\r\n    if (Array.isArray(field_value)) {\r\n        let value = \"\";\r\n\r\n        for (const sub_field of field_value) {\r\n            const sub_field_doc = doc.getElementsByTagName(sub_field)[0];\r\n            let sub_value: string;\r\n\r\n            if (as_html) {\r\n                sub_value = sub_field_doc?.innerHTML;\r\n            } else {\r\n                sub_value = sub_field_doc?.textContent;\r\n            }\r\n\r\n            if (sub_value) {\r\n                value += sub_value;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    } else {\r\n        // otherwise, get the value\r\n        if (as_html) {\r\n            return doc.getElementsByTagName(field_value)[0]?.innerHTML;\r\n        } else {\r\n            return doc.getElementsByTagName(field_value)[0]?.textContent;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport default {\r\n    name: \"rss\",\r\n    description: \"Reads from an RSS feed.\",\r\n    usage_suffix: \"[-h] [url] [-m items] [-x]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"url\": \"The URL to the XML feed (plaintext feed recommended, unless the HTML is basic). Defaults to https://blog.ollieg.codes/rss/feed.xml\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-h\": \"Print this help message.\",\r\n            \"-m\": \"The maximum number of items to display. Defaults to no limit.\",\r\n            \"-x\": \"Only display titles, links and publishing dates, not descriptions.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"rss\"], shell).completion;\r\n        }\r\n\r\n        let max_items: number | undefined = undefined;\r\n        if (args.includes(\"-m\")) {\r\n            // get the index of the flag\r\n            const index = args.indexOf(\"-m\");\r\n\r\n            // get the value after the flag\r\n            const value = args[index + 1];\r\n\r\n            // check if the value is valid\r\n            if (!value || isNaN(parseInt(value)) || parseInt(value) < 0) {\r\n                term.writeln(`${PREFABS.error}Invalid value for -m flag. Expected a positive integer.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // set the max items\r\n            max_items = parseInt(value);\r\n\r\n            // remove the flag and value from the args\r\n            args.splice(index, 2);\r\n        }\r\n\r\n        const no_content = args.includes(\"-x\");\r\n\r\n\r\n        // check if the user provided a URL\r\n        let url = \"https://blog.ollieg.codes/rss/feed.xml\";\r\n        if (args.length !== 0) {\r\n            url = args.shift();\r\n        }\r\n\r\n        // validate url\r\n        try {\r\n            const proc_url = new URL(url);\r\n\r\n            if (proc_url.protocol !== \"http:\" && proc_url.protocol !== \"https:\") {\r\n                throw new Error(\"Invalid protocol\");\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Invalid URL. Expected a valid HTTP or HTTPS protocol URL.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // fetch the feed\r\n        // TODO: potential DRY with webget\r\n        let response: Response;\r\n\r\n        term.writeln(`${FG.green}Fetching feed...${STYLE.reset_all}`);\r\n\r\n        try {\r\n            response = await fetch(url);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to fetch feed.${STYLE.reset_all}`);\r\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            return 1;\r\n        }\r\n\r\n        if (!response.ok) {\r\n            term.writeln(`${PREFABS.error}Request not OK.${STYLE.reset_all}`);\r\n\r\n            // get the error message\r\n            const text = await response.text();\r\n\r\n            if (text !== \"\") {\r\n                term.writeln(`${PREFABS.error}${text}${STYLE.reset_all}`);\r\n            }\r\n\r\n            return 1;\r\n        }\r\n\r\n        // get the text and convert newlines (\\r\\n or \\n) to the terminal's newline\r\n        const text = (await response.text()).replace(/\\r\\n|\\n/g, NEWLINE);\r\n\r\n        // parse the text\r\n        const parser = new DOMParser();\r\n\r\n        let doc: Document;\r\n\r\n        try {\r\n            doc = parser.parseFromString(text, \"text/xml\");\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to parse feed.${STYLE.reset_all}`);\r\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            return 1;\r\n        }\r\n\r\n        term.write(NEWLINE);\r\n\r\n        // print the title if it exists\r\n        const feed_title = get_field(doc, DocType.FEED, \"title\") ?? \"Untitled feed\";\r\n        term.writeln(`${FG.cyan + STYLE.bold + STYLE.italic}${feed_title}${STYLE.reset_all}`);\r\n\r\n        // print the site link if it exists\r\n        const site_link = get_field(doc, DocType.FEED, \"link\") ?? \"\";\r\n        term.writeln(`${FG.cyan}${site_link}${STYLE.reset_all}`);\r\n\r\n        // print the site description if it exists\r\n        const site_description = get_field(doc, DocType.FEED, \"description\") ?? \"\";\r\n        term.writeln(`${site_description}`);\r\n\r\n        term.write(NEWLINE);\r\n        term.writeln(`${FG.gray}------${STYLE.reset_all}`);\r\n        term.write(NEWLINE);\r\n\r\n        // get the items\r\n        const items = doc.getElementsByTagName(\"item\");\r\n\r\n        if (max_items === undefined) {\r\n            max_items = items.length;\r\n        }\r\n\r\n        // print the items\r\n        for (let item_idx = 0; item_idx < max_items; item_idx++) {\r\n            const item = items.item(item_idx);\r\n\r\n            // check if the item exists\r\n            if (!item) {\r\n                // hit the end of the items, break\r\n                break;\r\n            }\r\n\r\n            // get each field of the item if they exist\r\n\r\n            // title\r\n            const item_title = get_field(item, DocType.ITEM, \"title\") ?? \"Untitled item\";\r\n\r\n            // link\r\n            const link = get_field(item, DocType.ITEM, \"link\") ?? \"\";\r\n\r\n\r\n            let description = \"\";\r\n            if (!no_content) {\r\n                description = get_field(item, DocType.ITEM, \"description\") ?? \"\";\r\n\r\n                // if the description is html, attempt to convert it to plaintext\r\n                if (HTML_TAG_REGEX.test(description)) {\r\n                    term.writeln(`${FG.gray}(interpreting description as HTML)${STYLE.reset_all}`)\r\n                    term.write(NEWLINE);\r\n\r\n                    // reparse as html\r\n                    description = get_field(item, DocType.ITEM, \"description\", true) ?? \"\";\r\n\r\n                    // remove CDATA tags if present\r\n                    description = description.replace(/<!\\[CDATA\\[|\\]\\]>/g, \"\");\r\n\r\n                    // parse the description using custom highlighters\r\n                    description = convert_html_to_text(description,\r\n                        {\r\n                            formatters: {\r\n                                \"ansi_formatter\": (elem, walk, builder, options) => {\r\n                                    builder.openBlock();\r\n                                    builder.addInline(options.opener);\r\n                                    walk(elem.children, builder);\r\n                                    builder.addInline(STYLE.reset_all);\r\n                                    builder.closeBlock();\r\n                                },\r\n                                \"img_highlight\": (elem, walk, builder, options) => {\r\n                                    const img_fmt = builder.options.formatters[\"image\"];\r\n                                    if (img_fmt) {\r\n                                        builder.addInline(STYLE.bold + FG.magenta);\r\n                                        img_fmt(elem, walk, builder, options);\r\n                                        builder.addInline(STYLE.reset_all);\r\n                                    }\r\n                                },\r\n                                \"a_highlight\": (elem, walk, builder, options) => {\r\n                                    const a_fmt = builder.options.formatters[\"anchor\"];\r\n                                    if (a_fmt) {\r\n                                        builder.addInline(STYLE.bold + FG.blue);\r\n                                        a_fmt(elem, walk, builder, options);\r\n                                        builder.addInline(STYLE.reset_all);\r\n                                    }\r\n                                }\r\n                            },\r\n                            selectors: [\r\n                                {\r\n                                    selector: \"b\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.bold\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"strong\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.bold\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"i\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.italic\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"em\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.italic\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"u\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.underline\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"img\",\r\n                                    format: \"img_highlight\"\r\n                                },\r\n                                {\r\n                                    selector: \"a\",\r\n                                    format: \"a_highlight\"\r\n                                },\r\n                                {\r\n                                    selector: \"table\",\r\n                                    format: \"dataTable\"\r\n                                }\r\n                            ]\r\n                        }\r\n                    );\r\n                }\r\n\r\n                // trim start and end whitespace\r\n                description = description.trim();\r\n\r\n                // replace newlines again in case the description was html\r\n                description = description.replace(/\\r\\n|\\n/g, NEWLINE);\r\n            }\r\n\r\n            // pubDate\r\n            const date = get_field(item, DocType.ITEM, \"date\") ?? \"\";\r\n\r\n            // print the item\r\n            term.writeln(`${FG.green + STYLE.bold + STYLE.underline}${item_title}${STYLE.reset_all}`);\r\n            term.writeln(`${FG.cyan}${link}${STYLE.reset_all}`);\r\n            term.writeln(`${FG.yellow}${date}${STYLE.reset_all}`);\r\n            term.write(NEWLINE);\r\n\r\n            if (!no_content) {\r\n                term.writeln(`${description}`);\r\n                term.write(NEWLINE);\r\n            }\r\n\r\n            term.writeln(`${FG.gray}------${STYLE.reset_all}`);\r\n            term.write(NEWLINE);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"legacy\",\r\n    description: \"Opens the legacy ollieg.codes site if you're having trouble with this version.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (_data) => {\r\n        window.location.assign(\"https://legacy.ollieg.codes/\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: keep this or not?\r\n","import type {Program, ProgramMainData} from \"../types\";\r\nimport { ANSI, NEWLINE, type WrappedTerminal } from \"../term_ctl\";\r\n\r\n\r\nconst wait_block = (term: WrappedTerminal) => {\r\n    term.write(NEWLINE);\r\n    term.writeln(`${ANSI.STYLE.italic}Press any key to continue...${ANSI.STYLE.reset_all}`)\r\n    return term.wait_for_keypress();\r\n};\r\n\r\nconst run_cmd = async (data: ProgramMainData, cmd: string, args: string[] = []) => {\r\n    data.term.writeln(`${ANSI.STYLE.bold}$ ${cmd}${ANSI.STYLE.reset_all}${NEWLINE}`);\r\n    await data.kernel.spawn(cmd, args, data.shell).completion;\r\n    data.term.write(NEWLINE);\r\n};\r\n\r\n\r\nconst welcome = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}Welcome to OllieOS!`);\r\n    term.writeln(`===================${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"This tour covers the basic commands and features of OllieOS.\");\r\n    term.writeln(`First, let's use ${PREFABS.program_name}mefetch${STYLE.reset_all} to view info about me.`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"Normally, you would type the command into the terminal and press RETURN, but for this tour, the command will be run automatically.\");\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst mefetch = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}mefetch`);\r\n    term.writeln(`=======${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"mefetch\");\r\n\r\n    term.writeln(`The ${PREFABS.program_name}mefetch${STYLE.reset_all} command is used to display information about a GitHub user.`);\r\n    term.writeln(\"By default, it uses my username, obfuscatedgenerated. You can also specify a different username as an argument.\");\r\n    term.writeln(\"If another username is used, less information will be displayed.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.write(`Now, let's use ${PREFABS.program_name}rss${STYLE.reset_all} to read my blog.`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst rss = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}rss`);\r\n    term.writeln(`===${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"rss\", [\"-m\", \"1\"]);\r\n\r\n    term.writeln(`The ${PREFABS.program_name}rss${STYLE.reset_all} command is used to read RSS feeds.`);\r\n    term.writeln(\"By default, it uses my blog's RSS feed. You can also specify a different RSS feed as an argument.\");\r\n    term.writeln(\"A plaintext RSS feed is recommended, but the program can also parse basic HTML.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"For the output above, the -m 1 flag was used to only display the first item in the feed. Without it, all items would be displayed.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`Let's use the ${PREFABS.program_name}help${STYLE.reset_all} command to view a list of all available commands, and to get help with a specific command.`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst fs = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}Filesystem`);\r\n    term.writeln(`==========${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"OllieOS has a filesystem, which is used to store files and folders.\");\r\n    term.writeln(\"The filesystem is persistent, so files and folders will not be deleted when the OS is restarted.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`Let's use the ${PREFABS.program_name}ls${STYLE.reset_all} command to view the contents of the home directory.`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"ls\");\r\n\r\n    term.writeln(`There's a file in the directory called ${PREFABS.file_path}credits.txt${STYLE.reset_all}. Let's use the ${PREFABS.program_name}cat${STYLE.reset_all} command to view its contents.`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n    await run_cmd(data, \"cat\", [\"credits.txt\"]);\r\n\r\n    term.writeln(`The ${PREFABS.program_name}cat${STYLE.reset_all} command is used to view the contents of one or more files.`);\r\n    term.writeln(\"If multiple files are specified, their contents will be concatenated together.\");\r\n    term.write(NEWLINE);\r\n    \r\n    term.writeln(`There are many other commands that can be used to interact with the filesystem, such as ${PREFABS.program_name}cd${STYLE.reset_all}, ${PREFABS.program_name}fsedit${STYLE.reset_all}, ${PREFABS.program_name}rm${STYLE.reset_all}, and more.`);\r\n    term.writeln(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst help = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}help`);\r\n    term.writeln(`====${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"help\");\r\n\r\n    term.write(NEWLINE);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`The ${PREFABS.program_name}help${STYLE.reset_all} command is used to view a list of all available commands, and to get help with a specific command.`);\r\n    term.writeln(\"If a command is specified as an argument, the help text for that command will be displayed.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`For example, let's view the help text for the ${PREFABS.program_name}rss${STYLE.reset_all} command:`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n    await run_cmd(data, \"help\", [\"rss\"]);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\n\r\nconst end = async (data: ProgramMainData,) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, FG, PREFABS } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}Thanks for using OllieOS!`);\r\n    term.writeln(`=========================${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"That's all for now!\");\r\n    term.writeln(\"There is a lot more to explore, so feel free to play around with the OS and try out different commands.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"Things to try:\");\r\n    term.writeln(` - Use ${PREFABS.program_name}mefetch${STYLE.reset_all}, passing your GitHub username as an argument.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}cd${STYLE.reset_all} to enter the ${PREFABS.dir_name}projects${STYLE.reset_all} directory, and then use ${PREFABS.program_name}ls${STYLE.reset_all} to view its contents.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}imagine${STYLE.reset_all} and ${PREFABS.program_name}ascmagine${STYLE.reset_all} to view an image.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}fsedit${STYLE.reset_all} to explore the filesystem.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}webget${STYLE.reset_all} to download a file from the Internet into the OS.`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"Thanks for using OllieOS.\");\r\n    term.writeln(\"The OS will now restart.\");\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n\r\n    await run_cmd(data, \"shutdown\", [\"-r\", \"-t\", \"0\"]);\r\n};\r\n\r\n\r\nexport default {\r\n    name: \"tour\",\r\n    description: \"Runs the onboarding tour.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        await welcome(data);\r\n\r\n        await mefetch(data);\r\n        await rss(data);\r\n        await fs(data);\r\n        await help(data);\r\n\r\n        await end(data);\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import {determine_program_name_from_js} from \"../../prog_registry\";\r\nimport { ANSI, NEWLINE } from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {graph_query, triggers} from \"./index\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, PREFABS, FG } = ANSI;\r\n\r\n// TODO: resolve unused deps?\r\n\r\nexport const remove_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel, shell } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing package name.`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // remove duplicate args\r\n    let unique_args = [...new Set(args)];\r\n\r\n    // if any args contain @, trim to before @ and show warning\r\n    // TODO: accept version specifier and check that the requested version is the one installed before removing\r\n    for (const arg of unique_args) {\r\n        if (arg.includes(\"@\")) {\r\n            term.writeln(`${FG.yellow}Warning: ${arg} contains a version specifier.`);\r\n            term.writeln(`This will be ignored.${STYLE.reset_all}`);\r\n        }\r\n    }\r\n\r\n    // perform removal\r\n    unique_args = unique_args.map(arg => arg.split(\"@\")[0]);\r\n\r\n    // remove duplicates again\r\n    unique_args = [...new Set(unique_args)];\r\n\r\n    let error_count = 0;\r\n    // returns 0 for success, 1 for failure, 2 for fatal error\r\n\r\n    const fs = kernel.get_fs();\r\n    const prog_reg = kernel.get_program_registry();\r\n\r\n    // iter over remaining args\r\n    const total_pkgs = unique_args.length;\r\n    while (unique_args.length >= 1) {\r\n        term.writeln(`${NEWLINE}${FG.gray}------------------------${STYLE.reset_all}${NEWLINE}`);\r\n\r\n        const pkg = unique_args.shift();\r\n\r\n        term.writeln(`${FG.yellow}Checking for ${pkg}...${STYLE.reset_all}`);\r\n\r\n        // if .., /, or \\ in pkg, skip\r\n        if (pkg.includes(\"..\") || pkg.includes(\"/\") || pkg.includes(\"\\\\\")) {\r\n            term.writeln(`${PREFABS.error}Illegal package name '${pkg}'.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        const pkg_dir = `/usr/bin/${pkg}`;\r\n\r\n        // check if pkg exists\r\n        if (!(await fs.dir_exists(pkg_dir))) {\r\n            term.writeln(`${PREFABS.error}Package '${pkg}' not installed.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Updating graph...${STYLE.reset_all}`);\r\n\r\n        let meta_triggers = {};\r\n        let meta_version = \"unknown\";\r\n        let meta_deps: string[] = [];\r\n\r\n        if (await fs.exists(fs.join(pkg_dir, \"meta.json\"))) {\r\n            try {\r\n                const meta_raw = await fs.read_file(fs.join(pkg_dir, \"meta.json\")) as string;\r\n                const meta = JSON.parse(meta_raw);\r\n\r\n                meta_triggers = meta.triggers || {};\r\n                meta_version = meta.version || \"unknown\";\r\n                meta_deps = meta.deps || [];\r\n            } catch (e) {\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Could not read meta.json for package ${pkg}: ${e.message}${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        // remove self as a dependent from packages listed as dependencies\r\n        for (const dep_pkg of meta_deps) {\r\n            try {\r\n                // split into name and version if @ present\r\n                const dep_pkg_name = dep_pkg.split(\"@\")[0];\r\n                await graph_query.remove_pkg_dependent(fs, dep_pkg_name, pkg);\r\n            } catch (e) {\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Could not remove dependent ${pkg} from package ${dep_pkg}: ${e.message}${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        try {\r\n            await graph_query.remove_pkg(fs, pkg);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Error removing package '${pkg}': ${e.message}${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        term.writeln(`${FG.cyan}Unmounting programs...${STYLE.reset_all}`);\r\n\r\n        const files = await fs.list_dir(pkg_dir);\r\n\r\n        for (const file of files) {\r\n            if (!file.endsWith(\".js\")) {\r\n                continue;\r\n            }\r\n\r\n            const file_path = fs.join(pkg_dir, file);\r\n\r\n            let program_name: string;\r\n            try {\r\n                const content = await fs.read_file(file_path) as string;\r\n                program_name = await determine_program_name_from_js(content);\r\n            } catch (e) {\r\n                if (e.message.endsWith(\"is not compatible with Node.js.\")) {\r\n                    // silently skip node.js incompatible programs (they wouldn't have been mounted anyway)\r\n                    // yes this is a weird way to do it, but better than changing how build_registrant works\r\n                    continue;\r\n                }\r\n\r\n                term.writeln(`${PREFABS.error}Error determining program name for ${file}: ${e.message}${STYLE.reset_all}`);\r\n                term.writeln(`${FG.yellow}Skipping program (will remain mounted until restart)...${STYLE.reset_all}`);\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                prog_reg.unregister(program_name);\r\n                term.writeln(`${FG.cyan}(-) ${program_name}${STYLE.reset_all}`);\r\n            } catch (e) {\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Program ${program_name} was never registered.${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Removing package data...${STYLE.reset_all}`);\r\n        await fs.delete_dir(pkg_dir, true);\r\n        fs.purge_cache();\r\n\r\n        term.writeln(`${FG.green}Package '${pkg}' removed.${STYLE.reset_all}`);\r\n\r\n        // check for any removal triggers\r\n        // check for any triggers\r\n        if (meta_triggers && Object.keys(meta_triggers).length > 0) {\r\n            term.writeln(`${FG.cyan}Processing uninstall triggers...${STYLE.reset_all}`);\r\n\r\n            for (const [trigger_name, trigger_data] of Object.entries(meta_triggers)) {\r\n                if (!await triggers.trigger_exists(fs, trigger_name)) {\r\n                    term.writeln(`${FG.yellow}Warning: trigger '${trigger_name}' is not recognised and will be skipped.${STYLE.reset_all}`);\r\n                    continue;\r\n                }\r\n\r\n                term.writeln(`${FG.cyan}Processing uninstall trigger: ${trigger_name}...${STYLE.reset_all}`);\r\n                await triggers.process_uninstall_trigger(trigger_name, trigger_data, pkg, meta_version, term, kernel, shell)\r\n            }\r\n\r\n            term.writeln(`${FG.cyan}Uninstall trigger processing complete.${STYLE.reset_all}`);\r\n        }\r\n    }\r\n\r\n    term.writeln(`${NEWLINE}${FG.magenta + STYLE.bold}========================${STYLE.reset_all}${NEWLINE}`);\r\n\r\n    if (error_count > 0) {\r\n        term.writeln(`${PREFABS.error}Failed to remove ${error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.green}Successfully removed ${total_pkgs - error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.cyan}Total packages: ${total_pkgs}${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`${FG.green}Successfully removed all ${total_pkgs} package(s).${STYLE.reset_all}`);\r\n\r\n    return 0;\r\n}\r\n","import {graph_query, json_convert_dep_sets_to_arrs, repo_query, triggers} from \".\";\r\nimport {mount_and_register_with_output} from \"../../prog_registry\";\r\n\r\nimport {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport {ProgramMainData} from \"../../types\"\r\nimport {remove_subcommand} from \"./remove\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS, FG} = ANSI;\r\n\r\n// we arent allowing multiple versions of the same package to be installed at once to simplify things significantly\r\n// TODO: write to a file that tracks installed packages and their dependents (for list and smart removal/cleanup)\r\n\r\nexport const add_subcommand = async (data: ProgramMainData, depended_by?: string) => {\r\n    // extract from data to make code less verbose\r\n    const {args, term, kernel, shell} = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing package name.`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // remove duplicate args\r\n    const unique_args = [...new Set(args)];\r\n\r\n    let error_count = 0;\r\n    // returns 0 for success, 1 for failure, 2 for fatal error\r\n\r\n    const fs = kernel.get_fs();\r\n    const prog_reg = kernel.get_program_registry();\r\n\r\n    // iter over remaining args\r\n    const total_pkgs = unique_args.length;\r\n    while (unique_args.length >= 1) {\r\n        term.writeln(`${NEWLINE}${FG.gray}------------------------${STYLE.reset_all}${NEWLINE}`);\r\n\r\n        const pkg_at_version = unique_args.shift();\r\n\r\n        // if in the format of pkg@version, split it up\r\n        const pkg_split = pkg_at_version.split(\"@\");\r\n        if (pkg_split.length > 2) {\r\n            term.writeln(`${PREFABS.error}Invalid package name: ${pkg_at_version}`);\r\n            term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n            return 2;\r\n        }\r\n\r\n        const pkg_name = pkg_split[0];\r\n        let pkg_version = pkg_split[1];\r\n\r\n        term.writeln(`${FG.yellow}Checking for ${pkg_name}...${STYLE.reset_all}`);\r\n\r\n        const pkg_json = await repo_query.get_pkg_json(pkg_name);\r\n\r\n        if (!pkg_json) {\r\n            term.writeln(`${PREFABS.error}Package '${pkg_name}' not found.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        // if no version specified, use latest\r\n        if (!pkg_version) {\r\n            pkg_version = pkg_json.latest_version;\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Using ${pkg_name}@${pkg_version}...${STYLE.reset_all}`);\r\n\r\n        // check if version exists (and get metadata)\r\n        const meta = await repo_query.get_pkg_meta(pkg_name, pkg_version);\r\n\r\n        if (!meta) {\r\n            term.writeln(`${PREFABS.error}Version '${pkg_version}' of '${pkg_name}' not found.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        if (!meta.externals || meta.externals !== \"global\") {\r\n            term.writeln(`${PREFABS.error}Package '${pkg_name}' is not using the new global externals system. Please build the package with a newer version of pkgbuild.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        const pkg_dir = `/usr/bin/${pkg_name}`;\r\n\r\n        // check version file if already installed\r\n        // TODO: switch to pkg graph?\r\n        if (graph_query.pkg_is_installed(pkg_name)) {\r\n            const installed_version = graph_query.get_pkg_version(pkg_name);\r\n\r\n            if (installed_version === pkg_version) {\r\n                // if exact version already installed, check dep graph then skip\r\n                // ie if depended_by is set but that isn't a dependent yet then add it\r\n\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: ${pkg_name}@${pkg_version} already installed. If you wish to reinstall the package, remove it first.${STYLE.reset_all}`);\r\n\r\n                // cant do this here as top level package isn't installed yet. it's the caller's job to do this. it wouldn't be safe to refactor the method in a way that allows this\r\n                // if (depended_by) {\r\n                //     graph_query.add_pkg_dependent(fs, pkg_name, depended_by);\r\n                //     term.writeln(`${FG.yellow}(dep graph updated)${STYLE.reset_all}`);\r\n                // }\r\n\r\n                continue;\r\n            } else {\r\n                // uninstall old version\r\n                term.writeln(`${FG.yellow}Uninstalling old ${pkg_name}@${pkg_version}...${STYLE.reset_all}`);\r\n\r\n                const remove_data = {kernel, term, process: data.process, args: [\"remove\", pkg_name], unsubbed_args: [\"remove\", pkg_name], raw_parts: [...data.raw_parts, \"remove\", pkg_name]};\r\n                const remove_exit_code = await remove_subcommand(remove_data);\r\n                if (remove_exit_code !== 0) {\r\n                    term.writeln(`${PREFABS.error}Failed to uninstall old version.${STYLE.reset_all}`);\r\n                    error_count++;\r\n                    term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        // firstly, install dependencies\r\n        if (meta.deps && meta.deps.size > 0) {\r\n            term.writeln(`${NEWLINE + FG.magenta + STYLE.bold}Installing dependencies...${STYLE.reset_all}`);\r\n\r\n            // simulate a call to this function with the deps as arguments\r\n            // TODO: is it worth doing this properly and decomposing each stage to a function and calling it?\r\n            // TODO: clearer logs\r\n            // TODO: unshifting add is silly, should this func be changed to accept args with add removed?\r\n            // TODO: parallelism with promise.all???\r\n            const virtual_args: string[] = [...meta.deps];\r\n            virtual_args.unshift(\"add\");\r\n\r\n            // we need to also pass the name of the dependent package to the virtual call to let the graph know\r\n            const virtual_data = {kernel, term, process: data.process, args: virtual_args, unsubbed_args: virtual_args, raw_parts: [...data.raw_parts, ...virtual_args]};\r\n            const virtual_exit_code = await add_subcommand(virtual_data, pkg_name);\r\n\r\n            if (virtual_exit_code !== 0) {\r\n                term.writeln(`${PREFABS.error}Failed to install dependencies.${STYLE.reset_all}`);\r\n                error_count++;\r\n                term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n                continue;\r\n                // TODO: remove partial installation\r\n            }\r\n\r\n            term.writeln(`${FG.magenta + STYLE.bold}Dependencies installed.${STYLE.reset_all + NEWLINE}`);\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Enumerating contents...${STYLE.reset_all}`);\r\n\r\n        const content_list = meta.files;\r\n\r\n        if (content_list.length === 0 || content_list.length === 1 && content_list[0] === \"\") {\r\n            term.writeln(`${PREFABS.error}Empty package.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        // get each file in contents and load it into memory\r\n        const file_map = new Map<string, string>();\r\n\r\n        for (const file of content_list) {\r\n            if (file === \"\") {\r\n                continue;\r\n            }\r\n\r\n            term.writeln(`${FG.yellow}Downloading ${file}...${STYLE.reset_all}`);\r\n\r\n            const file_contents = await repo_query.get_pkg_file(pkg_name, pkg_version, file);\r\n\r\n            if (!file_contents) {\r\n                term.writeln(`${PREFABS.error}Not found.${STYLE.reset_all}`);\r\n                error_count++;\r\n                term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n                continue;\r\n            }\r\n\r\n            file_map.set(file, file_contents);\r\n        }\r\n\r\n        // add pkg.json and meta.json to file map\r\n        file_map.set(\"pkg.json\", JSON.stringify(pkg_json));\r\n        // TODO: adding this might be redundant, we could just move build timestamp to the graph. could also use file array to help mounting? prob not needed.\r\n        // TODO: build timestamp isnt actually used anywhere yet so not a big deal until implemented. might be quicker to just open this file rather than access the graph anyway!\r\n        file_map.set(\"meta.json\", JSON.stringify(meta, json_convert_dep_sets_to_arrs));\r\n\r\n        // not actually executing the file map yet, as we need to ensure the graph is valid\r\n\r\n        term.writeln(`${FG.yellow}Updating graph...${STYLE.reset_all}`);\r\n\r\n        // don't need to check if installed or do anything fancy if it is, as previous checks have already run and updated the graph if needed\r\n        // this is guaranteed to be a new install (whether first time or remove was just run)\r\n        // TODO: test if that's true! test it more!\r\n        try {\r\n            await graph_query.install_new_pkg(fs, pkg_name, pkg_version, meta.deps, !depended_by, depended_by);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to add to graph: ${e.message}${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        // if there were dependencies, add this package as a dependent to each of them\r\n        try {\r\n            if (meta.deps && meta.deps.size > 0) {\r\n                for (const dep of meta.deps) {\r\n                    const dep_name = dep.split(\"@\")[0];\r\n                    await graph_query.add_pkg_dependent(fs, dep_name, pkg_name);\r\n                }\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to update dependencies: ${e.message}${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Rolling back graph...${STYLE.reset_all}`);\r\n            // TODO: safety check? is it safer to capture the entire graph before starting and then rollback to that? add a capture and rollback method to graph_query?\r\n            await graph_query.remove_pkg(fs, pkg_name);\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Installing ${pkg_name}...${STYLE.reset_all}`);\r\n\r\n        await fs.make_dir(pkg_dir);\r\n\r\n        // write each file\r\n        for (const [file, value] of file_map) {\r\n            await fs.write_file(`${pkg_dir}/${file}`, value, true);\r\n        }\r\n\r\n        // TODO: check if this fails somehow, and if it does, rollback the graph\r\n\r\n        term.writeln(`${FG.green}Installed!${STYLE.reset_all}`);\r\n\r\n        term.writeln(`${FG.cyan}Mounting package ${pkg_name}...${STYLE.reset_all}`);\r\n\r\n        // it doesn't matter if mounting fails, the graph is fine and the files are downloaded properly, so no rollback needed\r\n\r\n        // mount each program\r\n        for (const [filename, value] of file_map) {\r\n            if (!filename.endsWith(\".js\")) {\r\n                continue;\r\n            }\r\n\r\n            await mount_and_register_with_output(filename, value, prog_reg, term, true);\r\n        }\r\n\r\n        term.writeln(`${FG.green}Package ${pkg_name}@${pkg_version} installed.${STYLE.reset_all}`);\r\n\r\n        // check for any triggers\r\n        if (meta && meta.triggers && Object.keys(meta.triggers).length > 0) {\r\n            term.writeln(`${FG.cyan}Processing install triggers...${STYLE.reset_all}`);\r\n\r\n            for (const [trigger_name, trigger_data] of Object.entries(meta.triggers)) {\r\n                if (!await triggers.trigger_exists(fs, trigger_name)) {\r\n                    term.writeln(`${FG.yellow}Warning: trigger '${trigger_name}' is not recognised and will be skipped.${STYLE.reset_all}`);\r\n                    continue;\r\n                }\r\n\r\n                term.writeln(`${FG.cyan}Processing install trigger: ${trigger_name}...${STYLE.reset_all}`);\r\n                await triggers.process_install_trigger(trigger_name, trigger_data, pkg_name, pkg_version, term, kernel, shell);\r\n            }\r\n\r\n            term.writeln(`${FG.cyan}Install trigger processing complete.${STYLE.reset_all}`);\r\n        }\r\n    }\r\n\r\n    term.writeln(`${NEWLINE}${FG.magenta + STYLE.bold}========================${STYLE.reset_all}${NEWLINE}`);\r\n\r\n    if (error_count > 0) {\r\n        term.writeln(`${PREFABS.error}Failed to install ${error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.green}Successfully installed ${total_pkgs - error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.cyan}Total packages: ${total_pkgs}${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`${FG.green}Successfully installed all ${total_pkgs} package(s).${STYLE.reset_all}`);\r\n\r\n    return 0;\r\n}\r\n// TODO: decompose into smaller functions\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {graph_query} from \"./index\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG } = ANSI;\r\nexport const list_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // check for presence of -t flag\r\n    let only_top_level = false;\r\n    if (args[0] === \"-t\") {\r\n        only_top_level = true;\r\n        args.shift();\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n\r\n    const pkg_names = graph_query.list_pkgs(only_top_level);\r\n\r\n    // print each package, marking top level packages in green, dependencies in white, and unused dependencies in gray\r\n    for (const pkg_name of pkg_names) {\r\n        const info = graph_query.get_pkg_info(pkg_name);\r\n\r\n        let color = FG.gray;\r\n        if (info.top_level) {\r\n            color = FG.green;\r\n        } else if (info.dependents.size !== 0) {\r\n            color = FG.white;\r\n        }\r\n\r\n        term.writeln(`${STYLE.bold}${color}${pkg_name}${STYLE.no_bold_or_dim}@${info.version}${STYLE.reset_all}`);\r\n    }\r\n\r\n    return 0;\r\n}\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport type { WrappedTerminal } from \"../../term_ctl\";\r\nimport type { ProgramMainData } from \"../../types\"\r\nimport {graph_query, repo_query} from \"./index\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, PREFABS } = ANSI;\r\n\r\ninterface PkgInfo {\r\n    description?: string;\r\n    author?: string;\r\n    license?: string;\r\n    homepage_url?: string;\r\n    repo_url?: string;\r\n    long_desc?: string;\r\n}\r\n\r\nconst print_info = (term: WrappedTerminal, pkg_name: string, pkg_version: string, pkg_data: PkgInfo, installed: boolean) => {\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`Package: ${STYLE.bold}${pkg_name}${STYLE.no_bold_or_dim}`);\r\n    term.writeln(`Version: ${STYLE.bold}${pkg_version}${STYLE.no_bold_or_dim}`);\r\n    term.writeln(`Description: ${pkg_data.description || \"No description provided.\"}`);\r\n    term.writeln(`Author: ${pkg_data.author || \"Unknown\"}`);\r\n    term.writeln(`License: ${pkg_data.license || \"Unknown\"}`);\r\n    term.writeln(`Installed: ${STYLE.bold}${installed ? \"Yes\" : \"No\"}${STYLE.no_bold_or_dim}`);\r\n\r\n    if (pkg_data.homepage_url) {\r\n        term.writeln(`Homepage: ${pkg_data.homepage_url}`);\r\n    }\r\n\r\n    if (pkg_data.repo_url) {\r\n        term.writeln(`Repository: ${pkg_data.repo_url}`);\r\n    }\r\n\r\n    if (pkg_data.long_desc) {\r\n        term.write(NEWLINE);\r\n        term.writeln(`Long description available. Use ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} read${STYLE.reset_all} ${pkg_name} to read it.`);\r\n    }\r\n}\r\n\r\nexport const info_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // check for presence of -r flag\r\n    let always_fetch = false;\r\n    if (args[0] === \"-r\") {\r\n        always_fetch = true;\r\n        args.shift();\r\n    }\r\n\r\n    // check for package name\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing package name.`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const pkg_at_version = args[0];\r\n\r\n    // if in the format of pkg@version, split it up\r\n    const pkg_split = pkg_at_version.split(\"@\");\r\n    if (pkg_split.length > 2) {\r\n        term.writeln(`${PREFABS.error}Invalid package name: ${pkg_at_version}`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    const pkg_name = pkg_split[0];\r\n    let pkg_version = pkg_split[1];\r\n\r\n    // if no version specified, use what's installed\r\n    // if not installed, fetch latest from repo\r\n    // note that version doesnt really matter other than as a test whether the version exists and installed locally, as pkg.json is shared across versions\r\n    if (!pkg_version) {\r\n        const installed_pkg = graph_query.get_pkg_version(pkg_name);\r\n        if (installed_pkg && !always_fetch) {\r\n            pkg_version = installed_pkg;\r\n        } else {\r\n            const pkg_json = await repo_query.get_pkg_json(pkg_name);\r\n            if (!pkg_json) {\r\n                term.writeln(`${PREFABS.error}Package not found: ${pkg_name}`);\r\n                term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n                return 3;\r\n            }\r\n\r\n            pkg_version = pkg_json.latest_version;\r\n        }\r\n    }\r\n\r\n    const installed_pkg = graph_query.get_pkg_version(pkg_name);\r\n    const requested_version_installed = installed_pkg === pkg_version;\r\n\r\n    const fs = kernel.get_fs();\r\n\r\n    if (!always_fetch && requested_version_installed) {\r\n        const pkg_json_path = graph_query.get_file_path_in_pkg_bin(fs, pkg_name, \"pkg.json\");\r\n\r\n        if (!fs.exists(pkg_json_path)) {\r\n            // shouldnt happen, but just in case\r\n            console.error(`Invalid pkg.json path: ${pkg_json_path}`);\r\n            term.writeln(`${PREFABS.error}Error reading package files for ${pkg_name}`);\r\n            return 3;\r\n        }\r\n\r\n        const pkg_json = await fs.read_file(pkg_json_path) as string;\r\n        const pkg_data = JSON.parse(pkg_json);\r\n\r\n        print_info(term, pkg_name, pkg_version, pkg_data, true);\r\n        return 0;\r\n    }\r\n\r\n    // fetch package data from repo\r\n    const pkg_data = await repo_query.get_pkg_json(pkg_name);\r\n    if (!pkg_data) {\r\n        term.writeln(`${PREFABS.error}Package not found: ${pkg_name}`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 3;\r\n    }\r\n\r\n    print_info(term, pkg_name, pkg_version, pkg_data, requested_version_installed);\r\n    return 0;\r\n}\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport type { WrappedTerminal } from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {graph_query, repo_query} from \"./index\";\r\nimport type {Kernel} from \"../../kernel\";\r\nimport type {AbstractShell} from \"../../abstract_shell\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, CURSOR } = ANSI;\r\n\r\nconst ROWS = 10;\r\n\r\nconst view_pkg_info = async (pkg_name: string, term: WrappedTerminal, kernel: Kernel, shell?: AbstractShell) => {\r\n    const pkg_data = await repo_query.get_pkg_json(pkg_name);\r\n    const pkg_versions = await repo_query.get_pkg_versions(pkg_name);\r\n\r\n    term.clear();\r\n\r\n    term.write(NEWLINE);\r\n    term.writeln(`${STYLE.bold}${FG.cyan}${pkg_name}`);\r\n    term.write(STYLE.dim);\r\n    term.writeln(\"=\".repeat(pkg_name.length));\r\n    term.writeln(STYLE.reset_all);\r\n\r\n    // check for installed version\r\n    const installed_version = graph_query.get_pkg_version(pkg_name);\r\n\r\n    term.write(NEWLINE);\r\n    term.writeln(`${STYLE.bold}Available versions:${STYLE.no_bold_or_dim}`);\r\n    for (const version of pkg_versions) {\r\n        term.writeln(`  - ${version} ${installed_version === version ? `${STYLE.italic}(installed)${STYLE.reset_all}` : \"\"}`);\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n    term.writeln(`${STYLE.bold}Description:${STYLE.no_bold_or_dim} ${pkg_data.description || \"No description provided.\"}`);\r\n    term.writeln(`${STYLE.bold}Author:${STYLE.no_bold_or_dim} ${pkg_data.author || \"Unknown\"}`);\r\n    term.writeln(`${STYLE.bold}License:${STYLE.no_bold_or_dim} ${pkg_data.license || \"Unknown\"}`);\r\n\r\n    let printed_link_header = false;\r\n\r\n    if (pkg_data.homepage_url) {\r\n        if (!printed_link_header) {\r\n            term.write(NEWLINE);\r\n            printed_link_header = true;\r\n        }\r\n\r\n        term.writeln(`${STYLE.bold}Homepage:${STYLE.no_bold_or_dim} ${pkg_data.homepage_url}`);\r\n    }\r\n\r\n    if (pkg_data.repo_url) {\r\n        if (!printed_link_header) {\r\n            term.write(NEWLINE);\r\n            printed_link_header = true;\r\n        }\r\n\r\n        term.writeln(`${STYLE.bold}Repository:${STYLE.no_bold_or_dim} ${pkg_data.repo_url}`);\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`${STYLE.dim}Press 'i' to install the latest version of this package.${STYLE.reset_all}`);\r\n    term.writeln(`${STYLE.dim}Press any other key to return to the list...${STYLE.reset_all}`);\r\n\r\n    const key = await term.wait_for_keypress();\r\n\r\n    if (key.domEvent.key === \"i\") {\r\n        // double check installation\r\n        term.write(NEWLINE);\r\n        term.write(`${STYLE.bold}Are you sure you want to install '${pkg_name}'? (y/N)${STYLE.no_bold_or_dim}`);\r\n\r\n        const confirm_key = await term.wait_for_keypress();\r\n\r\n        if (confirm_key.domEvent.key.toLowerCase() === \"y\") {\r\n            term.write(\" yes\");\r\n            term.write(NEWLINE);\r\n\r\n            await kernel.spawn(\"pkg\", [\"add\", pkg_name], shell).completion;\r\n\r\n            term.write(NEWLINE);\r\n            term.writeln(`${STYLE.dim}Press any key to return to the list...${STYLE.reset_all}`);\r\n            await term.wait_for_keypress();\r\n        } else {\r\n            term.write(\" no\");\r\n            term.writeln(NEWLINE);\r\n\r\n            term.writeln(`${STYLE.dim}Installation cancelled. Press any key to return to the list...${STYLE.reset_all}`);\r\n            await term.wait_for_keypress();\r\n        }\r\n    }\r\n}\r\n\r\n// TODO: accept name argument to jump to specific package\r\n\r\nexport const browse_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel, shell } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    const provided = await repo_query.get_provided_list();\r\n\r\n    let offset = 0;\r\n    let selected_index = 0;\r\n    const draw = () => {\r\n        term.clear();\r\n\r\n        term.write(NEWLINE);\r\n        term.writeln(\"(use up/down arrow keys to scroll, enter to show more info, escape to quit)\");\r\n        term.write(NEWLINE);\r\n        term.write(CURSOR.invisible);\r\n\r\n        // show ... if there are more items above\r\n        if (offset > 0) {\r\n            term.writeln(`  ${STYLE.dim}...${STYLE.reset_all}`);\r\n        } else {\r\n            term.write(NEWLINE);\r\n        }\r\n\r\n        const slice = provided.slice(offset, offset + ROWS);\r\n        for (const [index, name] of slice.entries()) {\r\n            // check for installed version\r\n            const installed_version = graph_query.get_pkg_version(name);\r\n\r\n            // highlight selected item\r\n            if (offset + index === selected_index) {\r\n                term.write(`${FG.cyan}${STYLE.dim}> ${STYLE.no_bold_or_dim}${STYLE.bold}`);\r\n            } else {\r\n                term.write(\"  \");\r\n            }\r\n\r\n            term.writeln(`${name} ${installed_version ? `${STYLE.italic}(installed: ${installed_version})` : \"\"}${STYLE.reset_all}`);\r\n        }\r\n\r\n        // show ... if there are more items below\r\n        if (offset + ROWS < provided.length) {\r\n            term.writeln(`  ${STYLE.dim}...${STYLE.reset_all}`);\r\n        } else {\r\n            term.write(NEWLINE);\r\n        }\r\n    }\r\n\r\n    // TODO: type to filter\r\n\r\n    let quit = false;\r\n    while (!quit) {\r\n        draw();\r\n\r\n        const key = await term.wait_for_keypress();\r\n        console.log(key);\r\n        switch (key.domEvent.key) {\r\n            case \"Escape\":\r\n                quit = true;\r\n                break;\r\n            case \"ArrowUp\":\r\n                if (selected_index > 0) {\r\n                    selected_index--;\r\n                    if (selected_index < offset) {\r\n                        offset--;\r\n                    }\r\n                }\r\n                break;\r\n            case \"ArrowDown\":\r\n                if (selected_index < provided.length - 1) {\r\n                    selected_index++;\r\n                    if (selected_index >= offset + ROWS) {\r\n                        offset++;\r\n                    }\r\n                }\r\n                break;\r\n            case \"Enter\": {\r\n                const pkg_name = provided[selected_index];\r\n                await view_pkg_info(pkg_name, term, kernel, shell);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    term.clear();\r\n    term.write(CURSOR.visible);\r\n    return 0;\r\n}\r\n","import {add_subcommand} from \"./add\";\r\nimport {remove_subcommand} from \"./remove\";\r\n\r\nimport {ANSI, type WrappedTerminal} from \"../../term_ctl\";\r\nimport type {Program} from \"../../types\";\r\nimport type {AbstractFileSystem} from \"../../filesystem\";\r\nimport {list_subcommand} from \"./list\";\r\nimport {info_subcommand} from \"./info\";\r\nimport {browse_subcommand} from \"./browse\";\r\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\r\n\r\nimport type {Kernel, SpawnResult} from \"../../kernel\";\r\nimport type {AbstractShell} from \"../../abstract_shell\";\r\n\r\n\r\nconst REPO_URL = \"https://ollieg.codes/pkg_repo\";\r\nconst repo_url_obj = new URL(REPO_URL);\r\n// TODO: in future, this can be changed. it will also be a list of repos in priority order, and the first one that has the package will be used.\r\n\r\nconst GRAPH_DIR = \"/var/lib/pkg\";\r\nconst GRAPH_PATH = GRAPH_DIR + \"/graph.json\";\r\n\r\nconst BIN_DIR = \"/usr/bin\";\r\n\r\nconst TRIGGER_DIR = \"/var/lib/pkg/triggers\";\r\n\r\n// TODO: subcommand template / helper\r\n\r\nconst append_url_pathnames = (url: URL, pathnames: string[]) => {\r\n    const new_url = new URL(url.toString());\r\n    let urlpath = new_url.pathname;\r\n\r\n    // drop trailing /\r\n    if (urlpath.endsWith(\"/\")) {\r\n        urlpath = urlpath.slice(0, urlpath.length - 1);\r\n    }\r\n\r\n    for (const path of pathnames) {\r\n        if (path.includes(\"/\") || path.includes(\"\\\\\") || path.includes(\"..\")) {\r\n            throw new Error(\"Unsafe pathname: \" + path);\r\n        }\r\n\r\n        urlpath += (path === \"\" ? \"\" : \"/\" + path);\r\n    }\r\n\r\n    new_url.pathname = urlpath;\r\n    return new_url;\r\n    // TODO: safe?\r\n}\r\n\r\nexport type PkgAtVersion = `${string}@${string}`;\r\n// TODO: honestly handling of pakcage version sucks rn, need to test if even having deps = \"pkg@version\" works properly\r\n\r\ninterface PackageMeta {\r\n    files: string[];\r\n    version: string;\r\n    deps: Set<PkgAtVersion>;\r\n    triggers: { [trigger_name: string]: unknown };\r\n    build_timestamp: number;\r\n    externals: \"global\" | undefined;\r\n}\r\n\r\nexport const repo_query = {\r\n    // GETs a file path relative to the repo root\r\n    // TODO: why did i write this and not use it?? all other fetches are just this but returning null for a 404?? am i stupid?? it's being exported so maybe i had a reason\r\n    api_call: async (filepath: string) => {\r\n        const url = new URL(filepath, repo_url_obj);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n        return await response.text();\r\n    },\r\n\r\n    // returns null if not found, otherwise returns the contents of the file\r\n    get_pkg_json: async (pkg: string) => {\r\n        pkg = encodeURI(pkg);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, \"pkg.json\"]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        return await response.json();\r\n    },\r\n\r\n    // returns null if not found, otherwise returns the meta.json file as an object\r\n    get_pkg_meta: async (pkg: string, version: string): Promise<PackageMeta> => {\r\n        pkg = encodeURI(pkg);\r\n        version = encodeURI(version);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n        version = version.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/version/\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, version, \"meta.json\"]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        // TODO: validate meta\r\n\r\n        const data = await response.json();\r\n\r\n        // convert deps to set\r\n        data.deps = new Set(data.deps);\r\n\r\n        return data;\r\n    },\r\n\r\n    // gets a file within a package or returns null if not found\r\n    get_pkg_file: async (pkg: string, version: string, filepath: string) => {\r\n        pkg = encodeURI(pkg);\r\n        version = encodeURI(version);\r\n        filepath = encodeURI(filepath);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n        version = version.replace(/\\./g, \"%2E\");\r\n        filepath = filepath.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/version/filepath\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, version, filepath]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        return await response.text();\r\n    },\r\n\r\n    get_provided_list: async () => {\r\n        // repo/provided.txt\r\n        const url = append_url_pathnames(repo_url_obj, [\"provided.txt\"]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        // newline separated list of provided package names\r\n        const data = await response.text();\r\n        return data.split(\"\\n\").map((line) => line.trim()).filter((line) => line.length > 0);\r\n    },\r\n\r\n    get_pkg_versions: async (pkg: string) => {\r\n        pkg = encodeURI(pkg);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/versions.txt\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, \"versions.txt\"]);\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        // newline separated list of versions\r\n        const data = await response.text();\r\n        return data.split(\"\\n\").map((line) => line.trim()).filter((line) => line.length > 0);\r\n    }\r\n}\r\n\r\ninterface PkgGraphEntry {\r\n    version: string;\r\n    deps: Set<PkgAtVersion | string>;\r\n    dependents: Set<string>;\r\n    top_level: boolean; // as in, specified by the user at install time\r\n}\r\n\r\nexport const json_convert_dep_sets_to_arrs = (key: string, value: any) => {\r\n    if (key !== \"deps\" && key !== \"dependents\") {\r\n        return value;\r\n    }\r\n\r\n    if (value instanceof Set) {\r\n        return Array.from(value);\r\n    }\r\n\r\n    throw new Error(`${key} not a set in graph to be stringified!`);\r\n}\r\n\r\nexport const json_convert_dep_arrs_to_sets = (key: string, value: any) => {\r\n    if (key !== \"deps\" && key !== \"dependents\") {\r\n        return value;\r\n    }\r\n\r\n    if (Array.isArray(value)) {\r\n        return new Set(value);\r\n    }\r\n\r\n    throw new Error(`${key} not an array in graph to be parsed!`);\r\n}\r\n\r\nlet graph: { [pkg_name: string]: PkgGraphEntry } = {};\r\nexport const graph_query = {\r\n    // TODO: graph consistency checks / repair function\r\n    // TODO: dangling dep check\r\n\r\n    // gets the graph entry for a package\r\n    get_pkg_info: (pkg: string): PkgGraphEntry => {\r\n        return graph[pkg];\r\n    },\r\n\r\n    // lists names of all installed packages, optionally only top level\r\n    list_pkgs: (only_top_level = false) => {\r\n        const pkgs = Object.keys(graph);\r\n\r\n        if (only_top_level) {\r\n            return pkgs.filter((pkg) => graph[pkg].top_level);\r\n        }\r\n\r\n        return pkgs;\r\n    },\r\n\r\n    // checks if a package is installed, optionally with a specific version\r\n    pkg_is_installed: (pkg: string, version?: string) => {\r\n        if (!graph[pkg]) {\r\n            return false;\r\n        }\r\n\r\n        if (version) {\r\n            return graph[pkg].version === version;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    // gets the version of an installed package, or undefined if not installed\r\n    get_pkg_version: (pkg: string): string | undefined => {\r\n        return graph[pkg]?.version;\r\n    },\r\n\r\n    // gets the dependents of a package, or undefined if not installed\r\n    get_pkg_dependents: (pkg: string): Set<string> | undefined => {\r\n        return graph[pkg]?.dependents;\r\n    },\r\n\r\n    // gets the dependencies of a package, or undefined if not installed\r\n    get_pkg_dependencies: (pkg: string): Set<PkgAtVersion | string> | undefined => {\r\n        return graph[pkg]?.deps;\r\n    },\r\n\r\n    // installs a NEW package. if this is not a top level package, you must specify an initial dependent. you cannot modify an existing package unless you use the defined functions.\r\n    install_new_pkg: async (fs: AbstractFileSystem, pkg: string, version: string, deps: Set<PkgAtVersion>, top_level: boolean, dependended_by?: string) => {\r\n        // TODO: resolve what to do if the package is already installed rather than exploding, makes using it a lot simpler\r\n\r\n        if (graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is already installed and cannot be modified.`);\r\n        }\r\n\r\n        // TODO: we could assume top level based on if dependended_by is provided, but that's not very precise. top level packages may be dependencies!\r\n        if (!top_level && !dependended_by) {\r\n            throw new Error(`Package ${pkg} is not installed as a top-level package but does not have a dependent it was installed by.`);\r\n        }\r\n\r\n        const dependents = new Set<string>();\r\n\r\n        if (dependended_by) {\r\n            dependents.add(dependended_by);\r\n        }\r\n\r\n        graph[pkg] = {\r\n            version,\r\n            deps,\r\n            top_level,\r\n            dependents\r\n        };\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // makes a package a top level package, no checks are performed as top level packages may have dependents\r\n    promote_pkg_to_top_level: async (fs: AbstractFileSystem, pkg: string) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        graph[pkg].top_level = true;\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // makes a package not a top level package, but only if it has no dependents. use add_pkg_dependent FIRST before demoting if it has dependents now.\r\n    demote_pkg_from_top_level: async (fs: AbstractFileSystem, pkg: string) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        if (graph[pkg].dependents.size > 0) {\r\n            throw new Error(`Package ${pkg} has no dependents and cannot be demoted. Use add_pkg_dependent FIRST.`);\r\n        }\r\n\r\n        graph[pkg].top_level = false;\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // adds a dependent to a package, provided the dependent is already installed. also adds the dependency to the dependent package.\r\n    add_pkg_dependent: async (fs: AbstractFileSystem, pkg: string, dependent_pkg: string, add_to_deps = false) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        if (!graph[dependent_pkg]) {\r\n            throw new Error(`Dependent ${dependent_pkg} is not installed.`);\r\n        }\r\n\r\n        const pkg_at_version = `${pkg}@${graph[pkg].version}` as PkgAtVersion;\r\n\r\n        graph[pkg].dependents.add(dependent_pkg);\r\n\r\n        if (add_to_deps) {\r\n            graph[dependent_pkg].deps.add(pkg_at_version);\r\n        }\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // removes a dependent from a package, as well as clearing the dependency from the dependent package\r\n    remove_pkg_dependent: async (fs: AbstractFileSystem, pkg: string, dependent_pkg: string, remove_from_deps = false) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        if (!graph[dependent_pkg]) {\r\n            throw new Error(`Dependent ${dependent_pkg} is not installed.`);\r\n        }\r\n\r\n        if (!graph[pkg].dependents.has(dependent_pkg)) {\r\n            throw new Error(`Package ${pkg} does not have dependent ${dependent_pkg}.`);\r\n        }\r\n\r\n        const pkg_at_version = `${pkg}@${graph[pkg].version}` as PkgAtVersion;\r\n\r\n        if (!graph[dependent_pkg].deps.has(pkg) && !graph[dependent_pkg].deps.has(pkg_at_version)) {\r\n            throw new Error(`Inconsistent graph! Dependent ${dependent_pkg} does not have dependency ${pkg}, but ${pkg} has dependent ${dependent_pkg}.`);\r\n        }\r\n\r\n        graph[pkg].dependents.delete(dependent_pkg);\r\n\r\n        if (remove_from_deps) {\r\n            graph[dependent_pkg].deps.delete(pkg_at_version);\r\n        }\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n\r\n        // uninstall if it has no dependents now? probably not, we can have a separate command for that\r\n    },\r\n\r\n    // removes a package from the graph, provided it has no dependents. you can skip this check, but this will leave dangling dependencies.\r\n    remove_pkg: async (fs: AbstractFileSystem, pkg: string, skip_dep_check = false) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        // check if this package has any dependents\r\n        if (!skip_dep_check && graph[pkg].dependents.size > 0) {\r\n            throw new Error(`Package ${pkg} has dependents and cannot be removed.`);\r\n        }\r\n\r\n        // // remove this package from its dependents' dependencies\r\n        // no! don't do this! if they skip the dep check, we don't want to destroy the fact that there are hanging deps\r\n        // for (const dependent of graph[pkg].dependents) {\r\n        //     const dependent_name = dependent.split(\"@\")[0];\r\n        //     graph[dependent_name].deps = graph[dependent_name].deps.filter((dep) => dep !== pkg);\r\n        // }\r\n\r\n        // remove this package from its dependencies' dependents\r\n        for (const dep of graph[pkg].deps) {\r\n            const dep_name = dep.split(\"@\")[0];\r\n            graph[dep_name].dependents.delete(`${pkg}@${graph[pkg].version}` as PkgAtVersion);\r\n        }\r\n\r\n        // TODO: feels like something is missing? oh well, we'll find out when we test it\r\n\r\n        // remove this package from the graph\r\n        delete graph[pkg];\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // lists all packages that are not installed as top level and have no dependents\r\n    list_unused_pkgs: () => {\r\n        return Object.keys(graph).filter((pkg) => !graph[pkg].top_level && graph[pkg].dependents.size === 0);\r\n    },\r\n\r\n    get_file_path_in_pkg_bin: (fs: AbstractFileSystem, pkg: string, filepath: string) => {\r\n        const pkg_dir = fs.join(BIN_DIR, pkg);\r\n        return fs.join(pkg_dir, filepath);\r\n    }\r\n}\r\n\r\ninterface TriggerFile {\r\n    install_exec?: string;\r\n    uninstall_exec?: string;\r\n}\r\n\r\nexport const triggers = {\r\n    load_trigger_file: async (fs: AbstractFileSystem, trigger_name: string): Promise<TriggerFile | null> => {\r\n        const trigger_path = fs.join(TRIGGER_DIR, trigger_name + \".json\");\r\n        if (!(await fs.exists(trigger_path))) {\r\n            return null;\r\n        }\r\n\r\n        const data = await fs.read_file(trigger_path) as string;\r\n\r\n        try {\r\n            return JSON.parse(data) as TriggerFile;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    trigger_exists: async (fs: AbstractFileSystem, trigger_name: string): Promise<boolean> => {\r\n        return (await triggers.load_trigger_file(fs, trigger_name)) !== null;\r\n    },\r\n\r\n    // returns boolean indicating if the trigger was found and processed\r\n    process_install_trigger: async (trigger_name: string, data: unknown, pkg_name: string, pkg_version: string, term: WrappedTerminal, kernel: Kernel, shell?: AbstractShell) => {\r\n        const fs = kernel.get_fs();\r\n\r\n        const trigger = await triggers.load_trigger_file(fs, trigger_name);\r\n        if (!trigger) {\r\n            return false;\r\n        }\r\n\r\n        if (!trigger.install_exec) {\r\n            // nothing to do\r\n            return true;\r\n        }\r\n\r\n        const data_str = JSON.stringify(data);\r\n\r\n        console.log(`Processing install trigger ${trigger_name} with exec ${trigger.install_exec} and args [${pkg_name}, ${pkg_version}, ${data_str}]`);\r\n\r\n        let spawn_result: SpawnResult;\r\n\r\n        try {\r\n            spawn_result =  kernel.spawn(trigger.install_exec, [pkg_name, pkg_version, data_str], shell);\r\n            const exit_code = await spawn_result.completion;\r\n            if (exit_code !== 0) {\r\n                term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} exited with code ${exit_code}.${ANSI.STYLE.reset_all}`);\r\n            }\r\n\r\n            spawn_result.process.kill(exit_code);\r\n        } catch (e) {\r\n            term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} failed: ${e}.${ANSI.STYLE.reset_all}`);\r\n\r\n            if (spawn_result) {\r\n                spawn_result.process.kill(-1);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    // returns boolean indicating if the trigger was found and processed\r\n    process_uninstall_trigger: async (trigger_name: string, data: unknown, pkg_name: string, pkg_version: string, term: WrappedTerminal, kernel: Kernel, shell?: AbstractShell) => {\r\n        const fs = kernel.get_fs();\r\n\r\n        const trigger = await triggers.load_trigger_file(fs, trigger_name);\r\n        if (!trigger) {\r\n            return false;\r\n        }\r\n\r\n        if (!trigger.uninstall_exec) {\r\n            // nothing to do\r\n            return true;\r\n        }\r\n\r\n        const data_str = JSON.stringify(data);\r\n\r\n        console.log(`Processing uninstall trigger ${trigger_name} with exec ${trigger.uninstall_exec} and args [${pkg_name}, ${pkg_version}, ${data_str}]`);\r\n\r\n        let spawn_result: SpawnResult;\r\n\r\n        try {\r\n            spawn_result =  kernel.spawn(trigger.uninstall_exec, [pkg_name, pkg_version, data_str], shell);\r\n            const exit_code = await spawn_result.completion;\r\n            if (exit_code !== 0) {\r\n                term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} exited with code ${exit_code}.${ANSI.STYLE.reset_all}`);\r\n            }\r\n\r\n            spawn_result.process.kill(exit_code)\r\n        } catch (e) {\r\n            term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} failed: ${e}.${ANSI.STYLE.reset_all}`);\r\n\r\n            if (spawn_result) {\r\n                spawn_result.process.kill(-1);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS} = ANSI;\r\n\r\n// TODO: update command (update all installed or specific packages)\r\n\r\nexport default {\r\n    name: \"pkg\",\r\n    description: \"The package manager for OllieOS.\",\r\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\r\n    arg_descriptions: {\r\n        \"Subcommands:\": {\r\n            \"add\": `Installs a list of packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} add <packages...>${STYLE.reset_all}`,\r\n            \"remove\": `Uninstalls a list of packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} remove <packages...>${STYLE.reset_all}`,\r\n            \"list\": `Lists all installed packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} list [-t]${STYLE.reset_all}`,\r\n            \"info\": `Displays information about a package: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} info [-r] <package>${STYLE.reset_all}`,\r\n            \"read\": `Reads the long description for a package if it has one: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} read [-r] <package>${STYLE.reset_all}`,\r\n            \"browse\": `Browse the repository for packages and versions: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} browse${STYLE.reset_all}`,\r\n            \"clean\": `Removes all packages that are not top level and have no dependents (and are therefore unused): ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} clean [-d]${STYLE.reset_all}`,\r\n        },\r\n        \"Arguments:\": {\r\n            \"-h\": \"Displays this help message.\",\r\n            \"For add:\": {\r\n                \"packages\": \"The packages to install, separated by spaces. If you wish to install a specific version, use the format 'package@version'.\",\r\n            },\r\n            \"For remove:\": {\r\n                \"packages\": \"The packages to uninstall, separated by spaces.\",\r\n            },\r\n            \"For list:\": {\r\n                \"-t\": \"List only top-level packages.\",\r\n            },\r\n            \"For info:\": {\r\n                \"-r\": \"Always fetch the latest information from the repository.\",\r\n                \"package\": \"The package to get information about.\",\r\n            },\r\n            \"For read:\": {\r\n                \"-r\": \"Always fetch the latest information from the repository.\",\r\n                \"package\": \"The package to read the long description of.\",\r\n            },\r\n            \"For clean:\": {\r\n                \"-d\": \"Dry run. Lists the packages that would be removed without actually removing them.\",\r\n            }\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // TODO: smarter completion that understands flags for subcommands\r\n        switch (data.arg_index) {\r\n            case 0:\r\n                return helper_completion_options([\"add\", \"remove\", \"list\", \"info\", \"read\", \"browse\", \"clean\"])(data);\r\n            case 1:\r\n                if ([\"info\", \"read\", \"remove\"].includes(data.args[0])) {\r\n                    // complete with installed package names\r\n                    const fs = data.kernel.get_fs();\r\n\r\n                    // load graph\r\n                    let local_graph: { [pkg_name: string]: PkgGraphEntry } = {};\r\n                    try {\r\n                        local_graph = JSON.parse(await fs.read_file(\"/var/lib/pkg/graph.json\") as string, json_convert_dep_arrs_to_sets);\r\n                    } catch (e) {\r\n                        return [];\r\n                    }\r\n\r\n                    const pkgs = Object.keys(local_graph);\r\n                    return helper_completion_options(pkgs)(data);\r\n                }\r\n                break;\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // TODO: safety prompt on first use\r\n\r\n        // extract from data to make code less verbose\r\n        const {args, term, kernel, shell} = data;\r\n        const fs = kernel.get_fs();\r\n\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\r\n            term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"pkg\"], shell).completion;\r\n        }\r\n\r\n        // create /var/lib/pkg if it doesn't exist so subcommands don't have to check\r\n        if (!(await fs.exists(GRAPH_DIR))) {\r\n            await fs.make_dir(GRAPH_DIR);\r\n        }\r\n\r\n        // create /var/lib/pkg/graph.json if it doesn't exist\r\n        if (!(await fs.exists(GRAPH_PATH))) {\r\n            await fs.write_file(GRAPH_PATH, \"{}\");\r\n        }\r\n\r\n        // create /var/lib/pkg/triggers if it doesn't exist\r\n        if (!(await fs.exists(TRIGGER_DIR))) {\r\n            await fs.make_dir(TRIGGER_DIR);\r\n        }\r\n\r\n        // write /var/lib/pkg/triggers/create_trigger.json if it doesn't exist\r\n        const create_trigger_path = fs.join(TRIGGER_DIR, \"create_trigger.json\");\r\n        if (!(await fs.exists(create_trigger_path))) {\r\n            const create_trigger_data: TriggerFile = {\r\n                install_exec: \"trigger_create_trigger\",\r\n                uninstall_exec: \"trigger_remove_trigger\"\r\n            };\r\n\r\n            await fs.write_file(create_trigger_path, JSON.stringify(create_trigger_data));\r\n        }\r\n\r\n        // load graph\r\n        try {\r\n            graph = JSON.parse(await fs.read_file(\"/var/lib/pkg/graph.json\") as string, json_convert_dep_arrs_to_sets);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Fatal error: could not load package graph.${STYLE.reset_all}`);\r\n            return 2;\r\n        }\r\n\r\n        switch (args[0]) {\r\n            case \"add\":\r\n                return await add_subcommand(data);\r\n            case \"remove\":\r\n                return await remove_subcommand(data);\r\n            case \"list\":\r\n                return await list_subcommand(data);\r\n            case \"info\":\r\n                return await info_subcommand(data);\r\n            case \"read\":\r\n                term.writeln(`${PREFABS.error}Not implemented yet.${STYLE.reset_all}`);\r\n                break;\r\n            case \"browse\":\r\n                return await browse_subcommand(data);\r\n            case \"clean\":\r\n                term.writeln(`${PREFABS.error}Not implemented yet.${STYLE.reset_all}`);\r\n                break;\r\n            default:\r\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\r\n                term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type {Program} from \"../types\";\r\nimport {ANSI} from \"../term_ctl\";\r\n\r\n// yes, the actual touch command is used to modify access time and has more flags, but this os doesn't have access times and this is meant to be simple\r\n\r\nexport default {\r\n    name: \"touch\",\r\n    description: \"Creates a file.\",\r\n    usage_suffix: \"file\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"file\": \"The file to create.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const {kernel, args, term} = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const {STYLE, PREFABS} = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // if no arguments, print error\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing file operand.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // if more than one argument, print error\r\n        // TODO: i think this is the only program that checks this, the others drop the extra arguments. do something about this!\r\n        if (args.length > 1) {\r\n            term.writeln(`${PREFABS.error}Too many arguments${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // if the file already exists, do nothing\r\n        const file = args[0];\r\n        const absolute_file = fs.absolute(file);\r\n\r\n        if (await fs.exists(absolute_file)) {\r\n            return 0;\r\n        }\r\n\r\n        // check if the directory exists\r\n        // TODO: should abstractfilesystem have basename and dirname functions? check other programs for similar code!\r\n        const dir = absolute_file.split(\"/\").slice(0, -1).join(\"/\");\r\n        if (!(await fs.dir_exists(dir))) {\r\n            term.writeln(`${PREFABS.error}No such directory: ${dir}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // create the file\r\n        await fs.write_file(absolute_file, \"\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport {ANSI} from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"mkdir\",\r\n    description: \"Creates a directory.\",\r\n    usage_suffix: \"[-p] directory\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-p\": \"Create parent directories (recursive) if they don't exist.\"\r\n        },\r\n        \"Arguments:\": {\r\n            \"directory\": \"The directory to create.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n\r\n        // check if -p flag was passed\r\n        let recursive = false;\r\n        if (args[0] === \"-p\") {\r\n            recursive = true;\r\n            args.shift();\r\n        }\r\n\r\n        // check if there is only one argument after parsing flag\r\n        if (args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}Invalid arguments.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get directory\r\n        const dir = args[0];\r\n        const abs_dir = fs.absolute(dir);\r\n\r\n        // check if directory already exists\r\n        if (await fs.dir_exists(abs_dir)) {\r\n            return 0;\r\n        }\r\n\r\n        // create directory\r\n        // make_dir is recursive by default, so just check the directories exist already if NOT recursive\r\n        if (recursive) {\r\n            await fs.make_dir(abs_dir);\r\n        } else {\r\n            // check if the directory exists\r\n            const parent = abs_dir.split(\"/\").slice(0, -1).join(\"/\");\r\n            if (!(await fs.dir_exists(parent))) {\r\n                term.writeln(`${PREFABS.error}No such directory: ${parent}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            await fs.make_dir(abs_dir);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"mv\",\r\n    description: \"Moves files and directories.\",\r\n    usage_suffix: \"[-n] source destination\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"source\": \"The file or directory to move.\",\r\n            \"destination\": \"The new location for the file or directory.\",\r\n            \"-n\": \"Do not overwrite an existing file.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // check for -n\r\n        let no_overwrite = false;\r\n        //if (args.includes(\"-n\")) {\r\n            // TODO: why do programs care about flag order? should they?\r\n            //// remove -n from args\r\n            //args.splice(args.indexOf(\"-n\"), 1);\r\n        if (args[0] === \"-n\") {\r\n            no_overwrite = true;\r\n            args.shift();\r\n        }\r\n\r\n        // get source and destination\r\n        const source = fs.absolute(args[0]);\r\n        let destination = fs.absolute(args[1]);\r\n\r\n        // check if source exists\r\n        if (!(await fs.exists(source))) {\r\n            term.writeln(`${PREFABS.error}No such file or directory: ${source}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        const ended_with_slash = destination.endsWith(\"/\");\r\n        const dest_is_dir = await fs.dir_exists(destination);\r\n\r\n        // if destination is a directory and ending with a slash, append the basename of source to destination\r\n        if (dest_is_dir && ended_with_slash) {\r\n            const basename = source.split(\"/\").pop() as string;\r\n            destination = fs.join(destination, basename);\r\n        }\r\n\r\n        // check if destination exists if -n is passed OR we are moving a FILE (not a directory) into a DIRECTORY ending specifically with /\r\n        // TODO: there must be a way to adjust logic of the fs functions to make this check unnecessary or simpler. oh well.\r\n        const do_exists_check = no_overwrite || (dest_is_dir && !(await fs.dir_exists(source)) && ended_with_slash);\r\n        if (do_exists_check && await fs.exists(destination)) {\r\n            term.writeln(`${PREFABS.error}File or directory already exists: ${destination}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // move source to destination\r\n        // TODO: abstractfilesystem should have a file_exists function so we don't have to check if it's a directory first\r\n        if (await fs.dir_exists(source)) {\r\n            // temporary warning\r\n            term.writeln(`${FG.yellow + STYLE.bold}Warning: Moving directories is not fully supported yet. Some features may not work as expected! The operation will be performed anyway.${STYLE.reset_all}`);\r\n\r\n            // move inside if ended with slash OR the destination is a directory that already exists\r\n            // TODO: is this correct???? maybe???\r\n            const move_inside = ended_with_slash || (dest_is_dir && await fs.dir_exists(destination));\r\n            await fs.move_dir(source, destination, no_overwrite, move_inside);\r\n        } else if (await fs.exists(source)) {\r\n            await fs.move_file(source, destination);\r\n        } else {\r\n            term.writeln(`${PREFABS.error}Source is neither a file nor a directory: ${source}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG } = ANSI;\r\nexport const info_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    term.write(NEWLINE);\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const all_windows = wm!.get_all_windows();\r\n    const visible_windows = all_windows.filter(w => w.visible).length;\r\n\r\n    term.writeln(`Window manager: ${FG.cyan}${wm!.get_unique_manager_type_name()}${STYLE.reset_all}`);\r\n    term.writeln(`Total open windows: ${FG.cyan}${all_windows.length}${STYLE.reset_all}`);\r\n    term.writeln(`Visible windows: ${FG.cyan}${visible_windows}${STYLE.reset_all}`);\r\n    term.writeln(`Invisible windows: ${FG.cyan}${all_windows.length - visible_windows}${STYLE.reset_all}`);\r\n\r\n    return 0;\r\n}\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG } = ANSI;\r\nexport const list_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // check for presence of -v or -i flag\r\n    let only_visible = false;\r\n    let only_invisible = false;\r\n    if (args[0] === \"-v\") {\r\n        only_visible = true;\r\n        args.shift();\r\n    } else if (args[0] === \"-i\") {\r\n        only_invisible = true;\r\n        args.shift();\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const all_windows = wm!.get_all_windows();\r\n    for (const win of all_windows) {\r\n        if (only_visible && !win.visible) {\r\n            continue;\r\n        }\r\n\r\n        if (only_invisible && win.visible) {\r\n            continue;\r\n        }\r\n\r\n        // TODO: source process tracking to show which program opened the window\r\n        const visibility_text = win.visible ? `${FG.green}Visible${STYLE.reset_all}` : `${FG.red}Invisible${STYLE.reset_all}`;\r\n        term.writeln(`- [${win.id}] ${FG.cyan}${win.title}${STYLE.reset_all} : ${visibility_text} owned by PID ${FG.yellow}${win.owner_pid}${STYLE.reset_all}`);\r\n    }\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const show_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to show\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    if (wind.visible) {\r\n        term.writeln(`Window with ID ${FG.cyan}${window_id}${STYLE.reset_all} is already visible.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    term.writeln(`Showing window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\r\n    wind.show();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const hide_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to hide\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    if (!wind.visible) {\r\n        term.writeln(`Window with ID ${FG.cyan}${window_id}${STYLE.reset_all} is already hidden.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    term.writeln(`Hiding window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\r\n    wind.hide();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const close_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to close\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`Closing window with ID ${FG.cyan}${window_id}${STYLE.reset_all}. The process that opened this window may still be running.`);\r\n    wind.close();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const center_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to center\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`Centering window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\r\n    wind.center();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport type {Program} from \"../../types\";\r\n\r\nimport {info_subcommand} from \"./info\";\r\nimport {list_subcommand} from \"./list\";\r\nimport {show_subcommand} from \"./show\";\r\nimport {hide_subcommand} from \"./hide\";\r\nimport {close_subcommand} from \"./close\";\r\nimport {center_subcommand} from \"./center\";\r\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS} = ANSI;\r\n\r\n// TODO: maximise restore command, respecting maximisable property but providing a -f force flag\r\n\r\nexport default {\r\n    name: \"window\",\r\n    description: \"Interact with program windows.\",\r\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\r\n    arg_descriptions: {\r\n        \"Subcommands:\": {\r\n            \"info\": `Displays information about the window manager and open windows: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} info${STYLE.reset_all}`,\r\n            \"list\": `Lists all open windows: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} list [-vi]${STYLE.reset_all}`,\r\n            \"show\": `Shows a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} show <window_id>${STYLE.reset_all}`,\r\n            \"hide\": `Hides a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} hide <window_id>${STYLE.reset_all}`,\r\n            \"close\": `Closes a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} close <window_id>${STYLE.reset_all}. Note that this does not terminate the process that opened the window.`,\r\n            \"center\": `Centers a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} show <window_id>${STYLE.reset_all}`,\r\n        },\r\n        \"Arguments:\": {\r\n            \"-h\": \"Displays this help message.\",\r\n            \"For list:\": {\r\n                \"-v\": \"List only visible windows.\",\r\n                \"-i\": \"List only invisible (minimised/hidden) windows.\",\r\n            },\r\n            \"For show, hide, close, and center:\": {\r\n                \"<window_id>\": \"The ID of the window.\",\r\n            }\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        switch (data.arg_index) {\r\n            case 0:\r\n                return helper_completion_options([\"info\", \"list\", \"show\", \"hide\", \"close\", \"center\"])(data);\r\n            case 1:\r\n                // completing first argument of subcommand\r\n                if (data.raw_parts[1] === \"list\") {\r\n                    return helper_completion_options([\"-v\", \"-i\"])(data);\r\n                } else if ([\"show\", \"hide\", \"close\", \"center\"].includes(data.raw_parts[1])) {\r\n                    // complete window ids\r\n                    const wm = data.kernel.get_window_manager();\r\n                    if (!wm) {\r\n                        return [];\r\n                    }\r\n\r\n                    const window_ids = wm.get_all_windows().map((win) => win.id.toString());\r\n                    return helper_completion_options(window_ids)(data);\r\n                }\r\n                return [];\r\n            default:\r\n                return [];\r\n        }\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const {args, term, kernel, shell} = data;\r\n\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\r\n            term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"window\"], shell).completion;\r\n        }\r\n\r\n        if (!kernel.has_window_manager()) {\r\n            term.writeln(`${PREFABS.error}No window manager found.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        switch (args[0]) {\r\n            case \"info\":\r\n                return await info_subcommand(data);\r\n            case \"list\":\r\n                return await list_subcommand(data);\r\n            case \"show\":\r\n                return await show_subcommand(data);\r\n            case \"hide\":\r\n                return await hide_subcommand(data);\r\n            case \"close\":\r\n                return await close_subcommand(data);\r\n            case \"center\":\r\n                return await center_subcommand(data);\r\n            default:\r\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\r\n                term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n    }\r\n} as Program;\r\n","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"alias\",\r\n    description: \"Define or display aliases. (Use .ollierc to persist aliases)\",\r\n    usage_suffix: \"[name[=value] ...]\",\r\n    arg_descriptions: {\r\n        name: \"The name of the alias to define or display. If no arguments are given, all aliases are displayed. Multiple alias arguments can be provided.\",\r\n        \"name=value\": \"Defines an alias with the given name and value. End the value with a space to allow chaining.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, term } = data;\r\n\r\n        if (!shell) {\r\n            term.writeln(\"No shell available\");\r\n            return 1;\r\n        }\r\n\r\n        // TODO: move to shell builtin, not actual program\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = term.ansi;\r\n\r\n        if (data.args.length === 0) {\r\n            // display all aliases\r\n            const aliases = shell.memory.list_aliases();\r\n            for (const [name, value] of aliases.entries()) {\r\n                term.writeln(`alias ${name}='${value}'`);\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        for (const arg of data.args) {\r\n            if (arg.includes(\"=\")) {\r\n                // define alias\r\n                const [name, ...value_parts] = arg.split(\"=\");\r\n                const value = value_parts.join(\"=\");\r\n\r\n                // remove surrounding quotes if present\r\n                let final_value = value;\r\n                if ((final_value.startsWith(\"'\") && final_value.endsWith(\"'\")) ||\r\n                    (final_value.startsWith(\"\\\"\") && final_value.endsWith(\"\\\"\"))) {\r\n                    final_value = final_value.slice(1, -1);\r\n                }\r\n\r\n                shell.memory.set_alias(name, final_value);\r\n            } else {\r\n                // display alias\r\n                const value = shell.memory.get_alias(arg);\r\n                if (value) {\r\n                    term.writeln(`alias ${arg}='${value}'`);\r\n                } else {\r\n                    term.writeln(`${PREFABS.error}alias: ${arg}: not found${STYLE.reset_all}`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"unalias\",\r\n    description: \"Remove defined aliases.\",\r\n    usage_suffix: \"name [name ...]\",\r\n    arg_descriptions: {\r\n        name: \"The name of the alias to remove. Multiple alias names can be provided.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (!data.shell) {\r\n            return [];\r\n        }\r\n\r\n        const alias_names = [...data.shell.memory.list_aliases().keys()];\r\n        // TODO: check type to see why helper_completion_options wont work here\r\n        return alias_names.filter(name => name.startsWith(data.current_partial));\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, term } = data;\r\n\r\n        if (!shell) {\r\n            term.writeln(\"No shell available\");\r\n            return 1;\r\n        }\r\n\r\n        // TODO: move to shell builtin, not actual program\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = term.ansi;\r\n\r\n        if (data.args.length === 0) {\r\n            term.writeln(`${PREFABS.error}unalias: usage: unalias name [name ...]${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        for (const arg of data.args) {\r\n            const success = shell.memory.unset_alias(arg);\r\n            if (!success) {\r\n                term.writeln(`${PREFABS.error}unalias: ${arg}: not found${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import {ANSI, NEWLINE} from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"ps\",\r\n    description: \"Display currently running processes.\",\r\n    usage_suffix: \"[-p PID]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"-p PID\": \"Display information about the process with the given PID. If omitted, displays all running processes.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        console.log(data);\r\n        if (data.arg_index === 0) {\r\n            return helper_completion_options([\"-p\"])(data);\r\n        } else if (data.arg_index === 1 && data.args[0] === \"-p\") {\r\n            const pm = data.kernel.get_process_manager();\r\n            const pids = pm.list_pids().map((pid) => pid.toString());\r\n            return helper_completion_options(pids)(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // get process manager\r\n        const pm = kernel.get_process_manager();\r\n\r\n        if (data.args[0] === \"-p\") {\r\n            const pid = parseInt(data.args[1]);\r\n            if (isNaN(pid)) {\r\n                term.writeln(`${PREFABS.error}Invalid PID provided.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            const process = pm.get_process(pid);\r\n            if (!process) {\r\n                term.writeln(`${PREFABS.error}No process found with PID ${pid}.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            term.write(NEWLINE);\r\n            term.writeln(`${STYLE.bold}PID:${STYLE.no_bold_or_dim} ${process.pid}${STYLE.reset_all}`);\r\n            term.writeln(`${STYLE.bold}Command:${STYLE.no_bold_or_dim} ${process.source_command.command}${STYLE.reset_all}`);\r\n            term.writeln(`${STYLE.bold}Created:${STYLE.no_bold_or_dim} ${process.created_at.toLocaleString()}${STYLE.reset_all}`);\r\n\r\n            return 0;\r\n        }\r\n\r\n        const pids = pm.list_pids();\r\n\r\n        // get longest source command length for formatting\r\n        let longest_command_length = 7 // length of \"COMMAND\"\r\n        for (const pid of pids) {\r\n            const process = pm.get_process(pid)!;\r\n            if (process.source_command.command.length > longest_command_length) {\r\n                longest_command_length = process.source_command.command.length;\r\n            }\r\n        }\r\n\r\n        const get_command_space = (subtract = 0) => \" \".repeat(longest_command_length - subtract);\r\n\r\n        term.write(NEWLINE);\r\n        term.writeln(`${STYLE.bold}PID\\tCOMMAND${get_command_space(7)}\\t\\tCREATED${STYLE.reset_all}`);\r\n        for (const pid of pids) {\r\n            const process = pm.get_process(pid)!;\r\n            term.writeln(`${pid}\\t${process.source_command.command}${get_command_space(process.source_command.command.length)}\\t\\t${process.created_at.toLocaleString()}`);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import {ANSI} from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"kill\",\r\n    description: \"Kill a process by its PID.\",\r\n    usage_suffix: \"PID\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"PID\": \"The PID of the process to kill.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (data.arg_index === 0) {\r\n            const pm = data.kernel.get_process_manager();\r\n            const pids = pm.list_pids().map((pid) => pid.toString());\r\n            return helper_completion_options(pids)(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        if (data.args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}Exactly one argument (PID) expected.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // TODO: support more kill signals as arguments\r\n\r\n        // get process manager\r\n        const pm = kernel.get_process_manager();\r\n        const pid = parseInt(data.args[0]);\r\n\r\n        if (isNaN(pid)) {\r\n            term.writeln(`${PREFABS.error}Invalid PID provided.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        const process = pm.get_process(pid);\r\n        if (!process) {\r\n            term.writeln(`${PREFABS.error}No process found with PID ${pid}.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        process.kill(143); // SIGTERM\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: move this to be literal SIGTERM and SIGKILL signals sent to processes\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport {ProgramMainData} from \"../../types\"\r\n\r\nimport type {IgnitionIPCReply} from \"../core/ignition\";\r\nimport type {ServiceStatus} from \"../core/ignition/services\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, FG, PREFABS} = ANSI;\r\n\r\nexport const service_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const {args, term, process, kernel} = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing action.`);\r\n        term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    if (args.length === 1) {\r\n        term.writeln(`${PREFABS.error}Missing service ID.`);\r\n        term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const action = args[0];\r\n    const service_id = args[1];\r\n\r\n    // open ipc with ignition\r\n    const ipc = kernel.get_ipc();\r\n    const channel_id = ipc.create_channel(process.pid, \"init\");\r\n\r\n    if (!channel_id) {\r\n        term.writeln(`${PREFABS.error}Failed to communicate with ignition.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // function can be defined to handle response data, string responses and errors handled by default\r\n    let on_data: (msg_data: unknown) => void;\r\n    let reply_timeout: number;\r\n    let return_code = 0;\r\n\r\n    // listen for replies\r\n    ipc.channel_listen(channel_id, process.pid, async (msg) => {\r\n        const payload = msg.data as IgnitionIPCReply;\r\n\r\n        if (payload.type === \"data\") {\r\n            if (on_data) {\r\n                on_data(payload.data);\r\n            } else {\r\n                term.writeln(`${FG.yellow}Warning: Unhandled data response: ${JSON.stringify(payload.data)}${STYLE.reset_all}`);\r\n            }\r\n        } else if (payload.type === \"response\") {\r\n            term.writeln(`${FG.green}${payload.message}${STYLE.reset_all}`);\r\n        } else if (payload.type === \"error\") {\r\n            term.writeln(`${PREFABS.error}${payload.message}${STYLE.reset_all}`);\r\n            return_code = 1;\r\n        }\r\n\r\n        if (reply_timeout) {\r\n            process.cancel_timeout(reply_timeout);\r\n        }\r\n    });\r\n\r\n    if (action === \"status\") {\r\n        // special handler for status data\r\n        on_data = (msg_data: unknown) => {\r\n            const status = msg_data as ServiceStatus;\r\n\r\n            term.write(NEWLINE);\r\n            term.writeln(`${FG.cyan}Service ID:${STYLE.reset_all} ${service_id}`);\r\n\r\n            term.write(`${FG.cyan}Status: ${STYLE.reset_all}`);\r\n            switch (status.state) {\r\n                case \"running\":\r\n                    term.writeln(`${FG.green}Running${STYLE.reset_all}`);\r\n                    term.writeln(`${FG.cyan}PID:${STYLE.reset_all} ${status.pid}`);\r\n                    break;\r\n                case \"stopped\":\r\n                    term.writeln(`${FG.yellow}Stopped${STYLE.reset_all}`);\r\n                    break;\r\n                case \"failed\":\r\n                    term.writeln(`${FG.red}Failed${STYLE.reset_all}`);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // wait up to 3 seconds for a reply before erroring\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    reply_timeout = process.create_timeout(() => {}, 3000);\r\n\r\n    // can just send the action and service id directly rather than needing additional checking as the action matches the ipc action names\r\n    ipc.channel_send(channel_id, process.pid, {\r\n        type: \"service\",\r\n        action,\r\n        service_id\r\n    });\r\n\r\n    if (!process.has_timeout(reply_timeout)) {\r\n        // timeout already cleared, meaning we got a response\r\n        return return_code;\r\n    }\r\n\r\n    const got_no_reply = await process.wait_for_timeout(reply_timeout);\r\n\r\n    if (got_no_reply) {\r\n        term.writeln(`${PREFABS.error}No response from ignition.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    // TODO: all this logic is kinda jank, trying to be too clever with timeouts and async ipc\r\n\r\n    return return_code;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport {ProgramMainData} from \"../../types\"\r\n\r\nimport type {IgnitionIPCReply} from \"../core/ignition\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, FG, PREFABS} = ANSI;\r\n\r\nexport const reload_services_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const {args, term, process, kernel} = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // TODO: make function to do this back and forth with ignition rather than duplicating code for each subcommand\r\n\r\n    // open ipc with ignition\r\n    const ipc = kernel.get_ipc();\r\n    const channel_id = ipc.create_channel(process.pid, \"init\");\r\n\r\n    if (!channel_id) {\r\n        term.writeln(`${PREFABS.error}Failed to communicate with ignition.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    let reply_timeout: number;\r\n    let return_code = 0;\r\n\r\n    // listen for replies\r\n    ipc.channel_listen(channel_id, process.pid, async (msg) => {\r\n        const payload = msg.data as IgnitionIPCReply;\r\n\r\n        if (payload.type === \"response\") {\r\n            term.writeln(`${FG.green}${payload.message}${STYLE.reset_all}`);\r\n        } else if (payload.type === \"error\") {\r\n            term.writeln(`${PREFABS.error}${payload.message}${STYLE.reset_all}`);\r\n            return_code = 1;\r\n        }\r\n\r\n        if (reply_timeout) {\r\n            process.cancel_timeout(reply_timeout);\r\n        }\r\n    });\r\n\r\n    // wait up to 3 seconds for a reply before erroring\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    reply_timeout = process.create_timeout(() => {}, 3000);\r\n\r\n    ipc.channel_send(channel_id, process.pid, {\r\n        type: \"reload_services\"\r\n    });\r\n\r\n    if (!process.has_timeout(reply_timeout)) {\r\n        // timeout already cleared, meaning we got a response\r\n        return return_code;\r\n    }\r\n\r\n    const got_no_reply = await process.wait_for_timeout(reply_timeout);\r\n\r\n    if (got_no_reply) {\r\n        term.writeln(`${PREFABS.error}No response from ignition.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    // TODO: all this logic is kinda jank, trying to be too clever with timeouts and async ipc\r\n\r\n    return return_code;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport type {Program} from \"../../types\";\r\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\r\n\r\nimport {service_subcommand} from \"./service\";\r\nimport {reload_services_subcommand} from \"./reload_services\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS} = ANSI;\r\n\r\n\r\nexport default {\r\n    name: \"spark\",\r\n    description: \"Manage your system with ignition.\",\r\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\r\n    arg_descriptions: {\r\n        \"Subcommands:\": {\r\n            \"service\": \"Manage running services.\",\r\n            \"reload-services\": \"Reload the service definition files.\",\r\n        },\r\n        \"Arguments:\": {\r\n            \"-h\": \"Displays this help message.\",\r\n            \"For service:\": {\r\n                \"action\": \"The action to perform (start, stop, restart, status).\",\r\n                \"service_id\": \"The ID of the service to manage.\",\r\n            },\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // TODO: smarter completion that understands flags for subcommands\r\n        switch (data.arg_index) {\r\n            case 0:\r\n                return helper_completion_options([\"service\"])(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const {args, term, kernel, shell} = data;\r\n\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\r\n            term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"spark\"], shell).completion;\r\n        }\r\n\r\n        switch (args[0]) {\r\n            case \"service\":\r\n                return await service_subcommand(data);\r\n            case \"reload-services\":\r\n                return await reload_services_subcommand(data);\r\n            default:\r\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\r\n                term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"ipc_bg_test\",\r\n    description: \"\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term, process } = data;\r\n\r\n        process.detach();\r\n\r\n        const ipc = kernel.get_ipc();\r\n        ipc.service_register(\"ipc_bg_test\", process.pid, async (channel_id, from_pid) => {\r\n            ipc.channel_listen(channel_id, process.pid, async (msg) => {\r\n                term.writeln(`Received message on channel ${channel_id} from PID ${msg.from}: ${JSON.stringify(msg.data)}`);\r\n            });\r\n        });\r\n\r\n        term.writeln(\"ipc_bg_test service started and listening for messages.\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"ipc_fg_test\",\r\n    description: \"\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term, process } = data;\r\n\r\n        const ipc = kernel.get_ipc();\r\n        const channel = ipc.create_channel(process.pid, \"ipc_bg_test\");\r\n        \r\n        if (!channel) {\r\n            term.writeln(\"Failed to create IPC channel to service 'ipc_bg_test'.\");\r\n            return 1;\r\n        }\r\n\r\n        ipc.channel_send(channel, process.pid, { message: \"Hello from ipc_fg_test!\" });\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"taskbar_test\",\r\n    description: \"\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    hide_from_help: true,\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term, process, shell } = data;\r\n\r\n        if (!kernel.has_window_manager()) {\r\n            term.writeln(\"This program requires a window manager.\");\r\n            return 1;\r\n        }\r\n\r\n        const wind = process.create_window();\r\n\r\n        wind.title = \"Taskbar\";\r\n\r\n        wind.set_custom_flag(\"no-top-bar\", true);\r\n\r\n        wind.x = \"0vw\";\r\n        wind.y = \"92.5vh\";\r\n\r\n        wind.height = \"7.5vh\";\r\n        wind.width = \"100vw\";\r\n\r\n        const buttons = document.createElement(\"div\");\r\n        buttons.style.display = \"flex\";\r\n        buttons.style.height = \"100%\";\r\n        buttons.style.alignItems = \"center\";\r\n        buttons.style.gap = \"1vh\";\r\n        buttons.style.padding = \"0 1vh\";\r\n\r\n        wind.dom.appendChild(buttons);\r\n\r\n        const fsedit_button = document.createElement(\"button\");\r\n        fsedit_button.innerText = \"FSEdit\";\r\n        fsedit_button.style.height = \"100%\";\r\n        fsedit_button.style.fontSize = \"2vh\";\r\n        fsedit_button.onclick = () => {\r\n            kernel.spawn(\"fsedit\", [], shell);\r\n        };\r\n\r\n        buttons.appendChild(fsedit_button);\r\n\r\n        // if minecraft is installed, add a button for it\r\n        const prog_reg = kernel.get_program_registry();\r\n        if (prog_reg.getProgram(\"minecraft\")) {\r\n            const mc_button = document.createElement(\"button\");\r\n            mc_button.style.height = \"100%\";\r\n            mc_button.style.fontSize = \"2vh\";\r\n            mc_button.onclick = () => {\r\n                kernel.spawn(\"minecraft\", [], shell);\r\n            };\r\n\r\n            const mc_image = document.createElement(\"img\");\r\n            mc_image.src = \"https://brandlogos.net/wp-content/uploads/2022/07/minecraft-logo_brandlogos.net_faqdi-512x560.png\";\r\n            mc_image.style.height = \"100%\";\r\n            mc_image.style.objectFit = \"contain\";\r\n            mc_image.alt = \"Minecraft\";\r\n            mc_image.draggable = false;\r\n            mc_button.appendChild(mc_image);\r\n\r\n            buttons.appendChild(mc_button);\r\n        }\r\n\r\n        wind.show();\r\n\r\n        process.detach();\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../../../types\";\r\n\r\nexport default {\r\n    name: \"trigger_create_trigger\",\r\n    description: \"A trigger to create another trigger. Use this trigger to deploy custom triggers!\",\r\n    usage_suffix: \"pkg_name pkg_version trigger_file\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"pkg_name\": \"The name of the package creating the trigger, which will namespace the trigger. Passed automatically by the package manager.\",\r\n            \"pkg_version\": \"Ignored. Passed automatically by the package manager.\",\r\n            \"trigger_file\": \"The path to the trigger file to create. This is the string that you pass into the create_trigger trigger in your package's meta.json triggers section.\"\r\n        }\r\n    },\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        if (args.length !== 3) {\r\n            term.writeln(\"Usage: trigger_create_trigger pkg_name pkg_version trigger_file\");\r\n            return 1;\r\n        }\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        const pkg_name = args[0];\r\n        const trigger_file = JSON.parse(args[2]);\r\n\r\n        // trigger must end with .json\r\n        if (!trigger_file.endsWith(\".json\")) {\r\n            term.writeln(\"Error: Trigger file must end with .json\");\r\n            return 1;\r\n        }\r\n\r\n        // source path will be /usr/bin/PKG_NAME/TRIGGER_FILE\r\n        const source_path = fs.join(\"/usr/bin\", pkg_name, trigger_file);\r\n\r\n        // check the path is valid\r\n        if (!await fs.exists(source_path)) {\r\n            term.writeln(`Error: Trigger file not found at ${source_path}`);\r\n            return 1;\r\n        }\r\n\r\n        // destination path will be /var/lib/pkg/triggers/PKG_NAME/TRIGGER_FILE\r\n        const dest_path = fs.join(\"/var/lib/pkg/triggers\", pkg_name, trigger_file);\r\n\r\n        // check the destination path does not already exist\r\n        if (await fs.exists(dest_path)) {\r\n            term.writeln(`Error: Trigger file already exists at ${dest_path}.`);\r\n            return 1;\r\n        }\r\n\r\n        // copy the trigger file to the destination\r\n        // TODO: make fs support copy operation\r\n        const content = await fs.read_file(source_path);\r\n        await fs.write_file(dest_path, content);\r\n\r\n        term.writeln(`Trigger created at ${dest_path}`);\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: way to pass trigger data as json and identify it. then a way to pass just program name to use as both create and remove trigger?\r\n","import type { Program } from \"../../../types\";\r\n\r\nexport default {\r\n    name: \"trigger_remove_trigger\",\r\n    description: \"A trigger to remove a trigger.\",\r\n    usage_suffix: \"pkg_name pkg_version trigger_file\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"pkg_name\": \"The name of the package that created the trigger, which is used to namespace the trigger. Passed automatically by the package manager.\",\r\n            \"pkg_version\": \"Ignored. Passed automatically by the package manager.\",\r\n            \"trigger_file\": \"The path to the trigger file to remove. This is the string that you pass into the create_trigger trigger in your package's meta.json triggers section.\"\r\n        }\r\n    },\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        if (args.length !== 3) {\r\n            term.writeln(\"Usage: trigger_remove_trigger pkg_name pkg_version trigger_file\");\r\n            return 1;\r\n        }\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        const pkg_name = args[0];\r\n        const trigger_file = JSON.parse(args[2]);\r\n\r\n        // trigger must end with .json\r\n        if (!trigger_file.endsWith(\".json\")) {\r\n            term.writeln(\"Error: Trigger file must end with .json\");\r\n            return 1;\r\n        }\r\n\r\n        // destination path will be /var/lib/pkg/triggers/PKG_NAME/TRIGGER_FILE\r\n        const dest_path = fs.join(\"/var/lib/pkg/triggers\", pkg_name, trigger_file);\r\n\r\n        // check the destination path exists\r\n        if (!await fs.exists(dest_path)) {\r\n            return 0;\r\n        }\r\n\r\n        // remove the trigger file\r\n        await fs.delete_file(dest_path);\r\n\r\n        term.writeln(`Trigger removed from ${dest_path}`);\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: should triggers support using the same program as the uninstall trigger, an just passing different arguments?\r\n","import { AbstractFileSystem, FSEventType, NonRecursiveDirectoryError, PathNotFoundError } from \"../filesystem\";\r\n\r\n// TODO: may get laggy with large files and many files or dirs\r\n// NOTE: not using implements (TS) so the real methods can be used\r\n// indexeddb fs is superior\r\n// TODO: unsolveable prototype pollution without banning filenames. tried using map, but recursive traversal wont work as the instances are distinct (not writing to the original state dict)\r\nexport class LocalStorageFS extends AbstractFileSystem {\r\n    get_unique_fs_type_name(): string {\r\n        return \"localstorage\";\r\n    }\r\n\r\n    async is_ready() {\r\n        return true;\r\n    }\r\n\r\n    async erase_all() {\r\n        localStorage.removeItem(\"fs\");\r\n        localStorage.removeItem(\"fs_readonly_paths\");\r\n        localStorage.removeItem(\"fs_migrations\");\r\n    }\r\n\r\n    async make_dir(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // create directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            const absolute_path = parts.slice(0, parts.indexOf(part) + 1).join(\"/\");\r\n\r\n            if (!current_dir[part]) {\r\n                current_dir[part] = {};\r\n                this._call_callbacks(FSEventType.MADE_DIR, absolute_path);\r\n            }\r\n\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // save state\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async delete_dir_direct(path: string, recursive: boolean) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // delete innermost directory\r\n        for (let part_idx = 0; part_idx < parts.length; part_idx++) {\r\n            const part = parts[part_idx];\r\n            const absolute_path = parts.slice(0, parts.indexOf(part) + 1).join(\"/\");\r\n\r\n            if (!recursive && (await this.list_dir(absolute_path)).length > 0) {\r\n                throw new NonRecursiveDirectoryError(part);\r\n            }\r\n\r\n            // check if directory exists\r\n            if (!current_dir[part]) {\r\n                throw new PathNotFoundError(absolute_path);\r\n            }\r\n\r\n            // delete directory if it's the last part\r\n            if (part_idx === parts.length - 1) {\r\n                delete current_dir[part];\r\n                this._call_callbacks(FSEventType.DELETED_DIR, absolute_path);\r\n            }\r\n\r\n            // recurse into directory to discover the next part\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // save state\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async move_dir_direct(src: string, dest: string, no_overwrite: boolean, move_inside: boolean) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n\r\n        // using unix style rules, i.e\r\n        \r\n        // mv dir1 dir2 -> rename dir1 to dir2, or move dir1 into dir2 if dir2 already exists (THIS IS WHEN MOVE_INSIDE IS FALSE)\r\n        // overwrite any files in the destination directory if they exist in the source directory if no_overwrite is false\r\n        // and of course move across any files from the source directory to the destination directory and leave any only in the destination directory alone\r\n        \r\n        // mv dir1 dir2/ -> move dir1 into dir2 (dir2 must exist, dir1 must not exist in dir2) (THIS IS WHEN MOVE_INSIDE IS TRUE, THERE WILL NOT BE A TRAILING / IN THE DESTINATION PATH)\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const src_parts = src === this._root ? [\"\"] : src.split(\"/\");\r\n        const dest_parts = dest.split(\"/\");\r\n\r\n        // get directory for each part inside the previous one\r\n        let current_dir = state;\r\n        let current_dir_parent = null;\r\n        for (const part of src_parts) {\r\n            if (!current_dir[part]) {\r\n                throw new PathNotFoundError(src);\r\n            }\r\n            current_dir_parent = current_dir;\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // check if source is a directory\r\n        if (typeof current_dir !== \"object\") {\r\n            throw new PathNotFoundError(src);\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        let dest_current_dir = state;\r\n        //let dest_current_dir_parent = null;\r\n        for (const part of dest_parts) {\r\n            if (!dest_current_dir[part]) {\r\n                // if this is the last part, create the directory, otherwise throw an error\r\n                // TODO: is this correct? it acts correct, but is it too lax?\r\n                if (part === dest_parts[dest_parts.length - 1]) {\r\n                    dest_current_dir[part] = {};\r\n                } else {\r\n                    throw new PathNotFoundError(dest);\r\n                }\r\n            }\r\n            //dest_current_dir_parent = dest_current_dir;\r\n            dest_current_dir = dest_current_dir[part];\r\n        }\r\n\r\n        // check if destination is a directory\r\n        if (typeof dest_current_dir !== \"object\") {\r\n            throw new PathNotFoundError(dest);\r\n        }\r\n\r\n        // if we have equivalent paths, do nothing (so we don't accidentally delete the directory when calling delete after move)\r\n        if (src === dest) {\r\n            console.warn(\"source and destination are the same\");\r\n            return;\r\n        }\r\n\r\n        // TODO: significant fixes required! moving directories is just a mess\r\n        // TODO: need to consolidate exactly when we should be merging directories. its not exactly clear and chatgpt contradicts itself when asking for a formal definition!\r\n\r\n        if (move_inside) {\r\n            // if moving inside, check that the directory named the same as the source does not exist in the destination\r\n            if (dest_current_dir[src_parts[src_parts.length - 1]]) {\r\n                throw new Error(`Directory already exists in destination: ${dest}`);\r\n            }\r\n\r\n            // move directory inside destination\r\n            dest_current_dir[src_parts[src_parts.length - 1]] = current_dir;\r\n\r\n            // delete source directory\r\n            delete current_dir_parent[src_parts[src_parts.length - 1]];\r\n        } else {\r\n            // not moving inside, so merge files and directories from source into destination\r\n            for (const key of Object.keys(current_dir)) {\r\n                if (dest_current_dir[key] && no_overwrite) {\r\n                    throw new Error(`File or directory already exists in destination: ${dest}`);\r\n                }\r\n\r\n                dest_current_dir[key] = current_dir[key];\r\n            }\r\n\r\n            // delete source directory\r\n            delete current_dir_parent[src_parts[src_parts.length - 1]];\r\n        }\r\n\r\n        // save state\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async list_dir(path: string, dirs_first = false) {\r\n        this._call_callbacks(FSEventType.LISTING_DIR, path);\r\n\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // trim trailing slash\r\n        if (parts[parts.length - 1] === \"\") {\r\n            parts.pop();\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            if (current_dir[part]) {\r\n                current_dir = current_dir[part];\r\n            } else {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n        }\r\n\r\n        // if this is the root we will have an empty parts array, so we need to access the root directory\r\n        // our whole fs is stored under an empty top level key because im stupid\r\n        // we might have to do this elsewhere\r\n        if (parts.length === 0) {\r\n            current_dir = state[\"\"];\r\n        }\r\n\r\n        // return list of files in directory\r\n        const keys = Object.keys(current_dir);\r\n\r\n        if (dirs_first) {\r\n            for (const key of keys) {\r\n                // promote directories to the front of the list\r\n                if (typeof current_dir[key] === \"object\") {\r\n                    keys.splice(keys.indexOf(key), 1);\r\n                    keys.unshift(key);\r\n                }\r\n            }\r\n        }\r\n\r\n        return keys;\r\n    }\r\n\r\n\r\n    async read_file_direct(path: string, as_uint = false) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n        let current_part = state;\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // if this is not the last part, check if it is a directory\r\n            if (parts.indexOf(part) !== parts.length - 1 && !current_part[part]) {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n\r\n            current_part = current_part[part];\r\n        }\r\n\r\n        // check if file exists\r\n        if (current_part !== undefined) {\r\n            // if file is empty, return empty string / uint8array (or else it will be read as null byte)\r\n            if (current_part.length === 0) {\r\n                if (as_uint) {\r\n                    return new Uint8Array();\r\n                } else {\r\n                    return \"\";\r\n                }\r\n            }\r\n\r\n            const binary_string = atob(current_part);\r\n            const bytes = Uint8Array.from(binary_string, m => m.charCodeAt(0));\r\n\r\n            if (as_uint) {\r\n                return bytes;\r\n            } else {\r\n                return new TextDecoder().decode(bytes);\r\n            }\r\n        }\r\n\r\n        throw new PathNotFoundError(path);\r\n    }\r\n\r\n    async write_file_direct(path: string, data: string | ArrayBuffer | Uint8Array) {\r\n        let uint: Uint8Array;\r\n\r\n        // convert string to uint8array\r\n        if (typeof data === \"string\") {\r\n            uint = new TextEncoder().encode(data);\r\n        }\r\n\r\n        // convert array buffer to uint8array\r\n        if (data instanceof ArrayBuffer) {\r\n            uint = new Uint8Array(data);\r\n        }\r\n\r\n        if (data instanceof Uint8Array) {\r\n            uint = data;\r\n        }\r\n\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n        const file_name = parts[parts.length - 1];\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // go until before the last part\r\n            if (parts.indexOf(part) !== parts.length - 1) {\r\n                if (!current_dir[part]) {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                current_dir = current_dir[part];\r\n            }\r\n        }\r\n\r\n        // convert uint8array to base64\r\n        // uint.toBase64() isnt mainstream yet\r\n        current_dir[file_name] = btoa(String.fromCharCode.apply(null, uint));\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async delete_file_direct(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n        const file_name = parts[parts.length - 1];\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // go until before the last part\r\n            if (parts.indexOf(part) !== parts.length - 1) {\r\n                if (!current_dir[part]) {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                current_dir = current_dir[part];\r\n            }\r\n        }\r\n\r\n        // delete file from directory\r\n        delete current_dir[file_name];\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n\r\n        // remove from readonly list if it is there\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        if (readonly_list.includes(path)) {\r\n            readonly_list.splice(readonly_list.indexOf(path), 1);\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n        }\r\n    }\r\n\r\n    async move_file_direct(src: string, dest: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n\r\n        // split paths into parts, if root, use single empty string to avoid doubling\r\n        const src_parts = src === this._root ? [\"\"] : src.split(\"/\");\r\n        const dest_parts = dest === this._root ? [\"\"] : dest.split(\"/\");\r\n        const file_name = src_parts[src_parts.length - 1];\r\n        const new_file_name = dest_parts[dest_parts.length - 1];\r\n\r\n        // get directory for each part inside the previous one\r\n        let current_dir = state;\r\n        for (const part of src_parts.slice(0, -1)) {\r\n            if (!current_dir[part]) {\r\n                throw new PathNotFoundError(src);\r\n            }\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // check if file exists\r\n        if (current_dir[file_name] === undefined) {\r\n            throw new PathNotFoundError(src);\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        let new_current_dir = state;\r\n        for (const part of dest_parts.slice(0, -1)) {\r\n            if (!new_current_dir[part]) {\r\n                throw new PathNotFoundError(dest);\r\n            }\r\n            new_current_dir = new_current_dir[part];\r\n        }\r\n\r\n        // if we have equivalent paths, do nothing (so we don't accidentally delete the file when calling delete after move)\r\n        if (file_name === new_file_name && current_dir === new_current_dir) {\r\n            console.warn(\"source and destination are the same\");\r\n            return;\r\n        }\r\n\r\n        // move file from source to destination\r\n        new_current_dir[new_file_name] = current_dir[file_name];\r\n        delete current_dir[file_name];\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n\r\n        // relocate in readonly list if it is there\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        if (readonly_list.includes(src)) {\r\n            readonly_list.splice(readonly_list.indexOf(src), 1);\r\n            readonly_list.push(dest);\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n        }\r\n    }\r\n\r\n    async set_readonly_direct(path: string, readonly: boolean) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n\r\n        if (readonly && !state.includes(path)) {\r\n            state.push(path);\r\n        } else if (!readonly && state.includes(path)) {\r\n            state.splice(state.indexOf(path), 1);\r\n        }\r\n\r\n        localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(state));\r\n    }\r\n\r\n    async is_readonly_direct(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        return state.includes(path);\r\n    }\r\n\r\n    async exists_direct(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_part = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // remove trailing /\r\n        if (parts[parts.length - 1] === \"\") {\r\n            parts.pop();\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // important! empty strings are falsy so we need to specifically check for undefined\r\n            if (current_part[part] !== undefined) {\r\n                current_part = current_part[part];\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async dir_exists(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_part = state;\r\n\r\n        // if path ends with /, remove it\r\n        if (path.endsWith(\"/\")) {\r\n            path = path.slice(0, -1);\r\n        }\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            if (current_part[part]) {\r\n                current_part = current_part[part];\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return typeof current_part === \"object\";\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        // initialise file system\r\n        if (!localStorage.getItem(\"fs\")) {\r\n            localStorage.setItem(\"fs\", JSON.stringify({}));\r\n        }\r\n\r\n        if (!localStorage.getItem(\"fs_readonly_paths\")) {\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify([]));\r\n        }\r\n\r\n        const existing_migrations = localStorage.getItem(\"fs_migrations\");\r\n        if (!existing_migrations) {\r\n            localStorage.setItem(\"fs_migrations\", JSON.stringify({\r\n                string_to_array: false,\r\n                array_to_b64: false,\r\n            }));\r\n        }\r\n\r\n        const migrations = JSON.parse(localStorage.getItem(\"fs_migrations\"));\r\n\r\n        if (!migrations.string_to_array) {\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            migrate_old_string_fs(JSON.parse(localStorage.getItem(\"fs\")), true);\r\n        }\r\n\r\n        if (!migrations.array_to_b64) {\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            migrate_old_array_fs(JSON.parse(localStorage.getItem(\"fs\")));\r\n        }\r\n\r\n        // mark all migrations as done\r\n        migrations.string_to_array = true;\r\n        migrations.array_to_b64 = true;\r\n        localStorage.setItem(\"fs_migrations\", JSON.stringify(migrations));\r\n\r\n        // initialise root and home directory\r\n        this.make_dir(this._home).then(() => {\r\n            this._initialised = true;\r\n        }).catch((err) => {\r\n            console.error(\"Failed to create home directory:\", err);\r\n        });\r\n    }\r\n}\r\n\r\nconst migrate_old_string_fs = (state: object, is_outer = false) => {\r\n    // migration step: we used to use a string but now we use an array for files\r\n    // need to iterate DEEPLY into nested objects and convert string values to arrays\r\n    // (so recurse)\r\n    // TODO make iterative\r\n\r\n    for (const key of Object.keys(state)) {\r\n        if (typeof state[key] === \"object\" && !Array.isArray(state[key])) {\r\n            migrate_old_string_fs(state[key]);\r\n        } else if (typeof state[key] === \"string\") {\r\n            console.log(`Migration: converting ${key} to array`);\r\n            state[key] = state[key].split(\",\").map((x) => parseInt(x));\r\n        }\r\n    }\r\n\r\n    if (is_outer) {\r\n        // only save if we are at the outermost level\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n}\r\n\r\nconst migrate_old_array_fs = (state: object) => {\r\n    // migration step: we used to use an array for files but now we use base64 strings\r\n    // need to iterate DEEPLY into nested objects and convert array values to strings\r\n\r\n    // use a stack to avoid recursion limit issues\r\n    const stack = [state];\r\n\r\n    while (stack.length > 0) {\r\n        // get the next object to process\r\n        const current_obj = stack.pop();\r\n\r\n        if (current_obj === null || typeof current_obj !== \"object\" || Array.isArray(current_obj)) {\r\n            continue;\r\n        }\r\n\r\n        // iterate over the keys of the current object\r\n        for (const key of Object.keys(current_obj)) {\r\n            const value = current_obj[key];\r\n\r\n            if (!value) {\r\n                continue;\r\n            } else if (typeof value === \"object\" && !Array.isArray(value)) {\r\n                // if the value is a nested object, add it to the stack to be processed later (depth first)\r\n                stack.push(value);\r\n            } else if (Array.isArray(value)) {\r\n                console.log(`Migration: converting ${key} to b64 string`);\r\n\r\n                try {\r\n                    const values = value.map((x: string) => parseInt(x));\r\n                    const uint = new Uint8Array(values);\r\n                    // uint.toBase64() isnt mainstream yet\r\n                    current_obj[key] = btoa(String.fromCharCode.apply(null, uint));\r\n                } catch (e) {\r\n                    console.error(`Migration failed for key \"${key}\":`, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // only save after the whole traversal\r\n    localStorage.setItem(\"fs\", JSON.stringify(state));\r\n}\r\n","import {AbstractFileSystem, NonRecursiveDirectoryError, PathNotFoundError} from \"../filesystem\";\r\n\r\nexport class OPFSFileSystem extends AbstractFileSystem {\r\n    private _opfs_handle: FileSystemDirectoryHandle | null = null;\r\n\r\n    get_unique_fs_type_name(): string {\r\n        return \"opfs\";\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        if (!localStorage.getItem(\"fs_readonly_paths\")) {\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify([]));\r\n        }\r\n\r\n        // get the root directory handle\r\n        navigator.storage.getDirectory().then((handle) => {\r\n            this._opfs_handle = handle;\r\n        }).catch((err) => {\r\n            console.error(\"Failed to get OPFS directory handle:\", err);\r\n        });\r\n    }\r\n\r\n    async is_ready() {\r\n        return this._opfs_handle !== null;\r\n    }\r\n\r\n    private get_root_handle(): FileSystemDirectoryHandle {\r\n        if (!this._opfs_handle) {\r\n            throw new Error(\"OPFS directory handle is not initialised.\");\r\n        }\r\n\r\n        return this._opfs_handle;\r\n    }\r\n\r\n    async make_dir(path: string) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            current_handle = await current_handle.getDirectoryHandle(part, { create: true });\r\n        }\r\n    }\r\n\r\n    async dir_exists(path: string): Promise<boolean> {\r\n        // should return true only for directories\r\n\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(part);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && (err.name === \"NotFoundError\" || err.name === \"TypeMismatchError\")) {\r\n                    return false;\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async exists_direct(path: string) {\r\n        // should return true for both files and directories\r\n\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(part);\r\n            } catch (err) {\r\n                try {\r\n                    await current_handle.getFileHandle(part);\r\n                    return true;\r\n                } catch (err2) {\r\n                    if (err2 instanceof DOMException && err2.name === \"NotFoundError\") {\r\n                        return false;\r\n                    }\r\n                    throw err2;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async delete_dir_direct(path: string, recursive: boolean) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        try {\r\n            // recurse into directories\r\n            let current_handle = root;\r\n            for (let i = 0; i < parts.length - 1; i++) {\r\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\r\n            }\r\n\r\n            await current_handle.removeEntry(parts[parts.length - 1], { recursive });\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n\r\n            if (err instanceof DOMException && err.name === \"InvalidModificationError\" && !recursive) {\r\n                throw new NonRecursiveDirectoryError(path);\r\n            }\r\n\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    async list_dir(path: string) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(part);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        const entries: string[] = [];\r\n        for await (const [name, handle] of current_handle.entries()) {\r\n            entries.push(name);\r\n        }\r\n\r\n        return entries;\r\n    }\r\n\r\n    async is_readonly_direct(path: string) {\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\") || \"[]\");\r\n        return readonly_list.includes(path);\r\n    }\r\n\r\n    async set_readonly_direct(path: string, readonly: boolean) {\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\") || \"[]\");\r\n\r\n        if (readonly) {\r\n            if (!readonly_list.includes(path)) {\r\n                readonly_list.push(path);\r\n            }\r\n        } else {\r\n            if (readonly_list.includes(path)) {\r\n                readonly_list.splice(readonly_list.indexOf(path), 1);\r\n            }\r\n        }\r\n\r\n        localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n    }\r\n\r\n    async move_dir_direct(src: string, dest: string, no_overwrite: boolean, move_inside: boolean) {\r\n        // TODO: implement\r\n        return Promise.resolve(undefined);\r\n    }\r\n\r\n    async read_file_direct(path: string, as_uint: boolean) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        // recurse into directories\r\n        let current_handle = root;\r\n        for (let i = 0; i < parts.length - 1; i++) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        let file_handle: FileSystemFileHandle;\r\n        try {\r\n            file_handle = await current_handle.getFileHandle(parts[parts.length - 1]);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        const file = await file_handle.getFile();\r\n        const array_buffer = await file.arrayBuffer();\r\n\r\n        if (as_uint) {\r\n            return new Uint8Array(array_buffer);\r\n        } else {\r\n            const decoder = new TextDecoder();\r\n            return decoder.decode(array_buffer);\r\n        }\r\n    }\r\n\r\n    async write_file_direct(path: string, data: string | Uint8Array) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n        \r\n        // recurse into directories\r\n        let current_handle = root;\r\n        for (let i = 0; i < parts.length - 1; i++) {\r\n            current_handle = await current_handle.getDirectoryHandle(parts[i], { create: true });\r\n        }\r\n\r\n        const file_handle = await current_handle.getFileHandle(parts[parts.length - 1], { create: true });\r\n        const writable = await file_handle.createWritable();\r\n\r\n        const data_to_write = (data instanceof Uint8Array) ? data : new TextEncoder().encode(data);\r\n\r\n        await writable.write(data_to_write.buffer as ArrayBuffer);\r\n        await writable.close();\r\n    }\r\n\r\n    async delete_file_direct(path: string) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        // recurse into directories\r\n        let current_handle = root;\r\n        for (let i = 0; i < parts.length - 1; i++) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        try {\r\n            await current_handle.removeEntry(parts[parts.length - 1]);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        // remove from readonly list if it is there\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        if (readonly_list.includes(path)) {\r\n            readonly_list.splice(readonly_list.indexOf(path), 1);\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n        }\r\n    }\r\n\r\n    async move_file_direct(src: string, dest: string) {\r\n        const root = this.get_root_handle();\r\n        const src_parts = src.split(\"/\").filter(part => part.length > 0);\r\n        const dest_parts = dest.split(\"/\").filter(part => part.length > 0);\r\n\r\n        // get source file handle\r\n        let current_handle = root;\r\n        for (let i = 0; i < src_parts.length - 1; i++) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(src_parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(src);\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        let file_handle: FileSystemFileHandle;\r\n        try {\r\n            file_handle = await current_handle.getFileHandle(src_parts[src_parts.length - 1]);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(src);\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        const file = await file_handle.getFile();\r\n        const array_buffer = await file.arrayBuffer();\r\n\r\n        // write to destination\r\n        current_handle = root;\r\n        for (let i = 0; i < dest_parts.length - 1; i++) {\r\n            current_handle = await current_handle.getDirectoryHandle(dest_parts[i], { create: true });\r\n        }\r\n\r\n        const dest_file_handle = await current_handle.getFileHandle(dest_parts[dest_parts.length - 1], { create: true });\r\n        const writable = await dest_file_handle.createWritable();\r\n        await writable.write(array_buffer);\r\n        await writable.close();\r\n\r\n        // delete source file\r\n        await this.delete_file_direct(src);\r\n    }\r\n\r\n    async erase_all() {\r\n        const root = this.get_root_handle();\r\n\r\n        for await (const [name, handle] of root.entries()) {\r\n            if (handle.kind === \"file\") {\r\n                await root.removeEntry(name);\r\n            } else if (handle.kind === \"directory\") {\r\n                await root.removeEntry(name, { recursive: true });\r\n            }\r\n        }\r\n\r\n        localStorage.removeItem(\"fs_readonly_paths\");\r\n    }\r\n}\r\n\r\n// TODO: emit events\r\n","import { AbstractFileSystem } from \"./filesystem\";\r\nimport { ANSI, NEWLINE } from \"./term_ctl\";\r\n\r\nconst setup_boot = async (fs: AbstractFileSystem) => {\r\n    // create boot directory if it doesn't exist\r\n    const absolute_boot = fs.absolute(\"/boot\");\r\n    if (!(await fs.dir_exists(absolute_boot))) {\r\n        await fs.make_dir(absolute_boot);\r\n    }\r\n\r\n    // create init file if it doesn't exist\r\n    const init_content = \"ignition\";\r\n    const absolute_init = fs.absolute(\"/boot/init\");\r\n    if (!(await fs.exists(absolute_init))) {\r\n        await fs.write_file(absolute_init, init_content);\r\n    }\r\n\r\n    // create etc directory if it doesn't exist\r\n    const absolute_etc = fs.absolute(\"/etc\");\r\n    if (!(await fs.dir_exists(absolute_etc))) {\r\n        await fs.make_dir(absolute_etc);\r\n    }\r\n\r\n    // create boot_target file if it doesn't exist\r\n    const boot_target_content = \"jetty\";\r\n    const absolute_boot_target = fs.absolute(\"/etc/boot_target\");\r\n    if (!(await fs.exists(absolute_boot_target))) {\r\n        await fs.write_file(absolute_boot_target, boot_target_content);\r\n    }\r\n\r\n    // create default_shell file if it doesn't exist\r\n    const default_shell_content = \"ash --login\";\r\n    const absolute_default_shell = fs.absolute(\"/etc/default_shell\");\r\n    if (!(await fs.exists(absolute_default_shell))) {\r\n        await fs.write_file(absolute_default_shell, default_shell_content);\r\n    }\r\n}\r\n\r\nconst setup_motd = async (fs: AbstractFileSystem) => {\r\n    // create etc directory if it doesn't exist\r\n    const absolute_etc = fs.absolute(\"/etc\");\r\n    if (!(await fs.dir_exists(absolute_etc))) {\r\n        await fs.make_dir(absolute_etc);\r\n    }\r\n\r\n    // create motd file if it doesn't exist\r\n    const motd_content = ` Welcome to ${ANSI.STYLE.italic + ANSI.STYLE.bold + ANSI.FG.magenta}OllieOS...${ANSI.STYLE.reset_all} \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}help${ANSI.STYLE.no_italic + ANSI.FG.blue} for a list of commands.${ANSI.STYLE.reset_all}        \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}mefetch${ANSI.STYLE.no_italic + ANSI.FG.blue} for info about me.${ANSI.STYLE.reset_all}          \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}cd projects${ANSI.STYLE.no_italic + ANSI.FG.blue} to view project info.${ANSI.STYLE.reset_all}   \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}bugreport${ANSI.STYLE.no_italic + ANSI.FG.blue} to open the bug reporter.${ANSI.STYLE.reset_all} \r\n`.replace(/\\n/g, NEWLINE);\r\n\r\n    const absolute_motd = fs.absolute(\"/etc/motd.txt\");\r\n    if (!(await fs.exists(absolute_motd))) {\r\n        await fs.write_file(absolute_motd, motd_content);\r\n    }\r\n};\r\n\r\nconst migrate_rc_profile = async (fs: AbstractFileSystem) => {\r\n    // if .ollie_profile exists, and .ash_profile doesn't, rename it to .ash_profile\r\n    const absolute_ollie_profile = fs.absolute(\"~/.ollie_profile\");\r\n    const absolute_ash_profile = fs.absolute(\"~/.ash_profile\");\r\n    if (await fs.exists(absolute_ollie_profile) && !(await fs.exists(absolute_ash_profile))) {\r\n        await fs.move_file(absolute_ollie_profile, absolute_ash_profile);\r\n    }\r\n\r\n    // if .ollierc exists, and .ashrc doesn't, rename it to .ashrc\r\n    const absolute_ollierc = fs.absolute(\"~/.ollierc\");\r\n    const absolute_ashrc = fs.absolute(\"~/.ashrc\");\r\n    if (await fs.exists(absolute_ollierc) && !(await fs.exists(absolute_ashrc))) {\r\n        await fs.move_file(absolute_ollierc, absolute_ashrc);\r\n    }\r\n};\r\n\r\nconst setup_credits = async (fs: AbstractFileSystem) => {\r\n    // create credits file\r\n    const credits_content = `\r\nCredits\r\n=======\r\n\r\nThis website was created by obfuscatedgenerated using the following technologies:\r\n\r\n- TypeScript\r\n- xterm.js\r\n- Handlebars.js\r\n- Webpack\r\n\r\nAs well as the following libraries:\r\n\r\n- imgToAscii (modified)\r\n- node-sixel\r\n- @xterm/addon-fit\r\n- @xterm/addon-web-links\r\n- @xterm/addon-image\r\n- xterm-link-provider\r\n- howler.js\r\n- html-to-text\r\n- some code from rss-parser (modified)\r\n\r\nPlease consult https://ollieg.codes/public/script/3rdpartylicenses.txt for full license information.\r\n\r\nAdditionally, fsedit uses:\r\n\r\n- Font Awesome\r\n\r\nThe source code is available on GitHub at https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io.\r\n`.replace(/\\n/g, NEWLINE);\r\n\r\n    // only overwrite the file if it doesn't exist or the content is different\r\n    const absolute_credits = fs.absolute(\"~/credits.txt\");\r\n    if (!(await fs.exists(absolute_credits)) || await fs.read_file(absolute_credits) !== credits_content) {\r\n        await fs.write_file(absolute_credits, credits_content, true);\r\n        await fs.set_readonly(absolute_credits, true);\r\n    }\r\n};\r\n\r\n// syncs the data repository from the data service (data.ollieg.codes)\r\nconst setup_data_repo = async (fs: AbstractFileSystem) => {\r\n    console.log(\"Syncing data repository...\");\r\n\r\n    // check if data dir exists locally\r\n    const data_dir = fs.absolute(\"/var/lib/data\");\r\n    let existing_rev = \"\";\r\n    if (!(await fs.dir_exists(data_dir))) {\r\n        await fs.make_dir(data_dir);\r\n    } else {\r\n        // read the existing revision from version.json\r\n        const version_file = fs.join(data_dir, \"version.json\");\r\n        if (await fs.exists(version_file)) {\r\n            const version_data = JSON.parse(await fs.read_file(version_file) as string);\r\n            existing_rev = version_data.rev;\r\n        }\r\n    }\r\n\r\n    try {\r\n        // fetch the latest revision from the data service\r\n        const svc_version = await fetch(\"https://data.ollieg.codes/version.json\").then(res => res.json());\r\n        const latest_rev = svc_version.rev;\r\n\r\n        // if the revisions match, no need to update\r\n        if (existing_rev === latest_rev) {\r\n            console.log(\"Data repository is already up to date.\");\r\n            return;\r\n        }\r\n\r\n        // back up existing data folder\r\n        const possible_backup_dir = fs.absolute(`/var/lib/.data.old_${existing_rev}`);\r\n        if (existing_rev) {\r\n            await fs.move_dir(data_dir, possible_backup_dir);\r\n            await fs.make_dir(data_dir);\r\n        }\r\n\r\n        // fetch the index file\r\n        const index = await fetch(\"https://data.ollieg.codes/index.json\").then(res => res.json());\r\n\r\n        // check if the index file has the optional \"groups\" field\r\n        if (!index.groups) {\r\n            throw new Error(\"Index file is missing 'groups' field.\");\r\n        }\r\n\r\n        // write the index and version file to the data folder\r\n        await fs.write_file(fs.join(data_dir, \"index.json\"), JSON.stringify(index, null, 2), true);\r\n        await fs.write_file(fs.join(data_dir, \"version.json\"), JSON.stringify(svc_version, null, 2), true);\r\n\r\n        // for each group, fetch the index and then fetch each file listed in its index\r\n        for (const group of index.groups) {\r\n            console.log(`Syncing data group: ${group}`);\r\n\r\n            // ensure the group directory exists\r\n            const group_dir = fs.join(data_dir, group);\r\n            if (!(await fs.dir_exists(group_dir))) {\r\n                await fs.make_dir(group_dir);\r\n            }\r\n\r\n            // fetch the group index\r\n            const group_index = await fetch(`https://data.ollieg.codes/${group}/index.json`).then(res => res.json());\r\n\r\n            // ensure the group index is an array\r\n            if (!Array.isArray(group_index)) {\r\n                throw new Error(`Group index for ${group} is not an array.`);\r\n            }\r\n\r\n            // write the group index to the group folder\r\n            await fs.write_file(fs.join(group_dir, \"index.json\"), JSON.stringify(group_index, null, 2), true);\r\n\r\n            // for each file in the group index, fetch the file and write it to the data folder\r\n            for (const entry of group_index) {\r\n                console.log(`  Fetching file: ${entry}.json`);\r\n\r\n                const file_data = await fetch(`https://data.ollieg.codes/${group}/${entry}.json`).then(res => res.text());\r\n                const file_path = fs.join(group_dir, `${entry}.json`);\r\n\r\n                await fs.write_file(file_path, file_data, true);\r\n            }\r\n        }\r\n\r\n        console.log(\"Data repository synced successfully.\");\r\n\r\n        // delete backup if exists\r\n        if (await fs.dir_exists(possible_backup_dir)) {\r\n            await fs.delete_dir(possible_backup_dir, true);\r\n        }\r\n\r\n        // return new rev\r\n        return latest_rev;\r\n    } catch (e) {\r\n        console.error(\"Failed to sync data repository:\");\r\n        console.error(e);\r\n\r\n        // restore backup if exists\r\n        const possible_backup_dir = fs.absolute(`/var/lib/.data.old_${existing_rev}`);\r\n        if (await fs.dir_exists(possible_backup_dir)) {\r\n            console.error(\"Restoring backup...\");\r\n            await fs.move_dir(data_dir, fs.absolute(\"/var/lib/data.discard\"));\r\n            await fs.move_dir(possible_backup_dir, data_dir);\r\n            await fs.delete_dir(fs.absolute(\"/var/lib/data.discard\"), true);\r\n        } else {\r\n            // just delete the data dir in progress to prevent partial data\r\n            await fs.delete_dir(data_dir, true);\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nconst fetch_file_with_ttl = async (url: string, skip_cache: boolean) => {\r\n    // check if url exists in TTL cache\r\n    const ttl_cache = localStorage.getItem(\"fetch_ttl_cache\");\r\n    const ttl_cache_obj = ttl_cache ? JSON.parse(ttl_cache) : {};\r\n\r\n    // if the url's TTL hasn't expired, don't fetch the file\r\n    // saves time acquiring heavy files at startup whilst still allowing for updates at some point\r\n    if (!skip_cache && ttl_cache_obj[url]) {\r\n        if (ttl_cache_obj[url] > Date.now()) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // fetch the file and convert it to a Uint8Array\r\n    const response = await fetch(url);\r\n    const array_buffer = await response.arrayBuffer();\r\n\r\n    // add the url to the TTL cache\r\n    ttl_cache_obj[url] = Date.now() + 1000 * 60 * 60 * 24 * 7; // 1 week\r\n    localStorage.setItem(\"fetch_ttl_cache\", JSON.stringify(ttl_cache_obj));\r\n\r\n    return new Uint8Array(array_buffer);\r\n};\r\n\r\nconst generate_project_folder = async (fs: AbstractFileSystem, base_dir: string, data_projects_dir: string, project_entry: string, project_data: any = null): Promise<boolean> => {\r\n    console.log(`Generating project folder for ${project_entry}...`);\r\n\r\n    const project_dir = fs.join(base_dir, project_entry);\r\n    await fs.make_dir(project_dir);\r\n\r\n    // generate info.txt\r\n    const info_content = `\r\n${project_data.name}\r\n=${\"=\".repeat(project_data.name.length)}\r\n\r\n${project_data.primary_language ? `Primary Language: ${project_data.primary_language}\\n\\n` : \"\"}${project_data.description}\r\n${project_data.live_url ? `\\nLive URL: ${project_data.live_url}` : \"\"}${project_data.repo_url ? `\\nRepository: ${project_data.repo_url}` : \"\"}\r\n`.replace(/\\n/g, NEWLINE).trim();\r\n\r\n    await fs.write_file(fs.join(project_dir, \"info.txt\"), NEWLINE + info_content + NEWLINE, true);\r\n\r\n    // download image with ttl if defined\r\n    // not a fatal failure so don't return false on failure\r\n    if (project_data.image) {\r\n        const file_ext_regex = /\\.([a-zA-Z0-9]+)(?:\\?|$)/;\r\n        const match = project_data.image.match(file_ext_regex);\r\n\r\n        // if theres no file extension, default to png bc why not :)\r\n        const image_ext = match ? match[1] : \"png\";\r\n        if (image_ext) {\r\n            const absolute_file = fs.join(project_dir, `image.${image_ext}`);\r\n            let content: Uint8Array | null;\r\n\r\n            try {\r\n                // if the file doesn't exist, skip the TTL cache\r\n                const skip_cache = !(await fs.exists(absolute_file));\r\n\r\n                // fetch the file if TTL cache is expired or doesn't exist\r\n                content = await fetch_file_with_ttl(project_data.image, skip_cache);\r\n\r\n                // write the file if content is not null\r\n                if (content) {\r\n                    await fs.write_file(absolute_file, content, true);\r\n                }\r\n            } catch (e) {\r\n                console.error(`Failed to fetch image for project ${project_entry}:`);\r\n                console.error(e);\r\n            }\r\n        } else {\r\n            console.warn(`Project image for ${project_entry} has unsupported file extension; skipping image.`);\r\n        }\r\n    }\r\n\r\n    console.log(`Project folder for ${project_entry} generated successfully.`);\r\n\r\n    // recurse for sub_projects\r\n    if (project_data.sub_projects && Array.isArray(project_data.sub_projects)) {\r\n        for (const sub_project_entry of project_data.sub_projects) {\r\n            const success = await generate_project_folder(fs, project_dir, data_projects_dir, sub_project_entry.name, sub_project_entry);\r\n            if (!success) {\r\n                console.error(`Failed to generate sub-project folder for ${sub_project_entry}`);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nconst setup_projects = async (fs: AbstractFileSystem, data_rev: string | null) => {\r\n    // if data_rev is null, try read it from the data repo\r\n    if (!data_rev) {\r\n        try {\r\n            const version_file = fs.absolute(\"/var/lib/data/version.json\");\r\n            if (await fs.exists(version_file)) {\r\n                const version_data = JSON.parse(await fs.read_file(version_file) as string);\r\n                data_rev = version_data.rev;\r\n            } else {\r\n                throw new Error(\"Version file does not exist.\");\r\n            }\r\n        } catch (e) {\r\n            console.error(\"Failed to read data revision from data repository:\");\r\n            console.error(e);\r\n            data_rev = null;\r\n        }\r\n    }\r\n\r\n    // if data rev is still null, skip project setup\r\n    if (!data_rev) {\r\n        console.warn(\"Data repo not synced; skipping project setup.\");\r\n        return;\r\n    }\r\n\r\n    // create projects directory if it doesn't exist\r\n    const absolute_projects = fs.absolute(\"~/projects\");\r\n    let project_rev = \"\";\r\n    if (!(await fs.dir_exists(absolute_projects))) {\r\n        await fs.make_dir(absolute_projects);\r\n    } else {\r\n        // read the existing revision from the hidden .rev file\r\n        const version_file = fs.join(absolute_projects, \".rev\");\r\n        if (await fs.exists(version_file)) {\r\n            project_rev = await fs.read_file(version_file) as string;\r\n        }\r\n    }\r\n\r\n    // if the revisions match, no need to update\r\n    if (project_rev === data_rev) {\r\n        console.log(\"Projects are already up to date.\");\r\n        return;\r\n    }\r\n\r\n    // back up existing projects folder\r\n    const possible_backup_dir = fs.absolute(`~/.projects.old_${project_rev}`);\r\n    if (project_rev) {\r\n        await fs.move_dir(absolute_projects, possible_backup_dir);\r\n        await fs.make_dir(absolute_projects);\r\n    }\r\n\r\n    try {\r\n        // for each project in the data repo, convert the json to the file structure in the projects folder\r\n        const data_projects_dir = fs.absolute(\"/var/lib/data/project\");\r\n        const project_index_file = fs.join(data_projects_dir, \"index.json\");\r\n\r\n        if (!(await fs.exists(project_index_file))) {\r\n            throw new Error(\"Project index file does not exist in data repository.\");\r\n        }\r\n\r\n        const projects = JSON.parse(await fs.read_file(project_index_file) as string);\r\n        if (!Array.isArray(projects)) {\r\n            throw new Error(\"Project index file is not an array.\");\r\n        }\r\n\r\n        for (const project_entry of projects) {\r\n            console.log(`Setting up project: ${project_entry}`);\r\n\r\n            const project_file = fs.join(data_projects_dir, `${project_entry}.json`);\r\n            if (!(await fs.exists(project_file))) {\r\n                console.warn(`Project file for ${project_entry} does not exist; skipping.`);\r\n                return false;\r\n            }\r\n\r\n            const project_data = JSON.parse(await fs.read_file(project_file) as string);\r\n\r\n            const success = await generate_project_folder(fs, absolute_projects, data_projects_dir, project_entry, project_data);\r\n            if (!success) {\r\n                // TODO: is it better to still keep partial data or throw an error?\r\n                throw new Error(`Failed to generate project folder for ${project_entry}`);\r\n            }\r\n        }\r\n\r\n        // write the new revision to the hidden .rev file\r\n        const version_file = fs.join(absolute_projects, \".rev\");\r\n        await fs.write_file(version_file, data_rev, true);\r\n\r\n        console.log(\"Projects set up successfully.\");\r\n    } catch (e) {\r\n        console.error(\"Failed to set up projects:\");\r\n        console.error(e);\r\n\r\n        // restore backup if exists\r\n        if (await fs.dir_exists(possible_backup_dir)) {\r\n            console.error(\"Restoring backup...\");\r\n            await fs.move_dir(absolute_projects, fs.absolute(\"~/projects.discard\"));\r\n            await fs.move_dir(possible_backup_dir, absolute_projects);\r\n            await fs.delete_dir(fs.absolute(\"~/projects.discard\"), true);\r\n        } else {\r\n            // just delete the projects dir in progress to prevent partial data\r\n            await fs.delete_dir(absolute_projects, true);\r\n        }\r\n\r\n        return;\r\n    }\r\n};\r\n\r\nexport const initial_fs_setup = async (fs: AbstractFileSystem) => {\r\n    await setup_boot(fs);\r\n    await setup_motd(fs);\r\n    await migrate_rc_profile(fs);\r\n    await setup_credits(fs);\r\n\r\n\r\n    const latest_rev = await setup_data_repo(fs);\r\n    await setup_projects(fs, latest_rev);\r\n};\r\n","export type WindowEvent = \"close\" | \"hide\" | \"show\" | \"focus\" | \"move\" | \"rename\" | \"resize\" | \"maximise\" | \"restore\";\r\n\r\nexport abstract class AbstractWindow {\r\n    abstract readonly id: number;\r\n\r\n    // TODO: more generic type somehow? depends if we ever need implementations that dont use shadow DOM\r\n    abstract readonly dom: ShadowRoot;\r\n\r\n    abstract readonly manager: AbstractWindowManager;\r\n\r\n    abstract moveable: boolean;\r\n\r\n    abstract resizable: boolean;\r\n\r\n    abstract maximisable: boolean;\r\n    abstract maximised: boolean;\r\n\r\n    private readonly _owner_pid: number;\r\n\r\n    protected constructor(owner_pid: number) {\r\n        this._owner_pid = owner_pid;\r\n    }\r\n\r\n    get owner_pid(): number {\r\n        return this._owner_pid;\r\n    }\r\n\r\n    abstract get title(): string;\r\n    abstract set title(new_title: string);\r\n\r\n    abstract get width(): string;\r\n    abstract set width(css_width: string);\r\n\r\n    abstract get height(): string;\r\n    abstract set height(css_height: string);\r\n\r\n    // number to be interpreted as pixels\r\n    abstract get x(): string | number;\r\n    abstract set x(css_pos: string | number);\r\n\r\n    // number to be interpreted as pixels\r\n    abstract get y(): string | number;\r\n    abstract set y(css_pos: string | number);\r\n\r\n    abstract center(): void;\r\n\r\n    abstract get visible(): boolean;\r\n    abstract set visible(is_visible: boolean);\r\n\r\n    abstract add_event_listener(event: WindowEvent, callback: () => Promise<void> | void): void;\r\n\r\n    abstract remove_event_listener(event: WindowEvent, callback: () => Promise<void> | void): void;\r\n\r\n    abstract dispose(): void;\r\n\r\n    abstract close(): void;\r\n\r\n    abstract focus(): void;\r\n\r\n    abstract show(): void;\r\n    abstract hide(): void;\r\n    abstract toggle(): void;\r\n\r\n    // best effort flags, may not be supported by all implementations (e.g. transparent flag)\r\n    abstract get_custom_flag(flag: string): boolean;\r\n    abstract set_custom_flag(flag: string, value: boolean): void;\r\n\r\n    abstract wait_for_event(event: WindowEvent): Promise<void>;\r\n}\r\n\r\nexport abstract class AbstractWindowManager {\r\n    abstract get_unique_manager_type_name(): string;\r\n\r\n    abstract get Window(): new (owner_pid: number) => AbstractWindow;\r\n\r\n    abstract get_all_windows(): AbstractWindow[];\r\n\r\n    abstract get_window_by_id(id: number): AbstractWindow | null;\r\n\r\n    abstract dispose_all(): void;\r\n}\r\n\r\n// TODO: use separate interfaces so that only the process registry can create windows\r\n","import {AbstractWindow, AbstractWindowManager, WindowEvent} from \"../windowing\";\r\n\r\nexport class DOMWindowManager extends AbstractWindowManager {\r\n    private top_z_index = 10;\r\n\r\n    private _window_id_counter = 1;\r\n    private _window_map: Map<number, AbstractWindow> = new Map();\r\n\r\n    private readonly _WindowClass: new (owner_pid: number) => AbstractWindow;\r\n\r\n    get_unique_manager_type_name(): string {\r\n        return \"DOM\";\r\n    }\r\n\r\n    get Window() {\r\n        return this._WindowClass;\r\n    }\r\n\r\n    get_all_windows = () => {\r\n        return Array.from(this._window_map.values());\r\n    }\r\n\r\n    get_window_by_id = (id: number) => {\r\n        return this._window_map.get(id) || null;\r\n    }\r\n\r\n    dispose_all() {\r\n        for (const window of this._window_map.values()) {\r\n            window.dispose();\r\n        }\r\n\r\n        this._window_map.clear();\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const manager = this;\r\n\r\n        class DOMWindow extends AbstractWindow {\r\n            private readonly _manager = manager;\r\n\r\n            private readonly _window_id: number;\r\n\r\n            private readonly _window_root: HTMLDivElement;\r\n            private readonly _window_top_bar: HTMLDivElement;\r\n            private readonly _window_top_bar_title: HTMLSpanElement;\r\n            private readonly _window_top_bar_maximise_button: HTMLButtonElement;\r\n\r\n            private readonly _content_host: HTMLDivElement;\r\n            private readonly _shadow_dom: ShadowRoot;\r\n\r\n            private readonly _event_listeners: Map<WindowEvent, Array<() => Promise<void>>> = new Map();\r\n\r\n            private _title_text = \"New Window\";\r\n\r\n            moveable = true;\r\n            resizable = true;\r\n\r\n            private _maximisable = true;\r\n            private _maximised = false;\r\n\r\n            private readonly _custom_flags: Set<string> = new Set();\r\n\r\n            get manager() {\r\n                return this._manager;\r\n            }\r\n\r\n            constructor(owner_pid: number) {\r\n                super(owner_pid);\r\n\r\n                this._window_id = manager._window_id_counter++;\r\n\r\n                // contains the entire window\r\n                this._window_root = document.createElement(\"div\");\r\n                this._window_root.classList.add(\"window\");\r\n                this._window_root.role = \"dialog\";\r\n                this._window_root.ariaHidden = \"true\";\r\n                this._window_root.id = `window-${this._window_id}`;\r\n                document.body.appendChild(this._window_root);\r\n\r\n                this._window_root.style.zIndex = manager.top_z_index.toString();\r\n                this._window_root.addEventListener(\"mousedown\", () => this.focus(), { capture: true });\r\n                window.addEventListener(\"blur\", () => this._handle_window_blur());\r\n\r\n                // draggable top bar containing title and controls\r\n                this._window_top_bar = document.createElement(\"div\");\r\n                this._window_top_bar.classList.add(\"window-top-bar\");\r\n                this._window_root.appendChild(this._window_top_bar);\r\n\r\n                this._window_top_bar_title = document.createElement(\"span\");\r\n                this._window_top_bar_title.classList.add(\"window-top-bar-title\");\r\n                this._window_top_bar_title.innerText = this._title_text;\r\n                this._window_top_bar_title.id = `${this._window_root.id}-title`;\r\n                this._window_top_bar.appendChild(this._window_top_bar_title);\r\n                this._window_root.setAttribute(\"aria-labelledby\", this._window_top_bar_title.id);\r\n\r\n                const top_bar_controls = document.createElement(\"div\");\r\n                top_bar_controls.classList.add(\"window-top-bar-controls\");\r\n                top_bar_controls.addEventListener(\"mousedown\", (e) => e.stopPropagation());\r\n                this._window_top_bar.appendChild(top_bar_controls);\r\n\r\n                const minimise_button = document.createElement(\"button\");\r\n                minimise_button.title = \"Minimise window\";\r\n                minimise_button.classList.add(\"window-button\", \"window-minimise-button\");\r\n                minimise_button.innerText = \"\";\r\n                minimise_button.addEventListener(\"click\", () => this.hide());\r\n\r\n                this._window_top_bar_maximise_button = document.createElement(\"button\");\r\n                this._window_top_bar_maximise_button.title = \"Maximise window\";\r\n                this._window_top_bar_maximise_button.classList.add(\"window-button\", \"window-maximise-button\");\r\n                this._window_top_bar_maximise_button.innerText = \"\";\r\n                this._window_top_bar_maximise_button.addEventListener(\"click\", (ev) => {\r\n                    if (!this.maximisable) {\r\n                        return;\r\n                    }\r\n\r\n                    this.maximised = !this.maximised;\r\n                });\r\n\r\n                const close_button = document.createElement(\"button\");\r\n                close_button.title = \"Close window\";\r\n                close_button.classList.add(\"window-button\", \"window-close-button\");\r\n                close_button.innerText = \"\";\r\n                close_button.addEventListener(\"click\", this.close.bind(this));\r\n\r\n                top_bar_controls.appendChild(minimise_button);\r\n                top_bar_controls.appendChild(this._window_top_bar_maximise_button);\r\n                top_bar_controls.appendChild(close_button);\r\n\r\n                this._window_top_bar.addEventListener(\"mousedown\", (e) => this._start_drag(e));\r\n\r\n                // hosts the shadow dom where programs can add their content\r\n                this._content_host = document.createElement(\"div\");\r\n                this._content_host.classList.add(\"window-content-host\");\r\n\r\n                this._shadow_dom = this._content_host.attachShadow({ mode: \"closed\" });\r\n\r\n                this._window_root.appendChild(this._content_host);\r\n\r\n                // TODO: resize handles\r\n                // TODO: way to prevent windows existing when the program that created them exits? or is that not needed? theyll have to run background tasks to allow multitasking anyway\r\n\r\n                manager._window_map.set(this._window_id, this);\r\n            }\r\n\r\n            get id() {\r\n                return this._window_id;\r\n            }\r\n\r\n            dispose() {\r\n                this._window_root.remove();\r\n                manager._window_map.delete(this._window_id);\r\n            }\r\n\r\n            close() {\r\n                this._window_root.classList.add(\"animating-close\");\r\n                this._window_root.ariaHidden = \"true\";\r\n\r\n                this._emit_event(\"close\");\r\n\r\n                setTimeout(() => {\r\n                    this.dispose();\r\n                }, 200);\r\n            }\r\n\r\n            focus() {\r\n                this._emit_event(\"focus\");\r\n\r\n                manager.top_z_index += 1;\r\n                this._window_root.style.zIndex = manager.top_z_index.toString();\r\n            }\r\n\r\n            private _handle_window_blur() {\r\n                // TODO: fix for when focus jumps between iframes inside the window, this doesnt fire in that case\r\n\r\n                setTimeout(() => {\r\n                    if (document.activeElement === this._content_host) {\r\n                        this.focus();\r\n                    }\r\n                }, 0);\r\n            }\r\n\r\n            private async _emit_event(event: WindowEvent) {\r\n                if (!this._event_listeners.has(event)) {\r\n                    return;\r\n                }\r\n\r\n                const listeners = this._event_listeners.get(event)!;\r\n                await Promise.all(listeners.map(callback => callback()));\r\n            }\r\n\r\n            private _start_drag(start_event: MouseEvent) {\r\n                if (!this.moveable) {\r\n                    return;\r\n                }\r\n\r\n                this._content_host.classList.add(\"dragging\");\r\n\r\n                start_event.preventDefault();\r\n\r\n                const rect = this._window_root.getBoundingClientRect();\r\n                let offset_x = start_event.clientX - rect.left;\r\n                const offset_y = start_event.clientY - rect.top;\r\n\r\n                const mouse_move = (move_event: MouseEvent) => {\r\n                    move_event.preventDefault();\r\n\r\n                    if (this._maximised) {\r\n                        // break out of maximised, restoring size but not position\r\n                        this.maximised = false;\r\n\r\n                        // adjust offset_x to account for new window size\r\n                        const new_rect = this._window_root.getBoundingClientRect();\r\n                        const width_ratio = offset_x / rect.width;\r\n                        offset_x = new_rect.width * width_ratio;\r\n                    }\r\n\r\n                    this._window_root.style.left = `${move_event.clientX - offset_x}px`;\r\n                    this._window_root.style.top = `${move_event.clientY - offset_y}px`;\r\n\r\n                    this._emit_event(\"move\");\r\n                };\r\n\r\n                const mouse_up = (up_event: MouseEvent) => {\r\n                    document.removeEventListener(\"mousemove\", mouse_move);\r\n                    document.removeEventListener(\"mouseup\", mouse_up);\r\n\r\n                    this._content_host.classList.remove(\"dragging\");\r\n\r\n                    if (!this._maximised) {\r\n                        // if the mouse is at the top of the screen, maximise the window\r\n                        if (up_event.clientY <= 0 && this._maximisable) {\r\n                            this.maximised = true;\r\n                        }\r\n                    }\r\n\r\n                    // TODO: right and left side snapping to half the screen\r\n\r\n                    // if the rect is out of the top when released, snap it back in\r\n                    if (this._window_root.getBoundingClientRect().top < 0) {\r\n                        this._window_root.style.top = \"0px\";\r\n                    }\r\n                };\r\n\r\n                document.addEventListener(\"mousemove\", mouse_move);\r\n                document.addEventListener(\"mouseup\", mouse_up);\r\n            }\r\n\r\n            add_event_listener(event: WindowEvent, callback: () => Promise<void>) {\r\n                if (!this._event_listeners.has(event)) {\r\n                    this._event_listeners.set(event, []);\r\n                }\r\n\r\n                this._event_listeners.get(event)!.push(callback);\r\n            }\r\n\r\n            remove_event_listener(event: WindowEvent, callback: () => Promise<void>) {\r\n                if (!this._event_listeners.has(event)) {\r\n                    return;\r\n                }\r\n\r\n                const listeners = this._event_listeners.get(event)!;\r\n                const index = listeners.indexOf(callback);\r\n                if (index !== -1) {\r\n                    listeners.splice(index, 1);\r\n                }\r\n            }\r\n\r\n            get title() {\r\n                return this._title_text;\r\n            }\r\n\r\n            set title(new_title: string) {\r\n                this._window_top_bar_title.innerText = new_title;\r\n                this._title_text = new_title;\r\n\r\n                this._emit_event(\"rename\");\r\n            }\r\n\r\n            get width() {\r\n                return this._window_root.style.width;\r\n            }\r\n\r\n            set width(css_width: string) {\r\n                this._window_root.style.width = css_width;\r\n            }\r\n\r\n            get height() {\r\n                return this._window_root.style.height;\r\n            }\r\n\r\n            set height(css_height: string) {\r\n                this._window_root.style.height = css_height;\r\n            }\r\n\r\n            get maximisable() {\r\n                return this._maximisable;\r\n            }\r\n\r\n            set maximisable(value: boolean) {\r\n                this._maximisable = value;\r\n                this._window_top_bar_maximise_button.disabled = !value;\r\n            }\r\n\r\n            get maximised() {\r\n                return this._maximised;\r\n            }\r\n\r\n            set maximised(value: boolean) {\r\n                this._maximised = value;\r\n                this._window_root.classList.toggle(\"maximised\", value);\r\n\r\n                if (value) {\r\n                    this._window_top_bar_maximise_button.innerText = \"\";\r\n                    this._window_top_bar_maximise_button.title = \"Restore window\";\r\n\r\n                    this._emit_event(\"maximise\");\r\n                } else {\r\n                    this._window_top_bar_maximise_button.innerText = \"\";\r\n                    this._window_top_bar_maximise_button.title = \"Maximise window\";\r\n\r\n                    this._emit_event(\"restore\");\r\n                }\r\n            }\r\n\r\n            get x() {\r\n                return this._window_root.style.left;\r\n            }\r\n\r\n            set x(css_pos: string | number) {\r\n                if (typeof css_pos === \"number\") {\r\n                    css_pos = `${css_pos}px`;\r\n                }\r\n\r\n                this._window_root.style.left = css_pos;\r\n            }\r\n\r\n            get y() {\r\n                return this._window_root.style.top;\r\n            }\r\n\r\n            set y(css_pos: string | number) {\r\n                if (typeof css_pos === \"number\") {\r\n                    css_pos = `${css_pos}px`;\r\n                }\r\n\r\n                this._window_root.style.top = css_pos;\r\n            }\r\n\r\n            center() {\r\n                this.x = `calc(calc(100vw - ${this.width}) / 2)`;\r\n                this.y = `calc(calc(100vh - ${this.height}) / 2)`;\r\n            }\r\n\r\n            get dom() {\r\n                return this._shadow_dom;\r\n            }\r\n\r\n            show() {\r\n                this._window_root.classList.remove(\"animating-out\");\r\n                this._window_root.classList.add(\"visible\", \"animating-in\");\r\n                this._window_root.ariaHidden = \"false\";\r\n\r\n                setTimeout(() => {\r\n                    this._window_root.classList.remove(\"animating-in\");\r\n                }, 200);\r\n\r\n                this._emit_event(\"show\");\r\n            }\r\n\r\n            hide() {\r\n                this._window_root.classList.remove(\"animating-in\");\r\n                this._window_root.classList.add(\"animating-out\");\r\n                this._window_root.ariaHidden = \"true\";\r\n\r\n                setTimeout(() => {\r\n                    this._window_root.classList.remove(\"visible\", \"animating-out\");\r\n                }, 200);\r\n\r\n                this._emit_event(\"hide\");\r\n            }\r\n\r\n            toggle() {\r\n                this._window_root.classList.toggle(\"visible\");\r\n\r\n                if (this.visible) {\r\n                    this._emit_event(\"show\");\r\n                } else {\r\n                    this._emit_event(\"hide\");\r\n                }\r\n            }\r\n\r\n            get visible() {\r\n                return this._window_root.classList.contains(\"visible\");\r\n            }\r\n\r\n            set visible(is_visible: boolean) {\r\n                if (is_visible) {\r\n                    this.show();\r\n                } else {\r\n                    this.hide();\r\n                }\r\n            }\r\n\r\n            get_custom_flag(flag: string) {\r\n                return this._custom_flags.has(flag);\r\n            }\r\n\r\n            set_custom_flag(flag: string, value: boolean) {\r\n                if (value) {\r\n                    this._custom_flags.add(flag);\r\n                } else {\r\n                    this._custom_flags.delete(flag);\r\n                }\r\n\r\n                switch (flag) {\r\n                    case \"transparent\":\r\n                        if (value) {\r\n                            this._content_host.classList.add(\"transparent\");\r\n                        } else {\r\n                            this._content_host.classList.remove(\"transparent\");\r\n                        }\r\n                        break;\r\n                    case \"no-top-bar\":\r\n                        if (value) {\r\n                            this._window_top_bar.classList.add(\"hidden\");\r\n                        } else {\r\n                            this._window_top_bar.classList.remove(\"hidden\");\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n\r\n            wait_for_event(event: WindowEvent): Promise<void> {\r\n                return new Promise((resolve) => {\r\n                    const callback = async () => {\r\n                        this.remove_event_listener(event, callback);\r\n                        resolve();\r\n                    };\r\n\r\n                    this.add_event_listener(event, callback);\r\n                });\r\n            }\r\n        }\r\n\r\n        this._WindowClass = DOMWindow;\r\n    }\r\n}\r\n","// provides expected externals of pkgbuild programs into global\r\n\r\nimport * as howler from \"howler\";\r\nimport * as htmlToText from \"html-to-text\";\r\nimport * as sixel from \"sixel\";\r\nimport * as xterm from \"@xterm/xterm\";\r\n\r\nglobalThis.ollieos = {};\r\nglobalThis.howler = howler;\r\nglobalThis[\"html-to-text\"] = htmlToText;\r\nglobalThis.sixel = sixel;\r\nglobalThis[\"@xterm/xterm\"] = xterm;\r\n\r\n// support old xterm names\r\nglobalThis[\"xterm\"] = xterm;\r\n\r\nif (typeof window !== \"undefined\") {\r\n    console.log(\"Loading browser-specific global externals...\");\r\n\r\n    (async() => {\r\n        const fitAddon = await import(\"@xterm/addon-fit\");\r\n        const webLinksAddon = await import(\"@xterm/addon-web-links\");\r\n        const imageAddon = await import(\"@xterm/addon-image\");\r\n        const xtermLinkProvider = await import(\"xterm-link-provider\");\r\n\r\n        const sweetalert2 = await import(\"sweetalert2\");\r\n\r\n        globalThis[\"@xterm/addon-fit\"] = fitAddon;\r\n        globalThis[\"@xterm/addon-web-links\"] = webLinksAddon;\r\n        globalThis[\"@xterm/addon-image\"] = imageAddon;\r\n        globalThis[\"xterm-link-provider\"] = xtermLinkProvider;\r\n\r\n        globalThis.sweetalert2 = sweetalert2;\r\n\r\n        globalThis[\"xterm-addon-fit\"] = fitAddon;\r\n        globalThis[\"xterm-addon-web-links\"] = webLinksAddon;\r\n        globalThis[\"xterm-addon-image\"] = imageAddon;\r\n\r\n        console.log(\"Browser-specific global externals loaded successfully.\");\r\n    })();\r\n}\r\n","import { FitAddon } from \"@xterm/addon-fit\";\r\nimport { WebLinksAddon } from \"@xterm/addon-web-links\";\r\nimport { ImageAddon } from \"@xterm/addon-image\";\r\n\r\nimport {ANSI, NEWLINE, WrappedTerminal} from \"./term_ctl\";\r\n\r\nimport {Kernel} from \"./kernel\";\r\n\r\nimport {ProgramRegistry} from \"./prog_registry\";\r\nimport * as programs from \"./programs/@ALL\";\r\n\r\nimport { SoundRegistry } from \"./sfx_registry\";\r\n\r\nimport type {AbstractFileSystem} from \"./filesystem\";\r\nimport { LocalStorageFS } from \"./fs_impl/localstorage\";\r\nimport { OPFSFileSystem } from \"./fs_impl/opfs\";\r\nimport { initial_fs_setup } from \"./initial_fs_setup\";\r\n\r\nimport {DOMWindowManager} from \"./window_impl/dom\";\r\n\r\nimport \"./load_global_externals\";\r\n\r\nexport const boot_os = async (on_init_spawned?: (kernel: Kernel) => Promise<void>) => {\r\n    // create a program registry by importing all programs\r\n    const prog_reg = new ProgramRegistry();\r\n    for (const prog of Object.values(programs)) {\r\n        prog_reg.registerProgram({\r\n            program: prog,\r\n            built_in: true,\r\n        });\r\n    }\r\n\r\n\r\n    // create a sound registry\r\n    const sfx_reg = new SoundRegistry();\r\n    sfx_reg.register_file(\"reader_on\", \"public/sfx/reader_on.mp3\");\r\n    sfx_reg.register_file(\"reader_off\", \"public/sfx/reader_off.mp3\");\r\n\r\n\r\n    // create a filesystem\r\n    // try opfs but use localstorage if not available, or already in use\r\n    // TODO migrate from localstorage to opfs automatically\r\n    let fs: AbstractFileSystem;\r\n    if (!localStorage.getItem(\"fs\") && navigator.storage && \"getDirectory\" in navigator.storage) {\r\n        fs = new OPFSFileSystem();\r\n    } else {\r\n        fs = new LocalStorageFS();\r\n    }\r\n\r\n    if (!(await fs.is_ready())) {\r\n        // poll every 10ms until ready\r\n        await new Promise<void>((resolve) => {\r\n            const interval = setInterval(async () => {\r\n                if (await fs.is_ready()) {\r\n                    clearInterval(interval);\r\n                    resolve();\r\n                }\r\n            }, 10);\r\n        });\r\n    }\r\n\r\n    // create initial files\r\n    await initial_fs_setup(fs);\r\n\r\n    // create a dom window manager\r\n    const wm = new DOMWindowManager();\r\n\r\n    // create a terminal using the registry and filesystem\r\n    const term = new WrappedTerminal({\r\n        screenReaderMode: false,\r\n        cursorBlink: true,\r\n    });\r\n\r\n    // load addons\r\n    const fit = new FitAddon();\r\n    term.loadAddon(fit);\r\n\r\n    term.loadAddon(new WebLinksAddon());\r\n\r\n    term.loadAddon(new ImageAddon());\r\n\r\n\r\n    // open the terminal\r\n    const render = <HTMLElement>document.querySelector(\"#terminal\");\r\n    term.open(render);\r\n    fit.fit();\r\n\r\n\r\n    // if this is a small screen, show a message\r\n    if (window.innerWidth < 600) {\r\n        const wrapped = term.word_wrap(`${ANSI.BG.red + ANSI.FG.white}Warning: The screen that the terminal is running on is rather small!${NEWLINE + NEWLINE}Some programs may not display correctly, consider using a larger screen such as a computer or tablet.${NEWLINE + NEWLINE}An alternative interface is in the works. You can also use the command \"legacy\" to view the old (outdated) site.${ANSI.STYLE.reset_all}`, term.cols);\r\n        term.writeln(wrapped);\r\n    }\r\n\r\n\r\n    // disable F1 help\r\n    window.addEventListener(\"keydown\", function (e) {\r\n        if (e.code === \"F1\") {\r\n            e.preventDefault();\r\n        }\r\n    });\r\n\r\n\r\n    // on resize, resize the terminal\r\n    window.addEventListener(\"resize\", () => {\r\n        fit.fit();\r\n    });\r\n\r\n\r\n    // bind right click to copy/paste\r\n    window.addEventListener(\"contextmenu\", (e) => {\r\n        e.preventDefault();\r\n        term.copy_or_paste();\r\n    });\r\n\r\n    // create the kernel\r\n    const kernel = new Kernel(term, fs, prog_reg, sfx_reg, wm);\r\n    kernel.set_env_info(document.body.dataset.version, \"web\");\r\n\r\n    // boot the kernel and check for a false return (indicating boot failure). should probably never return true as the os should hopefully always run!\r\n    return await kernel.boot(on_init_spawned);\r\n}\r\n"],"names":["NEWLINE","NON_PRINTABLE_REGEX","ANSI_ESCAPE_REGEX","ANSI_UNESCAPED_REGEX","FG","reset","black","red","green","yellow","blue","magenta","cyan","white","gray","STYLE","reset_all","bold","dim","no_bold_or_dim","italic","no_italic","underline","double_underline","no_underline","inverse","no_inverse","hidden","no_hidden","strikethrough","no_strikethrough","negative","positive","CURSOR","invisible","visible","ANSI","BG","PREFABS","program_name","error","variable_name","file_path","dir_name","secret","WrappedTerminal","Terminal","ansi","newline","non_printable_regex","ansi_escape_regex","ansi_unescaped_regex","word_wrap","text","width","lines","split","wrapped_lines","line","words","current_line","word","length","push","join","copy","navigator","clipboard","writeText","this","getSelection","then","clearSelection","paste","_kernel_has_panicked","readText","char","dom_event_code","toUpperCase","key","_key_event_queue","domEvent","code","_is_handling_key_events","_handle_key_event_queue","copy_or_paste","hasSelection","constructor","xterm_opts","super","_key_handlers","Map","_on_printable_handlers","read_line","async","custom_key_handlers","custom_printable_handler","buffer","current_index","set_current_line","new_line","set_current_index","new_index","handler_dispose","Promise","resolve","handlers","_e","term","write","before","slice","after","repeat","register_key_event_handler","e","match","before_cursor","after_cursor","console","warn","block","high_priority","_search_handlers","domEventCode","strict","pair","entries","identfier","handler","props","identifier","keyString","entry","existing_entries","set","unshift","get","splice","indexOf","delete","_handle_key_event","all_key_entries","undefined","register_on_printable_key_event_handler","_enqueue_key_event","shift","wait_for_keypress","_disposable_onkey","dispose","onKey","get_text","max_length","unregister_handler","handle_kernel_panic","message","process_info","debug_info","textarea","disabled","writeln","Date","toISOString","window","location","origin","build_registrant_from_js","js_code","built_in","warn_deprecation","startsWith","data_url","encodeURIComponent","encode_js_to_url","program","import","default","Error","name","globalThis","OLLIEOS_NODE","node_opt_out","description","usage_suffix","arg_descriptions","main","async_main","old_main","data","determine_program_name_from_js","mount_and_register_with_output","filename","content","prog_reg","output_success","reg","endsWith","registerProgram","recurse_mount_and_register_with_output","fs","dir_path","prog_registry","list_dir","entry_path","dir_exists","read_file","ProgramRegistry","_program_regs","program_reg","has","getProgramRegistrant","getProgram","listProgramRegistrants","includes_builtin","includes_mounted","arr","Array","from","values","filter","listProgramNames","keys","listPrograms","map","forceUnregister","unregister","ProcessAttachment","SoundRegistry","_registry","register_howl","howl","ready","register_file","file","Howl","src","onload","await_ready","interval","reject","timer","setInterval","clearInterval","play","is_ready","wait_to_play","log","IPCManager","process_manager","_services","_channels","_next_channel_id","_process_manager","service","get_process","pid","channel_id","channel","initiator_process","initiator","peer_process","peer","dispose_all","clear","service_register","on_connection","service_unregister","service_lookup","create_channel","initiator_pid","service_name","peer_pid","initiator_to_peer_queue","peer_to_initiator_queue","listeners","catch","err","destroy_channel","channel_listen","listening_pid","listener","Set","add","channel_unlisten","channel_send","from_pid","msg","to","to_pid","ProcessContext","source_command","registry","_created_at","_exit_listeners","_attachment","FOREGROUND","_detach_silently","_timeouts","_timeout_promises","_timeout_cancel_callbacks","_intervals","_windows","_pid","_source_command","_manager","run_in_bg","BACKGROUND","created_at","is_detached","DETACHED","is_background","is_foreground","attachment","detaches_silently","detach","silently","dispose_resources","forEach","id","clearTimeout","win","kill","exit_code","mark_terminated","add_exit_listener","create_timeout","callback","delay","on_cancel","setTimeout","resolvers","cancel_timeout","cancel_callback","has_timeout","create_interval","has_interval","clear_interval","wait_for_timeout","create_window","wm","window_manager","Window","add_event_listener","ProcessManager","_processes","_next_pid","_ipc_manager","_wm","ipc_manager","process","create_process","context","list_pids","Kernel","panicked","_panicked","get_program_registry","_prog_registry","get_sound_registry","_sfx_registry","get_fs","_fs","get_window_manager","has_window_manager","get_process_manager","get_ipc","get_env_info","_env_info","set_env_info","version","env","panic","proc_mgr","pids","proc","command","trimEnd","_term","boot","on_init_spawned","usr_bin","absolute","init_program","exists","init_args","trim","init_parts","init","spawn","completion","toString","sound_registry","args","shell","original_line_parse","compat","parsed_line","type","unsubbed_args","raw_parts","kernel","result_promise","SERVICES_DIR","CLEAN_EXIT_CODES","ServiceManager","_service_files","_running_services","_should_be_running_services","_failed_services","_kernel","load_service_files","service_files","file_name","file_content","service_data","JSON","parse","service_id","substring","existing_service_id","includes","_calculate_service_start_order","visited","temp_mark","result","visit","dependencies","dep","start_initial_services","start_order","start_service","spawn_result","exec","_handle_service_exit","stop_service","restart_service","get_service_status","state","restart_policy","restart","on","delay_ms","hide_from_help","boot_target","boot_args","boot_target_parts","svc_mgr","ipc","payload","service_msg","action","status","current_tty_process","running","final_code","boot_target_proc","default_shell","default_shell_args","default_shell_parts","current_shell_process","shell_proc","AshMemory","_history","_current_history_index","_vars","_aliases","clear_history","get_previous_history_entry","get_next_history_entry","add_history_entry","list_variables","get_variable","set_variable","value","unset_variable","list_aliases","get_alias","set_alias","unset_alias","VAR_ASSIGNMENT_REGEX","parse_line","memory","sub","i","part","alias_value","alias_parts","pop","skip_variable_sub_idxs","arg","var_name","var_value","arg_idx","replace","var1","var2","AshShell","_memory","_prompt_suffix","_discard_cached_matches","execute","edit_doc_title","program_final_completion_callback","old_title","document","title","on_execute_completion","color","insert_prompt","run_script","path","get_prompt_suffix","set_prompt_suffix","suffix","get_prompt_string","get_cwd","get_home","RegExp","cached_matches","current_cached_match_index","tab_complete","discard_cached_matches","updated_discard","completeable_arguments","completion_data","current_partial","arg_index","completion_result","obj","Symbol","asyncIterator","results","get_completeable_arguments","complete_argument","parts","current_arg_partial","fill_completed_argument","programs","complete_command","fill_completed_command","helper_completion_options","options","option","env_info","absolute_profile","absolute_rc","profile_content","write_file","rc_content","localStorage","getItem","read_line_key_handlers","make_read_line_key_handlers","read_line_printable_handler","make_read_line_printable_handler","focus","input","header","single_column","visible_programs","programs_fmt","sort","max_allowable_length","Math","floor","cols","column1","_","column2","longest_program_length","max","new_args","paired_programs","program1","program2","program1_real_length","program2_real_length","Object","recurse","descs","nest_level","output","time","time_arg","parsed_time","parseInt","isNaN","reload","show_hidden","dir","max_width","set_cwd","absolute_path","setup","readonly","h_padding_l","ceil","h_padding_r","rows","footer","f_padding_l","f_padding_r","is_readonly","split_content","saved","set_readonly","cursor_y","normal","cursorY","line_length","cursor_x","cursorX","before_newline","after_newline","newline_content","left","right","test","url","proc_url","URL","protocol","overwrite","binary","method","headers","body","next_arg","abs_path","response","headers_obj","fetch","delete_file","ok","arrayBuffer","Uint8Array","filepath","hex","byte","padStart","idx","padded","concat","fill","MY_USERNAME","GH_USERNAME_REGEX","version_str","max_columns","asc_width","username","gh_info","res","json","bio","blog","followers","following","twitter","twitter_username","get_github_info","avatar_url","username_to_avatar_url","ascii_pfp","size","img","round","loadImage","stringANSI8BitColor","convert_to_ascii","known_data","data_index_str","user_data_str","pronouns","subject","object_or_alt","possessive","interests","websites","extra","known_info","stranger_info","txt_line_prefix","txt_line_suffix","asc_lines","txt_lines","max_lines","max_asc_line_length","max_txt_line_length","center_padding_size","side_padding_size","center_padding","side_padding","asc_line","txt_line","asc_line_padding","sfx_reg","screenReaderMode","sound_name","hint","querySelector","remove","setItem","pad","str","invis_codes","y_count","erase_all","removeItem","mime","width_arg","head_req","get_req","toLowerCase","createObjectURL","Blob","data_out","canvas","createElement","ctx","getContext","Image","crossOrigin","onerror","height","drawImage","img_data","getImageData","array","convert_to_image_data","img_width","img_height","width_scale","new_height","scaled_img_data","x","y","scaled_x","scaled_i","sixel","image2sixel","blob","createImageBitmap","trusted_formats","ext","directory","fs_name","get_unique_fs_type_name","encoded_dir","open","iframe","style","border","wind","dom","appendChild","show","other_fsedit_running","processes","message_handler","event","source","contentWindow","close","removeEventListener","addEventListener","PathNotFoundError","NonRecursiveDirectoryError","ReadOnlyError","FSEventType","AbstractFileSystem","purge_cache","smart","_cache","exists_direct","force_remove_from_cache","remote_purge_cache","remote_remove_from_cache","_remote_listener","remove_from_cache","register_callback","event_type","_callbacks","_call_callbacks","as_uint","READING_FILE","cached","read_file_direct","force","write_file_direct","WROTE_FILE","delete_file_direct","DELETED_FILE","move_file","new_path","move_file_direct","MOVED_FILE","set_readonly_direct","SET_READONLY","is_readonly_direct","delete_dir","recursive","delete_dir_direct","move_dir","dest","no_overwrite","move_inside","move_dir_direct","GETTING_CWD","_cwd","_root","SET_CWD","GETTING_HOME","_home","set_home","SET_HOME","get_root","GETTING_ROOT","set_root","SET_ROOT","CHECKING_EXISTS","effective_cwd","lastIndexOf","base_dir","paths","_initialised","rimraf","type_suffixes","bug","feature","other","HTML_TAG_REGEX","fields","feed","item","DocType","author","publisher","date","link","summary","get_field","doc","doc_type","field","as_html","dict","FEED","field_value","isArray","sub_field","sub_field_doc","getElementsByTagName","sub_value","innerHTML","textContent","max_items","index","no_content","parser","DOMParser","parseFromString","feed_title","site_link","site_description","items","item_idx","item_title","ITEM","convert","formatters","elem","walk","builder","openBlock","addInline","opener","children","closeBlock","img_fmt","a_fmt","selectors","selector","format","_data","assign","wait_block","run_cmd","cmd","welcome","end","remove_subcommand","unique_args","error_count","total_pkgs","pkg","pkg_dir","meta_triggers","meta_version","meta_deps","meta_raw","meta","triggers","deps","dep_pkg","dep_pkg_name","graph_query","remove_pkg_dependent","remove_pkg","files","trigger_name","trigger_data","trigger_exists","process_uninstall_trigger","add_subcommand","depended_by","pkg_at_version","pkg_split","pkg_name","pkg_version","pkg_json","repo_query","get_pkg_json","latest_version","get_pkg_meta","externals","pkg_is_installed","get_pkg_version","remove_data","virtual_args","virtual_data","content_list","file_map","file_contents","get_pkg_file","stringify","json_convert_dep_sets_to_arrs","install_new_pkg","dep_name","add_pkg_dependent","make_dir","process_install_trigger","print_info","pkg_data","installed","license","homepage_url","repo_url","long_desc","view_pkg_info","pkg_versions","get_pkg_versions","installed_version","printed_link_header","repo_url_obj","GRAPH_DIR","GRAPH_PATH","TRIGGER_DIR","append_url_pathnames","pathnames","new_url","urlpath","pathname","api_call","encodeURI","get_provided_list","json_convert_dep_arrs_to_sets","graph","get_pkg_info","list_pkgs","only_top_level","pkgs","top_level","get_pkg_dependents","dependents","get_pkg_dependencies","dependended_by","promote_pkg_to_top_level","demote_pkg_from_top_level","dependent_pkg","add_to_deps","remove_from_deps","skip_dep_check","list_unused_pkgs","get_file_path_in_pkg_bin","load_trigger_file","trigger_path","trigger","install_exec","data_str","uninstall_exec","local_graph","create_trigger_path","create_trigger_data","pkg_names","info","list_subcommand","always_fetch","installed_pkg","requested_version_installed","pkg_json_path","info_subcommand","provided","offset","selected_index","draw","quit","browse_subcommand","absolute_file","abs_dir","parent","destination","ended_with_slash","dest_is_dir","basename","window_ids","get_all_windows","all_windows","visible_windows","w","get_unique_manager_type_name","only_visible","only_invisible","visibility_text","owner_pid","window_id","get_window_by_id","show_subcommand","hide","hide_subcommand","close_subcommand","center","center_subcommand","aliases","value_parts","final_value","pm","toLocaleString","longest_command_length","get_command_space","subtract","on_data","reply_timeout","return_code","msg_data","service_subcommand","reload_services_subcommand","set_custom_flag","buttons","display","alignItems","gap","padding","fsedit_button","innerText","fontSize","onclick","mc_button","mc_image","objectFit","alt","draggable","trigger_file","source_path","dest_path","LocalStorageFS","current_dir","MADE_DIR","part_idx","DELETED_DIR","src_parts","dest_parts","current_dir_parent","dest_current_dir","dirs_first","LISTING_DIR","current_part","binary_string","atob","bytes","m","charCodeAt","TextDecoder","decode","uint","TextEncoder","encode","ArrayBuffer","btoa","String","fromCharCode","apply","readonly_list","new_file_name","new_current_dir","string_to_array","array_to_b64","migrations","migrate_old_string_fs","migrate_old_array_fs","is_outer","stack","current_obj","OPFSFileSystem","_opfs_handle","storage","getDirectory","handle","get_root_handle","root","current_handle","getDirectoryHandle","create","DOMException","getFileHandle","err2","removeEntry","file_handle","getFile","array_buffer","writable","createWritable","data_to_write","dest_file_handle","kind","generate_project_folder","data_projects_dir","project_entry","project_data","project_dir","info_content","primary_language","live_url","image","file_ext_regex","image_ext","skip_cache","ttl_cache","ttl_cache_obj","now","fetch_file_with_ttl","sub_projects","sub_project_entry","AbstractWindow","_owner_pid","AbstractWindowManager","DOMWindowManager","_WindowClass","_window_map","top_z_index","_window_id_counter","manager","_event_listeners","_title_text","moveable","resizable","_maximisable","_maximised","_custom_flags","_window_id","_window_root","classList","role","ariaHidden","zIndex","capture","_handle_window_blur","_window_top_bar","_window_top_bar_title","setAttribute","top_bar_controls","stopPropagation","minimise_button","_window_top_bar_maximise_button","ev","maximisable","maximised","close_button","bind","_start_drag","_content_host","_shadow_dom","attachShadow","mode","_emit_event","activeElement","all","start_event","preventDefault","rect","getBoundingClientRect","offset_x","clientX","offset_y","clientY","top","mouse_move","move_event","new_rect","width_ratio","mouse_up","up_event","remove_event_listener","new_title","css_width","css_height","toggle","css_pos","contains","is_visible","get_custom_flag","flag","wait_for_event","ollieos","howler","xterm","fitAddon","webLinksAddon","imageAddon","xtermLinkProvider","sweetalert2","boot_os","prog","absolute_boot","absolute_init","absolute_etc","absolute_boot_target","absolute_default_shell","setup_boot","motd_content","absolute_motd","setup_motd","absolute_ollie_profile","absolute_ash_profile","absolute_ollierc","absolute_ashrc","migrate_rc_profile","credits_content","absolute_credits","setup_credits","latest_rev","data_dir","existing_rev","version_file","rev","svc_version","possible_backup_dir","groups","group","group_dir","group_index","file_data","setup_data_repo","data_rev","absolute_projects","project_rev","project_index_file","projects","project_file","setup_projects","initial_fs_setup","cursorBlink","fit","FitAddon","loadAddon","WebLinksAddon","ImageAddon","render","innerWidth","wrapped","dataset"],"sourceRoot":""}