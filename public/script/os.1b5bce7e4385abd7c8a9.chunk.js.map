{"version":3,"file":"os.1b5bce7e4385abd7c8a9.chunk.js","mappings":"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","sources":["webpack://ollieos/./src/kernel/term_ctl.ts","webpack://ollieos/./src/kernel/prog_registry.ts","webpack://ollieos/./src/kernel/filesystem.ts","webpack://ollieos/./src/kernel/processes.ts","webpack://ollieos/./src/kernel/sfx_registry.ts","webpack://ollieos/./src/kernel/index.ts","webpack://ollieos/./src/programs/core/ignition/services.ts","webpack://ollieos/./src/programs/core/ignition/index.ts","webpack://ollieos/./src/programs/core/jetty.ts","webpack://ollieos/./src/programs/core/ash/memory.ts","webpack://ollieos/./src/programs/core/ash/parser.ts","webpack://ollieos/./src/programs/core/ash/core.ts","webpack://ollieos/./src/programs/core/ash/tab_completion.ts","webpack://ollieos/./src/programs/core/ash/index.ts","webpack://ollieos/./src/programs/core/ash/key_handlers.ts","webpack://ollieos/./src/programs/core/default_privilege_agent.ts","webpack://ollieos/./src/programs/core/recovery.ts","webpack://ollieos/./src/programs/help.ts","webpack://ollieos/./src/programs/shutdown.ts","webpack://ollieos/./src/programs/clear.ts","webpack://ollieos/./src/programs/echo.ts","webpack://ollieos/./src/programs/unset.ts","webpack://ollieos/./src/programs/ls.ts","webpack://ollieos/./src/programs/cd.ts","webpack://ollieos/./src/programs/pwd.ts","webpack://ollieos/./src/programs/edit.ts","webpack://ollieos/./src/programs/webget.ts","webpack://ollieos/./src/programs/cat.ts","webpack://ollieos/./src/programs/hex.ts","webpack://ollieos/./src/programs/mefetch.ts","webpack://ollieos/./src/programs/reader.ts","webpack://ollieos/./src/programs/selfdestruct.ts","webpack://ollieos/./src/programs/imagine.ts","webpack://ollieos/./src/programs/ascmagine.ts","webpack://ollieos/./src/programs/fsedit.ts","webpack://ollieos/./src/programs/rm.ts","webpack://ollieos/./src/programs/bugreport.ts","webpack://ollieos/./src/programs/repo.ts","webpack://ollieos/./src/programs/rss.ts","webpack://ollieos/./src/programs/legacy.ts","webpack://ollieos/./src/programs/tour.ts","webpack://ollieos/./src/programs/pkg/remove.ts","webpack://ollieos/./src/programs/pkg/add.ts","webpack://ollieos/./src/programs/pkg/list.ts","webpack://ollieos/./src/programs/pkg/info.ts","webpack://ollieos/./src/programs/pkg/browse.ts","webpack://ollieos/./src/programs/pkg/index.ts","webpack://ollieos/./src/programs/touch.ts","webpack://ollieos/./src/programs/mkdir.ts","webpack://ollieos/./src/programs/mv.ts","webpack://ollieos/./src/programs/window/info.ts","webpack://ollieos/./src/programs/window/list.ts","webpack://ollieos/./src/programs/window/show.ts","webpack://ollieos/./src/programs/window/hide.ts","webpack://ollieos/./src/programs/window/close.ts","webpack://ollieos/./src/programs/window/center.ts","webpack://ollieos/./src/programs/window/index.ts","webpack://ollieos/./src/programs/alias.ts","webpack://ollieos/./src/programs/unalias.ts","webpack://ollieos/./src/programs/ps.ts","webpack://ollieos/./src/programs/kill.ts","webpack://ollieos/./src/programs/spark/service.ts","webpack://ollieos/./src/programs/spark/reload_services.ts","webpack://ollieos/./src/programs/spark/index.ts","webpack://ollieos/./src/programs/ipc_bg_test.ts","webpack://ollieos/./src/programs/ipc_fg_test.ts","webpack://ollieos/./src/programs/taskbar_test.ts","webpack://ollieos/./src/programs/pkg/triggers/create_trigger.ts","webpack://ollieos/./src/programs/pkg/triggers/remove_trigger.ts","webpack://ollieos/./src/fs_impl/localstorage.ts","webpack://ollieos/./src/fs_impl/opfs.ts","webpack://ollieos/./src/initial_fs_setup.ts","webpack://ollieos/./src/kernel/windowing.ts","webpack://ollieos/./src/window_impl/dom.ts","webpack://ollieos/./src/load_global_externals.ts","webpack://ollieos/./src/os_loader.ts"],"sourcesContent":["import {IDisposable, ITerminalOptions, Terminal} from \"@xterm/xterm\";\n\nexport const NEWLINE = \"\\r\\n\";\n/* eslint-disable-next-line no-control-regex, no-misleading-character-class */\nexport const NON_PRINTABLE_REGEX = /[\\0-\\x1F\\x7F-\\x9F\\xAD\\u0378\\u0379\\u037F-\\u0383\\u038B\\u038D\\u03A2\\u0528-\\u0530\\u0557\\u0558\\u0560\\u0588\\u058B-\\u058E\\u0590\\u05C8-\\u05CF\\u05EB-\\u05EF\\u05F5-\\u0605\\u061C\\u061D\\u06DD\\u070E\\u070F\\u074B\\u074C\\u07B2-\\u07BF\\u07FB-\\u07FF\\u082E\\u082F\\u083F\\u085C\\u085D\\u085F-\\u089F\\u08A1\\u08AD-\\u08E3\\u08FF\\u0978\\u0980\\u0984\\u098D\\u098E\\u0991\\u0992\\u09A9\\u09B1\\u09B3-\\u09B5\\u09BA\\u09BB\\u09C5\\u09C6\\u09C9\\u09CA\\u09CF-\\u09D6\\u09D8-\\u09DB\\u09DE\\u09E4\\u09E5\\u09FC-\\u0A00\\u0A04\\u0A0B-\\u0A0E\\u0A11\\u0A12\\u0A29\\u0A31\\u0A34\\u0A37\\u0A3A\\u0A3B\\u0A3D\\u0A43-\\u0A46\\u0A49\\u0A4A\\u0A4E-\\u0A50\\u0A52-\\u0A58\\u0A5D\\u0A5F-\\u0A65\\u0A76-\\u0A80\\u0A84\\u0A8E\\u0A92\\u0AA9\\u0AB1\\u0AB4\\u0ABA\\u0ABB\\u0AC6\\u0ACA\\u0ACE\\u0ACF\\u0AD1-\\u0ADF\\u0AE4\\u0AE5\\u0AF2-\\u0B00\\u0B04\\u0B0D\\u0B0E\\u0B11\\u0B12\\u0B29\\u0B31\\u0B34\\u0B3A\\u0B3B\\u0B45\\u0B46\\u0B49\\u0B4A\\u0B4E-\\u0B55\\u0B58-\\u0B5B\\u0B5E\\u0B64\\u0B65\\u0B78-\\u0B81\\u0B84\\u0B8B-\\u0B8D\\u0B91\\u0B96-\\u0B98\\u0B9B\\u0B9D\\u0BA0-\\u0BA2\\u0BA5-\\u0BA7\\u0BAB-\\u0BAD\\u0BBA-\\u0BBD\\u0BC3-\\u0BC5\\u0BC9\\u0BCE\\u0BCF\\u0BD1-\\u0BD6\\u0BD8-\\u0BE5\\u0BFB-\\u0C00\\u0C04\\u0C0D\\u0C11\\u0C29\\u0C34\\u0C3A-\\u0C3C\\u0C45\\u0C49\\u0C4E-\\u0C54\\u0C57\\u0C5A-\\u0C5F\\u0C64\\u0C65\\u0C70-\\u0C77\\u0C80\\u0C81\\u0C84\\u0C8D\\u0C91\\u0CA9\\u0CB4\\u0CBA\\u0CBB\\u0CC5\\u0CC9\\u0CCE-\\u0CD4\\u0CD7-\\u0CDD\\u0CDF\\u0CE4\\u0CE5\\u0CF0\\u0CF3-\\u0D01\\u0D04\\u0D0D\\u0D11\\u0D3B\\u0D3C\\u0D45\\u0D49\\u0D4F-\\u0D56\\u0D58-\\u0D5F\\u0D64\\u0D65\\u0D76-\\u0D78\\u0D80\\u0D81\\u0D84\\u0D97-\\u0D99\\u0DB2\\u0DBC\\u0DBE\\u0DBF\\u0DC7-\\u0DC9\\u0DCB-\\u0DCE\\u0DD5\\u0DD7\\u0DE0-\\u0DF1\\u0DF5-\\u0E00\\u0E3B-\\u0E3E\\u0E5C-\\u0E80\\u0E83\\u0E85\\u0E86\\u0E89\\u0E8B\\u0E8C\\u0E8E-\\u0E93\\u0E98\\u0EA0\\u0EA4\\u0EA6\\u0EA8\\u0EA9\\u0EAC\\u0EBA\\u0EBE\\u0EBF\\u0EC5\\u0EC7\\u0ECE\\u0ECF\\u0EDA\\u0EDB\\u0EE0-\\u0EFF\\u0F48\\u0F6D-\\u0F70\\u0F98\\u0FBD\\u0FCD\\u0FDB-\\u0FFF\\u10C6\\u10C8-\\u10CC\\u10CE\\u10CF\\u1249\\u124E\\u124F\\u1257\\u1259\\u125E\\u125F\\u1289\\u128E\\u128F\\u12B1\\u12B6\\u12B7\\u12BF\\u12C1\\u12C6\\u12C7\\u12D7\\u1311\\u1316\\u1317\\u135B\\u135C\\u137D-\\u137F\\u139A-\\u139F\\u13F5-\\u13FF\\u169D-\\u169F\\u16F1-\\u16FF\\u170D\\u1715-\\u171F\\u1737-\\u173F\\u1754-\\u175F\\u176D\\u1771\\u1774-\\u177F\\u17DE\\u17DF\\u17EA-\\u17EF\\u17FA-\\u17FF\\u180F\\u181A-\\u181F\\u1878-\\u187F\\u18AB-\\u18AF\\u18F6-\\u18FF\\u191D-\\u191F\\u192C-\\u192F\\u193C-\\u193F\\u1941-\\u1943\\u196E\\u196F\\u1975-\\u197F\\u19AC-\\u19AF\\u19CA-\\u19CF\\u19DB-\\u19DD\\u1A1C\\u1A1D\\u1A5F\\u1A7D\\u1A7E\\u1A8A-\\u1A8F\\u1A9A-\\u1A9F\\u1AAE-\\u1AFF\\u1B4C-\\u1B4F\\u1B7D-\\u1B7F\\u1BF4-\\u1BFB\\u1C38-\\u1C3A\\u1C4A-\\u1C4C\\u1C80-\\u1CBF\\u1CC8-\\u1CCF\\u1CF7-\\u1CFF\\u1DE7-\\u1DFB\\u1F16\\u1F17\\u1F1E\\u1F1F\\u1F46\\u1F47\\u1F4E\\u1F4F\\u1F58\\u1F5A\\u1F5C\\u1F5E\\u1F7E\\u1F7F\\u1FB5\\u1FC5\\u1FD4\\u1FD5\\u1FDC\\u1FF0\\u1FF1\\u1FF5\\u1FFF\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u2072\\u2073\\u208F\\u209D-\\u209F\\u20BB-\\u20CF\\u20F1-\\u20FF\\u218A-\\u218F\\u23F4-\\u23FF\\u2427-\\u243F\\u244B-\\u245F\\u2700\\u2B4D-\\u2B4F\\u2B5A-\\u2BFF\\u2C2F\\u2C5F\\u2CF4-\\u2CF8\\u2D26\\u2D28-\\u2D2C\\u2D2E\\u2D2F\\u2D68-\\u2D6E\\u2D71-\\u2D7E\\u2D97-\\u2D9F\\u2DA7\\u2DAF\\u2DB7\\u2DBF\\u2DC7\\u2DCF\\u2DD7\\u2DDF\\u2E3C-\\u2E7F\\u2E9A\\u2EF4-\\u2EFF\\u2FD6-\\u2FEF\\u2FFC-\\u2FFF\\u3040\\u3097\\u3098\\u3100-\\u3104\\u312E-\\u3130\\u318F\\u31BB-\\u31BF\\u31E4-\\u31EF\\u321F\\u32FF\\u4DB6-\\u4DBF\\u9FCD-\\u9FFF\\uA48D-\\uA48F\\uA4C7-\\uA4CF\\uA62C-\\uA63F\\uA698-\\uA69E\\uA6F8-\\uA6FF\\uA78F\\uA794-\\uA79F\\uA7AB-\\uA7F7\\uA82C-\\uA82F\\uA83A-\\uA83F\\uA878-\\uA87F\\uA8C5-\\uA8CD\\uA8DA-\\uA8DF\\uA8FC-\\uA8FF\\uA954-\\uA95E\\uA97D-\\uA97F\\uA9CE\\uA9DA-\\uA9DD\\uA9E0-\\uA9FF\\uAA37-\\uAA3F\\uAA4E\\uAA4F\\uAA5A\\uAA5B\\uAA7C-\\uAA7F\\uAAC3-\\uAADA\\uAAF7-\\uAB00\\uAB07\\uAB08\\uAB0F\\uAB10\\uAB17-\\uAB1F\\uAB27\\uAB2F-\\uABBF\\uABEE\\uABEF\\uABFA-\\uABFF\\uD7A4-\\uD7AF\\uD7C7-\\uD7CA\\uD7FC-\\uF8FF\\uFA6E\\uFA6F\\uFADA-\\uFAFF\\uFB07-\\uFB12\\uFB18-\\uFB1C\\uFB37\\uFB3D\\uFB3F\\uFB42\\uFB45\\uFBC2-\\uFBD2\\uFD40-\\uFD4F\\uFD90\\uFD91\\uFDC8-\\uFDEF\\uFDFE\\uFDFF\\uFE1A-\\uFE1F\\uFE27-\\uFE2F\\uFE53\\uFE67\\uFE6C-\\uFE6F\\uFE75\\uFEFD-\\uFF00\\uFFBF-\\uFFC1\\uFFC8\\uFFC9\\uFFD0\\uFFD1\\uFFD8\\uFFD9\\uFFDD-\\uFFDF\\uFFE7\\uFFEF-\\uFFFB\\uFFFE\\uFFFF]/g;\nexport const ANSI_ESCAPE_REGEX = /(\\\\u001b|\\\\x1b)(8|7|H|>|\\[(\\?\\d+(h|l)|[0-2]?(K|J)|\\d*(A|B|C|D\\D|E|F|G|g|i|m|n|S|s|T|u)|1000D\\d+|\\d*;\\d*(f|H|r|m)|\\d+;\\d+;\\d+m))/g;\n\n// eslint-disable-next-line no-control-regex, no-misleading-character-class\nexport const ANSI_UNESCAPED_REGEX = /(\\u001b|\\x1b)\\[(\\d+)?(;\\d+)*m/g;\n\n\nconst FG = {\n    reset: \"\\x1B[39m\",\n    black: \"\\x1B[30m\",\n    red: \"\\x1B[31m\",\n    green: \"\\x1B[32m\",\n    yellow: \"\\x1B[33m\",\n    blue: \"\\x1B[34m\",\n    magenta: \"\\x1B[35m\",\n    cyan: \"\\x1B[36m\",\n    white: \"\\x1B[37m\",\n    gray: \"\\x1B[90m\"\n};\n\nconst BG = {\n    reset: \"\\x1B[49m\",\n    black: \"\\x1B[40m\",\n    red: \"\\x1B[41m\",\n    green: \"\\x1B[42m\",\n    yellow: \"\\x1B[44m\",\n    blue: \"\\x1B[44m\",\n    magenta: \"\\x1B[45m\",\n    cyan: \"\\x1B[46m\",\n    white: \"\\x1B[47m\",\n    gray: \"\\x1B[100m\"\n}\n\nconst STYLE = {\n    reset_all: \"\\x1B[0m\",\n    bold: \"\\x1B[1m\",\n    dim: \"\\x1B[2m\",\n    no_bold_or_dim: \"\\x1B[22m\",\n    italic: \"\\x1B[3m\",\n    no_italic: \"\\x1B[23m\",\n    underline: \"\\x1B[4m\",\n    double_underline: \"\\x1B[21m\",\n    no_underline: \"\\x1B[24m\",\n    inverse: \"\\x1B[7m\",\n    no_inverse: \"\\x1B[27m\",\n    hidden: \"\\x1B[8m\",\n    no_hidden: \"\\x1B[28m\",\n    strikethrough: \"\\x1B[9m\",\n    no_strikethrough: \"\\x1B[29m\",\n    negative: \"\\x1B[7m\",\n    positive: \"\\x1B[27m\"\n}\n\nconst CURSOR = {\n    // TODO: move cursor manipulation from edit to substitution functions here\n    invisible: \"\\x1B[?25l\",\n    visible: \"\\x1B[?25h\",\n}\n\nconst PREFABS = {\n    program_name: FG.cyan + STYLE.italic + STYLE.bold,\n    error: FG.red + STYLE.bold,\n    variable_name: FG.yellow + STYLE.bold,\n    file_path: FG.green + STYLE.bold,\n    dir_name: FG.blue + STYLE.bold,\n    secret: STYLE.hidden + CURSOR.invisible,\n}\n\nexport const ANSI = {\n    FG,\n    BG,\n    STYLE,\n    CURSOR,\n    PREFABS\n}\n\n\n// TODO: docstrings everywhere\n\nexport interface KeyEvent {\n    key: string;\n    domEvent: KeyboardEvent;\n}\n\nexport type KeyEventHandler = (event: KeyEvent, term: WrappedTerminal) => void | Promise<void>;\n\nexport interface RegisteredKeyEventIdentifier {\n    key?: string;\n    domEventCode?: string;\n}\n\nexport interface ReadLineBuffer {\n    current_line: string;\n    current_index: number;\n    set_current_line: (new_line: string) => void;\n    set_current_index: (new_index: number) => void;\n}\n\nexport type ReadLineKeyHandler = (event: KeyEvent, term: WrappedTerminal, buffer: ReadLineBuffer) => void | Promise<void> | boolean | Promise<boolean>;\n\nexport class WrappedTerminal extends Terminal {\n    #disposable_onkey: IDisposable;\n\n    readonly #key_handlers: Map<RegisteredKeyEventIdentifier, { handler: KeyEventHandler, block: boolean }[]> = new Map();\n    readonly #on_printable_handlers: KeyEventHandler[] = [];\n    readonly #key_event_queue: KeyEvent[] = [];\n    #is_handling_key_events = false;\n\n    #kernel_has_panicked = false;\n\n    // TODO: this exporting is a bit lazy, but it works for now\n\n    get ansi() {\n        return ANSI;\n    }\n\n    get newline() {\n        return NEWLINE;\n    }\n\n    get non_printable_regex() {\n        return NON_PRINTABLE_REGEX;\n    }\n\n    get ansi_escape_regex() {\n        return ANSI_ESCAPE_REGEX;\n    }\n\n    get ansi_unescaped_regex() {\n        return ANSI_UNESCAPED_REGEX;\n    }\n\n    // line discipline now completely handled by read_line, no global event loop\n    read_line = async (custom_key_handlers: { [key_string: string]: ReadLineKeyHandler } = {}, custom_printable_handler?: ReadLineKeyHandler): Promise<string> => {\n        const buffer: ReadLineBuffer = {\n            current_line: \"\",\n            current_index: 0,\n\n            set_current_line: (new_line: string) => {\n                buffer.current_line = new_line;\n            },\n\n            set_current_index: (new_index: number) => {\n                buffer.current_index = new_index;\n            }\n        };\n\n        let handler_dispose: (() => void) | null = null;\n\n        return new Promise<string>((resolve) => {\n            const handlers: { [key_string: string]: KeyEventHandler } = {\n                // arrow left - move cursor left\n                \"\\x1b[D\": (_e, term) => {\n                    if (buffer.current_index > 0) {\n                        term.write(\"\\b\");\n                        buffer.current_index--;\n                    }\n                },\n\n                // arrow right - move cursor right\n                \"\\x1b[C\": (_e, term) => {\n                    if (buffer.current_index < buffer.current_line.length) {\n                        term.write(buffer.current_line[buffer.current_index]);\n                        buffer.current_index++;\n                    }\n                },\n\n                // backspace - delete character\n                \"\\x7F\": (_e, term) => {\n                    if (buffer.current_line.length > 0 && buffer.current_index > 0) {\n                        // get everything before the cursor\n                        const before = buffer.current_line.slice(0, buffer.current_index - 1);\n\n                        // get everything after the cursor\n                        const after = buffer.current_line.slice(buffer.current_index);\n\n                        // update current line\n                        buffer.current_line = before + after;\n\n                        // move cursor back one\n                        term.write(\"\\b\");\n\n                        // overwrite with after content and a space (remove last character)\n                        term.write(after + \" \");\n\n                        // move cursor back to original position\n                        term.write(\"\\b\".repeat(after.length + 1));\n                        buffer.current_index--;\n                    }\n                },\n\n                // enter - finish line\n                \"\\r\": (_e, term) => {\n                    if (handler_dispose) {\n                        handler_dispose();\n                    }\n\n                    term.write(NEWLINE);\n                    resolve(buffer.current_line);\n                }\n            }\n\n            // register blocking catch all key handler which handles all keys during read_line\n            handler_dispose = this.register_key_event_handler(\n                async (e) => {\n                    // check for custom handlers first\n                    if (e.key in custom_key_handlers) {\n                        const block = await custom_key_handlers[e.key](e, this, buffer);\n\n                        if (block) {\n                            return;\n                        }\n                    }\n\n                    // check for builtin handlers\n                    if (e.key in handlers) {\n                        await handlers[e.key](e, this);\n                        return;\n                    }\n\n                    // check for printable characters\n                    if (e.key.match(NON_PRINTABLE_REGEX) === null) {\n                        if (custom_printable_handler) {\n                            const block = await custom_printable_handler(e, this, buffer);\n\n                            if (block) {\n                                return;\n                            }\n                        }\n\n                        // if at the end of the line, just append the character\n                        if (buffer.current_index === buffer.current_line.length) {\n                            buffer.current_line += e.key;\n                            this.write(e.key);\n                            buffer.current_index++;\n                            return;\n                        }\n\n                        // insert the character at the cursor, shift the rest of the line to the right\n                        const before_cursor = buffer.current_line.slice(0, buffer.current_index);\n                        const after_cursor = buffer.current_line.slice(buffer.current_index);\n                        buffer.current_line = before_cursor + e.key + after_cursor;\n\n                        // write the new right of the line over the old one\n                        this.write(e.key + after_cursor);\n\n                        // move back to the cursor position\n                        this.write(`\\x1b[${after_cursor.length}D`);\n\n                        // increment the cursor position\n                        buffer.current_index++;\n                    } else {\n                        console.warn(\"Ignored key event:\", e);\n                        // TODO: handle more special keys and sequences (probably in shells)\n                    }\n                },\n                {\n                    block: true,\n                    high_priority: true\n                }\n            );\n        });\n    }\n\n    _search_handlers = (key: string | undefined, domEventCode: string | undefined, strict = false): { handler: KeyEventHandler, block: boolean }[] => {\n        for (const pair of this.#key_handlers.entries()) {\n            const identfier = pair[0] as RegisteredKeyEventIdentifier;\n\n            // if strict matching is required, both key and domEventCode must match\n            if (strict) {\n                if (identfier.key === key && identfier.domEventCode === domEventCode) {\n                    return pair[1] as { handler: KeyEventHandler, block: boolean }[];\n                } else {\n                    continue;\n                }\n            }\n\n            // if the identifier matches, return the entries\n            if (identfier.key === key || identfier.domEventCode === domEventCode) {\n                return pair[1] as { handler: KeyEventHandler, block: boolean }[];\n            }\n        }\n\n        // if no match is found, return an empty array\n        return [];\n    }\n\n    /**\n     * Registers a key event handler.\n     * Handlers with no filter run BEFORE filtered handlers.\n     *\n     * @param {KeyEventHandler} handler The handler to register\n     * @param {{ keyString?: string, domEventCode?: string, block: boolean, high_priority: boolean }} props The properties of the handler. Key is the key as a string to filter by, domEventCode is the DOM event code to filter by. Block determines whether the event should be blocked from bubbling up to following handlers and/or the terminal display. High priority determines whether the handler should be placed at the beginning of the handler list.\n     * @returns {() => () => void} A function to unregister the handler\n     */\n    register_key_event_handler = (handler: KeyEventHandler, props: { keyString?: string, domEventCode?: string, block?: boolean, high_priority?: boolean }) => {\n        // build the identifier\n        const identifier: RegisteredKeyEventIdentifier = {\n            key: props.keyString,\n            domEventCode: props.domEventCode\n        };\n\n        const entry = { handler, block: props.block ?? false };\n\n        // if the identifier has not already been registered, create a new array for it\n        const existing_entries = this._search_handlers(props.keyString, props.domEventCode, true);\n        if (existing_entries.length === 0) {\n            this.#key_handlers.set(identifier, [entry]);\n        } else {\n            // otherwise, add the handler to the existing array\n            // NOTE: reference is retained so no need to search\n            if (props.high_priority) {\n                existing_entries.unshift(entry);\n            } else {\n                existing_entries.push(entry);\n            }\n        }\n\n        // return a function to unregister the handler\n        // NOTE: reference is retained so no need to search\n        return () => {\n            const handlers = this.#key_handlers.get(identifier);\n            if (!handlers) {\n                return;\n            }\n\n            handlers.splice(handlers.indexOf(entry), 1);\n\n            // if there are no more handlers for the identifier, remove the identifier from the map\n            if (handlers.length === 0) {\n                this.#key_handlers.delete(identifier);\n            }\n        }\n    }\n\n    _handle_key_event = async (e: KeyEvent): Promise<void> => {\n        // TODO: supress builtin key events when program is running, create ctrl+c handler\n\n        // look for any handlers against all keys\n        const all_key_entries = this._search_handlers(undefined, undefined, true);\n        if (all_key_entries) {\n            for (const entry of all_key_entries) {\n                // await if the handler is async\n                await entry.handler(e, this);\n\n                if (entry.block) {\n                    // if the handler is blocking, don't go to next handler or display logic\n                    return;\n                }\n            }\n        }\n\n        // search the handlers for the key\n        const entries = this._search_handlers(e.key, e.domEvent.code);\n\n        // if there are any handlers, run them\n        for (const entry of entries) {\n            // await if the handler is async\n            await entry.handler(e, this);\n\n            if (entry.block) {\n                // if the handler is blocking, don't go to next handler or display logic\n                return;\n            }\n        }\n\n        // check if the key is printable\n        if (e.key.match(NON_PRINTABLE_REGEX) === null) {\n            // call any registered printable key handlers\n            for (const handler of this.#on_printable_handlers) {\n                await handler(e, this);\n            }\n        }\n    }\n\n    /**\n     * Registers a handler that is called when any printable key is pressed.\n     * @param handler  - The handler to register\n     * @param high_priority - If true, the handler will be placed at the beginning of the handler list (cannot run before the default printable key handler)\n     */\n    register_on_printable_key_event_handler = (handler: KeyEventHandler, high_priority = false) => {\n        if (high_priority) {\n            this.#on_printable_handlers.unshift(handler);\n        } else {\n            this.#on_printable_handlers.push(handler);\n        }\n    }\n\n    _enqueue_key_event = (e: KeyEvent) => {\n        this.#key_event_queue.push(e);\n\n        // if the queue is not being handled, handle it\n        if (!this.#is_handling_key_events) {\n            this.#is_handling_key_events = true;\n            this._handle_key_event_queue();\n        }\n    }\n\n    _handle_key_event_queue = async () => {\n        // if there are no events in the queue, return\n        if (this.#key_event_queue.length === 0) {\n            this.#is_handling_key_events = false;\n            return;\n        }\n\n        if (this.#is_handling_key_events) {\n            // handle the first event in the queue\n            await this._handle_key_event(this.#key_event_queue.shift()!);\n\n            // handle the rest of the events in the queue\n            this._handle_key_event_queue();\n        }\n    }\n\n\n    // note that this does not recieve pasted input, use a key event handler for that\n    wait_for_keypress = async (): Promise<KeyEvent> => {\n        // dispose of the current key handler (block bubbling)\n        this.#disposable_onkey.dispose();\n\n        return new Promise((resolve) => {\n            this.#disposable_onkey = this.onKey((e) => {\n                // dispose of this handler\n                this.#disposable_onkey.dispose();\n\n                // re-register the original handler\n                this.#disposable_onkey = this.onKey(this._enqueue_key_event);\n\n                // resolve the promise\n                resolve(e);\n            });\n        });\n    }\n\n    get_text = async (max_length?: number): Promise<string> => {\n        let text = \"\";\n\n        return new Promise((resolve) => {\n            const unregister_handler = this.register_key_event_handler(\n                (e) => {\n                    if (e.key === \"\\r\") {\n                        // if the key is enter, return the text\n                        unregister_handler();\n                        resolve(text);\n                    } else if (e.key === \"\\x7F\") {\n                        // if the key is backspace, remove the last character\n                        if (text.length > 0) {\n                            text = text.slice(0, -1);\n                            this.write(\"\\b \\b\");\n                        }\n                    } else if (e.key.match(NON_PRINTABLE_REGEX) === null) {\n                        // if the key is printable, add it to the text\n                        if (max_length === undefined || text.length < max_length) {\n                            text += e.key;\n                            this.write(e.key);\n                        }\n                    }\n                },\n                {\n                    block: true,\n                    high_priority: true\n                }\n            );\n        });\n    }\n\n    word_wrap(text: string, width: number): string {\n        const lines = text.split(NEWLINE);\n        const wrapped_lines: string[] = [];\n\n        for (const line of lines) {\n            const words = line.split(\" \");\n            let current_line = \"\";\n\n            for (const word of words) {\n                if (current_line.length + word.length + 1 > width) {\n                    // push word by word until the line is full\n                    wrapped_lines.push(current_line);\n                    current_line = word;\n                } else {\n                    // if the current line is empty, don't add a space\n                    if (current_line.length === 0) {\n                        current_line = word;\n                    } else {\n                        current_line += \" \" + word;\n                    }\n                }\n            }\n\n            wrapped_lines.push(current_line);\n        }\n\n        return wrapped_lines.join(NEWLINE);\n    }\n\n    copy() {\n        // copy the selected text to the clipboard\n        navigator.clipboard.writeText(this.getSelection()).then(() => {\n            // clear the selection\n            this.clearSelection();\n        });\n    }\n\n    paste() {\n        if (this.#kernel_has_panicked) {\n            return;\n        }\n\n        // TODO: sometimes has issues with large text (queue consumption not restarted properly after execution)\n        // read the clipboard\n        navigator.clipboard.readText().then((text) => {\n            // simulate key events for each character (lazy but it works great, no need to rewrite the key handler)\n            for (const char of text) {\n                let dom_event_code = `Key${char.toUpperCase()}`;\n                let key = char;\n\n                if (char === \"\\r\") {\n                    // skip, its CRLF\n                    continue;\n                }\n\n                if (char === \"\\n\") {\n                    key = \"\\r\";\n                    dom_event_code = \"Enter\";\n                }\n\n                if (char === \" \") {\n                    dom_event_code = \"Space\";\n                }\n\n                this.#key_event_queue.push(({ key, domEvent: { code: dom_event_code } } as KeyEvent));\n            }\n\n            // if the queue is not being handled, handle it\n            if (!this.#is_handling_key_events) {\n                this.#is_handling_key_events = true;\n                this._handle_key_event_queue();\n            }\n        });\n    }\n\n    copy_or_paste() {\n        // if there is a selection, copy it\n        if (this.hasSelection()) {\n            this.copy();\n        } else {\n            this.paste();\n        }\n    }\n\n    handle_kernel_panic = (message: string, process_info: string, debug_info?: string) => {\n        if (this.#kernel_has_panicked) {\n            return;\n        }\n\n        this.#kernel_has_panicked = true;\n\n        this.reset();\n\n        // stop reading key events\n        this.#disposable_onkey.dispose();\n        this.write(ANSI.CURSOR.invisible);\n\n        if (this.textarea) {\n            this.textarea.disabled = true;\n        }\n\n        this.writeln(`${ANSI.BG.red + ANSI.FG.white}Panic: ${message}`);\n        this.writeln(`at time: ${new Date().toISOString()}`);\n\n        this.write(NEWLINE);\n        this.writeln(\"Debug info:\");\n        if (debug_info) {\n            this.writeln(debug_info);\n        } else {\n            this.writeln(\"No debug info provided.\");\n        }\n\n        this.write(NEWLINE);\n        this.writeln(\"Processes running at time of panic:\");\n        this.writeln(process_info || \"None.\");\n\n        if (typeof window !== \"undefined\") {\n            this.write(NEWLINE);\n            this.writeln(\"OS unrecoverable?\")\n            this.writeln(`Visit ${window.location.origin}/recover_fs if stuck.`);\n        }\n\n        this.writeln(ANSI.STYLE.reset_all);\n    }\n\n    constructor(xterm_opts?: ITerminalOptions) {\n        super(xterm_opts);\n        this.#disposable_onkey = this.onKey(this._enqueue_key_event);\n    }\n}\n\n// TODO: term needs hardening and possibly userspace protection to ensure programs cant dispatch keys to auto accept elevation prompts\n\n// as of 09/01/2026, the god class of WrappedTerminal is no more!\n// this used to be the kernel, shell, tty, and bootstrap all in one\n","import type {Program} from \"../types\";\nimport type {AbstractFileSystem} from \"./filesystem\";\nimport {ANSI, WrappedTerminal} from \"./term_ctl\";\n\nconst encode_js_to_url = (js_code: string): string => {\n    const encoded = encodeURIComponent(js_code);\n    return `data:text/javascript;charset=utf-8,${encoded}`;\n}\n\nexport interface ProgramRegistrant {\n    program: Program<unknown>,\n    built_in: boolean,\n}\n\nexport const build_registrant_from_js = async (js_code: string, built_in = false): Promise<ProgramRegistrant> => {\n    // inspect the js code to see if it starts with \"import\". if so, this is outdated, put a deprecation warning\n    let warn_deprecation = false;\n    if (js_code.startsWith(\"import\")) {\n        // delay the warning as we might find out the program name later\n        warn_deprecation = true;\n    }\n\n    // note: the webpackIgnore bypasses webpack's import() function and uses the browser's native import() function\n    // this is because webpack's import() function does not support data urls\n\n    const data_url = encode_js_to_url(js_code);\n    // note: risk to user, show warning\n    // TODO: explore sandboxing via webworkers or other methods\n    const imp = await import(/* webpackIgnore: true */data_url);\n    let program = imp.default;\n\n    if (program === undefined) {\n        if (warn_deprecation) {\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\n        }\n\n        throw new Error(\"Program is not the default export.\");\n    }\n\n    // validate program\n    if (typeof program !== \"object\") {\n        if (warn_deprecation) {\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\n        }\n\n        throw new Error(\"Program is not an object.\");\n    }\n\n    program = program as object;\n\n    if (typeof program.name !== \"string\") {\n        if (warn_deprecation) {\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\n        }\n\n        throw new Error(\"Program does not have a name.\");\n    }\n\n    if (warn_deprecation) {\n        console.warn(`Program ${program.name} has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.`);\n    }\n\n    // not warning about compat here to make it more obvious to end users when they try to run an incompatible program\n\n    if (globalThis.OLLIEOS_NODE && program.node_opt_out) {\n        throw new Error(`Program ${program.name} is not compatible with Node.js.`);\n    }\n\n    if (typeof program.description !== \"string\") {\n        throw new Error(`Program ${program.name} does not have a description.`);\n    }\n\n    if (typeof program.usage_suffix !== \"string\") {\n        throw new Error(`Program ${program.name} does not have a usage suffix.`);\n    }\n\n    if (typeof program.arg_descriptions !== \"object\") {\n        throw new Error(`Program ${program.name} does not have argument descriptions.`);\n    }\n\n    // migration: we got rid of syncprogram (with main) and asyncprogram (async_main)\n    // now there is a single async type called program\n    // problem: older packages have a field called async_main, and some have main that doesn't return a promise\n    if (!program.main) {\n        if (!program.async_main) {\n            throw new Error(`Program ${program.name} does not have a main function.`);\n        }\n\n        console.warn(`Program ${program.name} has an async_main function. This is deprecated and will be removed in the future. Please use main instead.`);\n\n        // migrate: rename async_main to main\n        program.main = program.async_main;\n        delete program.async_main;\n    }\n\n    if (program.main !== undefined && program.async_main !== undefined) {\n        throw new Error(`Program ${program.name} has both a main and async_main (deprecated) function.`);\n    }\n\n    // check if main is async\n    if (program.main !== undefined && program.main.constructor.name !== \"AsyncFunction\") {\n        console.warn(`Program ${program.name} has a main function that is not async. This is deprecated and will be removed in the future. Please make main async.`);\n\n        // migrate: wrap main in an async function\n        const old_main = program.main;\n        program.main = async (data) => {\n            return old_main(data);\n        }\n    }\n\n    program = program as Program;\n\n    // can't check what it takes and returns because javascript!\n    // just register it and the user can deal with the error if it doesn't work\n\n    return {\n        program,\n        built_in,\n    };\n}\n\nexport const determine_program_name_from_js = async (js_code: string): Promise<string> => {\n    const reg = await build_registrant_from_js(js_code);\n    return reg.program.name;\n}\n\n\n// mounts and registers a program and outputs errors to the terminal\nexport const mount_and_register_with_output = async (filename: string, content: string, prog_reg: ProgramRegistry | UserspaceProgramRegistry, term: WrappedTerminal, output_success = false) => {\n    const { PREFABS, FG, STYLE } = ANSI;\n\n    let reg: ProgramRegistrant;\n\n    try {\n        reg = await build_registrant_from_js(content);\n    } catch (e) {\n        if (e.message.endsWith(\"is not compatible with Node.js.\")) {\n            // silently skip node.js incompatible programs\n            // yes this is a weird way to do it, but better than changing how build_registrant works\n            return;\n        }\n\n        term.writeln(`${PREFABS.error}Failed to prepare program from '${filename}'.${STYLE.reset_all}`);\n        term.writeln(`${PREFABS.error}${e}${STYLE.reset_all}`);\n        term.writeln(`${PREFABS.error}Skipping mount...${STYLE.reset_all}`);\n        return;\n    }\n\n    try {\n        await prog_reg.registerProgram(reg);\n\n        if (output_success) {\n            term.writeln(`${FG.cyan}(+) ${reg.program.name}${STYLE.reset_all}`);\n        }\n    } catch (e) {\n        term.writeln(`${PREFABS.error}Failed to mount program '${reg.program.name}'.${STYLE.reset_all}`);\n        term.writeln(`${PREFABS.error}${e}${STYLE.reset_all}`);\n        term.writeln(`${PREFABS.error}Skipping mount...${STYLE.reset_all}`);\n    }\n}\n\n// recurses through a directory and mounts and registers all programs in it as well as its subdirectories\nexport const recurse_mount_and_register_with_output = async (fs: AbstractFileSystem, dir_path: string, prog_registry: ProgramRegistry | UserspaceProgramRegistry, term: WrappedTerminal) => {\n    const entries = await fs.list_dir(dir_path);\n\n    for (const entry of entries) {\n        const entry_path = fs.join(dir_path, entry);\n\n        if (await fs.dir_exists(entry_path)) {\n            await recurse_mount_and_register_with_output(fs, entry_path, prog_registry, term);\n        } else {\n            if (!entry.endsWith(\".js\")) {\n                continue;\n            }\n\n            const content = await fs.read_file(entry_path) as string;\n            await mount_and_register_with_output(entry, content, prog_registry, term);\n        }\n    }\n}\n\n// TODO: these 2 methods are a bit messy! perhaps remove the output stuff and just have the user deal with it\n\nexport interface UserspaceProgramRegistry {\n    getProgram(name: string): Program | undefined;\n    listProgramNames(includes_builtin?: boolean, includes_mounted?: boolean): string[];\n    registerProgram(program_reg: ProgramRegistrant): Promise<void>;\n    unregister(name: string): Promise<void>;\n    forceUnregister(name: string): Promise<void>;\n    build_registrant_from_js(js_code: string, built_in?: boolean): Promise<ProgramRegistrant>;\n    determine_program_name_from_js(js_code: string): Promise<string>;\n    mount_and_register_with_output(filename: string, content: string, term: WrappedTerminal, output_success?: boolean): Promise<void>;\n    recurse_mount_and_register_with_output(fs: AbstractFileSystem, dir_path: string, term: WrappedTerminal): Promise<void>;\n}\n\nexport class ProgramRegistry {\n    readonly #program_regs: Map<string, ProgramRegistrant> = new Map();\n\n    async registerProgram(program_reg: ProgramRegistrant) {\n        const program = program_reg.program;\n\n        if (this.#program_regs.has(program.name)) {\n            throw new Error(`Program with name ${program.name} already exists.`);\n        }\n\n        if (globalThis.OLLIEOS_NODE && program.node_opt_out) {\n            // don't register this program if it is not compatible with node.js\n            return;\n        }\n\n        this.#program_regs.set(program.name, program_reg);\n    }\n\n\n    getProgramRegistrant(name: string): ProgramRegistrant | undefined {\n        return this.#program_regs.get(name);\n    }\n\n    getProgram(name: string): Program | undefined {\n        const program_reg = this.getProgramRegistrant(name);\n        if (program_reg === undefined) {\n            return undefined;\n        }\n\n        return program_reg.program;\n    }\n\n\n    listProgramRegistrants(includes_builtin = true, includes_mounted = false): ProgramRegistrant[] {\n        const arr = Array.from(this.#program_regs.values());\n\n        if (includes_builtin && includes_mounted) {\n            return arr;\n        }\n\n        if (includes_builtin && !includes_mounted) {\n            return arr.filter((program_reg) => program_reg.built_in);\n        }\n\n        if (!includes_builtin && includes_mounted) {\n            return arr.filter((program_reg) => !program_reg.built_in);\n        }\n    }\n\n    listProgramNames(includes_builtin = true, includes_mounted = false): string[] {\n        const arr = Array.from(this.#program_regs.keys());\n\n        if (includes_builtin && includes_mounted) {\n            return arr;\n        }\n\n        if (includes_builtin && !includes_mounted) {\n            return arr.filter((program_name) => this.getProgramRegistrant(program_name)?.built_in);\n        }\n\n        if (!includes_builtin && includes_mounted) {\n            return arr.filter((program_name) => !this.getProgramRegistrant(program_name)?.built_in);\n        }\n    }\n\n    listPrograms(includes_builtin = true, includes_mounted = false): Program[] {\n        return this.listProgramRegistrants(includes_builtin, includes_mounted).map((program_reg) => program_reg.program);\n    }\n\n\n    async forceUnregister(name: string) {\n        this.#program_regs.delete(name);\n    }\n\n    async unregister(name: string) {\n        if (!this.#program_regs.has(name)) {\n            throw new Error(`Program with name ${name} does not exist.`);\n        }\n\n        await this.forceUnregister(name);\n    }\n\n    // note that some methods above are async because the userspace proxy needs them to be async\n\n    // TODO: move usage of above methods to use class methods instead of the standalone functions\n\n    async build_registrant_from_js(js_code: string, built_in = false): Promise<ProgramRegistrant> {\n        return build_registrant_from_js(js_code, built_in);\n    }\n\n    async determine_program_name_from_js(js_code: string): Promise<string> {\n        return determine_program_name_from_js(js_code);\n    }\n\n    async mount_and_register_with_output(filename: string, content: string, term: WrappedTerminal, output_success = false) {\n        return mount_and_register_with_output(filename, content, this, term, output_success);\n    }\n\n    async recurse_mount_and_register_with_output(fs: AbstractFileSystem, dir_path: string, term: WrappedTerminal) {\n        return recurse_mount_and_register_with_output(fs, dir_path, this, term);\n    }\n\n    create_userspace_proxy(init_program: string, fs: AbstractFileSystem): UserspaceProgramRegistry {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const proxy = Object.create(null);\n\n        const check_protected = async (name: string) => {\n            const reg = self.getProgramRegistrant(name);\n\n            // userspace cannot unregister built-in programs\n            if (reg?.built_in) {\n                throw new Error(`Security Error: Built-in program '${name}' is protected and cannot be modified.`);\n            }\n\n            // userspace cannot unregister the loaded init system\n            // TODO: is this actually necessary security wise? it wont get run as kernel til next boot anyway. maybe the boot file should be protected instead?\n            if (name === init_program) {\n                throw new Error(`Security Error: The init system program '${name}' cannot be modified.`);\n            }\n\n            // userspace cannot unregister program referenced by /sys/privilege_agent\n            let privilege_agent_program = \"default_privilege_agent\";\n            try {\n                const pa_data = await fs.read_file(\"/sys/privilege_agent\") as string;\n                privilege_agent_program = pa_data.trim();\n            } catch {\n                // ignore error\n            }\n\n            if (!privilege_agent_program) {\n                privilege_agent_program = \"default_privilege_agent\";\n            }\n\n            if (name === privilege_agent_program) {\n                throw new Error(`Security Error: The privilege agent program '${name}' cannot be modified.`);\n            }\n        }\n\n        Object.defineProperties(proxy, {\n            getProgram: {\n                value: (name: string) => self.getProgram(name),\n                enumerable: true\n            },\n            listProgramNames: {\n                value: (inc_builtin?: boolean, inc_mounted?: boolean) =>\n                    self.listProgramNames(inc_builtin, inc_mounted),\n                enumerable: true\n            },\n            registerProgram: {\n                value: async (program_reg: ProgramRegistrant) => {\n                    if (program_reg.built_in) {\n                        throw new Error(\"Security Error: Cannot register built-in programs from userspace.\");\n                    }\n\n                    await check_protected(program_reg.program.name);\n                    await self.registerProgram(program_reg);\n                },\n                enumerable: true\n            },\n            unregister: {\n                value: async (name: string) => {\n                    await check_protected(name);\n                    await self.unregister(name);\n                },\n                enumerable: true\n            },\n            forceUnregister: {\n                value: async (name: string) => {\n                    await check_protected(name);\n                    await self.forceUnregister(name);\n                },\n                enumerable: true\n            },\n\n            // its fine to build the registrant as builtin, but not fine to register it\n            build_registrant_from_js: {\n                value: async (js_code: string, built_in = false) =>\n                    self.build_registrant_from_js(js_code, built_in),\n                enumerable: true\n            },\n            determine_program_name_from_js: {\n                value: async (js_code: string) =>\n                    self.determine_program_name_from_js(js_code),\n                enumerable: true\n            },\n\n            // ensure the proxy is used for these methods to enforce protections\n            mount_and_register_with_output: {\n                value: async (filename: string, content: string, term: WrappedTerminal, output_success = false) =>\n                    mount_and_register_with_output(filename, content, proxy, term, output_success),\n                enumerable: true\n            },\n            recurse_mount_and_register_with_output: {\n                value: async (dir_path: string, term: WrappedTerminal) =>\n                    recurse_mount_and_register_with_output(fs, dir_path, proxy, term),\n                enumerable: true\n            },\n        });\n\n        return Object.freeze(proxy);\n    }\n}\n\n// TODO: restructure methods to not need fs (i.e. move this closer to the kernel where fs is accessible)\n\n","/**\n * Error thrown when a path is not found.\n *\n * @group Userspace\n * @category Filesystem\n */\nexport class PathNotFoundError extends Error {\n    constructor(path: string) {\n        super(`Path not found: ${path}`);\n    }\n}\n\n/**\n * Error thrown when attempting to delete a non-empty directory without recursive flag.\n *\n * @group Userspace\n * @category Filesystem\n */\nexport class NonRecursiveDirectoryError extends Error {\n    constructor(path: string) {\n        super(`Refusing to delete non-empty directory: ${path}`);\n    }\n}\n\n/**\n * Error thrown when attempting to move a directory into a non-empty destination.\n *\n * @group Userspace\n * @category Filesystem\n */\nexport class MoveDestinationDirectoryNotEmptyError extends Error {\n    constructor(path: string) {\n        super(`Destination directory is not empty: ${path}`);\n    }\n}\n\n/**\n * Error thrown when attempting to write to a read-only path.\n *\n * @group Userspace\n * @category Filesystem\n */\nexport class ReadOnlyError extends Error {\n    constructor(path: string) {\n        super(`Path is read-only: ${path}`);\n    }\n}\n\n/**\n * Event types emitted after filesystem operations.\n *\n * @group Userspace\n * @category Filesystem\n */\nexport enum FSEventType {\n    READING_FILE,\n    WROTE_FILE,\n    DELETED_FILE,\n    MOVED_FILE,\n    SET_READONLY,\n\n    LISTING_DIR,\n    MADE_DIR,\n    DELETED_DIR,\n    MOVED_DIR,\n\n    SET_CWD,\n    GETTING_CWD,\n    SET_HOME,\n    GETTING_HOME,\n    SET_ROOT,\n    GETTING_ROOT,\n\n    CHECKING_EXISTS,\n    CHECKING_DIR_EXISTS,\n}\n\n// TODO: ensure all functions fire these events (opfs doesnt at all yet!)\n\n/**\n * Handler type for filesystem events.\n * @param data Various string data related to the event, but most likely a path.\n * @param fs The filesystem instance emitting the event.\n *\n * @group Userspace\n * @category Filesystem\n */\nexport type FSEventHandler = (data: string, fs: AbstractFileSystem) => void;\n\n/**\n * Interface for interacting with the chosen filesystem implementation from userspace.\n *\n * @group Userspace\n * @category Filesystem\n */\nexport interface UserspaceFileSystem {\n    get_unique_fs_type_name(): string;\n    erase_all(): Promise<void>;\n    purge_cache(smart?: boolean): void;\n    read_file(path: string, as_uint?: boolean): Promise<string | Uint8Array>;\n    write_file(path: string, data: string | Uint8Array, force?: boolean): Promise<void>;\n    delete_file(path: string): Promise<void>;\n    move_file(path: string, new_path: string): Promise<void>;\n    list_dir(path: string, dirs_first?: boolean): Promise<string[]>;\n    make_dir(path: string): Promise<void>;\n    delete_dir(path: string, recursive?: boolean): Promise<void>;\n    move_dir(src: string, dest: string, force_move_inside?: boolean): Promise<void>;\n    set_readonly(path: string, readonly: boolean): Promise<void>;\n    is_readonly(path: string): Promise<boolean>;\n    exists(path: string): Promise<boolean>;\n    dir_exists(path: string): Promise<boolean>;\n    join(base_dir: string, ...paths: string[]): string;\n    absolute(path: string): string;\n    get_cwd(): string;\n    set_cwd(path: string): void;\n    get_home(): string;\n    get_root(): string;\n}\n\n// TODO: could protect erase_all but then also need to check recursive deletion, doesnt really gain much\n\n/**\n * Interface for interacting with a filesystem implementation.\n *\n * @group Kernel (Privileged)\n * @category Filesystem\n */\nexport abstract class AbstractFileSystem {\n    //TODO: dry\n\n    // note some members are conventionally private with _ prefix to allow implementations to access them\n    // they wont be exposed to userspace though\n\n    _initialised = false;\n\n    readonly #cache: Map<string, { readonly: boolean, content: string | Uint8Array, as_uint: boolean }> = new Map();\n    readonly #callbacks: Map<FSEventType, FSEventHandler[]> = new Map();\n\n    _root = \"/\";\n    _home = \"/home\";\n    _cwd = this._home;\n\n    abstract get_unique_fs_type_name(): string;\n    abstract erase_all(): Promise<void>;\n\n    abstract is_ready(): Promise<boolean>;\n\n    purge_cache(smart = false): void {\n        if (smart) {\n            for (const path in this.#cache) {\n                if (!this.exists_direct(path)) {\n                    this.#cache.delete(path);\n                }\n            }\n        } else {\n            this.#cache.clear();\n        }\n    }\n\n    force_remove_from_cache(path: string): void {\n        this.#cache.delete(path);\n    }\n\n    remote_purge_cache(smart: boolean): void {\n        localStorage.setItem(\"purge_cache\", smart.toString());\n    }\n\n    remote_remove_from_cache(path: string): void {\n        localStorage.setItem(\"remove_from_cache\", path);\n    }\n\n    #remote_listener(): void {\n        const purge_cache = localStorage.getItem(\"purge_cache\");\n        if (purge_cache) {\n            this.purge_cache(purge_cache === \"true\");\n            localStorage.removeItem(\"purge_cache\");\n        }\n\n        const remove_from_cache = localStorage.getItem(\"remove_from_cache\");\n        if (remove_from_cache) {\n            this.force_remove_from_cache(remove_from_cache);\n            localStorage.removeItem(\"remove_from_cache\");\n        }\n    }\n\n\n    register_callback(event_type: FSEventType, callback: FSEventHandler): () => void {\n        // if there are no callbacks for this event type, create an empty array\n        if (!this.#callbacks.has(event_type)) {\n            this.#callbacks.set(event_type, []);\n        }\n\n        // add callback to array\n        this.#callbacks.get(event_type).push(callback);\n\n        // return function to remove callback\n        return () => {\n            this.#callbacks.get(event_type).splice(this.#callbacks.get(event_type).indexOf(callback), 1);\n        }\n    }\n\n    _call_callbacks(event_type: FSEventType, data: string): void {\n        // call all callbacks\n        for (const callback of this.#callbacks.get(event_type) ?? []) {\n            callback(data, this);\n        }\n    }\n\n\n    abstract read_file_direct(path: string, as_uint: boolean): Promise<string | Uint8Array>;\n    abstract write_file_direct(path: string, data: string | Uint8Array): Promise<void>;\n    abstract delete_file_direct(path: string): Promise<void>;\n    // does not check if destination exists\n    abstract move_file_direct(src: string, new_path: string): Promise<void>;\n    abstract set_readonly_direct(path: string, readonly: boolean): Promise<void>;\n    abstract is_readonly_direct(path: string): Promise<boolean>;\n\n\n    async read_file(path: string, as_uint = false): Promise<string | Uint8Array> {\n        // prevent prototype pollution\n\n        this._call_callbacks(FSEventType.READING_FILE, path);\n\n        // check if file is in cache and still exists, as well as if it's the correct type\n        const cached = this.#cache.get(path);\n        if (cached && await this.exists(path) && cached.as_uint === as_uint) {\n            return this.#cache.get(path).content;\n        }\n\n        // if not, read it from disk and cache it\n        const content = await this.read_file_direct(path, as_uint);\n        this.#cache.set(path, { readonly: await this.is_readonly(path), content, as_uint });\n        return content;\n    }\n\n    async write_file(path: string, data: string | Uint8Array, force = false): Promise<void> {\n        // check if file is readonly\n        let readonly = false;\n        if (await this.exists(path)) {\n            readonly = await this.is_readonly(path);\n            \n            if (!force && readonly) {\n                throw new ReadOnlyError(path);\n            }\n        }\n\n        // write to disk and cache\n        this.#cache.set(path, { readonly, content: data, as_uint: data instanceof Uint8Array });\n        await this.write_file_direct(path, data);\n        this._call_callbacks(FSEventType.WROTE_FILE, path);\n    }\n\n    async delete_file(path: string): Promise<void> {\n        // delete from cache and disk\n        if (this.#cache.has(path)) {\n            this.#cache.delete(path);\n        }\n        await this.delete_file_direct(path);\n        this._call_callbacks(FSEventType.DELETED_FILE, path);\n    }\n\n    // does not check if destination exists\n    async move_file(path: string, new_path: string): Promise<void> {\n        // move in cache and disk\n        this.#cache.set(new_path, this.#cache.get(path));\n        this.#cache.delete(path);\n        await this.move_file_direct(path, new_path);\n        this._call_callbacks(FSEventType.MOVED_FILE, path);\n    }\n\n    async set_readonly(path: string, readonly: boolean): Promise<void> {\n        // check if file exists\n        if (!await this.exists(path)) {\n            throw new PathNotFoundError(path);\n        }\n\n        // set readonly in cache and disk\n        const entry = this.#cache.get(path);\n        if (entry) {\n            entry.readonly = readonly;\n            this.#cache.set(path, entry);\n        } else {\n            this.#cache.set(path, {readonly, content: await this.read_file(path), as_uint: false});\n        }\n\n        await this.set_readonly_direct(path, readonly);\n        this._call_callbacks(FSEventType.SET_READONLY, path);\n    }\n\n    async is_readonly(path: string): Promise<boolean> {\n        // check if file exists\n        if (!await this.exists(path)) {\n            throw new PathNotFoundError(path);\n        }\n\n        // check if file is in cache\n        const cached = this.#cache.get(path);\n        if (cached) {\n            return cached.readonly;\n        }\n\n        // if not, check on disk (cannot cache as would need to read content, causes recursive call)\n        return this.is_readonly_direct(path);\n    }\n\n\n    abstract list_dir(path: string, dirs_first?: boolean): Promise<string[]>;\n    // (recursive)\n    abstract make_dir(path: string): Promise<void>;\n    abstract delete_dir_direct(path: string, recursive: boolean): Promise<void>;\n    abstract move_dir_direct(src: string, dest: string, force_move_inside: boolean): Promise<void>;\n\n    async delete_dir(path: string, recursive = false): Promise<void> {\n        await this.delete_dir_direct(path, recursive);\n\n        // smart purge cache\n        this.purge_cache(true);\n    }\n\n    async move_dir(src: string, dest: string, force_move_inside = false): Promise<void> {\n        await this.move_dir_direct(src, dest, force_move_inside);\n\n        // smart purge cache\n        this.purge_cache(true);\n    }\n\n    get_cwd(): string {\n        this._call_callbacks(FSEventType.GETTING_CWD, this._cwd);\n        return this._cwd;\n    }\n\n    set_cwd(path: string): void {\n        // if path ends with /, remove it\n        if (path.endsWith(\"/\")) {\n            path = path.slice(0, -1);\n        }\n\n        // if path is empty, set to root\n        if (path === \"\") {\n            path = this._root;\n        }\n\n        this._cwd = path;\n        this._call_callbacks(FSEventType.SET_CWD, path);\n    }\n\n\n    get_home(): string {\n        this._call_callbacks(FSEventType.GETTING_HOME, this._home);\n        return this._home;\n    }\n\n    set_home(path: string): void {\n        this._home = path;\n        this._call_callbacks(FSEventType.SET_HOME, path);\n    }\n\n    get_root(): string {\n        this._call_callbacks(FSEventType.GETTING_ROOT, this._root);\n        return this._root;\n    }\n\n    set_root(path: string): void {\n        this._root = path;\n        this._call_callbacks(FSEventType.SET_ROOT, path);\n    }\n\n\n    abstract exists_direct(path: string): Promise<boolean>;\n    abstract dir_exists(path: string): Promise<boolean>;\n\n    async exists(path: string): Promise<boolean> {\n        // check if file is in cache\n        if (this.#cache.has(path)) {\n            return true;\n        }\n\n        // if not, check if it exists on disk\n        this._call_callbacks(FSEventType.CHECKING_EXISTS, path);\n        return this.exists_direct(path);\n    }\n\n    absolute(path: string): string {\n        // if path is blank, path is root\n        if (path === \"\") {\n            return this._root;\n        }\n\n        // if path is ., return cwd\n        // TODO: is it safer to run this assumption then do the rest of the code rather than do the following root/cwd checks?\n        if (path === \".\") {\n            return this._cwd;\n        }\n\n        // if path is ~, return home\n        // TODO: again, same for this and the later ~/ check\n        if (path === \"~\") {\n            return this._home;\n        }\n\n        // if path starts with cwd and doesn't contain .., it is absolute\n        if (path.startsWith(this._cwd) && !path.includes(\"..\")) {\n            return path;\n        }\n\n        // if path starts with root and doesn't contain .., it is absolute\n        if (path.startsWith(this._root) && !path.includes(\"..\")) {\n            return path;\n        }\n\n        // drop leading ./\n        if (path.startsWith(\"./\")) {\n            path = path.slice(2);\n        }\n\n\n        let effective_cwd = this._cwd;\n\n        // if path starts with .., step up the cwd\n        while (path.startsWith(\"..\") && effective_cwd !== this._root) {\n            path = path.slice(2);\n\n            // drop leading /\n            if (path.startsWith(\"/\")) {\n                path = path.slice(1);\n            }\n\n            effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\n        }\n\n        // TODO: doesn't support middle of path ..\n        // if path ends with .., remove the last part of the full path\n        while (path.endsWith(\"..\")) {\n            path = path.slice(0, path.lastIndexOf(\"..\"));\n\n            // drop trailing /\n            if (path.endsWith(\"/\")) {\n                path = path.slice(0, path.length - 1);\n            }\n\n            // slice path, slicing effective_cwd if path is empty\n            if (path === \"\") {\n                effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\n            } else {\n                path = path.slice(0, path.lastIndexOf(\"/\"));\n\n                if (path === \"\") {\n                    effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\n                }\n            }\n        }\n\n        // if path starts with ~/, replace it with home\n        if (path.startsWith(\"~/\")) {\n            path = path.slice(2);\n            effective_cwd = this._home;\n        }\n\n        // if path still starts with /, drop it\n        if (path.startsWith(\"/\")) {\n            path = path.slice(1);\n        }\n\n        return this.join(effective_cwd, path);\n    }\n\n    join(base_dir: string, ...paths: string[]): string {\n        // drop trailing /\n        if (base_dir.endsWith(\"/\")) {\n            base_dir = base_dir.slice(0, base_dir.length - 1);\n        }\n\n        // join base_dir and path, using slash if path is not empty\n        for (let path of paths) {\n            if (path.startsWith(\"/\")) {\n                path = path.slice(1);\n            }\n\n            if (path === \"\") {\n                continue;\n            }\n\n            base_dir += \"/\" + path;\n        }\n\n        return base_dir;\n    }\n\n    protected constructor() {\n        // check if the cache should be purged from remote changes\n        setInterval(() => this.#remote_listener(), 100);\n    }\n\n    static create_userspace_proxy(fs: AbstractFileSystem): UserspaceFileSystem {\n        const self = fs;\n        const proxy = Object.create(null);\n\n        // write protect certain kernel secured paths\n        const check_path = (path: string): string => {\n            const absolute_path = self.absolute(path);\n\n            const is_protected =\n                absolute_path === \"/sys\" ||\n                absolute_path.startsWith(\"/sys/\") ||\n                absolute_path === \"/boot\" ||\n                absolute_path.startsWith(\"/boot/\");\n\n            if (is_protected) {\n                throw new ReadOnlyError(absolute_path);\n            }\n\n            return absolute_path;\n        };\n\n        Object.defineProperties(proxy, {\n            get_unique_fs_type_name: { value: () => self.get_unique_fs_type_name(), enumerable: true },\n            erase_all: { value: () => self.erase_all(), enumerable: true },\n            purge_cache: { value: (smart?: boolean) => self.purge_cache(smart), enumerable: true },\n            read_file: { value: (path: string, as_uint?: boolean) => self.read_file(self.absolute(path), as_uint), enumerable: true },\n            list_dir: { value: (path: string, dirs_first?: boolean) => self.list_dir(self.absolute(path), dirs_first), enumerable: true },\n            exists: { value: (path: string) => self.exists(self.absolute(path)), enumerable: true },\n            dir_exists: { value: (path: string) => self.dir_exists(self.absolute(path)), enumerable: true },\n            is_readonly: {\n                value: async (path: string) => {\n                    try {\n                        check_path(path);\n                    } catch (e) {\n                        if (e instanceof ReadOnlyError) {\n                            return true;\n                        }\n\n                        throw e;\n                    }\n\n                    return await self.is_readonly(self.absolute(path));\n                },\n                enumerable: true\n            },\n            join: { value: (base: string, ...paths: string[]) => self.join(base, ...paths), enumerable: true },\n            absolute: { value: (path: string) => self.absolute(path), enumerable: true },\n            get_cwd: { value: () => self.get_cwd(), enumerable: true },\n            get_home: { value: () => self.get_home(), enumerable: true },\n            get_root: { value: () => self.get_root(), enumerable: true },\n            write_file: {\n                value: (path: string, data: string | Uint8Array, force?: boolean) =>\n                    self.write_file(check_path(path), data, force),\n                enumerable: true\n            },\n            delete_file: {\n                value: (path: string) => self.delete_file(check_path(path)),\n                enumerable: true\n            },\n            move_file: {\n                value: (path: string, new_path: string) => {\n                    return self.move_file(check_path(path), check_path(new_path));\n                },\n                enumerable: true\n            },\n            make_dir: {\n                value: (path: string) => self.make_dir(check_path(path)),\n                enumerable: true\n            },\n            delete_dir: {\n                value: (path: string, recursive?: boolean) => self.delete_dir(check_path(path), recursive),\n                enumerable: true\n            },\n            move_dir: {\n                value: (src: string, dest: string, move_inside?: boolean) => {\n                    return self.move_dir(check_path(src), check_path(dest), move_inside);\n                },\n                enumerable: true\n            },\n            set_readonly: {\n                value: (path: string, readonly: boolean) => self.set_readonly(check_path(path), readonly),\n                enumerable: true\n            },\n            set_cwd: { value: (path: string) => self.set_cwd(path), enumerable: true }\n        });\n\n        return Object.freeze(proxy);\n    }\n}\n\n// TODO: need a way to block programs from accessing the localstorage/OPFS themselves directly, maybe need a function wrapper for that to shadow it away?\n\n// TODO: doc methods in both interfaces!\n","import type {AbstractWindow, AbstractWindowManager} from \"./windowing\";\nimport type {AbstractShell} from \"../abstract_shell\";\nimport type {ParsedCommandLine} from \"./index\";\n\nexport interface IPCMessage {\n    from: number;\n    to: number;\n\n    data: unknown;\n}\n\nexport type IPCChannelListener = (msg: IPCMessage) => Promise<void>;\n\ninterface IPCChannel {\n    initiator: number;\n    peer: number;\n\n    initiator_to_peer_queue: IPCMessage[];\n    peer_to_initiator_queue: IPCMessage[];\n\n    // pid -> set of listeners\n    listeners: Map<number, Set<IPCChannelListener>>;\n}\n\nexport type IPCServiceOnConnectionCallback = (channel_id: number, from_pid: number) => Promise<void>;\n\ninterface IPCService {\n    pid: number;\n    on_connection: IPCServiceOnConnectionCallback;\n}\n\nexport const KERNEL_FAKE_PID = 0;\nconst UNASSIGNED_FAKE_PID = -1;\n\nexport interface UserspaceIPCManager {\n    service_register(name: string, on_connection: IPCServiceOnConnectionCallback): void;\n    service_unregister(name: string): void;\n    service_lookup(name: string): number | undefined;\n    create_channel(service_name: string): number | null;\n    destroy_channel(channel_id: number): void;\n    channel_listen(channel_id: number, listener: IPCChannelListener): boolean;\n    channel_unlisten(channel_id: number, listener: IPCChannelListener): boolean;\n    channel_send(channel_id: number, data: unknown): boolean;\n}\n\nexport class IPCManager {\n    readonly #process_manager: ProcessManager;\n\n    // service name -> IPCService\n    readonly #services: Map<string, IPCService> = new Map();\n\n    // channel id -> IPCChannel\n    readonly #channels: Map<number, IPCChannel> = new Map();\n    #next_channel_id = 1;\n\n    constructor(process_manager: ProcessManager) {\n        this.#process_manager = process_manager;\n\n        // clean up dead services and channels periodically\n        // TODO: add a global exit listener to process manager to be immediately notified of process exits\n        setInterval(() => {\n            // clean up services\n            for (const [name, service] of this.#services) {\n                const process = this.#process_manager.get_process(service.pid);\n                if (!process) {\n                    this.#services.delete(name);\n                }\n            }\n\n            // clean up channels\n            for (const [channel_id, channel] of this.#channels) {\n                const initiator_process = this.#process_manager.get_process(channel.initiator);\n                const peer_process = this.#process_manager.get_process(channel.peer);\n\n                if (!initiator_process || !peer_process) {\n                    this.#channels.delete(channel_id);\n                }\n            }\n        }, 10000);\n    }\n\n    dispose_all(): void {\n        this.#services.clear();\n        this.#channels.clear();\n    }\n\n    service_register(name: string, pid: number, on_connection: IPCServiceOnConnectionCallback): void {\n        this.#services.set(name, { pid, on_connection });\n    }\n\n    // TODO: disconnect callback? or change the on_connection to on_event with different event types\n\n    service_unregister(name: string): void {\n        this.#services.delete(name);\n    }\n\n    service_lookup(name: string): number | undefined {\n        const service = this.#services.get(name);\n\n        if (!service) {\n            return undefined;\n        }\n\n        // check if process is still running\n        const process = this.#process_manager.get_process(service.pid);\n        if (!process) {\n            this.#services.delete(name);\n            return undefined;\n        }\n\n        return service.pid;\n    }\n\n    create_direct_channel(initiator_pid: number, peer_pid: number): number {\n        const channel_id = this.#next_channel_id++;\n\n        this.#channels.set(channel_id, {\n            initiator: initiator_pid,\n            peer: peer_pid,\n\n            initiator_to_peer_queue: [],\n            peer_to_initiator_queue: [],\n\n            listeners: new Map(),\n        });\n\n        return channel_id;\n    }\n\n    create_channel(initiator_pid: number, service_name: string): number | null {\n        const peer_pid = this.service_lookup(service_name);\n\n        if (!peer_pid) {\n            return null;\n        }\n\n        const channel_id = this.create_direct_channel(initiator_pid, peer_pid);\n\n        // notify service of new connection without blocking\n        const service = this.#services.get(service_name)!;\n        service.on_connection(channel_id, initiator_pid).catch((err) => {\n            console.error(\"IPC service on_connection error:\", err);\n        });\n\n        return channel_id;\n    }\n\n    reserve_kernel_channel(): number {\n        return this.create_direct_channel(KERNEL_FAKE_PID, UNASSIGNED_FAKE_PID);\n    }\n\n    assign_kernel_channel(channel_id: number, peer_pid: number): boolean {\n        const channel = this.#channels.get(channel_id);\n        if (!channel) {\n            return false;\n        }\n\n        if (channel.initiator !== KERNEL_FAKE_PID || channel.peer !== UNASSIGNED_FAKE_PID) {\n            return false;\n        }\n\n        channel.peer = peer_pid;\n        return true;\n    }\n\n    destroy_channel(channel_id: number): void {\n        this.#channels.delete(channel_id);\n    }\n\n    channel_listen(channel_id: number, listening_pid: number, listener: IPCChannelListener): boolean {\n        const channel = this.#channels.get(channel_id);\n        if (!channel) {\n            return false;\n        }\n\n        if (channel.initiator !== listening_pid && channel.peer !== listening_pid) {\n            return false;\n        }\n\n        if (!channel.listeners.has(listening_pid)) {\n            channel.listeners.set(listening_pid, new Set());\n        }\n\n        channel.listeners.get(listening_pid)!.add(listener);\n        return true;\n    }\n\n    channel_unlisten(channel_id: number, listening_pid: number, listener: IPCChannelListener): boolean {\n        const channel = this.#channels.get(channel_id);\n        if (!channel) {\n            return false;\n        }\n\n        if (channel.initiator !== listening_pid && channel.peer !== listening_pid) {\n            return false;\n        }\n\n        const listeners = channel.listeners.get(listening_pid);\n        if (!listeners) {\n            return false;\n        }\n\n        listeners.delete(listener);\n        return true;\n    }\n\n    channel_send(channel_id: number, from_pid: number, data: unknown): boolean {\n        const channel = this.#channels.get(channel_id);\n        if (!channel) {\n            return false;\n        }\n\n        let msg: IPCMessage;\n        if (channel.initiator === from_pid) {\n            msg = {\n                from: from_pid,\n                to: channel.peer,\n                data,\n            };\n\n            channel.initiator_to_peer_queue.push(msg);\n        } else if (channel.peer === from_pid) {\n            msg = {\n                from: from_pid,\n                to: channel.initiator,\n                data,\n            };\n\n            channel.peer_to_initiator_queue.push(msg);\n        } else {\n            return false;\n        }\n\n        // notify listeners on the receiving end without blocking\n        const to_pid = msg.to;\n        const listeners = channel.listeners.get(to_pid);\n        if (listeners) {\n            for (const listener of listeners) {\n                listener(msg).catch((err) => {\n                    console.error(\"IPC channel listener error:\", err);\n                });\n            }\n        }\n\n        return true;\n    }\n\n    create_userspace_proxy(process_pid: number): UserspaceIPCManager {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const proxy = Object.create(null);\n\n        Object.defineProperties(proxy, {\n            service_register: { value: (name: string, on_connection: IPCServiceOnConnectionCallback) => {\n                self.service_register(name, process_pid, on_connection);\n            }, enumerable: true },\n            service_unregister: { value: (name: string) => {\n                self.service_unregister(name);\n            }, enumerable: true },\n            service_lookup: { value: (name: string) => {\n                return self.service_lookup(name);\n            }, enumerable: true },\n            create_channel: { value: (service_name: string) => {\n                return self.create_channel(process_pid, service_name);\n            }, enumerable: true },\n            destroy_channel: { value: (channel_id: number) => {\n                self.destroy_channel(channel_id);\n            }, enumerable: true },\n            channel_listen: { value: (channel_id: number, listener: IPCChannelListener) => {\n                return self.channel_listen(channel_id, process_pid, listener);\n            }, enumerable: true },\n            channel_unlisten: { value: (channel_id: number, listener: IPCChannelListener) => {\n                return self.channel_unlisten(channel_id, process_pid, listener);\n            }, enumerable: true },\n            channel_send: { value: (channel_id: number, data: unknown) => {\n                return self.channel_send(channel_id, process_pid, data);\n            }, enumerable: true },\n        });\n\n        return Object.freeze(proxy);\n    }\n}\n\n// TODO: could migrate the stuff where programs grab \"scary\" stuff like WindowManager and ProcessManager to be services\n\nexport enum ProcessAttachment {\n    FOREGROUND,\n    BACKGROUND,\n    DETACHED,\n}\n\nexport interface UserspaceOtherProcessContext {\n    readonly pid: number;\n    readonly created_at: Date;\n    readonly is_detached: boolean;\n    readonly is_background: boolean;\n    readonly is_foreground: boolean;\n    readonly attachment: ProcessAttachment;\n    readonly source_command: ParsedCommandLine;\n}\n\nexport interface UserspaceProcessContext extends UserspaceOtherProcessContext {\n    detach(silently?: boolean): void;\n    kill(exit_code?: number): void;\n    create_timeout(callback: () => void, delay: number): number;\n    cancel_timeout(id: number): void;\n    create_interval(callback: () => void, interval: number): number;\n    clear_interval(id: number): void;\n    create_window(): AbstractWindow | null;\n}\n\nexport class ProcessContext {\n    readonly #pid: number;\n    readonly #manager: ProcessManager;\n\n    readonly #source_command: ParsedCommandLine;\n    readonly #created_at: Date = new Date();\n    readonly #shell: AbstractShell | undefined;\n\n    readonly #exit_listeners: Set<(exit_code: number) => Promise<void> | void> = new Set();\n\n    #attachment: ProcessAttachment = ProcessAttachment.FOREGROUND;\n    #detach_silently = false;\n\n    readonly #timeouts: Set<number> = new Set();\n    readonly #timeout_promises: Map<number, Set<{resolve: (finished: boolean) => void}>> = new Map(); // timeout id -> promise resolvers (for waiting on timeouts but listening to cancellation)\n    readonly #timeout_cancel_callbacks: Map<number, () => void> = new Map(); // timeout id -> cancel callback\n\n    readonly #intervals: Set<number> = new Set();\n\n    readonly #windows: Set<AbstractWindow> = new Set();\n\n    constructor(pid: number, source_command: ParsedCommandLine, registry: ProcessManager, shell?: AbstractShell) {\n        this.#pid = pid;\n        this.#source_command = source_command;\n        this.#manager = registry;\n\n        if (shell) {\n            this.#shell = shell;\n        }\n\n        if (source_command.run_in_bg) {\n            this.#attachment = ProcessAttachment.BACKGROUND;\n        }\n    }\n\n    get pid(): number {\n        return this.#pid;\n    }\n    get source_command(): ParsedCommandLine {\n        return this.#source_command;\n    }\n\n    get created_at(): Date {\n        return this.#created_at;\n    }\n\n    get shell(): AbstractShell | undefined {\n        return this.#shell;\n    }\n\n    get is_detached(): boolean {\n        return this.#attachment === ProcessAttachment.DETACHED;\n    }\n\n    get is_background(): boolean {\n        return this.#attachment === ProcessAttachment.BACKGROUND;\n    }\n\n    get is_foreground(): boolean {\n        return this.#attachment === ProcessAttachment.FOREGROUND;\n    }\n\n    get attachment(): ProcessAttachment {\n        return this.#attachment;\n    }\n\n    get detaches_silently(): boolean {\n        return this.#detach_silently;\n    }\n\n    detach(silently = false): void {\n        this.#attachment = ProcessAttachment.DETACHED;\n        this.#detach_silently = silently;\n    }\n\n    dispose_resources(): void {\n        this.#intervals.forEach((id) => {\n            clearInterval(id);\n        });\n\n        this.#timeouts.forEach((id) => {\n            clearTimeout(id);\n        });\n\n        this.#timeout_promises.clear();\n        this.#timeout_cancel_callbacks.clear();\n\n        this.#windows.forEach((win) => {\n            win.dispose();\n        });\n    }\n\n    kill(exit_code = 0): void {\n        this.dispose_resources();\n\n        this.#manager.mark_terminated(this.#pid);\n\n        for (const listener of this.#exit_listeners) {\n            listener(exit_code);\n        }\n    }\n\n    add_exit_listener(listener: (exit_code: number) => Promise<void> | void): void {\n        this.#exit_listeners.add(listener);\n    }\n\n    create_timeout(callback: () => void, delay: number, on_cancel? : () => void): number {\n        const id = window.setTimeout(() => {\n            this.#timeouts.delete(id);\n\n            // resolve any waiters\n            if (this.#timeout_promises.has(id)) {\n                const resolvers = this.#timeout_promises.get(id)!;\n                for (const { resolve } of resolvers) {\n                    resolve(true);\n                }\n                this.#timeout_promises.delete(id);\n            }\n\n            callback();\n\n            if (on_cancel) {\n                this.#timeout_cancel_callbacks.delete(id);\n            }\n        }, delay);\n\n        this.#timeouts.add(id);\n\n        if (on_cancel) {\n            this.#timeout_cancel_callbacks.set(id, on_cancel);\n        }\n\n        return id;\n    }\n\n    cancel_timeout(id: number): void {\n        if (this.#timeouts.has(id)) {\n            clearTimeout(id);\n            this.#timeouts.delete(id);\n\n            // resolve any waiters as cancelled\n            if (this.#timeout_promises.has(id)) {\n                const resolvers = this.#timeout_promises.get(id)!;\n                for (const {resolve} of resolvers) {\n                    resolve(false);\n                }\n                this.#timeout_promises.delete(id);\n            }\n\n            // call cancel callback if exists\n            if (this.#timeout_cancel_callbacks.has(id)) {\n                const cancel_callback = this.#timeout_cancel_callbacks.get(id)!;\n                cancel_callback();\n                this.#timeout_cancel_callbacks.delete(id);\n            }\n        }\n    }\n\n    has_timeout(id: number): boolean {\n        return this.#timeouts.has(id);\n    }\n\n    create_interval(callback: () => void, interval: number): number {\n        const id = window.setInterval(callback, interval);\n        this.#intervals.add(id);\n        return id;\n    }\n\n    has_interval(id: number): boolean {\n        return this.#intervals.has(id);\n    }\n\n    clear_interval(id: number): void {\n        if (this.#intervals.has(id)) {\n            clearInterval(id);\n            this.#intervals.delete(id);\n        }\n    }\n\n    async wait_for_timeout(id: number): Promise<boolean> {\n        if (!this.#timeouts.has(id)) {\n            throw new Error(`Timeout ID ${id} does not exist.`);\n        }\n\n        return new Promise<boolean>((resolve) => {\n            if (!this.#timeout_promises.has(id)) {\n                this.#timeout_promises.set(id, new Set());\n            }\n\n            this.#timeout_promises.get(id)!.add({ resolve });\n        });\n    }\n\n    create_window(): AbstractWindow | null {\n        const wm = this.#manager.window_manager;\n        if (!wm) {\n            return null;\n        }\n\n        const win = new wm.Window(this.#pid);\n        this.#windows.add(win);\n\n        // clean up on close\n        win.add_event_listener(\"close\", () => {\n            this.#windows.delete(win);\n        });\n\n        return win;\n    }\n\n\n    create_userspace_proxy_as_other_process(): UserspaceOtherProcessContext {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const proxy = Object.create(null);\n\n        Object.defineProperties(proxy, {\n            pid: { get: () => self.pid, enumerable: true },\n            created_at: { get: () => self.created_at, enumerable: true },\n            is_detached: { get: () => self.is_detached, enumerable: true },\n            is_background: { get: () => self.is_background, enumerable: true },\n            is_foreground: { get: () => self.is_foreground, enumerable: true },\n            attachment: { get: () => self.attachment, enumerable: true },\n            source_command: { get: () => self.source_command, enumerable: true },\n        });\n\n        return Object.freeze(proxy);\n    }\n\n    create_userspace_proxy(): UserspaceProcessContext {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const proxy = Object.create(null);\n\n        Object.defineProperties(proxy, {\n            pid: { get: () => self.pid, enumerable: true },\n            created_at: { get: () => self.created_at, enumerable: true },\n            is_detached: { get: () => self.is_detached, enumerable: true },\n            is_background: { get: () => self.is_background, enumerable: true },\n            is_foreground: { get: () => self.is_foreground, enumerable: true },\n            attachment: { get: () => self.attachment, enumerable: true },\n            source_command: { get: () => self.source_command, enumerable: true },\n\n            detach: { value: (silently = false) => { self.detach(silently); }, enumerable: true },\n            kill: { value: (exit_code = 0) => { self.kill(exit_code); }, enumerable: true },\n            create_timeout: { value: (callback: () => void, delay: number) => self.create_timeout(callback, delay), enumerable: true },\n            cancel_timeout: { value: (id: number) => { self.cancel_timeout(id); }, enumerable: true },\n            create_interval: { value: (callback: () => void, interval: number) => self.create_interval(callback, interval), enumerable: true },\n            clear_interval: { value: (id: number) => { self.clear_interval(id); }, enumerable: true },\n            create_window: { value: () => self.create_window(),  enumerable: true },\n        });\n\n        return Object.freeze(proxy);\n    }\n}\n\nexport interface UserspaceProcessManager {\n    readonly ipc_manager: UserspaceIPCManager;\n    list_pids(): number[];\n    get_process(pid: number): UserspaceOtherProcessContext | undefined;\n    kill(pid: number, exit_code?: number): boolean;\n}\n\nexport class ProcessManager {\n    readonly #processes: Map<number, ProcessContext> = new Map();\n    #next_pid = 1;\n\n    readonly #wm: AbstractWindowManager | null;\n    readonly #ipc_manager: IPCManager = new IPCManager(this);\n\n    constructor(wm: AbstractWindowManager | null = null) {\n        this.#wm = wm;\n    }\n\n    get window_manager(): AbstractWindowManager | null {\n        return this.#wm;\n    }\n\n    get ipc_manager(): IPCManager {\n        return this.#ipc_manager;\n    }\n\n    dispose_all(): void {\n        this.#ipc_manager.dispose_all();\n\n        for (const process of this.#processes.values()) {\n            process.dispose_resources();\n        }\n\n        this.#processes.clear();\n    }\n\n    create_process(source_command: ParsedCommandLine, shell?: AbstractShell): ProcessContext {\n        const pid = this.#next_pid++;\n        const context = new ProcessContext(pid, source_command, this, shell);\n        this.#processes.set(pid, context);\n        return context;\n    }\n\n    get_process(pid: number): ProcessContext | undefined {\n        return this.#processes.get(pid);\n    }\n\n    list_pids(): number[] {\n        return Array.from(this.#processes.keys());\n    }\n\n    mark_terminated(pid: number): void {\n        this.#processes.delete(pid);\n    }\n\n    kill(pid: number, exit_code = 0): boolean {\n        const process = this.#processes.get(pid);\n        if (!process) {\n            return false;\n        }\n\n        process.kill(exit_code);\n        return true;\n    }\n\n    create_userspace_proxy(process_pid: number): UserspaceProcessManager {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const proxy = Object.create(null);\n\n        const ipc_mgr_proxy = self.#ipc_manager.create_userspace_proxy(process_pid);\n\n        Object.defineProperties(proxy, {\n            ipc_manager: { get: () => ipc_mgr_proxy, enumerable: true },\n            list_pids: { value: () => self.list_pids(), enumerable: true },\n            get_process: { value: (pid: number) => {\n                const process = self.get_process(pid);\n                return process ? process.create_userspace_proxy_as_other_process() : undefined;\n            }, enumerable: true },\n            kill: { value: (pid: number, exit_code?: number) => self.kill(pid, exit_code), enumerable: true },\n        });\n\n        return Object.freeze(proxy);\n    }\n}\n","import { Howl } from \"howler\";\n\nexport class SoundRegistry {\n    readonly #registry: Map<string, { ready: boolean, howl: Howl }> = new Map();\n\n    register_howl(name: string, howl: Howl, ready = false) {\n        this.#registry.set(name, { ready, howl });\n    }\n\n    register_file(name: string, file: string) {\n        const howl = new Howl({\n            src: [file],\n            onload: () => {\n                const entry = this.#registry.get(name);\n                entry.ready = true;\n                this.#registry.set(name, entry);\n            },\n        });\n\n        this.register_howl(name, howl);\n    }\n\n    async await_ready(name: string, interval = 100): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const timer = setInterval(() => {\n                if (this.#registry.get(name).ready) {\n                    clearInterval(timer);\n                    resolve();\n                }\n            }, interval);\n        });\n    }\n\n    play(name: string) {\n        if (!this.#registry.has(name)) {\n            throw new Error(`Sound \"${name}\" is not registered.`);\n        }\n\n        if (!this.#registry.get(name).ready) {\n            throw new Error(`Sound \"${name}\" is not ready yet.`);\n        }\n\n        this.#registry.get(name).howl.play();\n    }\n\n    get(name: string) {\n        if (!this.#registry.has(name)) {\n            throw new Error(`Sound \"${name}\" is not registered.`);\n        }\n\n        return this.#registry.get(name).howl;\n    }\n\n    is_ready(name: string) {\n        return this.#registry.get(name).ready;\n    }\n\n    wait_to_play(name: string, interval = 100) {\n        if (this.is_ready(name)) {\n            this.play(name);\n        } else {\n            console.log(`Sound ${name} is not ready yet, waiting...`);\n            this.await_ready(name, interval).then(() => {\n                this.play(name);\n            });\n        }\n    }\n}","import {ProgramRegistry, recurse_mount_and_register_with_output, UserspaceProgramRegistry} from \"./prog_registry\";\nimport {AbstractFileSystem, type UserspaceFileSystem} from \"./filesystem\";\n\nimport {SoundRegistry} from \"./sfx_registry\";\nimport {AbstractWindowManager, UserspaceWindowManager} from \"./windowing\";\nimport {\n    IPCManager,\n    KERNEL_FAKE_PID,\n    ProcessContext,\n    ProcessManager,\n    UserspaceIPCManager, UserspaceOtherProcessContext,\n    UserspaceProcessManager\n} from \"./processes\";\nimport type {AbstractShell} from \"../abstract_shell\";\n\nimport {NEWLINE, type WrappedTerminal} from \"./term_ctl\";\n\nimport semver_validate from \"semver/functions/valid\";\nimport semver_compare from \"semver/functions/compare\"\n\nconst CURRENT_API_COMPAT = \"2.0.0\";\n\n/**\n * Result of a spawned process.\n * @property process The {@link ProcessContext} of the spawned process.\n * @property completion A promise that resolves to the exit code of the process. Note that the program has already started executing by the time this promise is returned. Awaiting it is not necessary to start execution.\n *\n * @group Userspace\n * @category Kernel\n */\nexport interface SpawnResult {\n    process: ProcessContext;\n    completion: Promise<number>;\n}\n\n/**\n * Interface for interacting with the kernel from userspace.\n *\n * @group Userspace\n * @category Kernel\n */\nexport interface UserspaceKernel {\n    /**\n     * Whether this kernel interface has privileged access (false for UserspaceKernel interface).\n     */\n    readonly privileged: boolean;\n\n    /**\n     * Access the {@link UserspaceProgramRegistry} for this kernel.\n     */\n    get_program_registry(): UserspaceProgramRegistry;\n\n    /**\n     * Access the {@link SoundRegistry} for this kernel.\n     */\n    get_sound_registry(): SoundRegistry;\n\n    /**\n     * Access the chosen {@link UserspaceFileSystem} for this kernel.\n     */\n    get_fs(): UserspaceFileSystem;\n\n    /**\n     * Access the chosen {@link UserspaceWindowManager} for this kernel, if any.\n     */\n    get_window_manager(): UserspaceWindowManager | null;\n\n    /**\n     * Determine if a window manager is present.\n     */\n    has_window_manager(): boolean;\n\n    /**\n     * Access the {@link UserspaceProcessManager} for this kernel.\n     */\n    get_process_manager(): UserspaceProcessManager;\n\n    /**\n     * Access the {@link UserspaceIPCManager} for this kernel.\n     */\n    get_ipc(): UserspaceIPCManager;\n\n    /**\n     * Access the version and environment info assigned to this kernel.\n     */\n    get_env_info(): {version: string, env: string};\n\n    /**\n     * Spawn a new process.\n     * @param cmd_or_line_parse Either a command string or a pre-parsed command line to execute.\n     * @param explicit_args Ignored if cmd_or_line_parse is a {@link ParsedCommandLine}. Otherwise, the explicit arguments to pass to the command.\n     * @param shell The shell that is spawning this process, if any.\n     * @returns A {@link SpawnResult} containing the process context and a promise for its completion. You are responsible for terminating the process on an error or after execution.\n     */\n    spawn(cmd_or_line_parse: string | ParsedCommandLine, explicit_args?: string[], shell?: AbstractShell): SpawnResult; // TODO: how safe will this be to expose?\n\n    /**\n     * Request privileged access from the kernel.\n     * @param reason The reason for requesting privileged access.\n     * @returns A promise that resolves to a privileged {@link Kernel} interface if approved, or false if denied.\n     */\n    request_privilege(reason: string): Promise<Kernel | false>;\n}\n\n/**\n * Parsed command line structure.\n * @property command The command (program name) to execute.\n * @property args The arguments to pass to the command, trimmed and with any substitutions applied (e.g. variables).\n * @property unsubbed_args The arguments to pass to the command, trimmed but without any substitutions applied.\n * @property raw_parts The raw parts of the command line, including the command and all unparsed but split arguments, without trimming or substitutions applied.\n * @property run_in_bg Whether the command is to be run in the background.\n *\n * @group Userspace\n * @category Kernel\n */\nexport interface ParsedCommandLine {\n    command: string;\n    args: string[];\n    unsubbed_args: string[];\n    raw_parts: string[];\n    run_in_bg: boolean;\n}\n\n/**\n * Interface for interacting with the kernel.\n *\n * @group Kernel (Privileged)\n * @category Kernel\n */\nexport class Kernel {\n    readonly #term: WrappedTerminal;\n    readonly #process_manager: ProcessManager;\n    readonly #prog_registry: ProgramRegistry;\n    readonly #sfx_registry: SoundRegistry;\n    readonly #fs: AbstractFileSystem;\n    readonly #wm: AbstractWindowManager | null = null;\n\n    #panicked = false;\n    #after_panic: (message: string, debug_info?: string) => void | null = null;\n\n    #env_info = {\n        version: \"unknown\",\n        env: \"unknown\"\n    };\n\n    #init_program_name: string | null = null;\n\n    /**\n     * Whether this kernel interface has privileged access (always true for Kernel class).\n     */\n    get privileged(): boolean {\n        return true;\n    }\n\n    /**\n     * Whether the kernel has panicked.\n     */\n    get panicked(): boolean {\n        return this.#panicked;\n    }\n\n    /**\n     * Access the {@link ProgramRegistry} for this kernel.\n     */\n    get_program_registry(): ProgramRegistry {\n        return this.#prog_registry;\n    }\n\n    /**\n     * Access the {@link SoundRegistry} for this kernel.\n     */\n    get_sound_registry(): SoundRegistry {\n        return this.#sfx_registry;\n    }\n\n    /**\n     * Access the chosen {@link AbstractFileSystem} implementation for this kernel.\n     */\n    get_fs(): AbstractFileSystem {\n        return this.#fs;\n    }\n\n    /**\n     * Access the chosen {@link AbstractWindowManager} implementation for this kernel, if any.\n     */\n    get_window_manager(): AbstractWindowManager | null {\n        return this.#wm;\n    }\n\n    /**\n     * Determine if a window manager is present.\n     */\n    has_window_manager(): boolean {\n        return this.#wm !== null;\n    }\n\n    /**\n     * Access the {@link ProcessManager} for this kernel.\n     */\n    get_process_manager(): ProcessManager {\n        return this.#process_manager;\n    }\n\n    /**\n     * Access the {@link IPCManager} for this kernel.\n     */\n    get_ipc(): IPCManager {\n        return this.#process_manager.ipc_manager;\n    }\n\n    /**\n     * Access the version and environment info assigned to this kernel.\n     */\n    get_env_info(): {version: string, env: string} {\n        return {...this.#env_info};\n    }\n\n    /**\n     * Assign version and environment info to this kernel.\n     * @param version The version of OllieOS running.\n     * @param env Custom string representing the environment OllieOS is running in (i.e. \"web\", \"node\", etc).\n     */\n    set_env_info(version: string, env: string) {\n        this.#env_info.version = version;\n        this.#env_info.env = env;\n    }\n\n    // TODO: cleaner spawn interface, shame theres no function overloading (but could make two more methods)\n\n    /**\n     * Spawn a new process.\n     * @param cmd_or_parse Either a command string or a pre-parsed command line to execute.\n     * @param explicit_args Ignored if cmd_or_parse is a {@link ParsedCommandLine}. Otherwise, the explicit arguments to pass to the command.\n     * @param shell The shell that is spawning this process, if any.\n     * @param start_privileged Whether to start the process with privileged kernel access. The process will not need to use {@link request_privilege} if this is true!!!\n     * @returns A {@link SpawnResult} containing the process context and a promise for its completion. You are responsible for terminating the process on an error or after execution.\n     */\n    spawn = (cmd_or_parse: string | ParsedCommandLine, explicit_args?: string[], shell?: AbstractShell, start_privileged?: boolean): SpawnResult => {\n        // TODO: is passing shell around annoying? how can it be alleviated without affecting separation of concerns?\n        // TODO: replace the above with process ownership :)\n\n        // we may not be provided a parsed line (if this is a direct call, not from execute()), but we can create one by assumption\n        // args are only used if cmd_or_parse is a string\n        // by ensuring only 1 source of truth is used at a time, we avoid manipulation from conflicting data\n        let parsed_line: ParsedCommandLine;\n        if (typeof cmd_or_parse === \"string\") {\n            if (!explicit_args) {\n                explicit_args = [];\n            }\n\n            parsed_line = {\n                command: cmd_or_parse,\n                args: [...explicit_args],\n                unsubbed_args: [...explicit_args],\n                raw_parts: [cmd_or_parse, ...explicit_args],\n                run_in_bg: false\n            };\n        } else {\n            parsed_line = cmd_or_parse;\n        }\n\n        const {command} = parsed_line;\n\n        // shallow clone args to avoid mutation exploits (you never know)\n        const args = parsed_line.args.slice();\n\n        // search for the command in the registry\n        const program = this.#prog_registry.getProgram(command);\n        if (program === undefined) {\n            throw new Error(`Command not found: ${command}`);\n        }\n\n        // validate that the name stored in the program matches the command called\n        // under normal circumstances this should always be true, but doing this prevents obscure spoofing exploits\n        if (program.name !== command) {\n            throw new Error(`Program name mismatch for command ${command}: expected ${command}, got ${program.name}`);\n        }\n\n        let compat = \"1.0.0\";\n        if (typeof program.compat === \"string\") {\n            compat = program.compat;\n        }\n\n        if (!semver_validate(compat)) {\n            throw new Error(`Program ${program.name} has an invalid compat SemVer: ${compat}`);\n        }\n\n        if (semver_compare(compat, CURRENT_API_COMPAT) < 0) {\n            throw new Error(`Program ${program.name} is not compatible with OllieOS 2. (Add compat: \"2.0.0\" to the program object to mark it as ported.)`);\n        }\n\n        // create new process context\n        const process = this.#process_manager.create_process(parsed_line, shell);\n\n        // protect from pollution\n        const data = Object.create(null);\n\n        // provide either privileged or userspace kernel access\n        if (start_privileged) {\n            data.kernel = this;\n        } else {\n            data.kernel = this.create_userspace_proxy(process);\n        }\n\n        data.term = this.#term;\n        data.args = args;\n        data.shell = shell;\n        data.unsubbed_args = parsed_line.unsubbed_args;\n        data.raw_parts = parsed_line.raw_parts;\n        data.process = process;\n\n        Object.freeze(data);\n\n        // create a promise that resolves when the program completes\n        let result_promise: Promise<number>;\n        if (\"main\" in program) {\n            result_promise = Promise.resolve(program.main(data));\n        } else {\n            throw new Error(\"Invalid program type\");\n        }\n\n        return {\n            process,\n            completion: result_promise\n        };\n    }\n\n    /**\n     * Throw all the toys out of the pram.\n     * @param message The panic message to show at the top of the panic screen.\n     * @param debug_info Optional debug information to show below the panic message. It is usually helpful to pass the error message and stack trace here.\n     */\n    panic(message: string, debug_info?: string) {\n        if (this.#panicked) {\n            return;\n        }\n\n        this.#panicked = true;\n\n        // print formatted panic to js console\n        console.error(`%cPANIC: ${message}\\n${debug_info || \"\"}`, \"background: red; color: white; font-weight: bold;\");\n\n        const proc_mgr = this.get_process_manager();\n        const pids = proc_mgr.list_pids();\n\n        let process_info = \"\"\n\n        for (const pid of pids) {\n            const proc = proc_mgr.get_process(pid);\n\n            if (proc) {\n                process_info += `- PID ${proc.pid}: ${proc.source_command.command} (started at ${proc.created_at.toISOString()})${NEWLINE}`;\n            }\n        }\n\n        // remove last NEWLINE\n        process_info = process_info.trimEnd();\n\n        proc_mgr.dispose_all();\n        this.#term.handle_kernel_panic(message, process_info, debug_info);\n\n        if (this.#after_panic) {\n            this.#after_panic(message, debug_info);\n        }\n    }\n\n    /**\n     * Boot the kernel by starting the init system.\n     * @param on_init_spawned Optional callback that is called once the init program has been spawned.\n     * @param after_panic Optional callback that is called after a panic occurs.\n     * @returns A promise that resolves at the end of all OllieOS execution (i.e. when init exits). Returns true for a successful finish, false for an unexpected exit (but neither case is good if expecting the system to keep running!).\n     */\n    async boot(on_init_spawned?: (kernel: Kernel) => Promise<void>, after_panic?: (message: string, debug_info?: string) => void): Promise<boolean> {\n        this.#after_panic = after_panic || null;\n\n        const fs = this.get_fs();\n\n        // mount all programs in any subdirectory of /usr/bin\n        // TODO: get rid of the concept of a programregistry being the sole way to run programs. mounting is a bad concept. it should be a cache, not the sole execution method. may need to redesign how programs are stored to have it be more part of the filesystem\n        // TODO: smarter system that has files to be mounted so any stray js files don't get mounted? or maybe it doesn't matter and is better mounting everything for hackability!\n        const usr_bin = fs.absolute(\"/usr/bin\");\n        if (await fs.exists(usr_bin)) {\n            await recurse_mount_and_register_with_output(fs, usr_bin, this.get_program_registry(), this.#term);\n        }\n\n        // read /boot/init to determine init system\n        let init_program: string;\n        let init_args: string[] = [];\n\n        try {\n            const init_data = await fs.read_file(\"/boot/init\") as string;\n            init_program = init_data.trim();\n        } catch {\n            this.panic(\"Failed to read /boot/init to determine init system!\");\n            return false;\n        }\n\n        if (!init_program) {\n            this.panic(\"No init program specified in /boot/init!\");\n            return false;\n        }\n\n        // separate args if any\n        const init_parts = init_program.split(\" \");\n        init_program = init_parts[0];\n\n        if (init_parts.length > 1) {\n            init_args = init_parts.slice(1);\n        }\n\n        // run init program\n        try {\n            const init = this.spawn(init_program, init_args, undefined, true);\n\n            this.#init_program_name = init_program;\n            this.#term.focus();\n\n            if (on_init_spawned) {\n                on_init_spawned(this).catch((e) => {\n                    console.error(e);\n                });\n            }\n\n            if (init.process.pid !== 1) {\n                this.panic(`init program ${init_program} did not start as PID 1!`);\n                return false;\n            }\n\n            try {\n                const exit_code = await init.completion;\n\n                this.panic(`init program ${init_program} exited ${exit_code === 0 ? \"unexpectedly\" : \"with an error\"}!`, `Exit code: ${exit_code}`);\n                return false;\n            } catch (e) {\n                console.error(e);\n                this.panic(`init program ${init_program} error!`, e.toString() + NEWLINE + e.stack);\n                return false;\n            }\n        } catch (e) {\n            console.error(e);\n            this.panic(`Failed to start init program ${init_program}!`, e.toString() + NEWLINE + e.stack);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Request privileged access from the kernel.\n     * @param reason The reason for requesting privileged access.\n     * @param process The process requesting privileged access.\n     * @returns A promise that resolves to a privileged {@link Kernel} interface if approved, or false if denied.\n     */\n    async request_privilege(reason: string, process: ProcessContext): Promise<Kernel | false> {\n        // TODO: a way to skip this when already privileged? or by pid?\n        // TODO: remember my answer option when /sys security is implemented\n        // TODO: implement killing in the proxies so that when the process dies, any privileged access is revoked\n\n        // read /sys/privilege_agent to determine privilege agent\n        const fs = this.get_fs();\n        let agent_program = \"default_privilege_agent\";\n        try {\n            const agent_data = await fs.read_file(\"/sys/privilege_agent\") as string;\n            agent_program = agent_data.trim();\n        } catch {\n            // ignore, use default\n            console.warn(\"Failed to read /sys/privilege_agent, using default privilege agent.\");\n        }\n\n        if (!agent_program) {\n            agent_program = \"default_privilege_agent\";\n            console.warn(\"/sys/privilege_agent is empty, using default privilege agent.\");\n        }\n\n        // create an unassigned ipc channel\n        const ipc = this.get_ipc();\n        const channel_id = ipc.reserve_kernel_channel();\n\n        // spawn the privilege agent program, passing the channel id, and assign the channel to it\n        const agent_proc = this.spawn(agent_program, [channel_id.toString()]);\n        ipc.assign_kernel_channel(channel_id, agent_proc.process.pid);\n\n        let handling_request = false;\n        let approved: boolean | null = null;\n\n        // listen for response on the channel\n        ipc.channel_listen(channel_id, KERNEL_FAKE_PID, async (msg) => {\n            const data = msg.data as { process: UserspaceOtherProcessContext; granted?: boolean; handling?: boolean; };\n\n            // validate approved pid matches requesting pid\n            if (data.process.pid !== process.pid) {\n                console.warn(`Privilege request response pid ${data.process.pid} does not match requesting pid ${process.pid}, ignoring response.`);\n                return;\n            }\n\n            // check if handling acknowledgement\n            if (data.handling) {\n                handling_request = true;\n                return;\n            }\n\n            // otherwise, check for granted/denied\n            if (data.granted !== undefined) {\n                approved = data.granted;\n            }\n        });\n\n        const process_proxy = process.create_userspace_proxy_as_other_process();\n\n        // wait to handle for up to 10 seconds, repeating the request if not yet being handled\n        // overall timeout up to 60 seconds\n        const start_time = Date.now();\n        // TODO: cleaner logic here\n        while ((Date.now() - start_time) < 60000 && approved === null && (handling_request || (Date.now() - start_time) < 10000)) {\n            if (!handling_request) {\n                ipc.channel_send(channel_id, KERNEL_FAKE_PID, {\n                    process: process_proxy,\n                    reason\n                });\n            }\n\n            await new Promise((resolve) => setTimeout(resolve, 500));\n        }\n\n        ipc.destroy_channel(channel_id);\n\n        if (approved === null) {\n            console.warn(\"Privilege request timed out.\");\n        }\n\n        agent_proc.process.kill(approved === null ? 1 : 0);\n\n        // return result\n        if (approved) {\n            return this;\n        } else {\n            return false;\n        }\n    }\n\n    constructor(term: WrappedTerminal, fs: AbstractFileSystem, prog_registry?: ProgramRegistry, sound_registry?: SoundRegistry, wm?: AbstractWindowManager) {\n        this.#term = term;\n        this.#fs = fs;\n        this.#prog_registry = prog_registry || new ProgramRegistry();\n        this.#sfx_registry = sound_registry || new SoundRegistry();\n        this.#wm = wm || null;\n        this.#process_manager = new ProcessManager(this.#wm);\n    }\n\n    /**\n     * Create a userspace proxy of this kernel for use in a userspace process.\n     * @param process The process to create the proxy for.\n     * @returns A {@link UserspaceKernel} proxy of this kernel.\n     */\n    create_userspace_proxy(process: ProcessContext): Promise<UserspaceKernel> {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const proxy = Object.create(null);\n\n        const kernel_fs = self.get_fs();\n\n        const proc_mgr_proxy = self.get_process_manager().create_userspace_proxy(process.pid);\n        const prog_reg_proxy = self.get_program_registry().create_userspace_proxy(this.#init_program_name, kernel_fs);\n        const fs_proxy = AbstractFileSystem.create_userspace_proxy(kernel_fs);\n\n        Object.defineProperties(proxy, {\n            privileged: { value: false, enumerable: true },\n            get_program_registry: { value: () => prog_reg_proxy, enumerable: true },\n            get_sound_registry: { value: () => self.get_sound_registry(), enumerable: true },\n            get_fs: { value: () => fs_proxy, enumerable: true },\n            get_window_manager: {\n                value: () => {\n                    const wm = self.get_window_manager();\n                    return wm ? wm.create_userspace_proxy() : null;\n                },\n                enumerable: true\n            },\n            has_window_manager: { value: () => self.has_window_manager(), enumerable: true },\n            get_process_manager: { value: () => proc_mgr_proxy, enumerable: true },\n            get_ipc: { value: () => proc_mgr_proxy.ipc_manager, enumerable: true },\n            get_env_info: { value: () => self.get_env_info(), enumerable: true },\n            spawn: {\n                value: (command: string | ParsedCommandLine, args?: string[], shell?: AbstractShell) =>\n                    self.spawn(command, args, shell, false),\n                enumerable: true\n            },\n            request_privilege: {\n                value: (reason: string) => self.request_privilege(reason, process),\n                enumerable: true\n            }\n        });\n\n        return Object.freeze(proxy);\n    }\n}\n\n// TODO: document the other kernel classes etc. could use {@inheritDoc} to make it easier for filesystem as will not be overridden by userspace much\n","import type {Kernel, SpawnResult} from \"../../../kernel\";\n\nconst SERVICES_DIR = \"/etc/services/\";\n\ninterface ServiceRestartPolicyBase {\n    on: \"failure\" | \"always\" | \"never\";\n}\n\ninterface ServiceRestartPolicyWithRules extends ServiceRestartPolicyBase {\n    on: \"failure\" | \"always\";\n    max_retries?: number;\n    delay_ms?: number;\n}\n\ntype ServiceRestartPolicy = ServiceRestartPolicyBase | ServiceRestartPolicyWithRules;\n\ninterface ServiceFile {\n    name?: string;\n    dependencies?: string[];\n    exec: string;\n    args?: string[];\n    oneshot?: boolean;\n    restart?: ServiceRestartPolicy;\n}\n\n// TODO: support oneshot\n// TODO: do something with name\n// TODO: do something with max_retries\n\ninterface ServiceFileWithId extends ServiceFile {\n    id: string;\n}\n\nconst CLEAN_EXIT_CODES = new Set([0, 143]); // 0 = success, 143 = SIGTERM\n\ninterface ServiceStatusBase {\n    state: \"running\" | \"stopped\" | \"failed\";\n}\n\ninterface ServiceStatusNotRunning extends ServiceStatusBase {\n    state: \"stopped\" | \"failed\";\n}\n\ninterface ServiceStatusRunning extends ServiceStatusBase {\n    state: \"running\";\n    pid: number;\n}\n\n// TODO: store stop code for failed services\n// TODO: store start time for running services\n\nexport type ServiceStatus = ServiceStatusRunning | ServiceStatusNotRunning;\n\nexport class ServiceManager {\n    readonly #kernel: Kernel;\n\n    readonly #service_files: Map<string, ServiceFileWithId> = new Map();\n    readonly #running_services: Map<string, SpawnResult> = new Map(); // service ID to spawn result\n    readonly #should_be_running_services: Set<string> = new Set();\n    readonly #failed_services: Set<string> = new Set();\n\n    constructor(kernel: Kernel) {\n        this.#kernel = kernel;\n    }\n\n    async load_service_files() {\n        const fs = this.#kernel.get_fs();\n\n        if (!await fs.exists(SERVICES_DIR)) {\n            console.warn(`Services directory ${SERVICES_DIR} does not exist. Skipping service loading.`);\n            return;\n        }\n\n        const service_files = await fs.list_dir(SERVICES_DIR);\n\n        // load each service file\n        for (const file_name of service_files) {\n            if (file_name.endsWith(\".service.json\")) {\n                const file_path = fs.join(SERVICES_DIR, file_name);\n                const file_content = await fs.read_file(file_path) as string;\n\n                try {\n                    const service_data = JSON.parse(file_content) as ServiceFile;\n                    const service_id = file_name.substring(0, file_name.length - \".service.json\".length);\n\n                    // TODO: validate service_data here\n\n                    const service: ServiceFileWithId = {\n                        id: service_id,\n                        ...service_data\n                    };\n\n                    // add or update service file\n                    this.#service_files.set(service_id, service);\n                } catch (e) {\n                    console.error(`Failed to parse service file ${file_name}:`, e);\n                }\n            }\n        }\n\n        // remove any services that no longer exist\n        for (const existing_service_id of this.#service_files.keys()) {\n            if (!service_files.includes(existing_service_id + \".service.json\")) {\n                this.#service_files.delete(existing_service_id);\n            }\n        }\n    }\n\n    private _calculate_service_start_order(): string[] {\n        const visited: Set<string> = new Set();\n        const temp_mark: Set<string> = new Set();\n        const result: string[] = [];\n\n        const visit = (service_id: string) => {\n            if (visited.has(service_id)) {\n                return;\n            }\n            if (temp_mark.has(service_id)) {\n                throw new Error(`Circular dependency detected involving service: ${service_id}`);\n            }\n\n            temp_mark.add(service_id);\n\n            const service = this.#service_files.get(service_id);\n            if (service && service.dependencies) {\n                for (const dep of service.dependencies) {\n                    visit(dep);\n                }\n            }\n\n            temp_mark.delete(service_id);\n            visited.add(service_id);\n            result.push(service_id);\n        };\n\n        for (const service_id of this.#service_files.keys()) {\n            visit(service_id);\n        }\n\n        return result;\n    }\n\n    start_initial_services() {\n        const start_order = this._calculate_service_start_order();\n        for (const service_id of start_order) {\n            this.start_service(service_id);\n        }\n    }\n\n    start_service(service_id: string) {\n        // TODO: check dependencies are running\n\n        if (this.#running_services.has(service_id)) {\n            console.warn(`Service ${service_id} is already running.`);\n            return;\n        }\n\n        const service = this.#service_files.get(service_id);\n        if (!service) {\n            console.error(`Service ${service_id} not found.`);\n            return;\n        }\n\n        // mark service as should be running, so exit handlers know to restart it\n        this.#should_be_running_services.add(service_id);\n\n        let spawn_result: SpawnResult;\n        try {\n            spawn_result = this.#kernel.spawn(service.exec, service.args || []);\n        } catch (e) {\n            console.error(`Failed to start service ${service_id}:`, e);\n            return;\n        }\n\n        this.#running_services.set(service_id, spawn_result);\n        this.#failed_services.delete(service_id);\n\n        const { process, completion } = spawn_result;\n\n        // mark process as detached\n        process.detach(true);\n\n        // check for errors\n        completion.catch((e) => {\n            console.error(`Service ${service_id} encountered an error:`, e);\n            this.#running_services.delete(service_id);\n            this.#failed_services.add(service_id);\n            this._handle_service_exit(service_id, -1);\n        });\n\n        // handle normal exit\n        process.add_exit_listener((exit_code) => {\n            this.#running_services.delete(service_id);\n            this._handle_service_exit(service_id, exit_code);\n        });\n    }\n\n    stop_service(service_id: string) {\n        if (!this.#running_services.has(service_id)) {\n            console.warn(`Service ${service_id} is not running.`);\n            return;\n        }\n\n        const spawn_result = this.#running_services.get(service_id);\n        if (!spawn_result) {\n            console.error(`Service ${service_id} spawn result not found.`);\n            return;\n        }\n\n        const { process } = spawn_result;\n\n        // mark service as should not be running\n        this.#should_be_running_services.delete(service_id);\n\n        // send SIGTERM\n        process.kill(143);\n\n        // removal from running services will be handled in exit listener\n    }\n\n    restart_service(service_id: string) {\n        this.stop_service(service_id);\n        this.start_service(service_id); // TODO: will this conflict with the exit listener?\n    }\n\n    get_service_status(service_id: string): ServiceStatus | null {\n        if (!this.#service_files.has(service_id)) {\n            return null;\n        }\n\n        if (this.#running_services.has(service_id)) {\n            const spawn_result = this.#running_services.get(service_id);\n            if (spawn_result) {\n                return {\n                    state: \"running\",\n                    pid: spawn_result.process.pid\n                };\n            }\n        } else {\n            if (this.#failed_services.has(service_id)) {\n                return {\n                    state: \"failed\"\n                };\n            } else {\n                return {\n                    state: \"stopped\"\n                };\n            }\n        }\n    }\n\n    private _handle_service_exit(service_id: string, exit_code: number) {\n        console.warn(`Service ${service_id} exited with code ${exit_code}.`);\n\n        if (!this.#should_be_running_services.has(service_id)) {\n            return;\n        }\n\n        const service = this.#service_files.get(service_id);\n        if (!service) {\n            return;\n        }\n\n        const restart_policy = service.restart;\n        if (!restart_policy || restart_policy.on === \"never\") {\n            return;\n        }\n\n        if (restart_policy.on === \"always\" || (restart_policy.on === \"failure\" && !CLEAN_EXIT_CODES.has(exit_code))) {\n            console.log(`Restarting service ${service_id} as per restart policy.`);\n\n            let delay_ms = 0;\n            if (\"delay_ms\" in restart_policy && restart_policy.delay_ms) {\n                delay_ms = restart_policy.delay_ms;\n            }\n\n            setTimeout(() => {\n                this.start_service(service_id);\n            }, delay_ms);\n        }\n    }\n}\n","import type { PrivilegedProgram } from \"../../../types\";\n\nimport {ServiceManager} from \"./services\";\nimport type {ProcessContext} from \"../../../kernel/processes\";\n\nimport {ANSI} from \"../../../kernel/term_ctl\";\n\ninterface IgnitionIPCMessageBase {\n    type: string;\n}\n\ninterface IgnitionIPCPowerMessage extends IgnitionIPCMessageBase {\n    type: \"power\";\n    action: \"shutdown\" | \"reboot\";\n    hard?: boolean;\n}\n\ninterface IgnitionIPCServiceMessage extends IgnitionIPCMessageBase {\n    type: \"service\";\n    action: \"start\" | \"stop\" | \"restart\" | \"status\";\n    service_id: string;\n}\n\ninterface IgnitionIPCReloadServicesMessage extends IgnitionIPCMessageBase {\n    type: \"reload_services\";\n}\n\nexport type IgnitionIPCMessage =\n    IgnitionIPCPowerMessage |\n    IgnitionIPCServiceMessage |\n    IgnitionIPCReloadServicesMessage;\n\ninterface IgnitionIPCResponse extends IgnitionIPCMessageBase {\n    type: \"response\";\n    message: string;\n}\n\ninterface IgnitionIPCDataResponse extends IgnitionIPCMessageBase {\n    type: \"data\";\n    data: unknown;\n}\n\ninterface IgnitionIPCError extends IgnitionIPCMessageBase {\n    type: \"error\";\n    message: string;\n}\n\nexport type IgnitionIPCReply =\n    IgnitionIPCResponse |\n    IgnitionIPCDataResponse |\n    IgnitionIPCError;\n\n// TODO: split ipc handling etc into files\n\nexport default {\n    name: \"ignition\",\n    description: \"System init process\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    hide_from_help: true,\n    compat: \"2.0.0\",\n    main: async (data) => {\n        const { kernel, term, process } = data;\n\n        const {CURSOR} = ANSI;\n\n        // check if ignition is already running (only allowed to be PID 1)\n        if (process.pid !== 1) {\n            term.writeln(\"ignition can only be run as PID 1!\");\n            return 1;\n        }\n\n        // check for privileged environment\n        if (!kernel.privileged) {\n            term.writeln(\"ignition requires privileged environment!\");\n            return 1;\n        }\n\n        const fs = kernel.get_fs();\n\n        // determine boot target from /etc/boot_target\n        let boot_target = \"jetty\";\n        let boot_args: string[] = [];\n\n        try {\n            const boot_target_data = await fs.read_file(\"/etc/boot_target\") as string;\n            boot_target = boot_target_data.trim();\n        } catch (e) {\n            term.writeln(\"Warning: /etc/boot_target not found, defaulting to 'jetty' target!\");\n\n            // wait 3 seconds\n            await new Promise((resolve) => setTimeout(resolve, 3000));\n        }\n\n        if (!boot_target) {\n            term.writeln(\"Warning: /etc/boot_target is empty, defaulting to 'jetty' target!\");\n\n            // wait 3 seconds\n            await new Promise((resolve) => setTimeout(resolve, 3000));\n        }\n\n        // separate args if any\n        const boot_target_parts = boot_target.split(\" \");\n        boot_target = boot_target_parts[0];\n\n        if (boot_target_parts.length > 1) {\n            boot_args = boot_target_parts.slice(1);\n        }\n\n        // create service manager\n        const svc_mgr = new ServiceManager(kernel);\n\n        // load service files but don't start them yet\n        await svc_mgr.load_service_files();\n\n        // open and handle ipc communication\n        const ipc = kernel.get_ipc();\n\n        ipc.service_register(\"init\", process.pid, async (channel_id) => {\n            ipc.channel_listen(channel_id, process.pid, async (msg) => {\n                const payload = msg.data as IgnitionIPCMessage;\n\n                // TODO: clean up when it gets more complex\n\n                switch (payload.type) {\n                    case \"reload_services\": {\n                        await svc_mgr.load_service_files();\n                        ipc.channel_send(channel_id, process.pid, {\n                            type: \"response\",\n                            message: \"Service files reloaded.\"\n                        });\n                        break;\n                    }\n                    case \"service\": {\n                        const service_msg = payload as IgnitionIPCServiceMessage;\n                        switch (service_msg.action) {\n                            case \"start\": {\n                                svc_mgr.start_service(service_msg.service_id);\n                                ipc.channel_send(channel_id, process.pid, {\n                                    type: \"response\",\n                                    message: `Service ${service_msg.service_id} started.`\n                                });\n                                break;\n                            }\n                            case \"stop\": {\n                                svc_mgr.stop_service(service_msg.service_id);\n                                ipc.channel_send(channel_id, process.pid, {\n                                    type: \"response\",\n                                    message: `Service ${service_msg.service_id} stopped.`\n                                });\n                                break;\n                            }\n                            case \"restart\": {\n                                svc_mgr.restart_service(service_msg.service_id);\n                                ipc.channel_send(channel_id, process.pid, {\n                                    type: \"response\",\n                                    message: `Service ${service_msg.service_id} restarted.`\n                                });\n                                break;\n                            }\n                            case \"status\": {\n                                const status = svc_mgr.get_service_status(service_msg.service_id);\n\n                                if (!status) {\n                                    ipc.channel_send(channel_id, process.pid, {\n                                        type: \"error\",\n                                        message: `Service ${service_msg.service_id} not found.`\n                                    });\n                                    break;\n                                }\n\n                                ipc.channel_send(channel_id, process.pid, {\n                                    type: \"data\",\n                                    data: status\n                                });\n                                break;\n                            }\n                            default:\n                                ipc.channel_send(channel_id, process.pid, {\n                                    type: \"error\",\n                                    message: `Unknown service action: ${service_msg.action}`\n                                });\n                        }\n                    }\n                        break;\n                    default:\n                        ipc.channel_send(channel_id, process.pid, {\n                            type: \"error\",\n                            message: `Unknown message type: ${payload.type}`\n                        });\n                }\n            });\n        });\n\n        let running = true;\n        let final_code = 0;\n        let current_tty_process: ProcessContext;\n\n        // on exit, force boot target to exit too\n        // TODO: add process ownership to automatically kill child processes\n        const proc_mgr = kernel.get_process_manager();\n        process.add_exit_listener(async (exit_code) => {\n            if (current_tty_process && proc_mgr.get_process(current_tty_process.pid)) {\n                current_tty_process.kill(exit_code);\n            }\n\n            final_code = exit_code;\n            running = false;\n        });\n\n        // start initial services\n        svc_mgr.start_initial_services();\n\n        let window_start: number | null = null;\n        let deaths_in_window = 0;\n\n        // execute boot target in a respawn loop\n        while (running) {\n            const boot_target_proc = kernel.spawn(boot_target, boot_args);\n            current_tty_process = boot_target_proc.process;\n\n            let exit_code: number;\n            let error: Error | null = null;\n            try {\n                exit_code = await boot_target_proc.completion;\n            } catch (e) {\n                console.error(e);\n                error = e as Error;\n                exit_code = -1;\n            }\n\n            boot_target_proc.process.kill(exit_code);\n            console.log(`boot target ${boot_target} exited with code ${exit_code}`);\n\n            term.writeln(`Boot target ${boot_target} exited with code ${exit_code}!`);\n            if (error) {\n                term.writeln(`Error details: ${error}`);\n            }\n\n            const now = Date.now();\n            if (!window_start || (now - window_start) > 10000) {\n                window_start = now;\n                deaths_in_window = 0;\n            }\n\n            deaths_in_window++;\n\n            if (deaths_in_window >= 5) {\n                term.writeln(\"Boot target has crashed too many times in a short period.\");\n                term.writeln(\"Press R key to enter recovery mode, or any other key to retry...\");\n                term.write(CURSOR.invisible);\n\n                const key = await term.wait_for_keypress();\n                if (key.key.toLowerCase() === \"r\") {\n                    term.writeln(\"Entering recovery mode...\");\n\n                    const recovery_proc = kernel.spawn(\"recovery\", [], undefined, true);\n                    let recovery_exit_code: number;\n                    try {\n                        recovery_exit_code = await recovery_proc.completion;\n                        recovery_proc.process.kill(recovery_exit_code);\n                    } catch (e) {\n                        console.error(e);\n                        recovery_exit_code = -1;\n                    }\n\n                    term.writeln(`Recovery environment exited with code ${recovery_exit_code}. Retrying boot target...`);\n                } else {\n                    term.writeln(\"Retrying boot target...\");\n                }\n\n                term.write(CURSOR.visible);\n\n                deaths_in_window = 0;\n                window_start = null;\n            }\n\n            // TODO: add recovery options\n        }\n\n        return final_code;\n    }\n} as PrivilegedProgram;\n\n// TODO: implement graceful shutdown, stops programs, stops services in reverse order etc as well as move the actual final shutdown/reboot logic to kern`","import type {Program} from \"../../types\";\nimport type {ProcessContext} from \"../../kernel/processes\";\nimport {ANSI} from \"../../kernel/term_ctl\";\n\nexport default {\n    name: \"jetty\",\n    description: \"TTY init process\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    hide_from_help: true,\n    compat: \"2.0.0\",\n    main: async (data) => {\n        const {kernel, term, process} = data;\n\n        term.reset();\n\n        const fs = kernel.get_fs();\n\n        // determine default shell from /etc/default_shell\n        let default_shell = \"ash\";\n        let default_shell_args: string[] = [];\n\n        try {\n            const default_shell_data = await fs.read_file(\"/etc/default_shell\") as string;\n            default_shell = default_shell_data.trim();\n        } catch (e) {\n            term.writeln(\"Warning: /etc/default_shell not found, defaulting to 'ash' shell!\");\n\n            // wait 3 seconds\n            await new Promise((resolve) => setTimeout(resolve, 3000));\n        }\n\n        if (!default_shell) {\n            term.writeln(\"Warning: /etc/default_shell is empty, defaulting to 'ash' shell!\");\n\n            // wait 3 seconds\n            await new Promise((resolve) => setTimeout(resolve, 3000));\n        }\n\n        // separate shell args if any\n        const default_shell_parts = default_shell.split(\" \");\n        default_shell = default_shell_parts[0];\n\n        if (default_shell_parts.length > 1) {\n            default_shell_args = default_shell_parts.slice(1);\n        }\n\n        let running = true;\n        let final_code = 0;\n        let current_shell_process: ProcessContext;\n\n        // on exit, force shell to exit too\n        // TODO: add process ownership to automatically kill child processes\n        const proc_mgr = kernel.get_process_manager();\n        process.add_exit_listener(async (exit_code) => {\n            if (current_shell_process && proc_mgr.get_process(current_shell_process.pid)) {\n                current_shell_process.kill(exit_code);\n            }\n\n            final_code = exit_code;\n            running = false;\n        });\n\n        // execute shell in a respawn loop\n        while (running) {\n            const shell_proc = kernel.spawn(default_shell, default_shell_args);\n            current_shell_process = shell_proc.process;\n\n            let exit_code: number;\n            let error: Error | null = null;\n            try {\n                exit_code = await shell_proc.completion;\n                shell_proc.process.kill(exit_code);\n            } catch (e) {\n                console.error(e);\n                error = e as Error;\n                exit_code = -1;\n            }\n\n            console.log(`default shell ${default_shell} exited with code ${exit_code}`);\n\n            // early break in case jetty is being killed\n            if (!running) {\n                break;\n            }\n\n            term.reset();\n\n            term.writeln(exit_code === 0 ? \"Logged out.\" : `Shell exited with code ${exit_code}!`);\n\n            if (error) {\n                term.writeln(`Error details: ${error}`);\n            }\n\n            term.writeln(`Press any key to log back in.${ANSI.CURSOR.invisible}`);\n\n            await term.wait_for_keypress();\n            term.write(ANSI.CURSOR.visible);\n\n            term.reset();\n\n            // TODO: add recovery logic here too, maybe add /etc/safe_mode_shell file to launch ash --no-scripts or similar\n        }\n\n        return final_code;\n    }\n} as Program;\n","import type {AbstractShellMemory} from \"../../../abstract_shell\";\n\nexport class AshMemory implements AbstractShellMemory {\n    // TODO: backup history in a file\n    #history: string[] = [];\n\n    current_history_index = 0;\n\n    readonly #vars: Map<string, string> = new Map();\n    readonly #aliases: Map<string, string> = new Map();\n\n    clear_history(): void {\n        this.#history = [];\n        this.current_history_index = 0;\n    }\n\n    get_previous_history_entry(): string | undefined {\n        if (this.#history.length === 0 || this.current_history_index >= this.#history.length) {\n            return undefined;\n        }\n\n        const entry = this.#history[this.#history.length - 1 - this.current_history_index];\n        this.current_history_index += 1;\n        return entry;\n    }\n\n    get_next_history_entry(): string | undefined {\n        if (this.#history.length === 0 || this.current_history_index <= 0) {\n            return undefined;\n        }\n\n        this.current_history_index -= 1;\n        if (this.current_history_index === 0) {\n            return \"\";\n        }\n\n        return this.#history[this.#history.length - 1 - this.current_history_index];\n    }\n\n    add_history_entry(entry: string): void {\n        this.#history.push(entry);\n        this.current_history_index = 0;\n    }\n\n    list_variables(): Map<string, string> {\n        return this.#vars;\n    }\n\n    get_variable(name: string): string | undefined {\n        return this.#vars.get(name);\n    }\n\n    set_variable(name: string, value: string): void {\n        this.#vars.set(name, value);\n    }\n\n    unset_variable(name: string): boolean {\n        return this.#vars.delete(name);\n    }\n\n    list_aliases(): Map<string, string> {\n        return this.#aliases;\n    }\n\n    get_alias(name: string): string | undefined {\n        return this.#aliases.get(name);\n    }\n\n    set_alias(name: string, value: string): void {\n        this.#aliases.set(name, value);\n    }\n\n    unset_alias(name: string): boolean {\n        return this.#aliases.delete(name);\n    }\n}\n","import {AshMemory} from \"./memory\";\nimport type {ParsedCommandLine} from \"../../../kernel\";\n\nexport interface LineParseResultCommand extends ParsedCommandLine {\n    type: \"command\";\n}\n\nexport interface LineParseResultVarAssignment {\n    type: \"var\";\n\n    var_name: string;\n    var_value: string;\n}\n\nexport type LineParseResult = LineParseResultCommand | LineParseResultVarAssignment | null;\n\nconst VAR_ASSIGNMENT_REGEX = /^([a-zA-Z0-9_]+)=(.+)$/;\n\nexport const parse_line = (line: string, memory?: AshMemory): LineParseResult => {\n    if (line.length === 0) {\n        // if the line is empty, nothing to parse\n        return null;\n    }\n\n    // TODO: handle multiple commands separated by semicolons\n\n    // remove leading and trailing whitespace and split by spaces, unless contained in single or double quotes\n    // TODO: use a proper stack based parser for readability and maintainability\n    const raw_parts = line.split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\n    const sub = line.trim().split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\n\n    // handle aliases\n    // for each part, check if it's an alias, and if so, replace it with the value\n    // if the value ends with a space, check the next part as well\n    for (let i = 0; i < sub.length; i++) {\n        const part = sub[i];\n        const alias_value = memory ? memory.get_alias(part) : undefined;\n\n        if (!alias_value) {\n            // not an alias, abort (alias only applies to the first word unless chaining)\n            break;\n        }\n\n        // split the alias value into parts\n        const alias_parts = alias_value.split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\n\n        // if ends with a space, remove the trailing empty part\n        if (alias_value.endsWith(\" \")) {\n            alias_parts.pop();\n        }\n\n        // remove the current part and insert the alias parts\n        sub.splice(i, 1, ...alias_parts);\n\n        // adjust the index to account for the new parts\n        i += alias_parts.length - 1;\n\n        // if the alias value ends with a space, check the next part as well\n        if (!alias_value.endsWith(\" \")) {\n            break;\n        }\n    }\n\n    const skip_variable_sub_idxs = [];\n\n    // remove quotes from arguments if starting and ending with quotes\n    // if they are single quotes then disable substitution\n    for (let i = 0; i < sub.length; i++) {\n        if (i === 0) {\n            // skip the first argument (the command)\n            continue;\n        }\n\n        const arg = sub[i];\n\n        if (arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\")) {\n            sub[i] = arg.slice(1, -1);\n        }\n\n        if (arg.startsWith(\"'\") && arg.endsWith(\"'\")) {\n            sub[i] = arg.slice(1, -1);\n            skip_variable_sub_idxs.push(i - 1); // skip variable substitution for this argument (adjust for slice)\n        }\n    }\n\n    // the first word is the command, the rest are arguments\n    const command = sub[0];\n\n    if (command === \"#\") {\n        // if the command is a comment, just ignore\n        return null;\n    }\n\n    // determine if the line is a variable assignment with regex\n    if (command.includes(\"=\")) {\n        const match = line.match(VAR_ASSIGNMENT_REGEX);\n\n        if (match) {\n            const var_name = match[1];\n            let var_value = match[2];\n\n            // remove single or double quotes from the value\n            // TODO: make this more unixy when we add semicolons\n            if (var_value.startsWith(\"'\") || var_value.startsWith(\"\\\"\")) {\n                var_value = var_value.slice(1, -1);\n            }\n\n            // this is a variable assignment\n            return {\n                type: \"var\",\n\n                var_name,\n                var_value\n            }\n        }\n    }\n\n    const args = sub.slice(1);\n\n    // if the last arg value is &, run in bg and remove it from args BEFORE variable substitution\n    let run_in_bg = false;\n    if (args.length > 0 && args[args.length - 1] === \"&\") {\n        run_in_bg = true;\n        args.pop();\n    }\n\n    const unsubbed_args = args.slice();\n\n    // substitute args with variables\n    for (let arg_idx = 0; arg_idx < args.length; arg_idx++) {\n        if (skip_variable_sub_idxs.includes(arg_idx)) {\n            // skip variable substitution for this argument\n            continue;\n        }\n\n        let arg = args[arg_idx];\n\n        // replaces any instance of $VAR or ${VAR} with the value of the variable VAR (alphabetical only except special var $?)\n        // TODO: backslash to escape dollar sign without using single quotes\n        arg = arg.replace(/\\$(\\w+|\\?)|\\$\\{([^}]+)\\}/g, (match, var1, var2) => {\n            const var_name = var1 || var2;\n            const var_value = memory ? memory.get_variable(var_name) : undefined;\n\n            if (!var_value) {\n                // if the variable is not set, return the original match\n                return match;\n            }\n\n            return var_value;\n        });\n\n        args[arg_idx] = arg;\n    }\n\n    // this is a command\n    return {\n        type: \"command\",\n\n        command,\n        args,\n        unsubbed_args,\n        raw_parts,\n        run_in_bg\n    };\n}\n","import type {AbstractShell} from \"../../../abstract_shell\";\nimport type {UserspaceKernel, SpawnResult} from \"../../../kernel\";\n\nimport {ANSI, NEWLINE, type WrappedTerminal} from \"../../../kernel/term_ctl\";\n\nimport {AshMemory} from \"./memory\";\nimport {parse_line} from \"./parser\";\n\nconst {PREFABS, FG, STYLE} = ANSI;\n\nexport class AshShell implements AbstractShell {\n    readonly #kernel: UserspaceKernel;\n    readonly #term: WrappedTerminal;\n    readonly #memory = new AshMemory();\n\n    #prompt_suffix = \"$ \";\n\n    // TODO: find a better place/way to handle this, maybe tab completion should be a class that stores its own state\n    _discard_cached_matches = false;\n\n    constructor(term: WrappedTerminal, kernel: UserspaceKernel) {\n        this.#term = term;\n        this.#kernel = kernel;\n    }\n\n    get memory(): AshMemory {\n        return this.#memory;\n    }\n\n    // returns success flag (or error if critical)\n    execute = async (line: string, edit_doc_title = true, program_final_completion_callback?: (exit_code?: number) => void): Promise<boolean> => {\n        const kernel = this.#kernel;\n        const term = this.#term;\n        const memory = this.#memory;\n\n        // TODO: semicolon to run multiple commands regardless of success\n        // TODO: double ampersand to run multiple commands only if previous succeeded\n        // TODO: double pipe to run multiple commands only if previous failed\n        // TODO: single pipe to pipe output of previous command to next command\n        // TODO: allow certain control characters to be escaped e.g. $\n        // TODO: support sh files\n\n        if (line.length === 0) {\n            // if the line is empty, just move to the next line (additional check if called from external source)\n            return true;\n        }\n\n        const parsed_line = parse_line(line, memory);\n\n        if (parsed_line === null) {\n            // if the line is a comment or empty, do nothing\n            return true;\n        }\n\n        // handle variable assignment\n        if (parsed_line.type === \"var\") {\n            memory.set_variable(parsed_line.var_name, parsed_line.var_value);\n            return true;\n        }\n\n        // otherwise, it's a command. destructure it\n        const { command } = parsed_line;\n\n        // check if the command exists\n        const prog_reg = kernel.get_program_registry();\n        if (!prog_reg.getProgram(command)) {\n            term.writeln(`${PREFABS.error}Command not found: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\n            return false;\n        }\n\n        let old_title = \"\";\n        if (edit_doc_title) {\n            old_title = document.title;\n            document.title = command;\n        }\n\n        // spawn the process\n        let spawn_result: SpawnResult;\n        try {\n            spawn_result = kernel.spawn(parsed_line, undefined, this);\n        } catch (e) {\n            if (edit_doc_title) {\n                document.title = old_title;\n            }\n\n            term.writeln(`${PREFABS.error}Failed to execute command: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}.`);\n            term.writeln(`${FG.red + STYLE.italic}${(e as Error).message}${STYLE.reset_all}`);\n\n            console.error(e);\n\n            return false;\n        }\n\n        const { process, completion } = spawn_result;\n\n        const on_execute_completion = (exit_code?: number) => {\n            if (exit_code === undefined) {\n                exit_code = -2;\n                console.warn(`Program ${command} did not return an exit code. Defaulting to -2.`)\n            }\n\n            memory.current_history_index = 0;\n\n            if (edit_doc_title) {\n                document.title = old_title;\n            }\n\n            if (process.is_detached) {\n                process.add_exit_listener((code) => {\n                    if (program_final_completion_callback) {\n                        try {\n                            program_final_completion_callback(code);\n                        } catch (e) {\n                            console.error(\"Error in program final completion callback for detached process:\", e);\n                        }\n                    }\n\n                    if (process.detaches_silently) {\n                        return;\n                    }\n\n                    const status = code === 0 ? \"Done\" : `Exit ${code}`;\n                    const color = code === 0 ? FG.green : FG.red;\n\n                    // TODO: erase existing prompt and line\n                    term.writeln(\"\");\n                    term.writeln(`${FG.gray}[${process.pid}] + ${color}${status}${FG.gray} \\t ${command}${STYLE.reset_all}`);\n\n                    // reinsert the prompt and current line\n                    // TODO: respect running programs, maybe need a notification queue\n                    this.insert_prompt(false);\n                });\n\n                // don't kill the process\n                return;\n            }\n\n            process.kill(exit_code);\n\n            if (program_final_completion_callback) {\n                try {\n                    program_final_completion_callback(exit_code);\n                } catch (e) {\n                    console.error(\"Error in program final completion callback:\", e);\n                }\n            }\n\n            if (process.is_background) {\n                term.writeln(`\\n${FG.gray}[${process.pid}] + Done \\t ${command}${STYLE.reset_all}`);\n            }\n        }\n\n        // now handle awaiting program completion\n        try {\n            if (process.is_detached) {\n                if (!process.detaches_silently) {\n                    term.writeln(`${FG.gray}[${process.pid}] process detached${STYLE.reset_all}`);\n                }\n\n                completion.then((exit_code) => {\n                    on_execute_completion(exit_code);\n                }).catch((e) => {\n                    term.writeln(`${PREFABS.error}An unhandled error occurred in detached process [${process.pid}]: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\n                    console.error(e);\n                    on_execute_completion(-1);\n                });\n            } else if (process.is_foreground) {\n                const exit_code = await completion;\n                on_execute_completion(exit_code);\n\n                // set the exit code variable\n                memory.set_variable(\"?\", exit_code.toString());\n            } else {\n                this.#term.writeln(`${FG.gray}[${process.pid}] ${STYLE.italic}running in background${STYLE.reset_all}`);\n\n                completion.then((exit_code) => {\n                    on_execute_completion(exit_code);\n                }).catch((e) => {\n                    this.#term.writeln(`${PREFABS.error}An unhandled error occurred in background process [${process.pid}]: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\n                    console.error(e);\n\n                    on_execute_completion(-1);\n                });\n            }\n        } catch (e) {\n            term.writeln(`${PREFABS.error}An unhandled error occurred while running the command: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\n            console.error(e);\n\n            on_execute_completion(-1);\n            return false;\n        }\n\n        return true;\n    }\n\n    async run_script(path: string) {\n        const fs = this.#kernel.get_fs();\n\n        if (await fs.exists(path)) {\n            // iter through the lines of the file and execute them\n            const content = await fs.read_file(path) as string;\n            for (const line of content.split(NEWLINE)) {\n                // TODO: catch errors\n                await this.execute(line);\n            }\n        }\n    }\n\n    get_prompt_suffix(): string {\n        return this.#prompt_suffix;\n    }\n\n    set_prompt_suffix(suffix: string): void {\n        this.#prompt_suffix = suffix;\n    }\n\n    get_prompt_string(): string {\n        const fs = this.#kernel.get_fs();\n\n        let path = fs.get_cwd();\n\n        if (path.startsWith(fs.get_home())) {\n            // replace home with ~ at start of path only\n            path = path.replace(new RegExp(`^${fs.get_home()}`), \"~\");\n        }\n\n        // build result e.g. ~$\n        return `${PREFABS.dir_name}${path}${STYLE.reset_all}${this.#prompt_suffix}`;\n    }\n\n    async insert_prompt(newline = true) {\n        const term = this.#term;\n\n        if (newline) {\n            term.write(NEWLINE);\n        }\n\n        // resolve a promise when writing is complete\n        await new Promise<void>((resolve) => {\n            term.write(this.get_prompt_string(), () => {\n                resolve();\n            });\n        });\n    }\n}\n","import type {UserspaceKernel} from \"../../../kernel\";\nimport type {ReadLineBuffer, WrappedTerminal} from \"../../../kernel/term_ctl\";\nimport type {CompletionData} from \"../../../types\";\n\nimport {parse_line} from \"./parser\";\nimport {AbstractShell} from \"../../../abstract_shell\";\n\n// TODO this is really poor OOP\nlet cached_matches: string[] = [];\nlet current_cached_match_index = 0;\n\nconst complete_command = (buffer: ReadLineBuffer, discard_cached_matches: boolean, kernel: UserspaceKernel) => {\n    // get the program registry\n    const registry = kernel.get_program_registry();\n    const programs = registry.listProgramNames(true, true);\n\n    // check for existing matches\n    let match: string;\n    if (!discard_cached_matches && cached_matches.length > 0) {\n        // if the current line hasn't changed, just get the next match\n        current_cached_match_index = (current_cached_match_index + 1) % cached_matches.length;\n        match = cached_matches[current_cached_match_index] || \"\";\n    } else {\n        // if the current line has changed, refresh the matches\n        cached_matches = programs.filter((program) => program.startsWith(buffer.current_line));\n        current_cached_match_index = 0;\n\n        // get the first match\n        match = cached_matches[current_cached_match_index] || \"\";\n\n        // mark as unmodified\n        discard_cached_matches = false;\n    }\n\n    return {match, discard_cached_matches};\n}\n\nconst is_async_generator = (obj: unknown): obj is AsyncGenerator<string> => {\n    return obj && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\nconst get_completeable_arguments = async (buffer: ReadLineBuffer, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\n    // parse the line\n\n    const parsed_line = parse_line(buffer.current_line);\n    if (parsed_line.type !== \"command\") {\n        console.warn(\"Tab completion for non-command lines is not yet implemented\");\n        return null;\n    }\n\n    // destructure parsed line\n    const {command, args, unsubbed_args, raw_parts} = parsed_line;\n\n    // get the command from the registry\n    const registry = kernel.get_program_registry();\n    const program = registry.getProgram(command);\n    if (!program) {\n        console.warn(`Tab completion for unknown command \"${command}\"`);\n        return null;\n    }\n\n    // if the program has no completion generator, complete based on file paths\n    if (!program.completion) {\n        // TODO need to change data structure first\n        console.warn(`Tab completion for command \"${command}\" with no completion generator is not yet implemented`);\n        return null;\n    }\n\n    const completion_data = {\n        term,\n        kernel,\n        shell,\n        command,\n        args,\n        raw_parts: raw_parts,\n        unsubbed_args,\n        current_partial: raw_parts[raw_parts.length - 1] || \"\",\n        arg_index: raw_parts.length - 2, // -1 for current arg, -1 for program name\n    };\n\n    const completion_result = await program.completion(completion_data);\n\n    // if the result is an async generator, get all values for now\n    // in future this will be done incrementally, but the current data structure doesn't support that yet\n    if (is_async_generator(completion_result)) {\n        const results: string[] = [];\n        for await (const value of completion_result) {\n            results.push(value);\n        }\n        return results;\n    } else {\n        if (completion_result === null) {\n            // TODO fall back to file path completion\n            console.warn(`Tab completion for command \"${command}\" with null completion result is not yet implemented`);\n            return null;\n        }\n\n        return completion_result;\n    }\n}\n\nconst complete_argument = async (buffer: ReadLineBuffer, discard_cached_matches: boolean, kernel: UserspaceKernel, term: WrappedTerminal, shell?: AbstractShell) => {\n    // get the completeable arguments\n    const completeable_arguments = await get_completeable_arguments(buffer, term, kernel, shell);\n    if (!completeable_arguments) {\n        return {match: \"\", discard_cached_matches};\n    }\n\n    // check for existing matches\n    let match: string;\n    if (!discard_cached_matches && cached_matches.length > 0) {\n        // if the current line hasn't changed, just get the next match\n        current_cached_match_index = (current_cached_match_index + 1) % cached_matches.length;\n        match = cached_matches[current_cached_match_index] || \"\";\n    } else {\n        // if the current line has changed, refresh the matches\n        cached_matches = completeable_arguments.filter((arg) => arg.startsWith(buffer.current_line.split(\" \").pop() || \"\"));\n        current_cached_match_index = 0;\n\n        // get the first match\n        match = cached_matches[current_cached_match_index] || \"\";\n\n        // mark as unmodified\n        discard_cached_matches = false;\n    }\n\n    return {match, discard_cached_matches};\n}\n\nconst fill_completed_command = (term: WrappedTerminal, buffer: ReadLineBuffer, match: string) => {\n    // erase the current line\n    term.write(\"\\b \\b\".repeat(buffer.current_index));\n\n    // write the match\n    term.write(match);\n\n    // NOTE: above is done rather than filling what is remaining because if tab is hit again, the next match will be written\n\n    // update current line and index\n    buffer.set_current_line(match);\n    buffer.set_current_index(match.length);\n}\n\nconst fill_completed_argument = (term: WrappedTerminal, buffer: ReadLineBuffer, match: string) => {\n    // get the current line parts\n    const parts = buffer.current_line.split(\" \");\n    const current_arg_partial = parts.pop() || \"\";\n\n    // erase the current argument partial\n    term.write(\"\\b \\b\".repeat(current_arg_partial.length));\n\n    // write the match\n    term.write(match);\n\n    // NOTE: above is done rather than filling what is remaining because if tab is hit again, the next match will be written\n\n    // update current line and index\n    parts.push(match);\n    buffer.set_current_line(parts.join(\" \"));\n    buffer.set_current_index(buffer.current_line.length);\n}\n\n// TODO: how does this work? would be good to make it linked to the terminal instance. what is discard_cached_matches even for?\nexport const tab_complete = async (buffer: ReadLineBuffer, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell, discard_cached_matches = false): Promise<boolean> => {\n    // if the current line is empty, do nothing\n    if (buffer.current_line.length === 0) {\n        return;\n    }\n\n    // if the current line has no spaces, tab complete the command\n    if (!buffer.current_line.includes(\" \")) {\n        const {match, discard_cached_matches: updated_discard} = complete_command(buffer, discard_cached_matches, kernel);\n        discard_cached_matches = updated_discard;\n\n        // if there is a match, tab complete\n        if (match) {\n            fill_completed_command(term, buffer, match);\n        }\n    } else {\n        // otherwise, tab complete the argument\n        const {match, discard_cached_matches: updated_discard} = await complete_argument(buffer, discard_cached_matches, kernel, term, shell);\n        discard_cached_matches = updated_discard;\n\n        // if there is a match, tab complete\n        if (match) {\n            fill_completed_argument(term, buffer, match);\n        }\n    }\n\n    return discard_cached_matches;\n}\n\n// TODO: the discard cache arg is janky. come up with a better solution. should also be using generators directly instead of arrays for completions\n// TODO: would be much better as a class that maintains its own state and remembers term, kernel etc.\n\nexport const helper_completion_options = (options: string[]) => {\n    return async function* (data: CompletionData): AsyncGenerator<string> {\n        const {current_partial} = data;\n        for (const option of options) {\n            if (option.startsWith(current_partial)) {\n                yield option;\n            }\n        }\n    };\n}\n\nexport const helper_completion_options_ordered = (options: string[][]) => {\n    return async function* (data: CompletionData): AsyncGenerator<string> {\n        const {current_partial, raw_parts} = data;\n        const index = raw_parts.length - 1;\n        const options_at_index = options[index] || [];\n        for (const option of options_at_index) {\n            if (option.startsWith(current_partial)) {\n                yield option;\n            }\n        }\n    };\n}\n\n// TODO: make these helpers available to 3rd party programs","import type {Program} from \"../../../types\";\nimport {NEWLINE} from \"../../../kernel/term_ctl\";\n\nimport {AshShell} from \"./core\";\nimport {make_read_line_key_handlers, make_read_line_printable_handler} from \"./key_handlers\";\n\nexport default {\n    name: \"ash\",\n    description: \"A shell.\",\n    usage_suffix: \"[--login] [--no-scripts]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"--login\": \"Start the shell as a login shell. Don't pass this flag manually, it's handled by the system.\",\n            \"--no-scripts\": \"Do not run any startup scripts like .ashrc or .ash_profile.\"\n        }\n    },\n    compat: \"2.0.0\",\n    main: async (data) => {\n        const {kernel, term, process, args} = data;\n\n        const shell = new AshShell(term, kernel);\n\n        const env_info = kernel.get_env_info();\n        shell.memory.set_variable(\"VERSION\", env_info.version);\n        shell.memory.set_variable(\"ENV\", env_info.env);\n\n        const fs = kernel.get_fs();\n\n        const absolute_profile = fs.absolute(\"~/.ash_profile\");\n        const absolute_rc = fs.absolute(\"~/.ashrc\");\n\n        // create .ash_profile file if it doesn't exist\n        const profile_content = `# ash configuration file${NEWLINE}# This file is run at login.${NEWLINE}${NEWLINE}cat /etc/motd.txt${NEWLINE}echo \"OllieOS v$VERSION ($ENV)\"${NEWLINE}`;\n        if (!(await fs.exists(absolute_profile))) {\n            await fs.write_file(absolute_profile, profile_content);\n        }\n\n        // create .ashrc file if it doesn't exist\n        const rc_content = `# ash configuration file${NEWLINE}# This file is run when a shell is created.${NEWLINE}${NEWLINE}`;\n        if (!(await fs.exists(absolute_rc))) {\n            await fs.write_file(absolute_rc, rc_content);\n        }\n\n        if (args.includes(\"--login\")) {\n            // enable screen reader mode if stored in local storage\n            if (localStorage.getItem(\"reader\") === \"true\") {\n                await shell.execute(\"reader -s on\");\n            }\n\n            // run .ash_profile, checking it exists again just in case (because why not)\n            if (!args.includes(\"--no-scripts\") && await fs.exists(absolute_profile)) {\n                await shell.run_script(absolute_profile);\n            }\n        }\n\n        // run .ashrc, checking it exists again just in case (could be deleted in profile)\n        if (!args.includes(\"--no-scripts\") && await fs.exists(absolute_rc)) {\n            await shell.run_script(absolute_rc);\n        }\n\n        let running = true;\n        let final_code = 0;\n        process.add_exit_listener((exit_code) => {\n            final_code = exit_code;\n            running = false;\n        });\n\n        const read_line_key_handlers = make_read_line_key_handlers(shell, kernel);\n        const read_line_printable_handler = make_read_line_printable_handler(shell);\n\n        while (running) {\n            await shell.insert_prompt(true);\n\n            const input = await term.read_line(read_line_key_handlers, read_line_printable_handler);\n            if (!input.trim()) {\n                continue;\n            }\n\n            // TODO: have an actual builtin processor instead of just reading input here\n            if (input === \"exit\") {\n                running = false;\n                break;\n            }\n\n            shell.memory.add_history_entry(input);\n            await shell.execute(input);\n        }\n\n        return final_code;\n    }\n} as Program;\n","import type {ReadLineKeyHandler} from \"../../../kernel/term_ctl\";\n\nimport type {AshShell} from \"./core\";\nimport type {UserspaceKernel} from \"../../../kernel\";\nimport {tab_complete} from \"./tab_completion\";\n\nexport const make_read_line_key_handlers = (shell: AshShell, kernel: UserspaceKernel): { [key: string]: ReadLineKeyHandler } => ({\n    // arrow up - previous history\n    \"\\x1b[A\": (_e, term, buffer) => {\n        const command = shell.memory.get_previous_history_entry();\n\n        if (command) {\n            shell._discard_cached_matches = true;\n\n            // bring cursor to end of line\n            term.write(\" \".repeat(buffer.current_line.length - buffer.current_index));\n\n            // clear current line (and move cursor back to start)\n            term.write(\"\\b \\b\".repeat(buffer.current_line.length));\n\n            // write command\n            term.write(command);\n\n            // update current line and index\n            buffer.set_current_line(command);\n            buffer.set_current_index(command.length);\n        }\n    },\n\n    // arrow down - next history\n    \"\\x1b[B\": (_e, term, buffer) => {\n        const command = shell.memory.get_next_history_entry();\n\n        shell._discard_cached_matches = true;\n\n        // bring cursor to end of line\n        term.write(\" \".repeat(buffer.current_line.length - buffer.current_index));\n\n        // clear current line (and move cursor back to start)\n        term.write(\"\\b \\b\".repeat(buffer.current_line.length));\n\n        if (command) {\n            // write command\n            term.write(command);\n\n            // update current line and index\n            buffer.set_current_line(command);\n            buffer.set_current_index(command.length);\n        } else {\n            // end of history, just clear line\n            buffer.set_current_line(\"\");\n            buffer.set_current_index(0);\n        }\n    },\n\n    // tab - tab completion\n    \"\\t\": async (_e, term, buffer) => {\n        shell._discard_cached_matches = await tab_complete(buffer, term, kernel, shell, shell._discard_cached_matches);\n    },\n\n    // backspace - discard cached matches\n    \"\\x7f\": () => {\n        // TODO: doesnt work quite the same, if they tab with nothing and hit backspace it will reset. need a way to check current line discipline\n        shell._discard_cached_matches = true;\n    }\n});\n\nexport const make_read_line_printable_handler = (shell: AshShell) => () => {\n    shell._discard_cached_matches = true;\n};\n","import type { Program } from \"../../types\";\nimport type {UserspaceOtherProcessContext} from \"../../kernel/processes\";\n\nimport {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\n\ninterface PrivilegeRequestMessage {\n    process: UserspaceOtherProcessContext;\n    reason: string;\n}\n\nexport default {\n    name: \"default_privilege_agent\",\n    description: \"Default agent for handling kernel privilege requests\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    hide_from_help: true,\n    compat: \"2.0.0\",\n    main: async (data) => {\n        const { kernel, term, args, process: my_process } = data;\n\n        // expect arg for channel id\n        const channel_id_str = args[0];\n        if (!channel_id_str) {\n            term.writeln(\"Error in privilege agent: No channel ID provided.\");\n            return 1;\n        }\n\n        const channel_id = parseInt(channel_id_str, 10);\n        if (isNaN(channel_id)) {\n            term.writeln(\"Error in privilege agent: Invalid channel ID.\");\n            return 1;\n        }\n\n        // wait briefly to ensure the channel is assigned to us\n        // TODO: a way to fix the race condition without making the kernel expose ipc, could at least use a retry mechanism\n        await new Promise((resolve) => setTimeout(resolve, 250));\n\n        // listen to the channel\n        const ipc = kernel.get_ipc();\n\n        let finished = false;\n        let handling_request = false;\n\n        ipc.channel_listen(channel_id, async (msg) => {\n            if (handling_request) {\n                // already handling a request, ignore new ones\n                return;\n            }\n\n            handling_request = true;\n\n            const { process, reason } = msg.data as PrivilegeRequestMessage;\n\n            // immediately acknowledge the request is being handled\n            ipc.channel_send(channel_id, {\n                process,\n                handling: true\n            });\n\n            term.writeln(`${NEWLINE}${ANSI.STYLE.bold}${ANSI.BG.blue}${ANSI.FG.white}KERNEL PRIVILEGE REQUEST${ANSI.STYLE.reset_all}${ANSI.BG.gray}${NEWLINE}`);\n\n            term.writeln(`Process PID ${process.pid} (${process.source_command.command}) is requesting elevated kernel privileges.`);\n            term.writeln(`The process gave the following reason for the request:${NEWLINE}`);\n\n            term.writeln(`${ANSI.STYLE.bold}${ANSI.FG.yellow}\"${reason}\"${ANSI.FG.reset}${ANSI.STYLE.no_bold_or_dim}${NEWLINE}`);\n\n            term.writeln(\"Granting this request will allow the process full access to the kernel, which may compromise system security and stability.\");\n            term.writeln(\"It may also be able to temporarily share this access with other running processes.\");\n\n            term.writeln(`${NEWLINE}Do you wish to grant elevated privileges to PID ${process.pid}? (y/n)${ANSI.STYLE.reset_all}${ANSI.CURSOR.invisible}`);\n\n            const event = await term.wait_for_keypress();\n            term.write(ANSI.CURSOR.visible);\n\n            if (event.key.toLowerCase() === \"y\") {\n                term.writeln(`${NEWLINE}${ANSI.BG.green}${ANSI.FG.white}Privilege request granted.${ANSI.STYLE.reset_all}${NEWLINE}`);\n                ipc.channel_send(channel_id, {\n                    process,\n                    granted: true\n                });\n            } else {\n                term.writeln(`${NEWLINE}${ANSI.BG.red}${ANSI.FG.white}Privilege request denied.${ANSI.STYLE.reset_all}${NEWLINE}`);\n                ipc.channel_send(channel_id, {\n                    process,\n                    granted: false\n                });\n            }\n\n            finished = true;\n        });\n\n        my_process.add_exit_listener(() => {\n            finished = true;\n        });\n\n        // wait to handle for up to 10 seconds\n        // overall timeout up to 60 seconds\n        const start_time = Date.now();\n        // TODO: clean up logic here\n        while ((Date.now() - start_time) < 60000 && !finished && (handling_request || (Date.now() - start_time) < 10000)) {\n            const timeout_id = my_process.create_timeout(() => {}, 100);\n            await my_process.wait_for_timeout(timeout_id);\n        }\n\n        return 0;\n    }\n} as Program;\n","import type {PrivilegedProgram} from \"../../types\";\n\nimport {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\n\nexport default {\n    name: \"recovery\",\n    description: \"Emergency recovery environment\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    hide_from_help: true,\n    compat: \"2.0.0\",\n    main: async (data) => {\n        const { kernel, term } = data;\n\n        const {CURSOR} = ANSI;\n\n        if (!kernel.privileged) {\n            term.writeln(\"Recovery requires privileged environment.\");\n            return 1;\n        }\n\n        let running = true;\n        while (running) {\n            term.reset();\n\n            term.writeln(\"RECOVERY ENVIRONMENT\");\n            term.writeln(\"===================\");\n            term.write(NEWLINE);\n            term.writeln(\"1. Reboot\");\n            term.writeln(\"2. Privileged ash shell\");\n            term.writeln(\"3. Reset bootloader and reboot\");\n            term.writeln(\"4. Wipe filesystem and reboot\");\n            term.write(NEWLINE);\n            term.writeln(\"X: Exit recovery\");\n            term.write(NEWLINE);\n            term.writeln(\"Press the corresponding key to select an option.\");\n\n            if (typeof window !== \"undefined\") {\n                term.writeln(`Recovery also available at ${window.location.origin}/recover_fs`);\n            }\n\n            term.write(CURSOR.invisible);\n\n            const key = await term.wait_for_keypress();\n\n            switch (key.key.toLowerCase()) {\n                case \"1\":\n                    term.writeln(NEWLINE + \"Rebooting...\");\n                    window.location.reload();\n                    break;\n                case \"2\": {\n                    term.writeln(NEWLINE + \"Starting privileged ash shell...\");\n                    term.write(CURSOR.visible);\n\n                    // TODO: this doesnt make much difference being privileged as the programs are separate processes\n                    // TODO: bypass the privilege agent instead\n                    let exit_code: number;\n                    const shell = kernel.spawn(\"ash\", [\"--no-scripts\"], undefined, true);\n                    try {\n                        exit_code = await shell.completion;\n                    } catch (e) {\n                        exit_code = -1;\n                        term.writeln(\"Error in privileged shell:\");\n                        term.writeln(e);\n                    }\n\n                    shell.process.kill(exit_code)\n                }\n                    break;\n                case \"3\": {\n                    term.writeln(\"Are you sure you want to reset the bootloader? This will clear your choice of init system, boot target, default shell, and privilege agent but retains your files.\");\n                    term.writeln(\"Press Y to confirm, or any other key to cancel.\");\n\n                    const confirm_key = await term.wait_for_keypress();\n                    if (confirm_key.key.toLowerCase() !== \"y\") {\n                        term.writeln(\"Bootloader reset cancelled.\");\n                        break;\n                    }\n\n                    term.writeln(NEWLINE + \"Resetting bootloader...\");\n\n                    // delete /boot/init, /etc/boot_target, /etc/default_shell, /sys/privilege_agent\n                    const fs = kernel.get_fs();\n                    try {\n                        await fs.delete_file(\"/boot/init\");\n                    } catch (e) {\n                        term.writeln(\"Warning: Failed to delete /boot/init\");\n                        term.writeln(e);\n                    }\n\n                    try {\n                        await fs.delete_file(\"/etc/boot_target\");\n                    } catch (e) {\n                        term.writeln(\"Warning: Failed to delete /etc/boot_target\");\n                        term.writeln(e);\n                    }\n\n                    try {\n                        await fs.delete_file(\"/etc/default_shell\");\n                    } catch (e) {\n                        term.writeln(\"Warning: Failed to delete /etc/default_shell\");\n                        term.writeln(e);\n                    }\n\n                    try {\n                        await fs.delete_file(\"/sys/privilege_agent\");\n                    } catch (e) {\n                        term.writeln(\"Warning: Failed to delete /sys/privilege_agent\");\n                        term.writeln(e);\n                    }\n\n                    term.writeln(\"Rebooting...\");\n                    window.location.reload();\n                }\n                    break;\n                case \"4\": {\n                    term.writeln(\"Are you sure you want to erase the filesystem? This action cannot be undone.\");\n                    term.writeln(\"Press Y to confirm, or any other key to cancel.\");\n\n                    const confirm_key = await term.wait_for_keypress();\n                    if (confirm_key.key.toLowerCase() !== \"y\") {\n                        term.writeln(\"Filesystem wipe cancelled.\");\n                        break;\n                    }\n\n                    term.writeln(NEWLINE + \"Wiping filesystem...\");\n\n                    const fs = kernel.get_fs();\n                    try {\n                        await fs.erase_all();\n                    } catch (e) {\n                        term.writeln(\"Error: Failed to wipe filesystem.\");\n                        term.writeln(e);\n                    }\n\n                    term.writeln(\"Rebooting...\");\n                    window.location.reload();\n                }\n                    break;\n                case \"x\":\n                    term.writeln(NEWLINE + \"Exiting recovery.\");\n                    running = false;\n                    break;\n                default:\n                    // ignore other keys\n                    break;\n            }\n        }\n\n        return 0;\n    }\n} as PrivilegedProgram;\n","import { ANSI, NEWLINE, ANSI_ESCAPE_REGEX } from \"../kernel/term_ctl\";\nimport type { Program, ArgDescriptions } from \"../types\";\n\n\n// deferred to prevent double printing of header if program has to re-execute itself\nconst header = (term, includes_mounted: boolean) => {\n    // write header\n\n    if (!includes_mounted) {\n        term.writeln(`${ANSI.STYLE.italic}(Only built-in programs are included. Use the -m flag to include only mounted programs, or the -a flag to include all.)${ANSI.STYLE.reset_all}`);\n    }\n\n    term.writeln(`For help on a specific command, type ${ANSI.PREFABS.program_name}help${ANSI.STYLE.reset_all} [command].`)\n    term.writeln(`The exit code of the most recently executed program is stored in the ${ANSI.PREFABS.variable_name}$?${ANSI.STYLE.reset_all} variable.`)\n    term.writeln(`You can set variables with the syntax ${ANSI.PREFABS.variable_name}variable${ANSI.STYLE.reset_all}=value and unset them with ${ANSI.PREFABS.program_name}unset${ANSI.STYLE.reset_all}.`)\n    term.writeln(`To persist the variables, define them in the ${ANSI.PREFABS.file_path}.ollierc${ANSI.STYLE.reset_all} file in your ${ANSI.PREFABS.dir_name}home${ANSI.STYLE.reset_all} directory.`)\n    term.writeln(`You can run commands in the background by appending ${ANSI.STYLE.bold}${ANSI.FG.magenta}&${ANSI.STYLE.reset_all} to the end of the command.`)\n    term.write(NEWLINE);\n}\n\n// TODO: this should also probably be part of the shell rather than a program? i guess it doesn't matter much, it just acts more like man\nexport default {\n    name: \"help\",\n    description: \"List programs or get help for a specific program.\",\n    usage_suffix: \"[command | -s] [-a | -m]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"command\": \"The name of the program to get help for.\",\n        },\n        \"Flags:\": {\n            \"-s\": \"Single-column mode. Forces the program list to be displayed in a single column.\",\n            \"-a\": \"All programs. Includes all programs, built-in and mounted.\",\n            \"-m\": \"Mounted programs. Includes only mounted programs.\",\n        },\n    },\n    compat: \"2.0.0\",\n    completion: async (data) => {\n        // TODO smarter completion to handle number of args and flags\n        const programs = data.kernel.get_program_registry().listProgramNames();\n        return programs.filter((program) => program.startsWith(data.current_partial));\n    },\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { shell, kernel, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS } = ANSI;\n\n        const registry = kernel.get_program_registry();\n\n        let single_column = false;\n        let includes_mounted = false;\n        let includes_builtin = true;\n\n        // parse and remove flags from args\n        for (let i = 0; i < args.length; i++) {\n            switch (args[i]) {\n                case \"-s\":\n                    single_column = true;\n                    args.splice(i, 1);\n                    i--;\n                    break;\n                case \"-a\":\n                    includes_mounted = true;\n                    includes_builtin = true;\n                    args.splice(i, 1);\n                    i--;\n                    break;\n                case \"-m\":\n                    includes_mounted = true;\n                    includes_builtin = false;\n                    args.splice(i, 1);\n                    i--;\n                    break;\n            }\n        }\n\n        // if no arguments remain, use list mode\n        if (args.length === 0) {\n            // get program names\n            const programs = registry.listProgramNames(includes_builtin, includes_mounted);\n\n            // remove hidden programs\n            const visible_programs = programs.filter((program_name) => {\n                const program = registry.getProgram(program_name);\n                return program !== undefined && !program.hide_from_help;\n            });\n\n            // add usage suffix and styling to each program name\n            const programs_fmt = visible_programs.map((program) => {\n                return `${PREFABS.program_name}${program}${STYLE.reset_all} ${registry.getProgram(program).usage_suffix}`;\n            });\n\n            // sort the programs alphabetically (usually already sorted alphabetically by Object.keys, but not guaranteed)\n            programs_fmt.sort();\n\n\n            if (single_column) {\n                // FORMAT THE PROGRAMS INTO 1 COLUMN\n\n                header(term, includes_mounted);\n                term.writeln(programs_fmt.join(NEWLINE));\n            } else {\n                // FORMAT THE PROGRAMS INTO 2 COLUMNS\n\n\n                // get the maximum length of a column\n                const max_allowable_length = Math.floor(term.cols / 2) - 1;\n\n\n                // split the programs into 2 columns\n                const column1 = programs_fmt.filter((_, i) => i <= programs_fmt.length / 2);\n                const column2 = programs_fmt.filter((_, i) => i > programs_fmt.length / 2);\n\n\n                // compute the length of the longest program name\n                const longest_program_length = Math.max(...programs_fmt.map((program) => program.replace(ANSI_ESCAPE_REGEX, \"\").length));\n\n                // compute the smallest padding length\n                const min_padding_length = max_allowable_length - longest_program_length;\n\n                // if there is negative padding (overlap, terminal too small), re-execute the program in single-column mode\n                if (min_padding_length < 0) {\n                    term.writeln(\"Terminal too small to display programs in 2 columns. Re-executing in single-column mode.\");\n                    term.write(NEWLINE);\n                    \n                    const new_args = [\"-s\"];\n\n                    if (includes_mounted) {\n                        new_args.push(\"-m\");\n                    }\n\n                    if (includes_builtin) {\n                        new_args.push(\"-a\");\n                    }\n                    \n                    return await kernel.spawn(\"help\", new_args, shell).completion;\n                }\n\n\n                // pair the programs in the 2 columns\n                const paired_programs = column1.map((program1, i) => {\n                    let program2 = column2[i] ?? \"\";\n\n                    const program1_real_length = program1.replace(ANSI_ESCAPE_REGEX, \"\").length;\n                    const program2_real_length = program2.replace(ANSI_ESCAPE_REGEX, \"\").length;\n\n                    // if the program name is too long, truncate it\n                    if (program1_real_length > max_allowable_length) {\n                        program1 = program1.slice(0, max_allowable_length / 2 - 3) + \"...\";\n                    }\n                    if (program2_real_length > max_allowable_length) {\n                        program2 = program2.slice(0, max_allowable_length / 2 - 3) + \"...\";\n                    }\n\n                    // pad the programs so that they are both left-aligned\n                    const padding = \" \".repeat(max_allowable_length - program1_real_length);\n                    return program1 + padding + program2;\n                });\n\n\n                // write the programs to the terminal\n                header(term, includes_mounted);\n                term.writeln(paired_programs.join(NEWLINE));\n            }\n\n            return 0;\n        }\n\n        // if an argument remains, get help for it\n        const program = registry.getProgram(args[0]);\n\n        if (program === undefined) {\n            term.writeln(`${PREFABS.error}Could not resolve help for ${args[0]}.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        term.writeln(`${NEWLINE}${PREFABS.program_name}${program.name}${STYLE.reset_all}`);\n        term.writeln(`${program.description}`);\n        term.write(NEWLINE);\n        term.writeln(`Usage: ${PREFABS.program_name}${program.name}${STYLE.reset_all} ${program.usage_suffix}`);\n\n        if (Object.keys(program.arg_descriptions).length > 0) {\n            // recurse each level of nesting\n            // each level is a section title, until the innermost object, in which they are pairs of argument name and description.\n            // add indents depending on the level of nesting\n            const recurse = (descs: ArgDescriptions, nest_level: number): string => {\n                let output = \"\";\n\n                for (const [key, value] of Object.entries(descs)) {\n                    if (typeof value === \"string\") {\n                        // argument, innermost nest\n                        output += `${\" \".repeat(nest_level * 4)}${key} - ${value}${NEWLINE}`;\n                    } else {\n                        // title, deeper nest\n                        output += `${NEWLINE}${\" \".repeat(nest_level * 4)}${STYLE.bold + STYLE.italic}${key}${STYLE.reset_all}${NEWLINE}`;\n                        output += recurse(value, nest_level + 1);\n                    }\n                }\n\n                return output;\n            }\n\n\n            term.write(NEWLINE);\n            term.write(recurse(program.arg_descriptions, 0));\n        }\n\n        return 0;\n    }\n} as Program;","import { ANSI } from \"../kernel/term_ctl\";\nimport type { Program } from \"../types\";\n\nexport default {\n    name: \"shutdown\",\n    description: \"Stops the OS.\",\n    usage_suffix: \"[-h] [-r] [-t ms]\",\n    arg_descriptions: {\n        \"Flags:\": {\n            \"-h\": \"Show this help message.\",\n            \"-r\": \"Reboot the terminal.\",\n            \"-t\": \"Set the time before shutdown in milliseconds. Default is 1000.\"\n        }\n    },\n    compat: \"2.0.0\",\n    // TODO: completion\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, shell, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { FG, STYLE } = ANSI;\n\n        let time = 1000;\n        let restart = false;\n\n        for (const arg of args) {\n            switch (arg) {\n                case \"-h\":\n                    return await kernel.spawn(\"help\", [\"shutdown\"], shell).completion;\n                case \"-r\":\n                    restart = true;\n                    break;\n                case \"-t\": {\n                    // get the next argument\n                    const time_arg = args[args.indexOf(arg) + 1];\n                    if (time_arg === undefined) {\n                        term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\n                        return 1;\n                    }\n\n                    // parse the time\n                    const parsed_time = parseInt(time_arg);\n                    if (isNaN(parsed_time)) {\n                        term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\n                        return 1;\n                    }\n\n                    time = parsed_time;\n\n                    // skip the next argument\n                    args.splice(args.indexOf(arg) + 1, 1);\n                    break;\n                }\n                default:\n                    term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\n                    return 1;\n            }\n        }\n\n        if (restart) {\n            term.writeln(`${FG.red}Restarting...${STYLE.reset_all}`);\n        } else {\n            term.writeln(`${FG.red}Shutting down...${STYLE.reset_all}`);\n        }\n\n        setTimeout(() => {\n            if (restart) {\n                window.location.reload();\n            } else {\n                term.dispose();\n            }\n        }, time);\n\n        // hang the terminal until it is shut down or restarted (dont allow any more commands)\n        // await an event that will never happen\n        await new Promise(() => {});\n    }\n} as Program;\n\n// TODO: move this to talk to ignition to perform a soft (or hard) shutdown via IPC\n","import { ANSI } from \"../kernel/term_ctl\";\nimport type { Program } from \"../types\";\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\n\nexport default {\n    name: \"clear\",\n    description: \"Clears the screen, and/or the scrollback.\",\n    usage_suffix: \"[-h | -s | -so]\",\n    arg_descriptions: {\n        \"Flags:\": {\n            \"-h\": \"Show this help message.\",\n            \"-s\": \"Clear the screen and the scrollback.\",\n            \"-so\": \"Only clear the scrollback.\"\n        }\n    },\n    compat: \"2.0.0\",\n    completion: helper_completion_options([\"-h\", \"-s\", \"-so\"]),\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, shell, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { FG, STYLE, PREFABS } = ANSI;\n\n        switch (args[0]) {\n            case undefined:\n                term.reset();\n                break;\n            case \"-s\":\n                term.reset();\n\n                if (shell) {\n                    shell.memory.clear_history();\n                } else {\n                    term.writeln(`${PREFABS.error}Cannot clear scrollback: no shell available.${STYLE.reset_all}`);\n                    return 1;\n                }\n\n                break;\n            case \"-so\":\n                if (!shell) {\n                    term.writeln(`${PREFABS.error}Cannot clear scrollback: no shell available.${STYLE.reset_all}`);\n                    return 1;\n                }\n\n                shell.memory.clear_history();\n                term.writeln(`${STYLE.bold + FG.gray}Scrollback cleared.${STYLE.reset_all}`);\n                break;\n            case \"-h\":\n                return await kernel.spawn(\"help\", [\"clear\"], shell).completion;\n            default:\n                term.writeln(`${FG.red}Invalid argument: ${args[0]}${STYLE.reset_all}`);\n                return 1;\n        }\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\n\nexport default {\n    name: \"echo\",\n    description: \"Echos a string to the terminal.\",\n    usage_suffix: \"string\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"string\": \"The string to echo.\"\n        }\n    },\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { args, term } = data;\n\n        const content = args.join(\" \");\n        term.writeln(content);\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\n\nexport default {\n    name: \"unset\",\n    description: \"Unsets a list of variables.\",\n    usage_suffix: \"[names...]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"names\": \"The names of each variable to unset.\"\n        }\n    },\n    compat: \"2.0.0\",\n    completion: async (data) => {\n        if (!data.shell) {\n            return [];\n        }\n\n        const var_names = [...data.shell.memory.list_variables().keys()];\n        // TODO: check type to see why helper_completion_options wont work here\n        return var_names.filter(name => name.startsWith(data.current_partial));\n    },\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { shell, args, term } = data;\n\n        if (!shell) {\n            term.writeln(\"No shell available\");\n            return 1;\n        }\n\n        // TODO: move to shell builtin, not actual program\n\n        // for each variable name, unset it, with no regards to whether it exists or not\n        for (const name of args) {\n            shell.memory.unset_variable(name);\n        }\n        \n        return 0;\n    }\n} as Program;","import { ANSI, ANSI_ESCAPE_REGEX, ANSI_UNESCAPED_REGEX } from \"../kernel/term_ctl\";\nimport type { Program } from \"../types\";\n\nexport default {\n    name: \"ls\",\n    description: \"List files in the current or another directory.\",\n    usage_suffix: \"[-h] [-a] [path]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"path\": \"The path to the directory to list. Defaults to the current directory.\"\n        },\n        \"Flags:\": {\n            \"-h\": \"Show this help message.\",\n            \"-a\": \"Show hidden files.\"\n        }\n    },\n    compat: \"2.0.0\",\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, shell, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS } = ANSI;\n\n        // get filesystem\n        const fs = kernel.get_fs();\n\n        // parse arguments\n        let show_hidden = false;\n        let path = fs.get_cwd();\n\n        for (const arg of args) {\n            switch (arg) {\n                case \"-a\":\n                    show_hidden = true;\n                    break;\n                case \"-h\":\n                    return await kernel.spawn(\"help\", [\"ls\"], shell).completion;\n                default:\n                    path = fs.absolute(arg);\n            }\n        }\n\n        // check if path is a directory and exists\n        if (!(await fs.dir_exists(path))) {\n            term.writeln(`${PREFABS.error}No such directory: ${path}${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // list dir\n        let dir = await fs.list_dir(path);\n\n        // sort alphabetically (usually already sorted by Object.keys but just in case)\n        dir.sort();\n\n        // filter out hidden files\n        if (!show_hidden) {\n            dir = dir.filter((file) => !file.startsWith(\".\"));\n        }\n\n        // fit as many files as possible on one line, with a space between each, otherwise wrap\n        const max_width = term.cols;\n        let line = \"\";\n\n        for (const file of dir) {\n            // check if file will fit on current line\n            const real_length = line.replace(ANSI_ESCAPE_REGEX, \"\").replace(ANSI_UNESCAPED_REGEX, \"\").length;\n            if (real_length + file.length + 1 > max_width) {\n                // write line and reset\n                term.writeln(line);\n                line = \"\";\n            }\n\n            // add to line\n            if (await fs.dir_exists(fs.join(path, file))) {\n                line += `${PREFABS.dir_name}${file}${STYLE.reset_all} `;\n            } else {\n                line += `${PREFABS.file_path}${file}${STYLE.reset_all} `;\n            }\n        }\n\n        // write last line\n        term.writeln(line);\n\n        return 0;\n    }\n} as Program;","import { ANSI } from \"../kernel/term_ctl\";\nimport type { Program } from \"../types\";\n\nexport default {\n    name: \"cd\",\n    description: \"Change directory.\",\n    usage_suffix: \"[path]\",\n    arg_descriptions: {\n        path: \"Path to directory to change to. If no path is given, change to home directory.\"\n    },\n    compat: \"2.0.0\",\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS } = ANSI;\n        \n        // get filesystem\n        const fs = kernel.get_fs();\n\n        \n        // if no arguments, go to home directory\n        if (args.length === 0) {\n            fs.set_cwd(fs.get_home());\n            return 0;\n        }\n\n        // if more than one argument, print error\n        if (args.length > 1) {\n            term.writeln(`${PREFABS.error}Too many arguments${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // check if path is a directory and exists\n        const path = args[0];\n        const absolute_path = fs.absolute(path);\n\n        if (!(await fs.dir_exists(absolute_path))) {\n            term.writeln(`${PREFABS.error}No such directory: ${path}${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // change directory\n        fs.set_cwd(absolute_path);\n\n        return 0;\n    }\n} as Program;","import { ANSI } from \"../kernel/term_ctl\";\nimport type { Program } from \"../types\";\n\nexport default {\n    name: \"pwd\",\n    description: \"Print working directory.\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS } = ANSI;\n        \n        // get filesystem\n        const fs = kernel.get_fs();\n\n        // print working directory\n        term.writeln(PREFABS.dir_name + fs.get_cwd() + STYLE.reset_all);\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { ANSI, NEWLINE, WrappedTerminal, NON_PRINTABLE_REGEX } from \"../kernel/term_ctl\";\n\nconst HEADER = 2;\n\nconst setup = (term: WrappedTerminal, content: string, path: string, readonly: boolean) => {\n    // extract from ANSI to make code less verbose\n    const { STYLE, BG, FG } = ANSI;\n\n    // clear the screen\n    term.clear();\n\n    // write the file name centered in the header, showing the read-only status if the file is read-only\n    const filename = path.split(\"/\").pop() || \"\";\n    const header = readonly ? `Viewing read-only file: ${filename}` : `Editing file: ${filename}`;\n    const h_padding_l = \" \".repeat(Math.ceil((term.cols - header.length) / 2));\n    const h_padding_r = \" \".repeat(Math.floor((term.cols - header.length) / 2));\n\n    term.write(BG.white + FG.black + STYLE.bold);\n    term.write(h_padding_l);\n    term.write(header);\n    term.write(h_padding_r);\n    term.write(STYLE.reset_all)\n\n    // go to the bottom of the screen with ansi\n    term.write(`\\x1b[${term.rows - 1};0H`);\n\n    // write the footer, showing the save and exit key if the file is not read-only\n    const footer = `${readonly ? \"\" : \"F1: Save & Exit | \"}ESC: Exit without saving | F2: Debug Redraw`;\n    const f_padding_l = \" \".repeat(Math.ceil((term.cols - footer.length) / 2));\n    const f_padding_r = \" \".repeat(Math.floor((term.cols - footer.length) / 2));\n\n    term.write(BG.white + FG.black + STYLE.bold);\n    term.write(f_padding_l);\n    term.write(footer);\n    term.write(f_padding_r);\n    term.write(STYLE.reset_all)\n\n    // reset the cursor position to under the header\n    term.write(\"\\x1b[2;0H\");\n    term.write(NEWLINE);\n\n    // write the content\n    term.write(content);\n\n    // reset the cursor position to under the header\n    term.write(\"\\x1b[2;0H\");\n    term.write(NEWLINE);\n}\n\n\n// TODO: expose ANSI cursor control codes as functions in term_ctl\n// TODO: consider instead using a hidden textarea to store the character buffer, or using a queue and reimplementing the terminal's keypress handler\n// TODO: provide method in terminal to set up the above ^^^\n// TODO: none of this accounts for scrolling!! use of cursorPos will not function properly if the terminal is scrolled\n// TODO: it would be nice to not \"cheat\" at enter and backspace, but to actually handle them properly. this is fine for now i guess\n\nexport default {\n    name: \"edit\",\n    description: \"Edits the specified file.\",\n    usage_suffix: \"path\",\n    arg_descriptions: {},\n    compat: \"2.0.0\",\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS, FG } = ANSI;\n\n        // get filesystem\n        const fs = kernel.get_fs();\n\n        // parse argument\n        if (args.length !== 1) {\n            term.writeln(`${PREFABS.error}A single argument, the path, is required.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        const path = fs.absolute(args[0]);\n\n\n        let content = \"\";\n\n        // if the file exists, load it in. otherwise, keep the content empty\n        let readonly = false;\n        if (await fs.exists(path)) {\n            content = await fs.read_file(path) as string;\n            readonly = await fs.is_readonly(path);\n\n            // lock the file by making it read-only\n            // TODO: the user can lock the file permanently if edit crashes, they close the tab, reload, or their computer loses power! perhaps use a separate flag for this and have the os erase the lock on boot, not the same as readonly\n            // TODO: i'm disabling this for now for my own sanity (when it crashes and dies). its incredibly unlikely the user will concurrent write with fsedit and if they do they're stupid\n            //fs.set_readonly(path, true);\n        }\n\n        // temporary note\n        // TODO: remove when scrolling is implemented properly\n        term.writeln(`${FG.yellow}Note: This program is still in development and has numerous issues, including no scrolling!${NEWLINE}Pressing F2 to redraw may help some visual issues, but not any file writing related issues.${NEWLINE}Consider using ${PREFABS.program_name}cat${STYLE.reset_all + FG.yellow} or the ${PREFABS.program_name}fsedit${STYLE.reset_all + FG.yellow} UI for your purposes.${NEWLINE}Please don't report issues in this program unless you know a fix :)${NEWLINE}Press any key to proceed.${STYLE.reset_all}`);\n        await term.wait_for_keypress();\n\n        // setup the screen\n        setup(term, content, path, readonly);\n\n        const split_content = content.split(NEWLINE);\n\n        // wait for keypresses\n        let exit_code: number | null = null;\n        let saved = false;\n        while (exit_code === null) {\n            const key = await term.wait_for_keypress();\n\n            switch (key.domEvent.code) {\n                case \"Escape\":\n                    // revert the file to its original read-only status\n                    if (await fs.exists(path)) {\n                        await fs.set_readonly(path, readonly);\n                    }\n\n                    exit_code = 0;\n                    break;\n                case \"F1\":\n                    // if readonly, don't allow saving\n                    if (readonly) {\n                        break;\n                    }\n\n                    await fs.write_file(path, split_content.join(NEWLINE));\n                    saved = true;\n\n                    // revert the file to its original read-only status\n                    await fs.set_readonly(path, readonly);\n\n                    exit_code = 0;\n                    break;\n                case \"F2\":\n                    term.reset();\n                    setup(term, split_content.join(NEWLINE), path, readonly);\n                    console.log(split_content.join(\"\\n\"));\n                    break;\n                case \"ArrowUp\": {\n                    // determine the current cursor position\n                    const cursor_y = term.buffer.normal.cursorY;\n\n                    if (cursor_y === 2) {\n                        // TODO: scroll file\n                        // we're at the top of the file, so we can't move up\n                        break;\n                    }\n\n                    // pass through to the terminal\n                    term.write(key.key);\n\n                    // determine the current line's length (sub 2 for header, sub 1 for moving up)\n                    const line_length = split_content[cursor_y - HEADER - 1].length;\n\n                    // determine the cursor's x position\n                    const cursor_x = term.buffer.normal.cursorX;\n\n                    // move cursor to the end of the line, typing backspaces if it is past the end or the right arrow code if it is not\n                    if (cursor_x >= line_length) {\n                        term.write(\"\\b\".repeat(cursor_x - line_length));\n                    } else {\n                        term.write(\"\\x1b[C\".repeat(line_length - cursor_x));\n                    }\n                }\n                    break;\n                case \"ArrowDown\": {\n                    // determine the current cursor position\n                    const cursor_y = term.buffer.normal.cursorY;\n\n                    if (cursor_y === term.rows - 4) {\n                        // TODO: scroll file\n                        // we're at the bottom of the screen, so we can't move down\n                        break;\n                    }\n\n                    if (cursor_y === split_content.length + HEADER - 1) { // (add 2 for header, sub 1 for 0-indexing)\n                        // we're at the bottom of the file, so we can't move down\n                        break;\n                    }\n\n                    // pass through to the terminal\n                    term.write(key.key);\n\n                    // determine the current line's length (sub 2 for header, add 1 for moving down)\n                    const line_length = split_content[cursor_y - HEADER + 1].length;\n\n                    // determine the cursor's x position\n                    const cursor_x = term.buffer.normal.cursorX;\n\n                    // move cursor to the end of the line, typing backspaces if it is past the end or the right arrow code if it is not\n                    if (cursor_x >= line_length) {\n                        term.write(\"\\b\".repeat(cursor_x - line_length));\n                    } else {\n                        term.write(\"\\x1b[C\".repeat(line_length - cursor_x));\n                    }\n                }\n                    break;\n                case \"ArrowLeft\":\n                    // left arrow can always be passed through to the terminal as the terminal will handle the left margin\n                    term.write(key.key);\n                    break;\n                case \"ArrowRight\": {\n                    // determine cursor position\n                    const cursor_x = term.buffer.normal.cursorX;\n                    const cursor_y = term.buffer.normal.cursorY;\n\n                    // determine the current line's length (sub 2 for header)\n                    const line_length = split_content[cursor_y - HEADER].length;\n\n                    if (cursor_x < line_length) {\n                        // pass through to the terminal\n                        // NOTE: no need to check right margin, because the terminal will handle that\n                        term.write(key.key);\n                    }\n                }\n                    break;\n                case \"Enter\": {\n                    // if readonly, don't allow editing\n                    if (readonly) {\n                        break;\n                    }\n\n\n                    // determine cursor position\n                    const cursor_x = term.buffer.normal.cursorX;\n                    let cursor_y = term.buffer.normal.cursorY;\n\n                    // split the current line at the cursor position\n                    const line = split_content[cursor_y - HEADER];\n\n                    const before_newline = line.slice(0, cursor_x);\n                    const after_newline = line.slice(cursor_x);\n\n                    const old_split_content = split_content.slice();\n\n                    // insert the new line into the content, between the before_newline and after_newline\n                    split_content.splice(cursor_y - HEADER, 1, before_newline, after_newline);\n\n                    // the code below to redraw selectively is a mess and doesn't work properly for all cases, but is improving\n                    // for now, just to get edit in a somewhat working state, we'll just clear the screen and redraw everything (debug redraw but restoring cursor position)\n\n                    // debug redraw\n                    term.reset();\n                    setup(term, split_content.join(NEWLINE), path, readonly);\n\n                    // move the cursor to the start of the new line\n                    term.write(`\\x1b[${cursor_y + 2};1H`);\n\n                    break;\n\n                    // clear text past the cursor\n                    term.write(\" \".repeat(line.length - cursor_x));\n\n                    // move the cursor down one line and to the beginning of the line\n                    term.write(\"\\x1b[1B\\x1b[1G\");\n\n                    // we are now on the new line. clear it using the old line length and write the new content from after_newline\n                    // TODO: could just clear what overruns the new content, but the logic is more confusing. clearing everything is simpler but less efficient\n                    term.write(\" \".repeat(old_split_content[cursor_y - HEADER].length)); // doesnt work for all cases, sometime leaves longer line stray\n                    term.write(\"\\x1b[1G\")\n                    term.write(after_newline);\n\n                    // adjust cursor y to reflect the real newline being handled\n                    cursor_y++;\n\n                    // clear all the lines below the new cursor position, then write the new content into them\n                    // TODO: could just clear what overruns the new content, but the logic is more confusing. clearing everything is simpler but less efficient\n                    let lines_redrawn = 0;\n                    for (let i = cursor_y - HEADER + 1; i < split_content.length; i++) {\n                        term.write(\"\\x1b[1B\\x1b[1G\");\n                        if (old_split_content[i]) {\n                            term.write(\" \".repeat(old_split_content[i].length));\n                            term.write(\"\\x1b[1G\");\n                        }\n                        term.write(split_content[i]);\n                        lines_redrawn++;\n                    }\n\n                    // move the cursor back to the original line at the start of the new line\n                    term.write(\"\\x1b[1G\");\n                    if (lines_redrawn > 0) {\n                        term.write(`\\x1b[${lines_redrawn}A`);\n                    }\n                }\n                    break;\n                case \"Backspace\": {\n                    // if readonly, don't allow editing\n                    if (readonly) {\n                        break;\n                    }\n\n                    // get the current cursor position\n                    const cursor_x = term.buffer.normal.cursorX;\n                    const cursor_y = term.buffer.normal.cursorY;\n\n                    // do nothing at the start of the file\n                    if (cursor_x === 0 && cursor_y === 2) {\n                        break;\n                    }\n\n                    // if at the beginning of the line, remove the newline\n                    if (cursor_x === 0) {\n                        // move previous line's content to the end of the current line\n                        const newline_content = split_content[cursor_y - HEADER];\n                        split_content[cursor_y - HEADER - 1] += newline_content;\n\n                        split_content.splice(cursor_y - HEADER, 1);\n\n                        // the code below to handle backspacing a newline ever only partly worked\n                        // for now, just to get edit in a somewhat working state, we'll just clear the screen and redraw everything (debug redraw but restoring cursor position)\n\n                        // debug redraw\n                        term.reset();\n                        setup(term, split_content.join(NEWLINE), path, readonly);\n\n                        // move the cursor to the previous line to the right length across (N from the end where N is the length of the line we just merged, newline_content)\n                        // TODO: why isn't this working in all cases??????????????????????????????????\n                        term.write(`\\x1b[${cursor_y};${split_content[cursor_y - HEADER - 1].length - newline_content.length + 1}G`);\n\n                        break;\n\n                        // move the cursor up one line\n                        term.write(\"\\x1b[1A\");\n\n                        // move the cursor to the end of the line\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER - 1].length + 1}G`);\n\n                        // write the rest of the line\n                        term.write(split_content[cursor_y - HEADER]);\n\n                        // move the cursor back to the original position\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER].length + 1}D`);\n\n                        // TODO: redraw following lines properly\n\n                        break;\n                    }\n\n\n                    // otherwise, remove the character to the left of the cursor\n                    const left = split_content[cursor_y - HEADER].slice(0, cursor_x - 1);\n                    const right = split_content[cursor_y - HEADER].slice(cursor_x);\n\n                    split_content[cursor_y - HEADER] = left + right;\n\n                    // move the cursor back one space\n                    term.write(\"\\b\");\n\n                    // write the rest of the line\n                    term.write(right + \" \");\n\n                    // move the cursor back to the original position\n                    term.write(`\\x1b[${right.length + 1}D`);\n\n                    // if the line is now empty, remove it, unless it's the first line\n                    if (cursor_y !== 2 && split_content[cursor_y - HEADER] === \"\") {\n                        split_content.splice(cursor_y - HEADER, 1);\n                        term.write(\"\\x1b[1M\");\n                        break;\n                    }\n\n                    // if the cursor is now past the end of the line, move it to the end of the line\n                    if (cursor_x > split_content[cursor_y - HEADER].length) {\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER].length + 1}G`);\n                    }\n                }\n                    break;\n                default: {\n                    // if readonly, don't allow editing\n                    if (readonly) {\n                        break;\n                    }\n\n                    // get the current cursor position\n                    const cursor_x = term.buffer.normal.cursorX;\n                    const cursor_y = term.buffer.normal.cursorY;\n\n                    // if the key is a printable character, write it in\n                    if (!NON_PRINTABLE_REGEX.test(key.key)) {\n                        // if at the end of the line, append to the line\n                        if (cursor_x === split_content[cursor_y - HEADER].length + 1) {\n                            split_content[cursor_y - HEADER] += key.key;\n                            term.write(key.key);\n                        } else {\n                            // otherwise, insert it and shift the rest of the line\n                            const left = split_content[cursor_y - HEADER].slice(0, cursor_x);\n                            const right = split_content[cursor_y - HEADER].slice(cursor_x);\n\n                            split_content[cursor_y - HEADER] = left + key.key + right;\n\n                            // overwrite the line\n                            term.write(key.key + right);\n\n                            // move the cursor back to the correct position + 1\n                            term.write(`\\x1b[${cursor_x + 2}G`);\n                        }\n                    }\n                }\n            }\n        }\n\n        term.reset();\n\n        if (saved) {\n            term.writeln(`${FG.green}File saved!${STYLE.reset_all}`);\n        } else {\n            // TODO: cant exit without saving, crashes the program when trying to set readonly status\n            term.writeln(`${FG.red}Exited without saving!${STYLE.reset_all}`);\n        }\n\n        return exit_code;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { ANSI, NEWLINE } from \"../kernel/term_ctl\";\n\nexport default {\n    name: \"webget\",\n    description: \"Downloads a file from the World Wide Web.\",\n    usage_suffix: \"url filepath [-o] [-n] [-X method] [-H header] [-B body]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"url\": \"The URL to download from.\",\n            \"filepath\": \"The path to save the file to.\"\n        },\n        \"Flags:\": {\n            \"System flags:\": {\n                \"-h\": \"Print this help message.\",\n                \"-o\": \"Overwrite existing files.\",\n                \"-n\": \"Do not replace newlines with the current system's newline character, store as a binary (binary mode).\",\n            },\n            \"Request flags:\": {\n                \"-X\": \"Specify a custom HTTP method. (default: GET)\",\n                \"-H\": \"Add a custom header to the request.\",\n                \"-B\": \"Specify a custom request body. (only works with POST and PUT methods)\"\n            }\n        }\n    },\n    compat: \"2.0.0\",\n    // TODO: completion\n    main: async (data) => {\n        // TODO: replace filename with using piping and send content to stdout\n        // TODO: automatically guess binary mode based on file extension or recieved header\n\n        // extract from data to make code less verbose\n        const { kernel, shell, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { PREFABS, STYLE, FG } = ANSI;\n\n        // get filesystem\n        const fs = kernel.get_fs();\n\n        if (args[0] === \"-h\") {\n            return await kernel.spawn(\"help\", [\"webget\"], shell).completion;\n        }\n\n        // check if the user provided a URL\n        if (args.length === 0) {\n            term.writeln(`${PREFABS.error}A URL is required.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // parse url\n        const url = args.shift();\n\n        // validate url\n        try {\n            const proc_url = new URL(url);\n\n            if (proc_url.protocol !== \"http:\" && proc_url.protocol !== \"https:\") {\n                throw new Error(\"Invalid protocol\");\n            }\n        } catch (e) {\n            term.writeln(`${PREFABS.error}Invalid URL. Expected a valid HTTP or HTTPS protocol URL.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        let file_path = \"\";\n        let overwrite = false;\n        let binary = false;\n        let method = \"GET\";\n        const headers: Map<string, string> = new Map();\n        let body = null;\n\n        for (let arg_idx = 0; arg_idx < args.length; arg_idx++) {\n            const arg = args[arg_idx];\n\n            switch (arg) {\n                case \"-X\": {\n                    // consume next argument\n                    const next_arg = args[arg_idx + 1];\n\n                    if (next_arg === undefined) {\n                        term.writeln(`${PREFABS.error}Expected a method after -X.${STYLE.reset_all}`);\n                        return 1;\n                    }\n\n                    method = next_arg;\n                    args.splice(arg_idx + 1, 1);\n                }\n                    break;\n                case \"-H\": {\n                    // consume next argument\n                    const header = args[arg_idx + 1];\n\n                    if (header === undefined) {\n                        term.writeln(`${PREFABS.error}Expected a header after -H.${STYLE.reset_all}`);\n                        return 1;\n                    }\n\n                    const split = header.split(\": \");\n\n                    if (split.length !== 2 || split[0].includes(\" \")) {\n                        term.writeln(`${PREFABS.error}Invalid header. Expected a header in the format \"Header-Name: Header-Value\".${STYLE.reset_all}`);\n                        return 1;\n                    }\n\n                    headers.set(split[0], split[1]);\n                    args.splice(arg_idx + 1, 1);\n                }\n                    break;\n                case \"-B\": {\n                    // consume next argument\n                    const next_arg = args[arg_idx + 1];\n\n                    if (next_arg === undefined) {\n                        term.writeln(`${PREFABS.error}Expected a body after -B.${STYLE.reset_all}`);\n                        return 1;\n                    }\n\n                    body = next_arg;\n                    args.splice(arg_idx + 1, 1);\n                }\n                    break;\n                case \"-o\":\n                    overwrite = true;\n                    break;\n                case \"-n\":\n                    binary = true;\n                    break;\n                default:\n                    if (file_path === \"\") {\n                        file_path = arg;\n                    } else {\n                        term.writeln(`${PREFABS.error}Unexpected string argument.${STYLE.reset_all}`);\n                        return 1;\n                    }\n            }\n        }\n\n        // check if the user provided a filename and i it is not a directory\n        if (file_path === \"\") {\n            term.writeln(`${PREFABS.error}A file path is required.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        if (file_path.endsWith(\"/\")) {\n            term.writeln(`${PREFABS.error}Cannot write to a directory.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // check if the file already exists\n        const abs_path = fs.absolute(file_path);\n\n        if (await fs.exists(abs_path) && !overwrite) {\n            term.writeln(`${PREFABS.error}File already exists.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // if overwriting, run initial check of readonly status\n        if (overwrite) {\n            if (await fs.is_readonly(abs_path)) {\n                term.writeln(`${PREFABS.error}File is readonly.${STYLE.reset_all}`);\n                return 1;\n            }\n        }\n\n        // lock the file, creating it if it does not exist\n        if (!(await fs.exists(abs_path))) {\n            await fs.write_file(abs_path, \"\");\n        }\n        await fs.set_readonly(abs_path, true);\n\n        // fetch the file\n        let response: Response;\n\n        term.writeln(`${FG.green}Downloading file...${STYLE.reset_all}`);\n\n        try {\n            // convert headers to object\n            const headers_obj: Record<string, string> = {};\n            headers.forEach((value, key) => {\n                headers_obj[key] = value;\n            });\n\n            response = await fetch(url, { method, headers: headers_obj, body });\n        } catch (e) {\n            term.writeln(`${PREFABS.error}Failed to fetch file.${STYLE.reset_all}`);\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\n            console.error(e);\n\n            // reset readonly state\n            await fs.set_readonly(abs_path, false);\n\n            //  if this wasn't an overwrite, delete the file that was created\n            if (!overwrite) {\n                await fs.delete_file(abs_path);\n            }\n\n            return 1;\n        }\n\n        if (!response.ok) {\n            term.writeln(`${PREFABS.error}Request not OK.${STYLE.reset_all}`);\n\n            // get the error message\n            const text = await response.text();\n\n            if (text !== \"\") {\n                term.writeln(`${PREFABS.error}${text}${STYLE.reset_all}`);\n            }\n\n            // reset readonly state\n            await fs.set_readonly(abs_path, false);\n\n            //  if this wasn't an overwrite, delete the file that was created\n            if (!overwrite) {\n                await fs.delete_file(abs_path);\n            }\n\n            return 1;\n        }\n\n        if (binary) {\n            // write the file as binary\n            const buffer = await response.arrayBuffer();\n\n            await fs.write_file(abs_path, new Uint8Array(buffer), true);\n        } else {\n            // write the file as text\n            const text = await response.text();\n\n            await fs.write_file(abs_path, text.replace(/\\r?\\n/g, NEWLINE), true);\n        }\n\n        // reset readonly state (must've be writable or else this wouldn't be reached)\n        await fs.set_readonly(abs_path, false);\n\n        term.writeln(`${FG.green}File downloaded successfully.${STYLE.reset_all}`);\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { ANSI } from \"../kernel/term_ctl\";\n\nexport default {\n    name: \"cat\",\n    description: \"Reads files and prints their contents to the terminal.\",\n    usage_suffix: \"[filepaths...]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"filepaths\": \"The paths of the files to read.\"\n        }\n    },\n    compat: \"2.0.0\",\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { PREFABS, STYLE } = ANSI;\n\n        // get filesystem\n        const fs = kernel.get_fs();\n\n        // get each file's content and print it to the terminal\n        for (const filepath of args) {\n            const abs_path = fs.absolute(filepath);\n\n            // check if the file exists and is a file\n            if (await fs.dir_exists(abs_path)) {\n                term.writeln(`${PREFABS.error}Cannot read a directory: ${abs_path}${STYLE.reset_all}`);\n                return 1;\n            }\n\n            if (!(await fs.exists(abs_path))) {\n                term.writeln(`${PREFABS.error}File not found: ${abs_path}${STYLE.reset_all}`);\n                return 1;\n            }\n\n            // get file\n            const content = await fs.read_file(abs_path);\n\n            // print file content to terminal\n            term.writeln(content);\n        }\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { ANSI } from \"../kernel/term_ctl\";\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\n\n// TODO: when edit is done, add a flag to edit the file in the editor\n\nexport default {\n    name: \"hex\",\n    description: \"Reads a file as hexadecimal.\",\n    usage_suffix: \"[-h] path [-i]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"path\": \"The path to the file to read.\"\n        },\n        \"Flags:\": {\n            \"-h\": \"Print this help message.\",\n            \"-i\": \"Print indexes.\"\n        }\n    },\n    compat: \"2.0.0\",\n    completion: async (data) => {\n        // use default logic for first argument\n        if (data.arg_index === 0) {\n            return null;\n        }\n\n        if (data.arg_index === 1) {\n            if (\"-i\".startsWith(data.current_partial)) {\n                return [\"-i\"];\n            }\n        }\n\n        return [];\n    },\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { shell, kernel, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { PREFABS, STYLE, FG } = ANSI;\n\n        // get filesystem\n        const fs = kernel.get_fs();\n\n        // check if the user provided a filepath\n        if (args.length === 0) {\n            term.writeln(`${PREFABS.error}A file path is required.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        if (args[0] === \"-h\") {\n            await kernel.spawn(\"help\", [\"hex\"], shell).completion;\n        }\n\n        // get filepath\n        const filepath = args[0];\n\n        // get absolute path\n        const abs_path = fs.absolute(filepath);\n\n        // check if the file exists and is a file\n        if (abs_path.endsWith(\"/\")) {\n            term.writeln(`${PREFABS.error}Cannot read a directory: ${abs_path}${STYLE.reset_all}`);\n            return 1;\n        }\n\n        if (!(await fs.exists(abs_path))) {\n            term.writeln(`${PREFABS.error}File not found: ${abs_path}${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // get file\n        const content = await fs.read_file(abs_path, true) as Uint8Array;\n\n        // convert uint8array to hex string\n        const hex = Array.from(content).map((byte) => byte.toString(16).toUpperCase().padStart(2, \"0\"));\n\n        // if printing indexes, print the header\n        if (args[1] === \"-i\") {\n            term.writeln(`         ${FG.blue}00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F${STYLE.reset_all}`);\n        }\n\n        // print hex bytes to terminal up to 16 bytes per line, padding the end with .. in place of the missing bytes\n        // if printing indexes, print the index of the first byte on the line, in hexadecimal up to 8 bytes\n        for (let i = 0; i < hex.length; i += 16) {\n            const line = hex.slice(i, i + 16);\n\n            if (args[1] === \"-i\") {\n                const idx = i <= 0xffffffff ? i.toString(16).toUpperCase() : \"........\";\n\n\n                term.write(`${FG.blue}${idx.padStart(8, \"0\")}${STYLE.reset_all} `);\n            }\n\n            const padded = line.concat(Array(16 - line.length).fill(`${FG.gray}..${STYLE.reset_all}`));\n            term.writeln(padded.join(\" \"));\n        }\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { NEWLINE, ANSI, ANSI_UNESCAPED_REGEX } from \"../kernel/term_ctl\";\n\nimport { default as img2ascii } from \"imgToAscii\";\n\n\nconst MY_USERNAME = \"obfuscatedgenerated\";\nconst GH_USERNAME_REGEX = /^[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}$/i;\n\nconst username_to_avatar_url = (username: string): string => {\n    return `https://avatars.githubusercontent.com/${username}`;\n}\n\ntype GHInfo = { name: string, bio: string, location: string, blog: string, followers: number, following: number, twitter: string };\nconst get_github_info = async (username: string): Promise<GHInfo> => {\n    const url = `https://api.github.com/users/${username}`;\n    const res = await fetch(url);\n\n    if (!res.ok) {\n        return null;\n    }\n\n    const json = await res.json();\n\n    return {\n        name: json.name,\n        bio: json.bio,\n        location: json.location,\n        blog: json.blog,\n        followers: json.followers,\n        following: json.following,\n        twitter: json.twitter_username\n    };\n}\n\nconst convert_to_ascii = async (url: string, size: number): Promise<string> => {\n    const img = new img2ascii(url, size, Math.round(size / 2));\n    await img.loadImage;\n\n    // convert newlines in string\n    const ascii = img.stringANSI8BitColor.replace(/\\n/g, NEWLINE);\n    return ascii;\n}\n\n\nconst known_info = (username: string, data: { [key: string]: any }, gh_info: GHInfo | null, version_str: string) => {\n    // extract from ANSI to make code less verbose\n    const { STYLE, FG, PREFABS } = ANSI;\n\n    return `\n${STYLE.bold}${username}\n-------------------\n${STYLE.bold}OS${STYLE.reset_all + FG.cyan}: OllieOS v${version_str}\n\n${STYLE.bold}Name${STYLE.reset_all + FG.cyan}: ${data.name || gh_info?.name || \"Unknown\"}\n${STYLE.bold}Pronouns${STYLE.reset_all + FG.cyan}: ${data.pronouns.subject}/${data.pronouns.object_or_alt}${data.pronouns.possessive ? `/${data.pronouns.possessive}` : \"\"}\n${STYLE.bold}Location${STYLE.reset_all + FG.cyan}: ${data.location || gh_info?.location || \"Unknown\"}\n${STYLE.bold}Interests${STYLE.reset_all + FG.cyan}: ${data.interests.join(\", \") || \"None listed\"}\n\n${data.websites ? Object.entries(data.websites).map(\n    ([name, url]) => `${STYLE.bold}${name}${STYLE.reset_all + FG.cyan}: ${url}`\n).join(NEWLINE) : \"\"}\n\n${STYLE.bold}GitHub Followers${STYLE.reset_all + FG.cyan}: ${gh_info.followers || 0}\n${STYLE.bold}GitHub Following${STYLE.reset_all + FG.cyan}: ${gh_info.following || 0}\n\n${data.extra ? Object.entries(data.extra).map(\n    ([name, value]) => `${STYLE.bold}${name}${STYLE.reset_all + FG.cyan}: ${value}`\n).join(NEWLINE) : \"\"}\n        `.replace(/\\n/g, NEWLINE);\n}\n\nconst stranger_info = (username: string, gh_info: GHInfo | null, cols: number, version_str: string) => {\n    // extract from ANSI to make code less verbose\n    const { STYLE, FG } = ANSI;\n\n    // line wrap the bio and make sure newlines ARE NOT CRLF (to retain columns)\n    if (gh_info.bio) {\n        gh_info.bio = gh_info.bio.replace(/\\r\\n/g, \"\\n\").replace(new RegExp(`(.{${Math.floor(cols * 0.25)}})\\\\s`, \"g\"), \"$1\\n\");\n    }\n\n    // TODO: messy, clean up\n    // insert known data or move up a line if not known (to undo the newline added by the ternary operator)\n    return `\n${STYLE.bold}${username}\n${\"-\".repeat(username.length)}\n${STYLE.bold}OS${STYLE.reset_all + FG.cyan}: OllieOS v${version_str}\n\n${gh_info.name ? `${STYLE.bold}Name${STYLE.reset_all + FG.cyan}: ${gh_info.name}` : \"\\x1b[1A\"}\n${gh_info.location ? `${STYLE.bold}Location${STYLE.reset_all + FG.cyan}: ${gh_info.location}` : \"\\x1b[1A\"}\n${gh_info.bio ? `${STYLE.bold}Bio${STYLE.reset_all + FG.cyan}: ${gh_info.bio}` : \"\\x1b[1A\"}\n\n${gh_info.blog ? `${STYLE.bold}Website${STYLE.reset_all + FG.cyan}: ${gh_info.blog}` : \"\\x1b[1A\"}\n\n${STYLE.bold}GitHub${STYLE.reset_all + FG.cyan}: https://github.com/${username}\n${gh_info.twitter ? `${STYLE.bold}Twitter${STYLE.reset_all + FG.cyan}: https://twitter.com/${gh_info.twitter}` : \"\\x1b[1A\"}\n\n${STYLE.bold}GitHub Followers${STYLE.reset_all + FG.cyan}: ${gh_info.followers || 0}\n${STYLE.bold}GitHub Following${STYLE.reset_all + FG.cyan}: ${gh_info.following || 0}\n    `.replace(/\\n/g, NEWLINE);\n}\n\nexport default {\n    name: \"mefetch\",\n    description: \"Shows information about me (or you!)\",\n    usage_suffix: \"[username]\",\n    arg_descriptions: {\n        \"username\": \"The GitHub username to show basic info about. Defaults to my username, with the special info shown.\"\n    },\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, term, args } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, FG } = ANSI;\n\n        // get version string\n        const version_str = kernel.get_env_info().version;\n\n        // restrict to first 3 quarters of screen\n        const max_columns = Math.floor(term.cols * 0.75);\n\n        // set image size\n        const asc_width = Math.floor(max_columns / 3);\n\n        // get username\n        const username = args[0] || MY_USERNAME;\n\n        // check if username is valid\n        if (!username.match(GH_USERNAME_REGEX)) {\n            term.write(`${STYLE.bold}${FG.red}Invalid username.${STYLE.reset_all}\\n`);\n            return 1;\n        }\n\n        // get info from GitHub\n        const gh_info = await get_github_info(username);\n\n        // if info is null, then the user doesn't exist\n        if (gh_info === null) {\n            term.write(`${STYLE.bold}${FG.red}User not found.${STYLE.reset_all}\\n`);\n            return 1;\n        }\n\n        // use local logo for efficiency if username is mine\n        const avatar_url = MY_USERNAME === username ? \"https://ollieg.codes/public/logo.png\" : username_to_avatar_url(username);\n\n        // convert image to ascii\n        const ascii_pfp = await convert_to_ascii(avatar_url, asc_width);\n\n        // check synced data if username exists in data repo\n        let known_data = null;\n        const fs = kernel.get_fs();\n        if (await fs.exists(\"/var/lib/data/person/index.json\")) {\n            const data_index_str = await fs.read_file(\"/var/lib/data/person/index.json\") as string;\n            const data_index = JSON.parse(data_index_str) as string[];\n\n            if (data_index.includes(username)) {\n                const user_data_str = await fs.read_file(`/var/lib/data/person/${username}.json`) as string;\n                known_data = JSON.parse(user_data_str);\n            }\n        }\n\n        // text is written with \\n as newlines for simplicity, replaced with NEWLINE\n        let text: string;\n        if (known_data) {\n            text = known_info(username, known_data, gh_info, version_str);\n        } else {\n            text = stranger_info(username, gh_info, term.cols, version_str);\n        }\n\n        // reapply style each line as image will override it\n        const txt_line_prefix = FG.cyan;\n        const txt_line_suffix = STYLE.reset_all;\n\n        // go line by line through both text and ascii\n        const asc_lines = ascii_pfp.split(NEWLINE);\n        const txt_lines = text.split(NEWLINE);\n\n        // get the greater of the two lengths\n        const max_lines = Math.max(asc_lines.length, txt_lines.length);\n\n        // get the longest length of a line of ascii ignoring ansi characters, and the longest length of a line of text\n        const max_asc_line_length = Math.max(...asc_lines.map(line => line.replace(ANSI_UNESCAPED_REGEX, \"\").length));\n        const max_txt_line_length = Math.max(...txt_lines.map(line => line.length));\n\n        // determine padding around and between text and ascii\n        const center_padding_size = Math.floor(max_columns / 15);\n        const side_padding_size = Math.floor((max_columns - max_txt_line_length - (max_asc_line_length / 2) - center_padding_size) / 2);\n\n        // generate padding strings, if positive\n        const center_padding = \" \".repeat(center_padding_size > 0 ? center_padding_size : 0);\n        const side_padding = \" \".repeat(side_padding_size > 0 ? side_padding_size : 0);\n\n        // print each line\n        for (let i = 0; i < max_lines; i++) {\n            const asc_line = asc_lines[i] || \"\";\n            const txt_line = txt_lines[i] || \"\";\n\n            // add additional padding so the width of the ascii line is always the same\n            const asc_line_padding = \" \".repeat(max_asc_line_length - asc_line.replace(ANSI_UNESCAPED_REGEX, \"\").length);\n\n            // print side by side with padding\n            term.writeln(side_padding + asc_line + asc_line_padding + center_padding + txt_line_prefix + txt_line + txt_line_suffix);\n        }\n\n        return 0;\n    }\n} as Program;\n","import { ANSI } from \"../kernel/term_ctl\";\nimport type { Program } from \"../types\";\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\n\nexport default {\n    name: \"reader\",\n    description: \"Toggles screen reader mode. Due to a technical limitation, on-screen links will not be clickable in screen reader mode.\",\n    usage_suffix: \"[-h] [-q] [-s on|off]\",\n    arg_descriptions: {\n        \"Flags:\": {\n            \"-h\": \"Show this help message.\",\n            \"-q\": \"Query the current screen reader mode.\",\n            \"-s\": \"Explicitly set the screen reader mode to on or off, rather than toggling it.\"\n        }\n    },\n    node_opt_out: true,\n    compat: \"2.0.0\",\n    completion: async (data) => {\n        if (data.arg_index === 0) {\n            return helper_completion_options([\"-h\", \"-q\", \"-s\"])(data);\n        }\n\n        if (data.arg_index === 1 && data.args[0] === \"-s\") {\n            return helper_completion_options([\"on\", \"off\"])(data);\n        }\n\n        return [];\n    },\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, shell, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { PREFABS, STYLE } = ANSI;\n\n        // get sound registry\n        const sfx_reg = kernel.get_sound_registry();\n\n        switch (args[0]) {\n            case \"-h\":\n                return await kernel.spawn(\"help\", [\"clear\"], shell).completion;\n            case \"-q\":\n                // query screen reader mode\n                term.writeln(`Screen reader mode is currently ${term.options.screenReaderMode ? \"on\" : \"off\"}.`);\n                return 0;\n            case \"-s\":\n                // set screen reader mode\n                switch (args[1]) {\n                    case \"on\":\n                        term.options.screenReaderMode = true;\n                        break;\n                    case \"off\":\n                        term.options.screenReaderMode = false;\n                        break;\n                    default:\n                        term.writeln(\"Invalid argument. Expected \\\"on\\\" or \\\"off\\\".\");\n                        return 1;\n                }\n                break;\n            default:\n                // toggle screen reader mode\n                term.options.screenReaderMode = !term.options.screenReaderMode;\n        }\n\n        const state = term.options.screenReaderMode ? \"on\" : \"off\";\n\n        // play sound\n        const sound_name = `reader_${state}`;\n        sfx_reg.wait_to_play(sound_name);\n\n        // print message\n        term.writeln(`Screen reader mode was turned ${state}. This setting is saved in your browser's local storage. Use the ${PREFABS.program_name}reader${STYLE.reset_all} command to toggle it.`);\n\n        // remove hint element if screen reader mode is on\n        if (term.options.screenReaderMode) {\n            const hint = document.querySelector(\"#screenreader_hint\");\n\n            if (hint) {\n                hint.remove();\n            }\n        }\n\n        // save into local storage\n        localStorage.setItem(\"reader\", term.options.screenReaderMode.toString());\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { ANSI, NEWLINE } from \"../kernel/term_ctl\";\n\nexport default {\n    name: \"selfdestruct\",\n    description: \"Permanently erases the filesystem and other data, then restarts the terminal.\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, shell, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { FG, BG, STYLE } = ANSI;\n\n        // get fs\n        const fs = kernel.get_fs();\n\n        const pad = (str: string, invis_codes = \"\") => {\n            if (str.length >= term.cols) {\n                return str;\n            }\n\n            return str + \" \".repeat(term.cols - str.length + invis_codes.length);\n        }\n\n        // make sure the user really wants to do this\n        term.writeln(BG.red + FG.white + STYLE.bold);\n        term.write(pad(\"WARNING: This will permanently erase the filesystem and other data, and restart the terminal.\"));\n        term.writeln(pad(\"This data cannot be recovered. Are you sure you want to do this?\"));\n        term.writeln(pad(`Press ${BG.blue}Y${BG.red} 3 times to continue, or anything else to cancel.`, BG.blue + BG.red));\n        term.write(STYLE.reset_all);\n\n        // wait for the user to press Y 3 times\n        let y_count = 0;\n        while (y_count < 3) {\n            const key = await term.wait_for_keypress();\n            if (key.key === \"y\" || key.key === \"Y\") {\n                y_count++;\n            } else {\n                term.writeln(\"Cancelled.\");\n                return 0;\n            }\n        }\n\n        // clear the screen and erase the filesystem\n        term.reset();\n\n        term.writeln(\"Erasing filesystem and other data...\");\n        await fs.erase_all();\n        localStorage.removeItem(\"fetch_ttl_cache\");\n\n        term.writeln(`${NEWLINE}Thank you for using OllieOS!${NEWLINE}`);\n\n        // TODO: talk to ignition instead of using shutdown command\n        return await kernel.spawn(\"shutdown\", [\"-r\", \"-t\", \"3000\"], shell).completion;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { ANSI } from \"../kernel/term_ctl\";\n\nimport { image2sixel } from \"sixel\";\n\n\n// returns null if image is invalid\nconst convert_to_image_data = async (url: string) => {\n    // create a canvas to draw the image on\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n\n    // create an image to draw the png data on\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    img.src = url;\n\n    // wait for the image to load via promise\n    try {\n        await new Promise((resolve, reject) => {\n            img.onload = () => {\n                resolve(null);\n            };\n\n            img.onerror = () => {\n                reject(null);\n            };\n        });\n    } catch (e) {\n        return null;\n    }\n\n    // draw the image on the canvas\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n\n    // get the image data\n    const img_data = ctx.getImageData(0, 0, img.width, img.height);\n\n    // convert image data to uint8array\n    const data_arr = new Uint8Array(img_data.data);\n\n    return { array: data_arr, width: img.width, height: img.height };\n};\n\nexport default {\n    name: \"imagine\",\n    description: \"Views images natively in the terminal.\",\n    usage_suffix: \"path [-w width] [-u]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"path\": \"The path to the image to view.\"\n        },\n        \"Options:\": {\n            \"-w\": \"The width of the image in PIXELS. Defaults to the width of the image.\",\n            \"-u\": \"Path is an web URL instead of a local filesystem path.\"\n        }\n    },\n    compat: \"2.0.0\",\n    // TODO: completion\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS } = ANSI;\n\n        // get fs\n        const fs = kernel.get_fs();\n\n        // get the path to the image\n        const path = args[0];\n\n        if (!path) {\n            term.writeln(`${PREFABS.error}No path specified.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // get the width of the image specified or the terminal width\n        let width_arg = args.includes(\"-w\") ? parseInt(args[args.indexOf(\"-w\") + 1]) : undefined;\n        const is_web_url = args.includes(\"-u\");\n\n        let url: string;\n        let mime: string;\n        if (!is_web_url) {\n            // process the path\n            url = fs.absolute(path);\n            if (!(await fs.exists(url))) {\n                term.writeln(`${PREFABS.error}No such file or directory: ${path}${STYLE.reset_all}`);\n                return 1;\n            }\n\n            // get the extension\n            const ext = url.slice(-4).toLowerCase();\n\n            // get the mime type\n            switch (ext) {\n                case \".png\":\n                    mime = \"image/png\";\n                    break;\n                case \".jpg\":\n                case \"jpeg\":\n                    mime = \"image/jpeg\";\n                    break;\n                case \".gif\":\n                    mime = \"image/gif\";\n                    break;\n                default:\n                    term.writeln(`${PREFABS.error}File is not known to be a .png, .jpg/.jpeg or .gif: ${url}${STYLE.reset_all}`);\n                    return 1;\n            }\n\n\n            // convert to blob URL\n            const content = await fs.read_file(url, true) as Uint8Array;\n            //@ts-expect-error\n            url = URL.createObjectURL(new Blob([content]));\n\n        } else {\n            // check path is a valid URL\n            try {\n                new URL(path);\n                url = path;\n            } catch (e) {\n                term.writeln(`${PREFABS.error}Invalid URL: ${path}${STYLE.reset_all}`);\n                return 1;\n            }\n\n            // do a HEAD request to get the mime type\n            try {\n                const head_req = await fetch(url, { method: \"HEAD\" });\n\n                // if the HEAD request failed, try a GET request\n                if (!head_req.ok) {\n                    console.log(\"HEAD request failed, trying GET request\");\n                    const get_req = await fetch(url);\n\n                    // if the GET request failed, error\n                    if (!get_req.ok) {\n                        term.writeln(`${PREFABS.error}URL is not accessible: ${url}${STYLE.reset_all}`);\n                        return 1;\n                    }\n\n                    mime = get_req.headers.get(\"content-type\");\n                } else {\n                    mime = head_req.headers.get(\"content-type\");\n                }\n\n                // check the mime type is valid\n                if ([\"image/png\", \"image/jpeg\", \"image/gif\"].indexOf(mime) === -1) {\n                    term.writeln(`${PREFABS.error}URL does not point to a .png, .jpg/.jpeg or .gif: ${url}${STYLE.reset_all}`);\n                    return 1;\n                }\n            } catch (e) {\n                term.writeln(`${PREFABS.error}Error accessing URL: ${url}${STYLE.reset_all}`);\n                return 1;\n            }\n        }\n\n        const data_out = await convert_to_image_data(url);\n\n        if (!data_out) {\n            term.writeln(`${PREFABS.error}Failed to convert image to data. Did you download it as a binary file?${STYLE.reset_all}`);\n            return 1;\n        }\n\n        const { array: img_data, width: img_width, height: img_height } = data_out\n\n        if (!width_arg) {\n            width_arg = img_width;\n        }\n\n        // scale the height to fit the width\n        const width_scale = width_arg / img_width;\n        const new_height = img_height * width_scale;\n\n        // scale the image data by chopping every nth pixel\n        const scaled_img_data = new Uint8Array(width_arg * new_height * 4);\n        for (let i = 0; i < scaled_img_data.length; i++) {\n            const x = Math.floor(i / 4) % width_arg;\n            const y = Math.floor(Math.floor(i / 4) / width_arg);\n\n            const scaled_x = Math.floor(x / width_scale);\n            const scaled_y = Math.floor(y / width_scale);\n\n            const scaled_i = (scaled_y * img_width + scaled_x) * 4 + (i % 4);\n\n            scaled_img_data[i] = img_data[scaled_i];\n        }\n\n        try {\n            // convert the Uint8Array to a sixel image\n            const sixel = image2sixel(scaled_img_data, width_arg, new_height);\n\n            // write the sixel image to the terminal\n            term.write(sixel);\n        } catch (e) {\n            term.writeln(`${PREFABS.error}Failed to convert image to sixel.${STYLE.reset_all}`);\n            console.error(e);\n            return 1;\n        }\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { ANSI, NEWLINE } from \"../kernel/term_ctl\";\n\nimport { default as img2ascii } from \"imgToAscii\";\n\n\n// TODO: DRY with mefetch\nconst convert_to_ascii = async (url: string, size: number): Promise<string> => {\n    const img = new img2ascii(url, size, Math.round(size / 2));\n    await img.loadImage;\n\n    // convert newlines in string\n    const ascii = img.stringANSI8BitColor.replace(/\\n/g, NEWLINE);\n    return ascii;\n}\n\nexport default {\n    name: \"ascmagine\",\n    description: \"Views images as ANSI/ASCII art.\",\n    usage_suffix: \"path [-w width] [-u]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"path\": \"The path to the image to view.\"\n        },\n        \"Options:\": {\n            \"-w\": \"The width of the image in COLUMNS. Defaults to the width of the terminal.\",\n            \"-u\": \"Path is an web URL instead of a local filesystem path.\"\n        }\n    },\n    compat: \"2.0.0\",\n    // TODO: completion\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS, FG } = ANSI;\n\n        // get fs\n        const fs = kernel.get_fs();\n\n        // get the path to the image\n        const path = args[0];\n\n        if (!path) {\n            term.writeln(`${PREFABS.error}No path specified.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // get the width of the image specified or the terminal width\n        const width_arg = args.includes(\"-w\") ? parseInt(args[args.indexOf(\"-w\") + 1]) : undefined;\n        const is_web_url = args.includes(\"-u\");\n\n        let url: string;\n        if (!is_web_url) {\n            // process the path\n            url = fs.absolute(path);\n            if (!(await fs.exists(url))) {\n                term.writeln(`${PREFABS.error}No such file or directory: ${path}${STYLE.reset_all}`);\n                return 1;\n            }\n\n            // convert to blob\n            const content = await fs.read_file(url, true) as Uint8Array;\n            //@ts-expect-error\n            const blob = new Blob([content]);\n\n            // attempt createImageBitmap on the file to determine if it's a canvas-compatible image in the browser\n            if (typeof createImageBitmap === \"function\") {\n                try {\n                    // using tiny region at low res for efficiency\n                    await createImageBitmap(blob, 0, 0, 1, 1);\n                } catch (e) {\n                    term.writeln(`${PREFABS.error}File is not a valid image: ${path}. Did you download it as a binary file?${STYLE.reset_all}`);\n                    return 1;\n                }\n            } else {\n                term.writeln(`${FG.yellow}Warning: ${STYLE.reset_all}createImageBitmap is not supported in this browser. Falling back to list of trusted image formats.${STYLE.reset_all}`)\n                \n                const trusted_formats = [\".png\", \".jpg\", \".jpeg\", \".gif\", \".bmp\", \".ico\", \".svg\"];\n                const ext = url.slice(-4).toLowerCase();\n\n                if (!(trusted_formats.includes(ext))) {\n                    term.writeln(`${PREFABS.error}File is not a valid image: ${path}. Did you download it as a binary file?${STYLE.reset_all}`);\n                    return 1;\n                }\n            }\n\n            // create a blob URL\n            //@ts-expect-error\n            url = URL.createObjectURL(new Blob([content]));\n\n        } else {\n            // check path is a valid URL\n            try {\n                new URL(path);\n                url = path;\n            } catch (e) {\n                term.writeln(`${PREFABS.error}Invalid URL: ${path}${STYLE.reset_all}`);\n                return 1;\n            }\n\n            // do a HEAD request to check the mime type\n            const head_req = await fetch(url, { method: \"HEAD\" });\n            let mime: string;\n\n            // if the HEAD request failed, try a GET request\n            if (!head_req.ok) {\n                console.log(\"HEAD request failed, trying GET request\");\n                const get_req = await fetch(url);\n\n                // if the GET request failed, error\n                if (!get_req.ok) {\n                    term.writeln(`${PREFABS.error}URL is not accessible: ${url}${STYLE.reset_all}`);\n                    return 1;\n                }\n\n                mime = get_req.headers.get(\"content-type\");\n            } else {\n                mime = head_req.headers.get(\"content-type\");\n            }\n\n            // check the mime type is valid\n            if (!mime.startsWith(\"image/\")) {\n                term.writeln(`${PREFABS.error}URL is not an image: ${url}${STYLE.reset_all}`);\n                return 1;\n            }\n        }\n\n        // get the image\n        const img = await convert_to_ascii(url, width_arg || term.cols - 1);\n\n        // write the image\n        term.write(img);\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { ANSI } from \"../kernel/term_ctl\";\n\nexport default {\n    name: \"fsedit\",\n    description: \"Opens the fsedit program to edit the filesystem.\",\n    usage_suffix: \"[directory]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            directory: \"The directory to open fsedit in. Defaults to the current working directory.\"\n        }\n    },\n    compat: \"2.0.0\",\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term, process } = data;\n\n        // extract from ANSI to make code less verbose\n        const { PREFABS, STYLE } = ANSI;\n\n        // get fs\n        const fs = kernel.get_fs();\n\n        // get fs name\n        const fs_name = fs.get_unique_fs_type_name();\n\n        // check args\n        let dir = fs.get_cwd();\n        if (args.length > 1) {\n            term.writeln(`${PREFABS.error}Too many arguments.${STYLE.reset_all}`);\n            return 1;\n        } else if (args.length === 1) {\n            // set dir\n            dir = fs.absolute(args[0]);\n        }\n\n        // check if directory exists\n        if (!(await fs.dir_exists(dir))) {\n            term.writeln(`${PREFABS.error}Directory '${args[0]}' does not exist.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // url encode the directory\n        const encoded_dir = encodeURIComponent(dir);\n\n        if (!kernel.has_window_manager()) {\n            // fallback to opening in a popup window\n            window.open(`./fsedit?type=${fs_name}&dir=${encoded_dir}`, \"_blank\", \"popup=true\");\n            term.writeln(\"Opened fsedit in a new popup window.\");\n            return 0;\n        }\n\n        const iframe = document.createElement(\"iframe\");\n        iframe.src = `./fsedit?type=${fs_name}&dir=${encoded_dir}`;\n        iframe.style.border = \"none\";\n        iframe.style.width = \"100%\";\n        iframe.style.height = \"100%\";\n\n        const wind = process.create_window();\n        wind.title = \"fsedit\";\n\n        wind.width = \"75vw\";\n        wind.height = \"75vh\";\n\n        wind.x = \"12.5vw\";\n        wind.y = \"12.5vh\";\n\n        wind.dom.appendChild(iframe);\n        wind.show();\n\n        // send message\n        term.writeln(\"Opened fsedit in a new window.\");\n\n        wind.add_event_listener(\"close\", async () => {\n            // backup unlock logic TODO improve the design of fsedit in general\n            if (await fs.exists(\"/.fs.lock\")) {\n                // check that no other fsedit processes are running\n                let other_fsedit_running = false;\n                const processes = kernel.get_process_manager().list_pids();\n                for (const pid of processes) {\n                    if (pid === process.pid) {\n                        continue;\n                    }\n\n                    const proc = kernel.get_process_manager().get_process(pid);\n                    if (proc && proc.source_command.command === \"fsedit\") {\n                        other_fsedit_running = true;\n                        break;\n                    }\n                }\n\n                if (!other_fsedit_running) {\n                    await fs.delete_file(\"/.fs.lock\");\n                }\n            }\n\n            process.kill(0);\n        });\n\n        // listen for message from iframe to close window\n        const message_handler = (event: MessageEvent) => {\n            if (event.source === iframe.contentWindow && event.data === \"closing-fsedit\") {\n                wind.close();\n                window.removeEventListener(\"message\", message_handler);\n            }\n        };\n        window.addEventListener(\"message\", message_handler);\n\n        process.detach();\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { ANSI } from \"../kernel/term_ctl\";\nimport { NonRecursiveDirectoryError, PathNotFoundError } from \"../kernel/filesystem\";\n\nexport default {\n    name: \"rm\",\n    description: \"Deletes a file or directory.\",\n    usage_suffix: \"[-rf | -f] path\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"path\": \"The path to the file or directory to delete.\"\n        },\n        \"Flags:\": {\n            \"-rf\": \"Recursively and forcibly delete directories (ignoring if directory has content, treated as -f if a file is passed).\",\n            \"-f\": \"Forcibly delete files (ignoring readonly state, NOT treated as -rf if a directory is passed).\"\n        }\n    },\n    compat: \"2.0.0\",\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { PREFABS, STYLE } = ANSI;\n\n        // get fs\n        const fs = kernel.get_fs();\n\n        // determine if -rf OR -f was passed\n        let rimraf = false;\n        let force = false;\n\n        if (args[0] === \"-rf\") {\n            rimraf = true;\n            force = true;\n            args.shift();\n        } else if (args[0] === \"-f\") {\n            force = true;\n            args.shift();\n        }\n\n        // check if there is only one argument after parsing flag\n        if (args.length !== 1) {\n            term.writeln(`${PREFABS.error}Invalid arguments.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // get path\n        const path = args[0];\n        const abs_path = fs.absolute(path);\n\n        // check if path exists\n        if (!(await fs.exists(abs_path))) {\n            term.writeln(`${PREFABS.error}Path does not exist.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // check if path is a directory\n        const is_dir = await fs.dir_exists(abs_path);\n\n        // perform deletion\n        if (is_dir) {\n            try {\n                await fs.delete_dir(abs_path, rimraf);\n            } catch (e) {\n                if (e instanceof NonRecursiveDirectoryError) {\n                    term.writeln(`${PREFABS.error}Directory is not empty. Refusing to delete without -rf flag.${STYLE.reset_all}`);\n                    return 1;\n                }\n\n                if (e instanceof PathNotFoundError) {\n                    term.writeln(`${PREFABS.error}Path no longer exists.${STYLE.reset_all}`);\n                    return 1;\n                }\n\n                throw e;\n            }\n        } else {\n            // if not forcing, check if file is readonly\n            if (!force && await fs.is_readonly(abs_path)) {\n                term.writeln(`${PREFABS.error}File is readonly. Refusing to delete without -f flag.${STYLE.reset_all}`);\n                return 1;\n            }\n\n            await fs.delete_file(abs_path);\n        }\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport { ANSI } from \"../kernel/term_ctl\";\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\n\nconst type_suffixes = {\n    bug: \"?assignees=&labels=awaiting+effort+estimate%2C+awaiting+triage%2C+bug%2C+unreviewed&template=bug-report-%F0%9F%90%9B.md&title=%5B%F0%9F%90%9B%5D+-+Descriptive%2C+short+title\",\n    feature: \"?assignees=&labels=awaiting+effort+estimate%2C+awaiting+triage%2C+feature%2C+unreviewed&template=feature-request-%F0%9F%92%A1.md&title=%5B%F0%9F%92%A1%5D+-+Descriptive%2C+short+title\",\n    other: \"/choose\",\n}\n\nexport default {\n    name: \"bugreport\",\n    description: \"Opens the bug reporter.\",\n    usage_suffix: \"[bug|feature|other]\",\n    arg_descriptions: {\n        bug: \"Opens the bug reporter with the bug report template.\",\n        feature: \"Opens the bug reporter with the feature request template.\",\n        other: \"Opens the bug reporter with the template chooser (default).\",\n    },\n    compat: \"2.0.0\",\n    completion: helper_completion_options([\"bug\", \"feature\", \"other\"]),\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { term, args } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS } = ANSI;\n\n        // if no arguments are provided, default to bug\n        let type = \"other\";\n        if (args.length > 0) {\n            type = args[0].toLowerCase();\n\n            // check if the type is valid (don't use in, it won't filter __proto__ etc.)\n            if (!Object.keys(type_suffixes).includes(type)) {\n                term.writeln(`${PREFABS.error} Invalid type: ${type}. Please choose bug, feature, or other.${STYLE.reset_all}`);\n                return 1;\n            }\n        }\n\n        window.open(`https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io/issues/new${type_suffixes[type]}`, \"_blank\", \"\");\n\n        term.writeln(\"Opened bug reporter in a new tab.\");\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\n\nexport default {\n    name: \"repo\",\n    description: \"Opens the GitHub repository for OllieOS.\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { term } = data;\n\n        window.open(\"https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io\", \"_blank\", \"\");\n\n        term.writeln(\"Opened repo in a new tab.\");\n\n        return 0;\n    }\n} as Program;\n","import type { Program } from \"../types\";\n\nimport { ANSI, NEWLINE } from \"../kernel/term_ctl\";\n\nimport { convert as convert_html_to_text } from \"html-to-text\";\n\nconst HTML_TAG_REGEX = /<\\/?[a-z][\\s\\S]*>/i;\n\n// modified from source: https://github.com/rbren/rss-parser/blob/master/lib/fields.js\nconst fields = { feed: {}, item: {} };\n\n// known feed fields\nfields.feed = {\n    author: [\"author\", \"creator\"],\n    publisher: [\"dc:publisher\", \"publisher\"],\n    title: [\"dc:title\", \"title\"],\n    description: \"description\",\n    date: \"pubDate\",\n    link: \"link\",\n};\n\n// known item fields\nfields.item = {\n    author: [\"author\", \"creator\"],\n    date: [\"dc:date\", \"date\", \"pubDate\"],\n    title: [\"dc:title\", \"title\"],\n    link: \"link\",\n    summary: \"summary\",\n    description: [\"content:encoded\", \"content\", \"description\"],\n};\n// end source: https://github.com/rbren/rss-parser/blob/master/lib/fields.js\n\nenum DocType {\n    FEED,\n    ITEM\n}\n\nconst get_field = (doc: Document | Element, doc_type: DocType, field: string, as_html = false) => {\n    // get the fields object\n    const dict = doc_type === DocType.FEED ? fields.feed : fields.item;\n\n    // check if the field is known (don't use in, it won't filter out __proto__ etc.)\n    if (!Object.keys(dict).includes(field)) {\n        return undefined;\n    }\n\n    // get the field\n    const field_value = dict[field];\n\n    // if the field is an array, concatenate the values\n    if (Array.isArray(field_value)) {\n        let value = \"\";\n\n        for (const sub_field of field_value) {\n            const sub_field_doc = doc.getElementsByTagName(sub_field)[0];\n            let sub_value: string;\n\n            if (as_html) {\n                sub_value = sub_field_doc?.innerHTML;\n            } else {\n                sub_value = sub_field_doc?.textContent;\n            }\n\n            if (sub_value) {\n                value += sub_value;\n            }\n        }\n\n        return value;\n    } else {\n        // otherwise, get the value\n        if (as_html) {\n            return doc.getElementsByTagName(field_value)[0]?.innerHTML;\n        } else {\n            return doc.getElementsByTagName(field_value)[0]?.textContent;\n        }\n    }\n}\n\n\nexport default {\n    name: \"rss\",\n    description: \"Reads from an RSS feed.\",\n    usage_suffix: \"[-h] [url] [-m items] [-x]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"url\": \"The URL to the XML feed (plaintext feed recommended, unless the HTML is basic). Defaults to https://blog.ollieg.codes/rss/feed.xml\"\n        },\n        \"Flags:\": {\n            \"-h\": \"Print this help message.\",\n            \"-m\": \"The maximum number of items to display. Defaults to no limit.\",\n            \"-x\": \"Only display titles, links and publishing dates, not descriptions.\"\n        }\n    },\n    compat: \"2.0.0\",\n    // TODO: completion\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, shell, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { PREFABS, STYLE, FG } = ANSI;\n\n        if (args.includes(\"-h\")) {\n            return await kernel.spawn(\"help\", [\"rss\"], shell).completion;\n        }\n\n        let max_items: number | undefined = undefined;\n        if (args.includes(\"-m\")) {\n            // get the index of the flag\n            const index = args.indexOf(\"-m\");\n\n            // get the value after the flag\n            const value = args[index + 1];\n\n            // check if the value is valid\n            if (!value || isNaN(parseInt(value)) || parseInt(value) < 0) {\n                term.writeln(`${PREFABS.error}Invalid value for -m flag. Expected a positive integer.${STYLE.reset_all}`);\n                return 1;\n            }\n\n            // set the max items\n            max_items = parseInt(value);\n\n            // remove the flag and value from the args\n            args.splice(index, 2);\n        }\n\n        const no_content = args.includes(\"-x\");\n\n\n        // check if the user provided a URL\n        let url = \"https://blog.ollieg.codes/rss/feed.xml\";\n        if (args.length !== 0) {\n            url = args.shift();\n        }\n\n        // validate url\n        try {\n            const proc_url = new URL(url);\n\n            if (proc_url.protocol !== \"http:\" && proc_url.protocol !== \"https:\") {\n                throw new Error(\"Invalid protocol\");\n            }\n        } catch (e) {\n            term.writeln(`${PREFABS.error}Invalid URL. Expected a valid HTTP or HTTPS protocol URL.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // fetch the feed\n        // TODO: potential DRY with webget\n        let response: Response;\n\n        term.writeln(`${FG.green}Fetching feed...${STYLE.reset_all}`);\n\n        try {\n            response = await fetch(url);\n        } catch (e) {\n            term.writeln(`${PREFABS.error}Failed to fetch feed.${STYLE.reset_all}`);\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\n            console.error(e);\n\n            return 1;\n        }\n\n        if (!response.ok) {\n            term.writeln(`${PREFABS.error}Request not OK.${STYLE.reset_all}`);\n\n            // get the error message\n            const text = await response.text();\n\n            if (text !== \"\") {\n                term.writeln(`${PREFABS.error}${text}${STYLE.reset_all}`);\n            }\n\n            return 1;\n        }\n\n        // get the text and convert newlines (\\r\\n or \\n) to the terminal's newline\n        const text = (await response.text()).replace(/\\r\\n|\\n/g, NEWLINE);\n\n        // parse the text\n        const parser = new DOMParser();\n\n        let doc: Document;\n\n        try {\n            doc = parser.parseFromString(text, \"text/xml\");\n        } catch (e) {\n            term.writeln(`${PREFABS.error}Failed to parse feed.${STYLE.reset_all}`);\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\n            console.error(e);\n\n            return 1;\n        }\n\n        term.write(NEWLINE);\n\n        // print the title if it exists\n        const feed_title = get_field(doc, DocType.FEED, \"title\") ?? \"Untitled feed\";\n        term.writeln(`${FG.cyan + STYLE.bold + STYLE.italic}${feed_title}${STYLE.reset_all}`);\n\n        // print the site link if it exists\n        const site_link = get_field(doc, DocType.FEED, \"link\") ?? \"\";\n        term.writeln(`${FG.cyan}${site_link}${STYLE.reset_all}`);\n\n        // print the site description if it exists\n        const site_description = get_field(doc, DocType.FEED, \"description\") ?? \"\";\n        term.writeln(`${site_description}`);\n\n        term.write(NEWLINE);\n        term.writeln(`${FG.gray}------${STYLE.reset_all}`);\n        term.write(NEWLINE);\n\n        // get the items\n        const items = doc.getElementsByTagName(\"item\");\n\n        if (max_items === undefined) {\n            max_items = items.length;\n        }\n\n        // print the items\n        for (let item_idx = 0; item_idx < max_items; item_idx++) {\n            const item = items.item(item_idx);\n\n            // check if the item exists\n            if (!item) {\n                // hit the end of the items, break\n                break;\n            }\n\n            // get each field of the item if they exist\n\n            // title\n            const item_title = get_field(item, DocType.ITEM, \"title\") ?? \"Untitled item\";\n\n            // link\n            const link = get_field(item, DocType.ITEM, \"link\") ?? \"\";\n\n\n            let description = \"\";\n            if (!no_content) {\n                description = get_field(item, DocType.ITEM, \"description\") ?? \"\";\n\n                // if the description is html, attempt to convert it to plaintext\n                if (HTML_TAG_REGEX.test(description)) {\n                    term.writeln(`${FG.gray}(interpreting description as HTML)${STYLE.reset_all}`)\n                    term.write(NEWLINE);\n\n                    // reparse as html\n                    description = get_field(item, DocType.ITEM, \"description\", true) ?? \"\";\n\n                    // remove CDATA tags if present\n                    description = description.replace(/<!\\[CDATA\\[|\\]\\]>/g, \"\");\n\n                    // parse the description using custom highlighters\n                    description = convert_html_to_text(description,\n                        {\n                            formatters: {\n                                \"ansi_formatter\": (elem, walk, builder, options) => {\n                                    builder.openBlock();\n                                    builder.addInline(options.opener);\n                                    walk(elem.children, builder);\n                                    builder.addInline(STYLE.reset_all);\n                                    builder.closeBlock();\n                                },\n                                \"img_highlight\": (elem, walk, builder, options) => {\n                                    const img_fmt = builder.options.formatters[\"image\"];\n                                    if (img_fmt) {\n                                        builder.addInline(STYLE.bold + FG.magenta);\n                                        img_fmt(elem, walk, builder, options);\n                                        builder.addInline(STYLE.reset_all);\n                                    }\n                                },\n                                \"a_highlight\": (elem, walk, builder, options) => {\n                                    const a_fmt = builder.options.formatters[\"anchor\"];\n                                    if (a_fmt) {\n                                        builder.addInline(STYLE.bold + FG.blue);\n                                        a_fmt(elem, walk, builder, options);\n                                        builder.addInline(STYLE.reset_all);\n                                    }\n                                }\n                            },\n                            selectors: [\n                                {\n                                    selector: \"b\",\n                                    format: \"ansi_formatter\",\n                                    options: {\n                                        opener: STYLE.bold\n                                    }\n                                },\n                                {\n                                    selector: \"strong\",\n                                    format: \"ansi_formatter\",\n                                    options: {\n                                        opener: STYLE.bold\n                                    }\n                                },\n                                {\n                                    selector: \"i\",\n                                    format: \"ansi_formatter\",\n                                    options: {\n                                        opener: STYLE.italic\n                                    }\n                                },\n                                {\n                                    selector: \"em\",\n                                    format: \"ansi_formatter\",\n                                    options: {\n                                        opener: STYLE.italic\n                                    }\n                                },\n                                {\n                                    selector: \"u\",\n                                    format: \"ansi_formatter\",\n                                    options: {\n                                        opener: STYLE.underline\n                                    }\n                                },\n                                {\n                                    selector: \"img\",\n                                    format: \"img_highlight\"\n                                },\n                                {\n                                    selector: \"a\",\n                                    format: \"a_highlight\"\n                                },\n                                {\n                                    selector: \"table\",\n                                    format: \"dataTable\"\n                                }\n                            ]\n                        }\n                    );\n                }\n\n                // trim start and end whitespace\n                description = description.trim();\n\n                // replace newlines again in case the description was html\n                description = description.replace(/\\r\\n|\\n/g, NEWLINE);\n            }\n\n            // pubDate\n            const date = get_field(item, DocType.ITEM, \"date\") ?? \"\";\n\n            // print the item\n            term.writeln(`${FG.green + STYLE.bold + STYLE.underline}${item_title}${STYLE.reset_all}`);\n            term.writeln(`${FG.cyan}${link}${STYLE.reset_all}`);\n            term.writeln(`${FG.yellow}${date}${STYLE.reset_all}`);\n            term.write(NEWLINE);\n\n            if (!no_content) {\n                term.writeln(`${description}`);\n                term.write(NEWLINE);\n            }\n\n            term.writeln(`${FG.gray}------${STYLE.reset_all}`);\n            term.write(NEWLINE);\n        }\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\n\nexport default {\n    name: \"legacy\",\n    description: \"Opens the legacy ollieg.codes site if you're having trouble with this version.\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (_data) => {\n        window.location.assign(\"https://legacy.ollieg.codes/\");\n\n        return 0;\n    }\n} as Program;\n\n// TODO: keep this or not?\n","import type {Program, ProgramMainData} from \"../types\";\nimport { ANSI, NEWLINE, type WrappedTerminal } from \"../kernel/term_ctl\";\n\n\nconst wait_block = (term: WrappedTerminal) => {\n    term.write(NEWLINE);\n    term.writeln(`${ANSI.STYLE.italic}Press any key to continue...${ANSI.STYLE.reset_all}`)\n    return term.wait_for_keypress();\n};\n\nconst run_cmd = async (data: ProgramMainData, cmd: string, args: string[] = []) => {\n    data.term.writeln(`${ANSI.STYLE.bold}$ ${cmd}${ANSI.STYLE.reset_all}${NEWLINE}`);\n    await data.kernel.spawn(cmd, args, data.shell).completion;\n    data.term.write(NEWLINE);\n};\n\n\nconst welcome = async (data: ProgramMainData) => {\n    // extract from ANSI to make code less verbose\n    const { STYLE, PREFABS, FG } = ANSI;\n\n    const { term } = data;\n\n    term.reset();\n\n    term.writeln(`${STYLE.bold + FG.magenta}Welcome to OllieOS!`);\n    term.writeln(`===================${STYLE.reset_all}`);\n    term.write(NEWLINE);\n\n    term.writeln(\"This tour covers the basic commands and features of OllieOS.\");\n    term.writeln(`First, let's use ${PREFABS.program_name}mefetch${STYLE.reset_all} to view info about me.`);\n    term.write(NEWLINE);\n\n    term.writeln(\"Normally, you would type the command into the terminal and press RETURN, but for this tour, the command will be run automatically.\");\n    term.write(NEWLINE);\n\n    await wait_block(term);\n};\n\nconst mefetch = async (data: ProgramMainData) => {\n    // extract from ANSI to make code less verbose\n    const { STYLE, PREFABS, FG } = ANSI;\n\n    const { term } = data;\n\n    term.reset();\n\n    term.writeln(`${STYLE.bold + FG.magenta}mefetch`);\n    term.writeln(`=======${STYLE.reset_all}`);\n    term.write(NEWLINE);\n\n    await run_cmd(data, \"mefetch\");\n\n    term.writeln(`The ${PREFABS.program_name}mefetch${STYLE.reset_all} command is used to display information about a GitHub user.`);\n    term.writeln(\"By default, it uses my username, obfuscatedgenerated. You can also specify a different username as an argument.\");\n    term.writeln(\"If another username is used, less information will be displayed.\");\n    term.write(NEWLINE);\n\n    term.write(`Now, let's use ${PREFABS.program_name}rss${STYLE.reset_all} to read my blog.`);\n    term.write(NEWLINE);\n\n    await wait_block(term);\n};\n\nconst rss = async (data: ProgramMainData) => {\n    // extract from ANSI to make code less verbose\n    const { STYLE, PREFABS, FG } = ANSI;\n\n    const { term } = data;\n\n    term.reset();\n\n    term.writeln(`${STYLE.bold + FG.magenta}rss`);\n    term.writeln(`===${STYLE.reset_all}`);\n    term.write(NEWLINE);\n\n    await run_cmd(data, \"rss\", [\"-m\", \"1\"]);\n\n    term.writeln(`The ${PREFABS.program_name}rss${STYLE.reset_all} command is used to read RSS feeds.`);\n    term.writeln(\"By default, it uses my blog's RSS feed. You can also specify a different RSS feed as an argument.\");\n    term.writeln(\"A plaintext RSS feed is recommended, but the program can also parse basic HTML.\");\n    term.write(NEWLINE);\n\n    term.writeln(\"For the output above, the -m 1 flag was used to only display the first item in the feed. Without it, all items would be displayed.\");\n    term.write(NEWLINE);\n\n    term.writeln(`Let's use the ${PREFABS.program_name}help${STYLE.reset_all} command to view a list of all available commands, and to get help with a specific command.`);\n    term.write(NEWLINE);\n\n    await wait_block(term);\n};\n\nconst fs = async (data: ProgramMainData) => {\n    // extract from ANSI to make code less verbose\n    const { STYLE, PREFABS, FG } = ANSI;\n\n    const { term } = data;\n\n    term.reset();\n\n    term.writeln(`${STYLE.bold + FG.magenta}Filesystem`);\n    term.writeln(`==========${STYLE.reset_all}`);\n    term.write(NEWLINE);\n\n    term.writeln(\"OllieOS has a filesystem, which is used to store files and folders.\");\n    term.writeln(\"The filesystem is persistent, so files and folders will not be deleted when the OS is restarted.\");\n    term.write(NEWLINE);\n\n    term.writeln(`Let's use the ${PREFABS.program_name}ls${STYLE.reset_all} command to view the contents of the home directory.`);\n    term.write(NEWLINE);\n\n    await run_cmd(data, \"ls\");\n\n    term.writeln(`There's a file in the directory called ${PREFABS.file_path}credits.txt${STYLE.reset_all}. Let's use the ${PREFABS.program_name}cat${STYLE.reset_all} command to view its contents.`);\n    term.write(NEWLINE);\n\n    await wait_block(term);\n    await run_cmd(data, \"cat\", [\"credits.txt\"]);\n\n    term.writeln(`The ${PREFABS.program_name}cat${STYLE.reset_all} command is used to view the contents of one or more files.`);\n    term.writeln(\"If multiple files are specified, their contents will be concatenated together.\");\n    term.write(NEWLINE);\n    \n    term.writeln(`There are many other commands that can be used to interact with the filesystem, such as ${PREFABS.program_name}cd${STYLE.reset_all}, ${PREFABS.program_name}fsedit${STYLE.reset_all}, ${PREFABS.program_name}rm${STYLE.reset_all}, and more.`);\n    term.writeln(NEWLINE);\n\n    await wait_block(term);\n};\n\nconst help = async (data: ProgramMainData) => {\n    // extract from ANSI to make code less verbose\n    const { STYLE, PREFABS, FG } = ANSI;\n\n    const { term } = data;\n\n    term.reset();\n\n    term.writeln(`${STYLE.bold + FG.magenta}help`);\n    term.writeln(`====${STYLE.reset_all}`);\n    term.write(NEWLINE);\n\n    await run_cmd(data, \"help\");\n\n    term.write(NEWLINE);\n    term.write(NEWLINE);\n\n    term.writeln(`The ${PREFABS.program_name}help${STYLE.reset_all} command is used to view a list of all available commands, and to get help with a specific command.`);\n    term.writeln(\"If a command is specified as an argument, the help text for that command will be displayed.\");\n    term.write(NEWLINE);\n\n    term.writeln(`For example, let's view the help text for the ${PREFABS.program_name}rss${STYLE.reset_all} command:`);\n    term.write(NEWLINE);\n\n    await wait_block(term);\n    await run_cmd(data, \"help\", [\"rss\"]);\n\n    await wait_block(term);\n};\n\n\nconst end = async (data: ProgramMainData,) => {\n    // extract from ANSI to make code less verbose\n    const { STYLE, FG, PREFABS } = ANSI;\n\n    const { term } = data;\n\n    term.reset();\n\n    term.writeln(`${STYLE.bold + FG.magenta}Thanks for using OllieOS!`);\n    term.writeln(`=========================${STYLE.reset_all}`);\n    term.write(NEWLINE);\n\n    term.writeln(\"That's all for now!\");\n    term.writeln(\"There is a lot more to explore, so feel free to play around with the OS and try out different commands.\");\n    term.write(NEWLINE);\n\n    term.writeln(\"Things to try:\");\n    term.writeln(` - Use ${PREFABS.program_name}mefetch${STYLE.reset_all}, passing your GitHub username as an argument.`);\n    term.writeln(` - Use ${PREFABS.program_name}cd${STYLE.reset_all} to enter the ${PREFABS.dir_name}projects${STYLE.reset_all} directory, and then use ${PREFABS.program_name}ls${STYLE.reset_all} to view its contents.`);\n    term.writeln(` - Use ${PREFABS.program_name}imagine${STYLE.reset_all} and ${PREFABS.program_name}ascmagine${STYLE.reset_all} to view an image.`);\n    term.writeln(` - Use ${PREFABS.program_name}fsedit${STYLE.reset_all} to explore the filesystem.`);\n    term.writeln(` - Use ${PREFABS.program_name}webget${STYLE.reset_all} to download a file from the Internet into the OS.`);\n    term.write(NEWLINE);\n\n    term.writeln(\"Thanks for using OllieOS.\");\n    term.writeln(\"The OS will now restart.\");\n    term.write(NEWLINE);\n\n    await wait_block(term);\n\n    await run_cmd(data, \"shutdown\", [\"-r\", \"-t\", \"0\"]);\n};\n\n\nexport default {\n    name: \"tour\",\n    description: \"Runs the onboarding tour.\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        await welcome(data);\n\n        await mefetch(data);\n        await rss(data);\n        await fs(data);\n        await help(data);\n\n        await end(data);\n\n        return 0;\n    }\n} as Program;\n","import {determine_program_name_from_js} from \"../../kernel/prog_registry\";\nimport { ANSI, NEWLINE } from \"../../kernel/term_ctl\";\nimport { ProgramMainData } from \"../../types\"\nimport {graph_query, triggers} from \"./index\";\n\n// extract from ANSI to make code less verbose\nconst { STYLE, PREFABS, FG } = ANSI;\n\n// TODO: resolve unused deps?\n\nexport const remove_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const { args, term, kernel, shell } = data;\n\n    // remove subcommand name\n    args.shift();\n\n    if (args.length === 0) {\n        term.writeln(`${PREFABS.error}Missing package name.`);\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // remove duplicate args\n    let unique_args = [...new Set(args)];\n\n    // if any args contain @, trim to before @ and show warning\n    // TODO: accept version specifier and check that the requested version is the one installed before removing\n    for (const arg of unique_args) {\n        if (arg.includes(\"@\")) {\n            term.writeln(`${FG.yellow}Warning: ${arg} contains a version specifier.`);\n            term.writeln(`This will be ignored.${STYLE.reset_all}`);\n        }\n    }\n\n    // perform removal\n    unique_args = unique_args.map(arg => arg.split(\"@\")[0]);\n\n    // remove duplicates again\n    unique_args = [...new Set(unique_args)];\n\n    let error_count = 0;\n    // returns 0 for success, 1 for failure, 2 for fatal error\n\n    const fs = kernel.get_fs();\n    const prog_reg = kernel.get_program_registry();\n\n    // iter over remaining args\n    const total_pkgs = unique_args.length;\n    while (unique_args.length >= 1) {\n        term.writeln(`${NEWLINE}${FG.gray}------------------------${STYLE.reset_all}${NEWLINE}`);\n\n        const pkg = unique_args.shift();\n\n        term.writeln(`${FG.yellow}Checking for ${pkg}...${STYLE.reset_all}`);\n\n        // if .., /, or \\ in pkg, skip\n        if (pkg.includes(\"..\") || pkg.includes(\"/\") || pkg.includes(\"\\\\\")) {\n            term.writeln(`${PREFABS.error}Illegal package name '${pkg}'.${STYLE.reset_all}`);\n            error_count++;\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\n            continue;\n        }\n\n        const pkg_dir = `/usr/bin/${pkg}`;\n\n        // check if pkg exists\n        if (!(await fs.dir_exists(pkg_dir))) {\n            term.writeln(`${PREFABS.error}Package '${pkg}' not installed.${STYLE.reset_all}`);\n            error_count++;\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\n            continue;\n        }\n\n        term.writeln(`${FG.yellow}Updating graph...${STYLE.reset_all}`);\n\n        let meta_triggers = {};\n        let meta_version = \"unknown\";\n        let meta_deps: string[] = [];\n\n        if (await fs.exists(fs.join(pkg_dir, \"meta.json\"))) {\n            try {\n                const meta_raw = await fs.read_file(fs.join(pkg_dir, \"meta.json\")) as string;\n                const meta = JSON.parse(meta_raw);\n\n                meta_triggers = meta.triggers || {};\n                meta_version = meta.version || \"unknown\";\n                meta_deps = meta.deps || [];\n            } catch (e) {\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Could not read meta.json for package ${pkg}: ${e.message}${STYLE.reset_all}`);\n            }\n        }\n\n        // remove self as a dependent from packages listed as dependencies\n        for (const dep_pkg of meta_deps) {\n            try {\n                // split into name and version if @ present\n                const dep_pkg_name = dep_pkg.split(\"@\")[0];\n                await graph_query.remove_pkg_dependent(fs, dep_pkg_name, pkg);\n            } catch (e) {\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Could not remove dependent ${pkg} from package ${dep_pkg}: ${e.message}${STYLE.reset_all}`);\n            }\n        }\n\n        try {\n            await graph_query.remove_pkg(fs, pkg);\n        } catch (e) {\n            term.writeln(`${PREFABS.error}Error removing package '${pkg}': ${e.message}${STYLE.reset_all}`);\n            error_count++;\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\n            continue;\n        }\n\n        term.writeln(`${FG.cyan}Unmounting programs...${STYLE.reset_all}`);\n\n        const files = await fs.list_dir(pkg_dir);\n\n        for (const file of files) {\n            if (!file.endsWith(\".js\")) {\n                continue;\n            }\n\n            const file_path = fs.join(pkg_dir, file);\n\n            let program_name: string;\n            try {\n                const content = await fs.read_file(file_path) as string;\n                program_name = await determine_program_name_from_js(content);\n            } catch (e) {\n                if (e.message.endsWith(\"is not compatible with Node.js.\")) {\n                    // silently skip node.js incompatible programs (they wouldn't have been mounted anyway)\n                    // yes this is a weird way to do it, but better than changing how build_registrant works\n                    continue;\n                }\n\n                term.writeln(`${PREFABS.error}Error determining program name for ${file}: ${e.message}${STYLE.reset_all}`);\n                term.writeln(`${FG.yellow}Skipping program (will remain mounted until restart)...${STYLE.reset_all}`);\n                continue;\n            }\n\n            try {\n                await prog_reg.unregister(program_name);\n                term.writeln(`${FG.cyan}(-) ${program_name}${STYLE.reset_all}`);\n            } catch (e) {\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Program ${program_name} was never registered.${STYLE.reset_all}`);\n            }\n        }\n\n        term.writeln(`${FG.yellow}Removing package data...${STYLE.reset_all}`);\n        await fs.delete_dir(pkg_dir, true);\n        fs.purge_cache();\n\n        term.writeln(`${FG.green}Package '${pkg}' removed.${STYLE.reset_all}`);\n\n        // check for any removal triggers\n        // check for any triggers\n        if (meta_triggers && Object.keys(meta_triggers).length > 0) {\n            term.writeln(`${FG.cyan}Processing uninstall triggers...${STYLE.reset_all}`);\n\n            for (const [trigger_name, trigger_data] of Object.entries(meta_triggers)) {\n                if (!await triggers.trigger_exists(fs, trigger_name)) {\n                    term.writeln(`${FG.yellow}Warning: trigger '${trigger_name}' is not recognised and will be skipped.${STYLE.reset_all}`);\n                    continue;\n                }\n\n                term.writeln(`${FG.cyan}Processing uninstall trigger: ${trigger_name}...${STYLE.reset_all}`);\n                await triggers.process_uninstall_trigger(trigger_name, trigger_data, pkg, meta_version, term, kernel, shell)\n            }\n\n            term.writeln(`${FG.cyan}Uninstall trigger processing complete.${STYLE.reset_all}`);\n        }\n    }\n\n    term.writeln(`${NEWLINE}${FG.magenta + STYLE.bold}========================${STYLE.reset_all}${NEWLINE}`);\n\n    if (error_count > 0) {\n        term.writeln(`${PREFABS.error}Failed to remove ${error_count} package(s).${STYLE.reset_all}`);\n        term.writeln(`${FG.green}Successfully removed ${total_pkgs - error_count} package(s).${STYLE.reset_all}`);\n        term.writeln(`${FG.cyan}Total packages: ${total_pkgs}${STYLE.reset_all}`);\n        return 1;\n    }\n\n    term.writeln(`${FG.green}Successfully removed all ${total_pkgs} package(s).${STYLE.reset_all}`);\n\n    return 0;\n}\n","import {graph_query, json_convert_dep_sets_to_arrs, repo_query, triggers} from \".\";\n\nimport {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\nimport {ProgramMainData} from \"../../types\"\nimport {remove_subcommand} from \"./remove\";\n\n// extract from ANSI to make code less verbose\nconst {STYLE, PREFABS, FG} = ANSI;\n\n// we arent allowing multiple versions of the same package to be installed at once to simplify things significantly\n// TODO: write to a file that tracks installed packages and their dependents (for list and smart removal/cleanup)\n\nexport const add_subcommand = async (data: ProgramMainData, depended_by?: string) => {\n    // extract from data to make code less verbose\n    const {args, term, kernel, shell} = data;\n\n    // remove subcommand name\n    args.shift();\n\n    if (args.length === 0) {\n        term.writeln(`${PREFABS.error}Missing package name.`);\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // remove duplicate args\n    const unique_args = [...new Set(args)];\n\n    let error_count = 0;\n    // returns 0 for success, 1 for failure, 2 for fatal error\n\n    const fs = kernel.get_fs();\n    const prog_reg = kernel.get_program_registry();\n\n    // iter over remaining args\n    const total_pkgs = unique_args.length;\n    while (unique_args.length >= 1) {\n        term.writeln(`${NEWLINE}${FG.gray}------------------------${STYLE.reset_all}${NEWLINE}`);\n\n        const pkg_at_version = unique_args.shift();\n\n        // if in the format of pkg@version, split it up\n        const pkg_split = pkg_at_version.split(\"@\");\n        if (pkg_split.length > 2) {\n            term.writeln(`${PREFABS.error}Invalid package name: ${pkg_at_version}`);\n            term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\n            return 2;\n        }\n\n        const pkg_name = pkg_split[0];\n        let pkg_version = pkg_split[1];\n\n        term.writeln(`${FG.yellow}Checking for ${pkg_name}...${STYLE.reset_all}`);\n\n        const pkg_json = await repo_query.get_pkg_json(pkg_name);\n\n        if (!pkg_json) {\n            term.writeln(`${PREFABS.error}Package '${pkg_name}' not found.${STYLE.reset_all}`);\n            error_count++;\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\n            continue;\n        }\n\n        // if no version specified, use latest\n        if (!pkg_version) {\n            pkg_version = pkg_json.latest_version;\n        }\n\n        term.writeln(`${FG.yellow}Using ${pkg_name}@${pkg_version}...${STYLE.reset_all}`);\n\n        // check if version exists (and get metadata)\n        const meta = await repo_query.get_pkg_meta(pkg_name, pkg_version);\n\n        if (!meta) {\n            term.writeln(`${PREFABS.error}Version '${pkg_version}' of '${pkg_name}' not found.${STYLE.reset_all}`);\n            error_count++;\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\n            continue;\n        }\n\n        if (!meta.externals || meta.externals !== \"global\") {\n            term.writeln(`${PREFABS.error}Package '${pkg_name}' is not using the new global externals system. Please build the package with a newer version of pkgbuild.${STYLE.reset_all}`);\n            error_count++;\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\n            continue;\n        }\n\n        const pkg_dir = `/usr/bin/${pkg_name}`;\n\n        // check version file if already installed\n        // TODO: switch to pkg graph?\n        if (graph_query.pkg_is_installed(pkg_name)) {\n            const installed_version = graph_query.get_pkg_version(pkg_name);\n\n            if (installed_version === pkg_version) {\n                // if exact version already installed, check dep graph then skip\n                // ie if depended_by is set but that isn't a dependent yet then add it\n\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: ${pkg_name}@${pkg_version} already installed. If you wish to reinstall the package, remove it first.${STYLE.reset_all}`);\n\n                // cant do this here as top level package isn't installed yet. it's the caller's job to do this. it wouldn't be safe to refactor the method in a way that allows this\n                // if (depended_by) {\n                //     graph_query.add_pkg_dependent(fs, pkg_name, depended_by);\n                //     term.writeln(`${FG.yellow}(dep graph updated)${STYLE.reset_all}`);\n                // }\n\n                continue;\n            } else {\n                // uninstall old version\n                term.writeln(`${FG.yellow}Uninstalling old ${pkg_name}@${pkg_version}...${STYLE.reset_all}`);\n\n                const remove_data = {kernel, term, process: data.process, args: [\"remove\", pkg_name], unsubbed_args: [\"remove\", pkg_name], raw_parts: [...data.raw_parts, \"remove\", pkg_name]};\n                const remove_exit_code = await remove_subcommand(remove_data);\n                if (remove_exit_code !== 0) {\n                    term.writeln(`${PREFABS.error}Failed to uninstall old version.${STYLE.reset_all}`);\n                    error_count++;\n                    term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\n                    continue;\n                }\n            }\n        }\n\n        // firstly, install dependencies\n        if (meta.deps && meta.deps.size > 0) {\n            term.writeln(`${NEWLINE + FG.magenta + STYLE.bold}Installing dependencies...${STYLE.reset_all}`);\n\n            // simulate a call to this function with the deps as arguments\n            // TODO: is it worth doing this properly and decomposing each stage to a function and calling it?\n            // TODO: clearer logs\n            // TODO: unshifting add is silly, should this func be changed to accept args with add removed?\n            // TODO: parallelism with promise.all???\n            const virtual_args: string[] = [...meta.deps];\n            virtual_args.unshift(\"add\");\n\n            // we need to also pass the name of the dependent package to the virtual call to let the graph know\n            const virtual_data = {kernel, term, process: data.process, args: virtual_args, unsubbed_args: virtual_args, raw_parts: [...data.raw_parts, ...virtual_args]};\n            const virtual_exit_code = await add_subcommand(virtual_data, pkg_name);\n\n            if (virtual_exit_code !== 0) {\n                term.writeln(`${PREFABS.error}Failed to install dependencies.${STYLE.reset_all}`);\n                error_count++;\n                term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\n                continue;\n                // TODO: remove partial installation\n            }\n\n            term.writeln(`${FG.magenta + STYLE.bold}Dependencies installed.${STYLE.reset_all + NEWLINE}`);\n        }\n\n        term.writeln(`${FG.yellow}Enumerating contents...${STYLE.reset_all}`);\n\n        const content_list = meta.files;\n\n        if (content_list.length === 0 || content_list.length === 1 && content_list[0] === \"\") {\n            term.writeln(`${PREFABS.error}Empty package.${STYLE.reset_all}`);\n            error_count++;\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\n            continue;\n        }\n\n        // get each file in contents and load it into memory\n        const file_map = new Map<string, string>();\n\n        for (const file of content_list) {\n            if (file === \"\") {\n                continue;\n            }\n\n            term.writeln(`${FG.yellow}Downloading ${file}...${STYLE.reset_all}`);\n\n            const file_contents = await repo_query.get_pkg_file(pkg_name, pkg_version, file);\n\n            if (!file_contents) {\n                term.writeln(`${PREFABS.error}Not found.${STYLE.reset_all}`);\n                error_count++;\n                term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\n                continue;\n            }\n\n            file_map.set(file, file_contents);\n        }\n\n        // add pkg.json and meta.json to file map\n        file_map.set(\"pkg.json\", JSON.stringify(pkg_json));\n        // TODO: adding this might be redundant, we could just move build timestamp to the graph. could also use file array to help mounting? prob not needed.\n        // TODO: build timestamp isnt actually used anywhere yet so not a big deal until implemented. might be quicker to just open this file rather than access the graph anyway!\n        file_map.set(\"meta.json\", JSON.stringify(meta, json_convert_dep_sets_to_arrs));\n\n        // not actually executing the file map yet, as we need to ensure the graph is valid\n\n        term.writeln(`${FG.yellow}Updating graph...${STYLE.reset_all}`);\n\n        // don't need to check if installed or do anything fancy if it is, as previous checks have already run and updated the graph if needed\n        // this is guaranteed to be a new install (whether first time or remove was just run)\n        // TODO: test if that's true! test it more!\n        try {\n            await graph_query.install_new_pkg(fs, pkg_name, pkg_version, meta.deps, !depended_by, depended_by);\n        } catch (e) {\n            term.writeln(`${PREFABS.error}Failed to add to graph: ${e.message}${STYLE.reset_all}`);\n            error_count++;\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\n            continue;\n        }\n\n        // if there were dependencies, add this package as a dependent to each of them\n        try {\n            if (meta.deps && meta.deps.size > 0) {\n                for (const dep of meta.deps) {\n                    const dep_name = dep.split(\"@\")[0];\n                    await graph_query.add_pkg_dependent(fs, dep_name, pkg_name);\n                }\n            }\n        } catch (e) {\n            term.writeln(`${PREFABS.error}Failed to update dependencies: ${e.message}${STYLE.reset_all}`);\n            error_count++;\n            term.writeln(`${FG.yellow}Rolling back graph...${STYLE.reset_all}`);\n            // TODO: safety check? is it safer to capture the entire graph before starting and then rollback to that? add a capture and rollback method to graph_query?\n            await graph_query.remove_pkg(fs, pkg_name);\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\n            continue;\n        }\n\n        term.writeln(`${FG.yellow}Installing ${pkg_name}...${STYLE.reset_all}`);\n\n        await fs.make_dir(pkg_dir);\n\n        // write each file\n        for (const [file, value] of file_map) {\n            await fs.write_file(`${pkg_dir}/${file}`, value, true);\n        }\n\n        // TODO: check if this fails somehow, and if it does, rollback the graph\n\n        term.writeln(`${FG.green}Installed!${STYLE.reset_all}`);\n\n        term.writeln(`${FG.cyan}Mounting package ${pkg_name}...${STYLE.reset_all}`);\n\n        // it doesn't matter if mounting fails, the graph is fine and the files are downloaded properly, so no rollback needed\n\n        // mount each program\n        for (const [filename, value] of file_map) {\n            if (!filename.endsWith(\".js\")) {\n                continue;\n            }\n\n            await prog_reg.mount_and_register_with_output(filename, value, term, true);\n        }\n\n        term.writeln(`${FG.green}Package ${pkg_name}@${pkg_version} installed.${STYLE.reset_all}`);\n\n        // check for any triggers\n        if (meta && meta.triggers && Object.keys(meta.triggers).length > 0) {\n            term.writeln(`${FG.cyan}Processing install triggers...${STYLE.reset_all}`);\n\n            for (const [trigger_name, trigger_data] of Object.entries(meta.triggers)) {\n                if (!await triggers.trigger_exists(fs, trigger_name)) {\n                    term.writeln(`${FG.yellow}Warning: trigger '${trigger_name}' is not recognised and will be skipped.${STYLE.reset_all}`);\n                    continue;\n                }\n\n                term.writeln(`${FG.cyan}Processing install trigger: ${trigger_name}...${STYLE.reset_all}`);\n                await triggers.process_install_trigger(trigger_name, trigger_data, pkg_name, pkg_version, term, kernel, shell);\n            }\n\n            term.writeln(`${FG.cyan}Install trigger processing complete.${STYLE.reset_all}`);\n        }\n    }\n\n    term.writeln(`${NEWLINE}${FG.magenta + STYLE.bold}========================${STYLE.reset_all}${NEWLINE}`);\n\n    if (error_count > 0) {\n        term.writeln(`${PREFABS.error}Failed to install ${error_count} package(s).${STYLE.reset_all}`);\n        term.writeln(`${FG.green}Successfully installed ${total_pkgs - error_count} package(s).${STYLE.reset_all}`);\n        term.writeln(`${FG.cyan}Total packages: ${total_pkgs}${STYLE.reset_all}`);\n        return 1;\n    }\n\n    term.writeln(`${FG.green}Successfully installed all ${total_pkgs} package(s).${STYLE.reset_all}`);\n\n    return 0;\n}\n// TODO: decompose into smaller functions\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\nimport { ProgramMainData } from \"../../types\"\nimport {graph_query} from \"./index\";\n\n// extract from ANSI to make code less verbose\nconst { STYLE, FG } = ANSI;\nexport const list_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const { args, term } = data;\n\n    // remove subcommand name\n    args.shift();\n\n    // check for presence of -t flag\n    let only_top_level = false;\n    if (args[0] === \"-t\") {\n        only_top_level = true;\n        args.shift();\n    }\n\n    term.write(NEWLINE);\n\n    const pkg_names = graph_query.list_pkgs(only_top_level);\n\n    // print each package, marking top level packages in green, dependencies in white, and unused dependencies in gray\n    for (const pkg_name of pkg_names) {\n        const info = graph_query.get_pkg_info(pkg_name);\n\n        let color = FG.gray;\n        if (info.top_level) {\n            color = FG.green;\n        } else if (info.dependents.size !== 0) {\n            color = FG.white;\n        }\n\n        term.writeln(`${STYLE.bold}${color}${pkg_name}${STYLE.no_bold_or_dim}@${info.version}${STYLE.reset_all}`);\n    }\n\n    return 0;\n}\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\nimport type { WrappedTerminal } from \"../../kernel/term_ctl\";\nimport type { ProgramMainData } from \"../../types\"\nimport {graph_query, repo_query} from \"./index\";\n\n// extract from ANSI to make code less verbose\nconst { STYLE, PREFABS } = ANSI;\n\ninterface PkgInfo {\n    description?: string;\n    author?: string;\n    license?: string;\n    homepage_url?: string;\n    repo_url?: string;\n    long_desc?: string;\n}\n\nconst print_info = (term: WrappedTerminal, pkg_name: string, pkg_version: string, pkg_data: PkgInfo, installed: boolean) => {\n    term.write(NEWLINE);\n\n    term.writeln(`Package: ${STYLE.bold}${pkg_name}${STYLE.no_bold_or_dim}`);\n    term.writeln(`Version: ${STYLE.bold}${pkg_version}${STYLE.no_bold_or_dim}`);\n    term.writeln(`Description: ${pkg_data.description || \"No description provided.\"}`);\n    term.writeln(`Author: ${pkg_data.author || \"Unknown\"}`);\n    term.writeln(`License: ${pkg_data.license || \"Unknown\"}`);\n    term.writeln(`Installed: ${STYLE.bold}${installed ? \"Yes\" : \"No\"}${STYLE.no_bold_or_dim}`);\n\n    if (pkg_data.homepage_url) {\n        term.writeln(`Homepage: ${pkg_data.homepage_url}`);\n    }\n\n    if (pkg_data.repo_url) {\n        term.writeln(`Repository: ${pkg_data.repo_url}`);\n    }\n\n    if (pkg_data.long_desc) {\n        term.write(NEWLINE);\n        term.writeln(`Long description available. Use ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} read${STYLE.reset_all} ${pkg_name} to read it.`);\n    }\n}\n\nexport const info_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const { args, term, kernel } = data;\n\n    // remove subcommand name\n    args.shift();\n\n    // check for presence of -r flag\n    let always_fetch = false;\n    if (args[0] === \"-r\") {\n        always_fetch = true;\n        args.shift();\n    }\n\n    // check for package name\n    if (args.length === 0) {\n        term.writeln(`${PREFABS.error}Missing package name.`);\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    const pkg_at_version = args[0];\n\n    // if in the format of pkg@version, split it up\n    const pkg_split = pkg_at_version.split(\"@\");\n    if (pkg_split.length > 2) {\n        term.writeln(`${PREFABS.error}Invalid package name: ${pkg_at_version}`);\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\n        return 2;\n    }\n\n    const pkg_name = pkg_split[0];\n    let pkg_version = pkg_split[1];\n\n    // if no version specified, use what's installed\n    // if not installed, fetch latest from repo\n    // note that version doesnt really matter other than as a test whether the version exists and installed locally, as pkg.json is shared across versions\n    if (!pkg_version) {\n        const installed_pkg = graph_query.get_pkg_version(pkg_name);\n        if (installed_pkg && !always_fetch) {\n            pkg_version = installed_pkg;\n        } else {\n            const pkg_json = await repo_query.get_pkg_json(pkg_name);\n            if (!pkg_json) {\n                term.writeln(`${PREFABS.error}Package not found: ${pkg_name}`);\n                term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\n                return 3;\n            }\n\n            pkg_version = pkg_json.latest_version;\n        }\n    }\n\n    const installed_pkg = graph_query.get_pkg_version(pkg_name);\n    const requested_version_installed = installed_pkg === pkg_version;\n\n    const fs = kernel.get_fs();\n\n    if (!always_fetch && requested_version_installed) {\n        const pkg_json_path = graph_query.get_file_path_in_pkg_bin(fs, pkg_name, \"pkg.json\");\n\n        if (!fs.exists(pkg_json_path)) {\n            // shouldnt happen, but just in case\n            console.error(`Invalid pkg.json path: ${pkg_json_path}`);\n            term.writeln(`${PREFABS.error}Error reading package files for ${pkg_name}`);\n            return 3;\n        }\n\n        const pkg_json = await fs.read_file(pkg_json_path) as string;\n        const pkg_data = JSON.parse(pkg_json);\n\n        print_info(term, pkg_name, pkg_version, pkg_data, true);\n        return 0;\n    }\n\n    // fetch package data from repo\n    const pkg_data = await repo_query.get_pkg_json(pkg_name);\n    if (!pkg_data) {\n        term.writeln(`${PREFABS.error}Package not found: ${pkg_name}`);\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\n        return 3;\n    }\n\n    print_info(term, pkg_name, pkg_version, pkg_data, requested_version_installed);\n    return 0;\n}\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\nimport type { WrappedTerminal } from \"../../kernel/term_ctl\";\nimport { ProgramMainData } from \"../../types\"\nimport {graph_query, repo_query} from \"./index\";\nimport type {UserspaceKernel} from \"../../kernel\";\nimport type {AbstractShell} from \"../../abstract_shell\";\n\n// extract from ANSI to make code less verbose\nconst { STYLE, FG, CURSOR } = ANSI;\n\nconst ROWS = 10;\n\nconst view_pkg_info = async (pkg_name: string, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\n    const pkg_data = await repo_query.get_pkg_json(pkg_name);\n    const pkg_versions = await repo_query.get_pkg_versions(pkg_name);\n\n    term.clear();\n\n    term.write(NEWLINE);\n    term.writeln(`${STYLE.bold}${FG.cyan}${pkg_name}`);\n    term.write(STYLE.dim);\n    term.writeln(\"=\".repeat(pkg_name.length));\n    term.writeln(STYLE.reset_all);\n\n    // check for installed version\n    const installed_version = graph_query.get_pkg_version(pkg_name);\n\n    term.write(NEWLINE);\n    term.writeln(`${STYLE.bold}Available versions:${STYLE.no_bold_or_dim}`);\n    for (const version of pkg_versions) {\n        term.writeln(`  - ${version} ${installed_version === version ? `${STYLE.italic}(installed)${STYLE.reset_all}` : \"\"}`);\n    }\n\n    term.write(NEWLINE);\n    term.writeln(`${STYLE.bold}Description:${STYLE.no_bold_or_dim} ${pkg_data.description || \"No description provided.\"}`);\n    term.writeln(`${STYLE.bold}Author:${STYLE.no_bold_or_dim} ${pkg_data.author || \"Unknown\"}`);\n    term.writeln(`${STYLE.bold}License:${STYLE.no_bold_or_dim} ${pkg_data.license || \"Unknown\"}`);\n\n    let printed_link_header = false;\n\n    if (pkg_data.homepage_url) {\n        if (!printed_link_header) {\n            term.write(NEWLINE);\n            printed_link_header = true;\n        }\n\n        term.writeln(`${STYLE.bold}Homepage:${STYLE.no_bold_or_dim} ${pkg_data.homepage_url}`);\n    }\n\n    if (pkg_data.repo_url) {\n        if (!printed_link_header) {\n            term.write(NEWLINE);\n            printed_link_header = true;\n        }\n\n        term.writeln(`${STYLE.bold}Repository:${STYLE.no_bold_or_dim} ${pkg_data.repo_url}`);\n    }\n\n    term.write(NEWLINE);\n\n    term.writeln(`${STYLE.dim}Press 'i' to install the latest version of this package.${STYLE.reset_all}`);\n    term.writeln(`${STYLE.dim}Press any other key to return to the list...${STYLE.reset_all}`);\n\n    const key = await term.wait_for_keypress();\n\n    if (key.domEvent.key === \"i\") {\n        // double check installation\n        term.write(NEWLINE);\n        term.write(`${STYLE.bold}Are you sure you want to install '${pkg_name}'? (y/N)${STYLE.no_bold_or_dim}`);\n\n        const confirm_key = await term.wait_for_keypress();\n\n        if (confirm_key.domEvent.key.toLowerCase() === \"y\") {\n            term.write(\" yes\");\n            term.write(NEWLINE);\n\n            await kernel.spawn(\"pkg\", [\"add\", pkg_name], shell).completion;\n\n            term.write(NEWLINE);\n            term.writeln(`${STYLE.dim}Press any key to return to the list...${STYLE.reset_all}`);\n            await term.wait_for_keypress();\n        } else {\n            term.write(\" no\");\n            term.writeln(NEWLINE);\n\n            term.writeln(`${STYLE.dim}Installation cancelled. Press any key to return to the list...${STYLE.reset_all}`);\n            await term.wait_for_keypress();\n        }\n    }\n}\n\n// TODO: accept name argument to jump to specific package\n\nexport const browse_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const { args, term, kernel, shell } = data;\n\n    // remove subcommand name\n    args.shift();\n\n    const provided = await repo_query.get_provided_list();\n\n    let offset = 0;\n    let selected_index = 0;\n    const draw = () => {\n        term.clear();\n\n        term.write(NEWLINE);\n        term.writeln(\"(use up/down arrow keys to scroll, enter to show more info, escape to quit)\");\n        term.write(NEWLINE);\n        term.write(CURSOR.invisible);\n\n        // show ... if there are more items above\n        if (offset > 0) {\n            term.writeln(`  ${STYLE.dim}...${STYLE.reset_all}`);\n        } else {\n            term.write(NEWLINE);\n        }\n\n        const slice = provided.slice(offset, offset + ROWS);\n        for (const [index, name] of slice.entries()) {\n            // check for installed version\n            const installed_version = graph_query.get_pkg_version(name);\n\n            // highlight selected item\n            if (offset + index === selected_index) {\n                term.write(`${FG.cyan}${STYLE.dim}> ${STYLE.no_bold_or_dim}${STYLE.bold}`);\n            } else {\n                term.write(\"  \");\n            }\n\n            term.writeln(`${name} ${installed_version ? `${STYLE.italic}(installed: ${installed_version})` : \"\"}${STYLE.reset_all}`);\n        }\n\n        // show ... if there are more items below\n        if (offset + ROWS < provided.length) {\n            term.writeln(`  ${STYLE.dim}...${STYLE.reset_all}`);\n        } else {\n            term.write(NEWLINE);\n        }\n    }\n\n    // TODO: type to filter\n\n    let quit = false;\n    while (!quit) {\n        draw();\n\n        const key = await term.wait_for_keypress();\n        console.log(key);\n        switch (key.domEvent.key) {\n            case \"Escape\":\n                quit = true;\n                break;\n            case \"ArrowUp\":\n                if (selected_index > 0) {\n                    selected_index--;\n                    if (selected_index < offset) {\n                        offset--;\n                    }\n                }\n                break;\n            case \"ArrowDown\":\n                if (selected_index < provided.length - 1) {\n                    selected_index++;\n                    if (selected_index >= offset + ROWS) {\n                        offset++;\n                    }\n                }\n                break;\n            case \"Enter\": {\n                const pkg_name = provided[selected_index];\n                await view_pkg_info(pkg_name, term, kernel, shell);\n                break;\n            }\n        }\n    }\n\n    term.clear();\n    term.write(CURSOR.visible);\n    return 0;\n}\n","import {add_subcommand} from \"./add\";\nimport {remove_subcommand} from \"./remove\";\n\nimport {ANSI, type WrappedTerminal} from \"../../kernel/term_ctl\";\nimport type {Program} from \"../../types\";\nimport type {UserspaceFileSystem} from \"../../kernel/filesystem\";\nimport {list_subcommand} from \"./list\";\nimport {info_subcommand} from \"./info\";\nimport {browse_subcommand} from \"./browse\";\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\n\nimport type {UserspaceKernel, SpawnResult} from \"../../kernel\";\nimport type {AbstractShell} from \"../../abstract_shell\";\n\n\nconst REPO_URL = \"https://ollieg.codes/pkg_repo\";\nconst repo_url_obj = new URL(REPO_URL);\n// TODO: in future, this can be changed. it will also be a list of repos in priority order, and the first one that has the package will be used.\n\nconst GRAPH_DIR = \"/var/lib/pkg\";\nconst GRAPH_PATH = GRAPH_DIR + \"/graph.json\";\n\nconst BIN_DIR = \"/usr/bin\";\n\nconst TRIGGER_DIR = \"/var/lib/pkg/triggers\";\n\n// TODO: subcommand template / helper\n\nconst append_url_pathnames = (url: URL, pathnames: string[]) => {\n    const new_url = new URL(url.toString());\n    let urlpath = new_url.pathname;\n\n    // drop trailing /\n    if (urlpath.endsWith(\"/\")) {\n        urlpath = urlpath.slice(0, urlpath.length - 1);\n    }\n\n    for (const path of pathnames) {\n        if (path.includes(\"/\") || path.includes(\"\\\\\") || path.includes(\"..\")) {\n            throw new Error(\"Unsafe pathname: \" + path);\n        }\n\n        urlpath += (path === \"\" ? \"\" : \"/\" + path);\n    }\n\n    new_url.pathname = urlpath;\n    return new_url;\n    // TODO: safe?\n}\n\nexport type PkgAtVersion = `${string}@${string}`;\n// TODO: honestly handling of pakcage version sucks rn, need to test if even having deps = \"pkg@version\" works properly\n\ninterface PackageMeta {\n    files: string[];\n    version: string;\n    deps: Set<PkgAtVersion>;\n    triggers: { [trigger_name: string]: unknown };\n    build_timestamp: number;\n    externals: \"global\" | undefined;\n}\n\nexport const repo_query = {\n    // GETs a file path relative to the repo root\n    // TODO: why did i write this and not use it?? all other fetches are just this but returning null for a 404?? am i stupid?? it's being exported so maybe i had a reason\n    api_call: async (filepath: string) => {\n        const url = new URL(filepath, repo_url_obj);\n\n        const response = await fetch(url.toString());\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return await response.text();\n    },\n\n    // returns null if not found, otherwise returns the contents of the file\n    get_pkg_json: async (pkg: string) => {\n        pkg = encodeURI(pkg);\n        pkg = pkg.replace(/\\./g, \"%2E\");\n\n        // repo/pkgs/pkg/\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, \"pkg.json\"]);\n\n        const response = await fetch(url.toString());\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        return await response.json();\n    },\n\n    // returns null if not found, otherwise returns the meta.json file as an object\n    get_pkg_meta: async (pkg: string, version: string): Promise<PackageMeta> => {\n        pkg = encodeURI(pkg);\n        version = encodeURI(version);\n        pkg = pkg.replace(/\\./g, \"%2E\");\n        version = version.replace(/\\./g, \"%2E\");\n\n        // repo/pkgs/pkg/version/\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, version, \"meta.json\"]);\n\n        const response = await fetch(url.toString());\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        // TODO: validate meta\n\n        const data = await response.json();\n\n        // convert deps to set\n        data.deps = new Set(data.deps);\n\n        return data;\n    },\n\n    // gets a file within a package or returns null if not found\n    get_pkg_file: async (pkg: string, version: string, filepath: string) => {\n        pkg = encodeURI(pkg);\n        version = encodeURI(version);\n        filepath = encodeURI(filepath);\n        pkg = pkg.replace(/\\./g, \"%2E\");\n        version = version.replace(/\\./g, \"%2E\");\n        filepath = filepath.replace(/\\./g, \"%2E\");\n\n        // repo/pkgs/pkg/version/filepath\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, version, filepath]);\n\n        const response = await fetch(url.toString());\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        return await response.text();\n    },\n\n    get_provided_list: async () => {\n        // repo/provided.txt\n        const url = append_url_pathnames(repo_url_obj, [\"provided.txt\"]);\n\n        const response = await fetch(url.toString());\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        // newline separated list of provided package names\n        const data = await response.text();\n        return data.split(\"\\n\").map((line) => line.trim()).filter((line) => line.length > 0);\n    },\n\n    get_pkg_versions: async (pkg: string) => {\n        pkg = encodeURI(pkg);\n        pkg = pkg.replace(/\\./g, \"%2E\");\n\n        // repo/pkgs/pkg/versions.txt\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, \"versions.txt\"]);\n        const response = await fetch(url.toString());\n        if (!response.ok) {\n            if (response.status === 404) {\n                return null;\n            }\n\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        // newline separated list of versions\n        const data = await response.text();\n        return data.split(\"\\n\").map((line) => line.trim()).filter((line) => line.length > 0);\n    }\n}\n\ninterface PkgGraphEntry {\n    version: string;\n    deps: Set<PkgAtVersion | string>;\n    dependents: Set<string>;\n    top_level: boolean; // as in, specified by the user at install time\n}\n\nexport const json_convert_dep_sets_to_arrs = (key: string, value: any) => {\n    if (key !== \"deps\" && key !== \"dependents\") {\n        return value;\n    }\n\n    if (value instanceof Set) {\n        return Array.from(value);\n    }\n\n    throw new Error(`${key} not a set in graph to be stringified!`);\n}\n\nexport const json_convert_dep_arrs_to_sets = (key: string, value: any) => {\n    if (key !== \"deps\" && key !== \"dependents\") {\n        return value;\n    }\n\n    if (Array.isArray(value)) {\n        return new Set(value);\n    }\n\n    throw new Error(`${key} not an array in graph to be parsed!`);\n}\n\nlet graph: { [pkg_name: string]: PkgGraphEntry } = {};\nexport const graph_query = {\n    // TODO: graph consistency checks / repair function\n    // TODO: dangling dep check\n\n    // gets the graph entry for a package\n    get_pkg_info: (pkg: string): PkgGraphEntry => {\n        return graph[pkg];\n    },\n\n    // lists names of all installed packages, optionally only top level\n    list_pkgs: (only_top_level = false) => {\n        const pkgs = Object.keys(graph);\n\n        if (only_top_level) {\n            return pkgs.filter((pkg) => graph[pkg].top_level);\n        }\n\n        return pkgs;\n    },\n\n    // checks if a package is installed, optionally with a specific version\n    pkg_is_installed: (pkg: string, version?: string) => {\n        if (!graph[pkg]) {\n            return false;\n        }\n\n        if (version) {\n            return graph[pkg].version === version;\n        }\n\n        return true;\n    },\n\n    // gets the version of an installed package, or undefined if not installed\n    get_pkg_version: (pkg: string): string | undefined => {\n        return graph[pkg]?.version;\n    },\n\n    // gets the dependents of a package, or undefined if not installed\n    get_pkg_dependents: (pkg: string): Set<string> | undefined => {\n        return graph[pkg]?.dependents;\n    },\n\n    // gets the dependencies of a package, or undefined if not installed\n    get_pkg_dependencies: (pkg: string): Set<PkgAtVersion | string> | undefined => {\n        return graph[pkg]?.deps;\n    },\n\n    // installs a NEW package. if this is not a top level package, you must specify an initial dependent. you cannot modify an existing package unless you use the defined functions.\n    install_new_pkg: async (fs: UserspaceFileSystem, pkg: string, version: string, deps: Set<PkgAtVersion>, top_level: boolean, dependended_by?: string) => {\n        // TODO: resolve what to do if the package is already installed rather than exploding, makes using it a lot simpler\n\n        if (graph[pkg]) {\n            throw new Error(`Package ${pkg} is already installed and cannot be modified.`);\n        }\n\n        // TODO: we could assume top level based on if dependended_by is provided, but that's not very precise. top level packages may be dependencies!\n        if (!top_level && !dependended_by) {\n            throw new Error(`Package ${pkg} is not installed as a top-level package but does not have a dependent it was installed by.`);\n        }\n\n        const dependents = new Set<string>();\n\n        if (dependended_by) {\n            dependents.add(dependended_by);\n        }\n\n        graph[pkg] = {\n            version,\n            deps,\n            top_level,\n            dependents\n        };\n\n        // write to file\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\n    },\n\n    // makes a package a top level package, no checks are performed as top level packages may have dependents\n    promote_pkg_to_top_level: async (fs: UserspaceFileSystem, pkg: string) => {\n        if (!graph[pkg]) {\n            throw new Error(`Package ${pkg} is not installed.`);\n        }\n\n        graph[pkg].top_level = true;\n\n        // write to file\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\n    },\n\n    // makes a package not a top level package, but only if it has no dependents. use add_pkg_dependent FIRST before demoting if it has dependents now.\n    demote_pkg_from_top_level: async (fs: UserspaceFileSystem, pkg: string) => {\n        if (!graph[pkg]) {\n            throw new Error(`Package ${pkg} is not installed.`);\n        }\n\n        if (graph[pkg].dependents.size > 0) {\n            throw new Error(`Package ${pkg} has no dependents and cannot be demoted. Use add_pkg_dependent FIRST.`);\n        }\n\n        graph[pkg].top_level = false;\n\n        // write to file\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\n    },\n\n    // adds a dependent to a package, provided the dependent is already installed. also adds the dependency to the dependent package.\n    add_pkg_dependent: async (fs: UserspaceFileSystem, pkg: string, dependent_pkg: string, add_to_deps = false) => {\n        if (!graph[pkg]) {\n            throw new Error(`Package ${pkg} is not installed.`);\n        }\n\n        if (!graph[dependent_pkg]) {\n            throw new Error(`Dependent ${dependent_pkg} is not installed.`);\n        }\n\n        const pkg_at_version = `${pkg}@${graph[pkg].version}` as PkgAtVersion;\n\n        graph[pkg].dependents.add(dependent_pkg);\n\n        if (add_to_deps) {\n            graph[dependent_pkg].deps.add(pkg_at_version);\n        }\n\n        // write to file\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\n    },\n\n    // removes a dependent from a package, as well as clearing the dependency from the dependent package\n    remove_pkg_dependent: async (fs: UserspaceFileSystem, pkg: string, dependent_pkg: string, remove_from_deps = false) => {\n        if (!graph[pkg]) {\n            throw new Error(`Package ${pkg} is not installed.`);\n        }\n\n        if (!graph[dependent_pkg]) {\n            throw new Error(`Dependent ${dependent_pkg} is not installed.`);\n        }\n\n        if (!graph[pkg].dependents.has(dependent_pkg)) {\n            throw new Error(`Package ${pkg} does not have dependent ${dependent_pkg}.`);\n        }\n\n        const pkg_at_version = `${pkg}@${graph[pkg].version}` as PkgAtVersion;\n\n        if (!graph[dependent_pkg].deps.has(pkg) && !graph[dependent_pkg].deps.has(pkg_at_version)) {\n            throw new Error(`Inconsistent graph! Dependent ${dependent_pkg} does not have dependency ${pkg}, but ${pkg} has dependent ${dependent_pkg}.`);\n        }\n\n        graph[pkg].dependents.delete(dependent_pkg);\n\n        if (remove_from_deps) {\n            graph[dependent_pkg].deps.delete(pkg_at_version);\n        }\n\n        // write to file\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\n\n        // uninstall if it has no dependents now? probably not, we can have a separate command for that\n    },\n\n    // removes a package from the graph, provided it has no dependents. you can skip this check, but this will leave dangling dependencies.\n    remove_pkg: async (fs: UserspaceFileSystem, pkg: string, skip_dep_check = false) => {\n        if (!graph[pkg]) {\n            throw new Error(`Package ${pkg} is not installed.`);\n        }\n\n        // check if this package has any dependents\n        if (!skip_dep_check && graph[pkg].dependents.size > 0) {\n            throw new Error(`Package ${pkg} has dependents and cannot be removed.`);\n        }\n\n        // // remove this package from its dependents' dependencies\n        // no! don't do this! if they skip the dep check, we don't want to destroy the fact that there are hanging deps\n        // for (const dependent of graph[pkg].dependents) {\n        //     const dependent_name = dependent.split(\"@\")[0];\n        //     graph[dependent_name].deps = graph[dependent_name].deps.filter((dep) => dep !== pkg);\n        // }\n\n        // remove this package from its dependencies' dependents\n        for (const dep of graph[pkg].deps) {\n            const dep_name = dep.split(\"@\")[0];\n            graph[dep_name].dependents.delete(`${pkg}@${graph[pkg].version}` as PkgAtVersion);\n        }\n\n        // TODO: feels like something is missing? oh well, we'll find out when we test it\n\n        // remove this package from the graph\n        delete graph[pkg];\n\n        // write to file\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\n    },\n\n    // lists all packages that are not installed as top level and have no dependents\n    list_unused_pkgs: () => {\n        return Object.keys(graph).filter((pkg) => !graph[pkg].top_level && graph[pkg].dependents.size === 0);\n    },\n\n    get_file_path_in_pkg_bin: (fs: UserspaceFileSystem, pkg: string, filepath: string) => {\n        const pkg_dir = fs.join(BIN_DIR, pkg);\n        return fs.join(pkg_dir, filepath);\n    }\n}\n\ninterface TriggerFile {\n    install_exec?: string;\n    uninstall_exec?: string;\n}\n\nexport const triggers = {\n    load_trigger_file: async (fs: UserspaceFileSystem, trigger_name: string): Promise<TriggerFile | null> => {\n        const trigger_path = fs.join(TRIGGER_DIR, trigger_name + \".json\");\n        if (!(await fs.exists(trigger_path))) {\n            return null;\n        }\n\n        const data = await fs.read_file(trigger_path) as string;\n\n        try {\n            return JSON.parse(data) as TriggerFile;\n        } catch (e) {\n            return null;\n        }\n    },\n\n    trigger_exists: async (fs: UserspaceFileSystem, trigger_name: string): Promise<boolean> => {\n        return (await triggers.load_trigger_file(fs, trigger_name)) !== null;\n    },\n\n    // returns boolean indicating if the trigger was found and processed\n    process_install_trigger: async (trigger_name: string, data: unknown, pkg_name: string, pkg_version: string, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\n        const fs = kernel.get_fs();\n\n        const trigger = await triggers.load_trigger_file(fs, trigger_name);\n        if (!trigger) {\n            return false;\n        }\n\n        if (!trigger.install_exec) {\n            // nothing to do\n            return true;\n        }\n\n        const data_str = JSON.stringify(data);\n\n        console.log(`Processing install trigger ${trigger_name} with exec ${trigger.install_exec} and args [${pkg_name}, ${pkg_version}, ${data_str}]`);\n\n        let spawn_result: SpawnResult;\n\n        try {\n            spawn_result =  kernel.spawn(trigger.install_exec, [pkg_name, pkg_version, data_str], shell);\n            const exit_code = await spawn_result.completion;\n            if (exit_code !== 0) {\n                term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} exited with code ${exit_code}.${ANSI.STYLE.reset_all}`);\n            }\n\n            spawn_result.process.kill(exit_code);\n        } catch (e) {\n            term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} failed: ${e}.${ANSI.STYLE.reset_all}`);\n\n            if (spawn_result) {\n                spawn_result.process.kill(-1);\n            }\n        }\n\n        return true;\n    },\n\n    // returns boolean indicating if the trigger was found and processed\n    process_uninstall_trigger: async (trigger_name: string, data: unknown, pkg_name: string, pkg_version: string, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\n        const fs = kernel.get_fs();\n\n        const trigger = await triggers.load_trigger_file(fs, trigger_name);\n        if (!trigger) {\n            return false;\n        }\n\n        if (!trigger.uninstall_exec) {\n            // nothing to do\n            return true;\n        }\n\n        const data_str = JSON.stringify(data);\n\n        console.log(`Processing uninstall trigger ${trigger_name} with exec ${trigger.uninstall_exec} and args [${pkg_name}, ${pkg_version}, ${data_str}]`);\n\n        let spawn_result: SpawnResult;\n\n        try {\n            spawn_result =  kernel.spawn(trigger.uninstall_exec, [pkg_name, pkg_version, data_str], shell);\n            const exit_code = await spawn_result.completion;\n            if (exit_code !== 0) {\n                term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} exited with code ${exit_code}.${ANSI.STYLE.reset_all}`);\n            }\n\n            spawn_result.process.kill(exit_code)\n        } catch (e) {\n            term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} failed: ${e}.${ANSI.STYLE.reset_all}`);\n\n            if (spawn_result) {\n                spawn_result.process.kill(-1);\n            }\n        }\n\n        return true;\n    }\n}\n\n// extract from ANSI to make code less verbose\nconst {STYLE, PREFABS} = ANSI;\n\n// TODO: update command (update all installed or specific packages)\n\nexport default {\n    name: \"pkg\",\n    description: \"The package manager for OllieOS.\",\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\n    arg_descriptions: {\n        \"Subcommands:\": {\n            \"add\": `Installs a list of packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} add <packages...>${STYLE.reset_all}`,\n            \"remove\": `Uninstalls a list of packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} remove <packages...>${STYLE.reset_all}`,\n            \"list\": `Lists all installed packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} list [-t]${STYLE.reset_all}`,\n            \"info\": `Displays information about a package: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} info [-r] <package>${STYLE.reset_all}`,\n            \"read\": `Reads the long description for a package if it has one: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} read [-r] <package>${STYLE.reset_all}`,\n            \"browse\": `Browse the repository for packages and versions: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} browse${STYLE.reset_all}`,\n            \"clean\": `Removes all packages that are not top level and have no dependents (and are therefore unused): ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} clean [-d]${STYLE.reset_all}`,\n        },\n        \"Arguments:\": {\n            \"-h\": \"Displays this help message.\",\n            \"For add:\": {\n                \"packages\": \"The packages to install, separated by spaces. If you wish to install a specific version, use the format 'package@version'.\",\n            },\n            \"For remove:\": {\n                \"packages\": \"The packages to uninstall, separated by spaces.\",\n            },\n            \"For list:\": {\n                \"-t\": \"List only top-level packages.\",\n            },\n            \"For info:\": {\n                \"-r\": \"Always fetch the latest information from the repository.\",\n                \"package\": \"The package to get information about.\",\n            },\n            \"For read:\": {\n                \"-r\": \"Always fetch the latest information from the repository.\",\n                \"package\": \"The package to read the long description of.\",\n            },\n            \"For clean:\": {\n                \"-d\": \"Dry run. Lists the packages that would be removed without actually removing them.\",\n            }\n        }\n    },\n    compat: \"2.0.0\",\n    completion: async (data) => {\n        // TODO: smarter completion that understands flags for subcommands\n        switch (data.arg_index) {\n            case 0:\n                return helper_completion_options([\"add\", \"remove\", \"list\", \"info\", \"read\", \"browse\", \"clean\"])(data);\n            case 1:\n                if ([\"info\", \"read\", \"remove\"].includes(data.args[0])) {\n                    // complete with installed package names\n                    const fs = data.kernel.get_fs();\n\n                    // load graph\n                    let local_graph: { [pkg_name: string]: PkgGraphEntry } = {};\n                    try {\n                        local_graph = JSON.parse(await fs.read_file(\"/var/lib/pkg/graph.json\") as string, json_convert_dep_arrs_to_sets);\n                    } catch (e) {\n                        return [];\n                    }\n\n                    const pkgs = Object.keys(local_graph);\n                    return helper_completion_options(pkgs)(data);\n                }\n                break;\n        }\n\n        return [];\n    },\n    main: async (data) => {\n        // TODO: safety prompt on first use\n\n        // extract from data to make code less verbose\n        const {args, term, kernel, shell} = data;\n        const fs = kernel.get_fs();\n\n        if (args.length === 0) {\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\n            term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        if (args.includes(\"-h\")) {\n            return await kernel.spawn(\"help\", [\"pkg\"], shell).completion;\n        }\n\n        // create /var/lib/pkg if it doesn't exist so subcommands don't have to check\n        if (!(await fs.exists(GRAPH_DIR))) {\n            await fs.make_dir(GRAPH_DIR);\n        }\n\n        // create /var/lib/pkg/graph.json if it doesn't exist\n        if (!(await fs.exists(GRAPH_PATH))) {\n            await fs.write_file(GRAPH_PATH, \"{}\");\n        }\n\n        // create /var/lib/pkg/triggers if it doesn't exist\n        if (!(await fs.exists(TRIGGER_DIR))) {\n            await fs.make_dir(TRIGGER_DIR);\n        }\n\n        // write /var/lib/pkg/triggers/create_trigger.json if it doesn't exist\n        const create_trigger_path = fs.join(TRIGGER_DIR, \"create_trigger.json\");\n        if (!(await fs.exists(create_trigger_path))) {\n            const create_trigger_data: TriggerFile = {\n                install_exec: \"trigger_create_trigger\",\n                uninstall_exec: \"trigger_remove_trigger\"\n            };\n\n            await fs.write_file(create_trigger_path, JSON.stringify(create_trigger_data));\n        }\n\n        // load graph\n        try {\n            graph = JSON.parse(await fs.read_file(\"/var/lib/pkg/graph.json\") as string, json_convert_dep_arrs_to_sets);\n        } catch (e) {\n            term.writeln(`${PREFABS.error}Fatal error: could not load package graph.${STYLE.reset_all}`);\n            return 2;\n        }\n\n        switch (args[0]) {\n            case \"add\":\n                return await add_subcommand(data);\n            case \"remove\":\n                return await remove_subcommand(data);\n            case \"list\":\n                return await list_subcommand(data);\n            case \"info\":\n                return await info_subcommand(data);\n            case \"read\":\n                term.writeln(`${PREFABS.error}Not implemented yet.${STYLE.reset_all}`);\n                break;\n            case \"browse\":\n                return await browse_subcommand(data);\n            case \"clean\":\n                term.writeln(`${PREFABS.error}Not implemented yet.${STYLE.reset_all}`);\n                break;\n            default:\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\n                term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\n                return 1;\n        }\n\n        return 0;\n    }\n} as Program;","import type {Program} from \"../types\";\nimport {ANSI} from \"../kernel/term_ctl\";\n\n// yes, the actual touch command is used to modify access time and has more flags, but this os doesn't have access times and this is meant to be simple\n\nexport default {\n    name: \"touch\",\n    description: \"Creates a file.\",\n    usage_suffix: \"file\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"file\": \"The file to create.\"\n        }\n    },\n    compat: \"2.0.0\",\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const {kernel, args, term} = data;\n\n        // extract from ANSI to make code less verbose\n        const {STYLE, PREFABS} = ANSI;\n\n        // get filesystem\n        const fs = kernel.get_fs();\n\n        // if no arguments, print error\n        if (args.length === 0) {\n            term.writeln(`${PREFABS.error}Missing file operand.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // if more than one argument, print error\n        // TODO: i think this is the only program that checks this, the others drop the extra arguments. do something about this!\n        if (args.length > 1) {\n            term.writeln(`${PREFABS.error}Too many arguments${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // if the file already exists, do nothing\n        const file = args[0];\n        const absolute_file = fs.absolute(file);\n\n        if (await fs.exists(absolute_file)) {\n            return 0;\n        }\n\n        // check if the directory exists\n        // TODO: should abstractfilesystem have basename and dirname functions? check other programs for similar code!\n        const dir = absolute_file.split(\"/\").slice(0, -1).join(\"/\");\n        if (!(await fs.dir_exists(dir))) {\n            term.writeln(`${PREFABS.error}No such directory: ${dir}${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // create the file\n        await fs.write_file(absolute_file, \"\");\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport {ANSI} from \"../kernel/term_ctl\";\n\nexport default {\n    name: \"mkdir\",\n    description: \"Creates a directory.\",\n    usage_suffix: \"[-p] directory\",\n    arg_descriptions: {\n        \"Flags:\": {\n            \"-p\": \"Create parent directories (recursive) if they don't exist.\"\n        },\n        \"Arguments:\": {\n            \"directory\": \"The directory to create.\"\n        }\n    },\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { PREFABS, STYLE } = ANSI;\n\n        // get fs\n        const fs = kernel.get_fs();\n\n\n        // check if -p flag was passed\n        let recursive = false;\n        if (args[0] === \"-p\") {\n            recursive = true;\n            args.shift();\n        }\n\n        // check if there is only one argument after parsing flag\n        if (args.length !== 1) {\n            term.writeln(`${PREFABS.error}Invalid arguments.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // get directory\n        const dir = args[0];\n        const abs_dir = fs.absolute(dir);\n\n        // check if directory already exists\n        if (await fs.dir_exists(abs_dir)) {\n            return 0;\n        }\n\n        // create directory\n        // make_dir is recursive by default, so just check the directories exist already if NOT recursive\n        if (recursive) {\n            await fs.make_dir(abs_dir);\n        } else {\n            // check if the directory exists\n            const parent = abs_dir.split(\"/\").slice(0, -1).join(\"/\");\n            if (!(await fs.dir_exists(parent))) {\n                term.writeln(`${PREFABS.error}No such directory: ${parent}${STYLE.reset_all}`);\n                return 1;\n            }\n\n            await fs.make_dir(abs_dir);\n        }\n\n        return 0;\n    }\n} as Program;\n","import type { Program } from \"../types\";\nimport { ANSI } from \"../kernel/term_ctl\";\n\nexport default {\n    name: \"mv\",\n    description: \"Moves files and directories.\",\n    usage_suffix: \"[-n] source destination\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"source\": \"The file or directory to move.\",\n            \"destination\": \"The new location for the file or directory.\",\n            \"-n\": \"Do not overwrite an existing file.\"\n        }\n    },\n    compat: \"2.0.0\",\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { PREFABS, STYLE } = ANSI;\n\n        // get fs\n        const fs = kernel.get_fs();\n\n        // check for -n\n        let no_overwrite = false;\n        //if (args.includes(\"-n\")) {\n            // TODO: why do programs care about flag order? should they?\n            //// remove -n from args\n            //args.splice(args.indexOf(\"-n\"), 1);\n        if (args[0] === \"-n\") {\n            no_overwrite = true;\n            args.shift();\n        }\n\n        // get source and destination\n        const source = fs.absolute(args[0]);\n        const raw_destination = args[1];\n        const ended_with_slash = raw_destination.endsWith(\"/\");\n        let destination = fs.absolute(raw_destination);\n\n        // check if source exists\n        if (!(await fs.exists(source))) {\n            term.writeln(`${PREFABS.error}No such file or directory: ${source}${STYLE.reset_all}`);\n            return 1;\n        }\n\n        const dest_is_dir = await fs.dir_exists(destination);\n\n        // now handled by move_dir implementation\n        // // if destination is a directory and ending with a slash, append the basename of source to destination\n        // if (dest_is_dir && ended_with_slash) {\n        //     const basename = source.split(\"/\").pop() as string;\n        //     destination = fs.join(destination, basename);\n        // }\n\n        // check if destination exists if -n is passed OR we are moving a FILE (not a directory) into a DIRECTORY ending specifically with /\n        // TODO: there must be a way to adjust logic of the fs functions to make this check unnecessary or simpler. oh well.\n        const do_exists_check = no_overwrite || (dest_is_dir && !(await fs.dir_exists(source)) && ended_with_slash);\n        if (do_exists_check && await fs.exists(destination)) {\n            term.writeln(`${PREFABS.error}File or directory already exists: ${destination}${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // move source to destination\n        // TODO: abstractfilesystem should have a file_exists function so we don't have to check if it's a directory first\n        if (await fs.dir_exists(source)) {\n            // force move inside if ended with slash\n            try {\n                await fs.move_dir(source, destination, ended_with_slash);\n            } catch (e) {\n                term.writeln(`${PREFABS.error}Error moving directory: ${(e as Error).message}${STYLE.reset_all}`);\n                return 1;\n            }\n        } else if (await fs.exists(source)) {\n            await fs.move_file(source, destination);\n        } else {\n            term.writeln(`${PREFABS.error}Source is neither a file nor a directory: ${source}${STYLE.reset_all}`);\n            return 1;\n        }\n\n        return 0;\n    }\n} as Program;\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\nimport { ProgramMainData } from \"../../types\"\n\n// extract from ANSI to make code less verbose\nconst { STYLE, FG } = ANSI;\nexport const info_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const { args, term, kernel } = data;\n\n    // remove subcommand name\n    args.shift();\n\n    term.write(NEWLINE);\n\n    const wm = kernel.get_window_manager();\n    const all_windows = wm!.get_all_windows();\n    const visible_windows = all_windows.filter(w => w.visible).length;\n\n    term.writeln(`Window manager: ${FG.cyan}${wm!.get_unique_manager_type_name()}${STYLE.reset_all}`);\n    term.writeln(`Total open windows: ${FG.cyan}${all_windows.length}${STYLE.reset_all}`);\n    term.writeln(`Visible windows: ${FG.cyan}${visible_windows}${STYLE.reset_all}`);\n    term.writeln(`Invisible windows: ${FG.cyan}${all_windows.length - visible_windows}${STYLE.reset_all}`);\n\n    return 0;\n}\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\nimport { ProgramMainData } from \"../../types\"\n\n// extract from ANSI to make code less verbose\nconst { STYLE, FG } = ANSI;\nexport const list_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const { args, term, kernel } = data;\n\n    // remove subcommand name\n    args.shift();\n\n    // check for presence of -v or -i flag\n    let only_visible = false;\n    let only_invisible = false;\n    if (args[0] === \"-v\") {\n        only_visible = true;\n        args.shift();\n    } else if (args[0] === \"-i\") {\n        only_invisible = true;\n        args.shift();\n    }\n\n    term.write(NEWLINE);\n\n    const wm = kernel.get_window_manager();\n    const all_windows = wm!.get_all_windows();\n    for (const win of all_windows) {\n        if (only_visible && !win.visible) {\n            continue;\n        }\n\n        if (only_invisible && win.visible) {\n            continue;\n        }\n\n        // TODO: source process tracking to show which program opened the window\n        const visibility_text = win.visible ? `${FG.green}Visible${STYLE.reset_all}` : `${FG.red}Invisible${STYLE.reset_all}`;\n        term.writeln(`- [${win.id}] ${FG.cyan}${win.title}${STYLE.reset_all} : ${visibility_text} owned by PID ${FG.yellow}${win.owner_pid}${STYLE.reset_all}`);\n    }\n\n    return 0;\n}\n","import {ANSI} from \"../../kernel/term_ctl\";\nimport { ProgramMainData } from \"../../types\"\n\n// extract from ANSI to make code less verbose\nconst { STYLE, FG, PREFABS } = ANSI;\nexport const show_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const { args, term, kernel: userspace_kernel } = data;\n\n    // remove subcommand name\n    args.shift();\n\n    // get the window id to show\n    if (args.length === 0) {\n        term.writeln(`${PREFABS.error}Missing window ID.`)\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    const window_id = parseInt(args[0], 10);\n    if (isNaN(window_id)) {\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // check window exists first with userspace kernel\n    const userspace_wm = userspace_kernel.get_window_manager();\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\n    if (!userspace_window) {\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // request elevation\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to show a window.\");\n    if (!kernel) {\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    const wm = kernel.get_window_manager();\n    const wind = wm!.get_window_by_id(window_id);\n\n    // check again for safety\n    if (!wind) {\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    if (wind.visible) {\n        term.writeln(`Window with ID ${FG.cyan}${window_id}${STYLE.reset_all} is already visible.${STYLE.reset_all}`);\n        return 2;\n    }\n\n    term.writeln(`Showing window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\n    wind.show();\n\n    return 0;\n}\n","import {ANSI} from \"../../kernel/term_ctl\";\nimport { ProgramMainData } from \"../../types\"\n\n// extract from ANSI to make code less verbose\nconst { STYLE, FG, PREFABS } = ANSI;\nexport const hide_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const { args, term, kernel: userspace_kernel } = data;\n\n    // remove subcommand name\n    args.shift();\n\n    // get the window id to hide\n    if (args.length === 0) {\n        term.writeln(`${PREFABS.error}Missing window ID.`)\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    const window_id = parseInt(args[0], 10);\n    if (isNaN(window_id)) {\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // check window exists first with userspace kernel\n    const userspace_wm = userspace_kernel.get_window_manager();\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\n    if (!userspace_window) {\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // request elevation\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to hide a window.\");\n    if (!kernel) {\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    const wm = kernel.get_window_manager();\n    const wind = wm!.get_window_by_id(window_id);\n\n    // check again for safety\n    if (!wind) {\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    if (!wind.visible) {\n        term.writeln(`Window with ID ${FG.cyan}${window_id}${STYLE.reset_all} is already hidden.${STYLE.reset_all}`);\n        return 2;\n    }\n\n    term.writeln(`Hiding window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\n    wind.hide();\n\n    return 0;\n}\n","import {ANSI} from \"../../kernel/term_ctl\";\nimport { ProgramMainData } from \"../../types\"\n\n// extract from ANSI to make code less verbose\nconst { STYLE, FG, PREFABS } = ANSI;\nexport const close_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const { args, term, kernel: userspace_kernel } = data;\n\n    // remove subcommand name\n    args.shift();\n\n    // get the window id to close\n    if (args.length === 0) {\n        term.writeln(`${PREFABS.error}Missing window ID.`)\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    const window_id = parseInt(args[0], 10);\n    if (isNaN(window_id)) {\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // check window exists first with userspace kernel\n    const userspace_wm = userspace_kernel.get_window_manager();\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\n    if (!userspace_window) {\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // request elevation\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to close a window.\");\n    if (!kernel) {\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    const wm = kernel.get_window_manager();\n    const wind = wm!.get_window_by_id(window_id);\n\n    // check again for safety\n    if (!wind) {\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    term.writeln(`Closing window with ID ${FG.cyan}${window_id}${STYLE.reset_all}. The process that opened this window may still be running.`);\n    wind.close();\n\n    return 0;\n}\n","import {ANSI} from \"../../kernel/term_ctl\";\nimport { ProgramMainData } from \"../../types\"\nimport {Kernel} from \"../../kernel\";\n\n// extract from ANSI to make code less verbose\nconst { STYLE, FG, PREFABS } = ANSI;\nexport const center_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const { args, term, kernel: userspace_kernel } = data;\n\n    // remove subcommand name\n    args.shift();\n\n    // get the window id to center\n    if (args.length === 0) {\n        term.writeln(`${PREFABS.error}Missing window ID.`)\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    const window_id = parseInt(args[0], 10);\n    if (isNaN(window_id)) {\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // check window exists first with userspace kernel\n    const userspace_wm = userspace_kernel.get_window_manager();\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\n    if (!userspace_window) {\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // request elevation\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to center a window.\");\n    if (!kernel) {\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    const wm = kernel.get_window_manager();\n    const wind = wm!.get_window_by_id(window_id);\n\n    // check again for safety\n    if (!wind) {\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    term.writeln(`Centering window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\n    wind.center();\n\n    return 0;\n}\n","import {ANSI} from \"../../kernel/term_ctl\";\nimport type {Program} from \"../../types\";\n\nimport {info_subcommand} from \"./info\";\nimport {list_subcommand} from \"./list\";\nimport {show_subcommand} from \"./show\";\nimport {hide_subcommand} from \"./hide\";\nimport {close_subcommand} from \"./close\";\nimport {center_subcommand} from \"./center\";\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\n\n// extract from ANSI to make code less verbose\nconst {STYLE, PREFABS} = ANSI;\n\n// TODO: maximise restore command, respecting maximisable property but providing a -f force flag\n\nexport default {\n    name: \"window\",\n    description: \"Interact with program windows.\",\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\n    arg_descriptions: {\n        \"Subcommands:\": {\n            \"info\": `Displays information about the window manager and open windows: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} info${STYLE.reset_all}`,\n            \"list\": `Lists all open windows: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} list [-vi]${STYLE.reset_all}`,\n            \"show\": `Shows a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} show <window_id>${STYLE.reset_all}`,\n            \"hide\": `Hides a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} hide <window_id>${STYLE.reset_all}`,\n            \"close\": `Closes a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} close <window_id>${STYLE.reset_all}. Note that this does not terminate the process that opened the window.`,\n            \"center\": `Centers a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} show <window_id>${STYLE.reset_all}`,\n        },\n        \"Arguments:\": {\n            \"-h\": \"Displays this help message.\",\n            \"For list:\": {\n                \"-v\": \"List only visible windows.\",\n                \"-i\": \"List only invisible (minimised/hidden) windows.\",\n            },\n            \"For show, hide, close, and center:\": {\n                \"<window_id>\": \"The ID of the window.\",\n            }\n        }\n    },\n    compat: \"2.0.0\",\n    completion: async (data) => {\n        switch (data.arg_index) {\n            case 0:\n                return helper_completion_options([\"info\", \"list\", \"show\", \"hide\", \"close\", \"center\"])(data);\n            case 1:\n                // completing first argument of subcommand\n                if (data.raw_parts[1] === \"list\") {\n                    return helper_completion_options([\"-v\", \"-i\"])(data);\n                } else if ([\"show\", \"hide\", \"close\", \"center\"].includes(data.raw_parts[1])) {\n                    // complete window ids\n                    const wm = data.kernel.get_window_manager();\n                    if (!wm) {\n                        return [];\n                    }\n\n                    const window_ids = wm.get_all_windows().map((win) => win.id.toString());\n                    return helper_completion_options(window_ids)(data);\n                }\n                return [];\n            default:\n                return [];\n        }\n    },\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const {args, term, kernel, shell} = data;\n\n        if (args.length === 0) {\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\n            term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        if (args.includes(\"-h\")) {\n            return await kernel.spawn(\"help\", [\"window\"], shell).completion;\n        }\n\n        if (!kernel.has_window_manager()) {\n            term.writeln(`${PREFABS.error}No window manager found.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        switch (args[0]) {\n            case \"info\":\n                return await info_subcommand(data);\n            case \"list\":\n                return await list_subcommand(data);\n            case \"show\":\n                return await show_subcommand(data);\n            case \"hide\":\n                return await hide_subcommand(data);\n            case \"close\":\n                return await close_subcommand(data);\n            case \"center\":\n                return await center_subcommand(data);\n            default:\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\n                term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\n                return 1;\n        }\n    }\n} as Program;\n","import type { Program } from \"../types\";\n\nexport default {\n    name: \"alias\",\n    description: \"Define or display aliases. (Use .ollierc to persist aliases)\",\n    usage_suffix: \"[name[=value] ...]\",\n    arg_descriptions: {\n        name: \"The name of the alias to define or display. If no arguments are given, all aliases are displayed. Multiple alias arguments can be provided.\",\n        \"name=value\": \"Defines an alias with the given name and value. End the value with a space to allow chaining.\"\n    },\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { shell, term } = data;\n\n        if (!shell) {\n            term.writeln(\"No shell available\");\n            return 1;\n        }\n\n        // TODO: move to shell builtin, not actual program\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS } = term.ansi;\n\n        if (data.args.length === 0) {\n            // display all aliases\n            const aliases = shell.memory.list_aliases();\n            for (const [name, value] of aliases.entries()) {\n                term.writeln(`alias ${name}='${value}'`);\n            }\n\n            return 0;\n        }\n\n        for (const arg of data.args) {\n            if (arg.includes(\"=\")) {\n                // define alias\n                const [name, ...value_parts] = arg.split(\"=\");\n                const value = value_parts.join(\"=\");\n\n                // remove surrounding quotes if present\n                let final_value = value;\n                if ((final_value.startsWith(\"'\") && final_value.endsWith(\"'\")) ||\n                    (final_value.startsWith(\"\\\"\") && final_value.endsWith(\"\\\"\"))) {\n                    final_value = final_value.slice(1, -1);\n                }\n\n                shell.memory.set_alias(name, final_value);\n            } else {\n                // display alias\n                const value = shell.memory.get_alias(arg);\n                if (value) {\n                    term.writeln(`alias ${arg}='${value}'`);\n                } else {\n                    term.writeln(`${PREFABS.error}alias: ${arg}: not found${STYLE.reset_all}`);\n                }\n            }\n        }\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\n\nexport default {\n    name: \"unalias\",\n    description: \"Remove defined aliases.\",\n    usage_suffix: \"name [name ...]\",\n    arg_descriptions: {\n        name: \"The name of the alias to remove. Multiple alias names can be provided.\"\n    },\n    compat: \"2.0.0\",\n    completion: async (data) => {\n        if (!data.shell) {\n            return [];\n        }\n\n        const alias_names = [...data.shell.memory.list_aliases().keys()];\n        // TODO: check type to see why helper_completion_options wont work here\n        return alias_names.filter(name => name.startsWith(data.current_partial));\n    },\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { shell, term } = data;\n\n        if (!shell) {\n            term.writeln(\"No shell available\");\n            return 1;\n        }\n\n        // TODO: move to shell builtin, not actual program\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS } = term.ansi;\n\n        if (data.args.length === 0) {\n            term.writeln(`${PREFABS.error}unalias: usage: unalias name [name ...]${STYLE.reset_all}`);\n            return 1;\n        }\n\n        for (const arg of data.args) {\n            const success = shell.memory.unset_alias(arg);\n            if (!success) {\n                term.writeln(`${PREFABS.error}unalias: ${arg}: not found${STYLE.reset_all}`);\n            }\n        }\n\n        return 0;\n    }\n} as Program;","import {ANSI, NEWLINE} from \"../kernel/term_ctl\";\nimport type { Program } from \"../types\";\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\n\nexport default {\n    name: \"ps\",\n    description: \"Display currently running processes.\",\n    usage_suffix: \"[-p PID]\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"-p PID\": \"Display information about the process with the given PID. If omitted, displays all running processes.\"\n        }\n    },\n    compat: \"2.0.0\",\n    completion: async (data) => {\n        console.log(data);\n        if (data.arg_index === 0) {\n            return helper_completion_options([\"-p\"])(data);\n        } else if (data.arg_index === 1 && data.args[0] === \"-p\") {\n            const pm = data.kernel.get_process_manager();\n            const pids = pm.list_pids().map((pid) => pid.toString());\n            return helper_completion_options(pids)(data);\n        }\n\n        return [];\n    },\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS } = ANSI;\n\n        // get process manager\n        const pm = kernel.get_process_manager();\n\n        if (data.args[0] === \"-p\") {\n            const pid = parseInt(data.args[1]);\n            if (isNaN(pid)) {\n                term.writeln(`${PREFABS.error}Invalid PID provided.${STYLE.reset_all}`);\n                return 1;\n            }\n\n            const process = pm.get_process(pid);\n            if (!process) {\n                term.writeln(`${PREFABS.error}No process found with PID ${pid}.${STYLE.reset_all}`);\n                return 1;\n            }\n\n            term.write(NEWLINE);\n            term.writeln(`${STYLE.bold}PID:${STYLE.no_bold_or_dim} ${process.pid}${STYLE.reset_all}`);\n            term.writeln(`${STYLE.bold}Command:${STYLE.no_bold_or_dim} ${process.source_command.command}${STYLE.reset_all}`);\n            term.writeln(`${STYLE.bold}Created:${STYLE.no_bold_or_dim} ${process.created_at.toLocaleString()}${STYLE.reset_all}`);\n\n            return 0;\n        }\n\n        const pids = pm.list_pids();\n\n        // get longest source command length for formatting\n        let longest_command_length = 7 // length of \"COMMAND\"\n        for (const pid of pids) {\n            const process = pm.get_process(pid)!;\n            if (process.source_command.command.length > longest_command_length) {\n                longest_command_length = process.source_command.command.length;\n            }\n        }\n\n        const get_command_space = (subtract = 0) => \" \".repeat(longest_command_length - subtract);\n\n        term.write(NEWLINE);\n        term.writeln(`${STYLE.bold}PID\\tCOMMAND${get_command_space(7)}\\t\\tCREATED${STYLE.reset_all}`);\n        for (const pid of pids) {\n            const process = pm.get_process(pid)!;\n            term.writeln(`${pid}\\t${process.source_command.command}${get_command_space(process.source_command.command.length)}\\t\\t${process.created_at.toLocaleString()}`);\n        }\n\n        return 0;\n    }\n} as Program;\n","import {ANSI} from \"../kernel/term_ctl\";\nimport type { Program } from \"../types\";\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\n\nexport default {\n    name: \"kill\",\n    description: \"Kill a process by its PID.\",\n    usage_suffix: \"PID\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"PID\": \"The PID of the process to kill.\"\n        }\n    },\n    compat: \"2.0.0\",\n    completion: async (data) => {\n        if (data.arg_index === 0) {\n            const pm = data.kernel.get_process_manager();\n            const pids = pm.list_pids().map((pid) => pid.toString());\n            return helper_completion_options(pids)(data);\n        }\n\n        return [];\n    },\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, term } = data;\n\n        // extract from ANSI to make code less verbose\n        const { STYLE, PREFABS } = ANSI;\n\n        if (data.args.length !== 1) {\n            term.writeln(`${PREFABS.error}Exactly one argument (PID) expected.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        // TODO: support more kill signals as arguments\n\n        // get process manager\n        const pm = kernel.get_process_manager();\n        const pid = parseInt(data.args[0]);\n\n        if (isNaN(pid)) {\n            term.writeln(`${PREFABS.error}Invalid PID provided.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        pm.kill(pid, 143); // SIGTERM\n        return 0;\n    }\n} as Program;\n\n// TODO: move this to be literal SIGTERM and SIGKILL signals sent to processes\n","import {ANSI, NEWLINE} from \"../../kernel/term_ctl\";\nimport {ProgramMainData} from \"../../types\"\n\nimport type {IgnitionIPCReply} from \"../core/ignition\";\nimport type {ServiceStatus} from \"../core/ignition/services\";\n\n// extract from ANSI to make code less verbose\nconst {STYLE, FG, PREFABS} = ANSI;\n\nexport const service_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const {args, term, process, kernel} = data;\n\n    // remove subcommand name\n    args.shift();\n\n    if (args.length === 0) {\n        term.writeln(`${PREFABS.error}Missing action.`);\n        term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    if (args.length === 1) {\n        term.writeln(`${PREFABS.error}Missing service ID.`);\n        term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    const action = args[0];\n    const service_id = args[1];\n\n    // open ipc with ignition\n    const ipc = kernel.get_ipc();\n    const channel_id = ipc.create_channel(\"init\");\n\n    if (!channel_id) {\n        term.writeln(`${PREFABS.error}Failed to communicate with ignition.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    // function can be defined to handle response data, string responses and errors handled by default\n    let on_data: (msg_data: unknown) => void;\n    let reply_timeout: number;\n    let return_code = 0;\n\n    // listen for replies\n    ipc.channel_listen(channel_id, async (msg) => {\n        const payload = msg.data as IgnitionIPCReply;\n\n        if (payload.type === \"data\") {\n            if (on_data) {\n                on_data(payload.data);\n            } else {\n                term.writeln(`${FG.yellow}Warning: Unhandled data response: ${JSON.stringify(payload.data)}${STYLE.reset_all}`);\n            }\n        } else if (payload.type === \"response\") {\n            term.writeln(`${FG.green}${payload.message}${STYLE.reset_all}`);\n        } else if (payload.type === \"error\") {\n            term.writeln(`${PREFABS.error}${payload.message}${STYLE.reset_all}`);\n            return_code = 1;\n        }\n\n        if (reply_timeout) {\n            process.cancel_timeout(reply_timeout);\n        }\n    });\n\n    if (action === \"status\") {\n        // special handler for status data\n        on_data = (msg_data: unknown) => {\n            const status = msg_data as ServiceStatus;\n\n            term.write(NEWLINE);\n            term.writeln(`${FG.cyan}Service ID:${STYLE.reset_all} ${service_id}`);\n\n            term.write(`${FG.cyan}Status: ${STYLE.reset_all}`);\n            switch (status.state) {\n                case \"running\":\n                    term.writeln(`${FG.green}Running${STYLE.reset_all}`);\n                    term.writeln(`${FG.cyan}PID:${STYLE.reset_all} ${status.pid}`);\n                    break;\n                case \"stopped\":\n                    term.writeln(`${FG.yellow}Stopped${STYLE.reset_all}`);\n                    break;\n                case \"failed\":\n                    term.writeln(`${FG.red}Failed${STYLE.reset_all}`);\n                    break;\n            }\n        }\n    }\n\n    // wait up to 3 seconds for a reply before erroring\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    reply_timeout = process.create_timeout(() => {}, 3000);\n\n    // can just send the action and service id directly rather than needing additional checking as the action matches the ipc action names\n    ipc.channel_send(channel_id, {\n        type: \"service\",\n        action,\n        service_id\n    });\n\n    if (!process.has_timeout(reply_timeout)) {\n        // timeout already cleared, meaning we got a response\n        return return_code;\n    }\n\n    const got_no_reply = await process.wait_for_timeout(reply_timeout);\n\n    if (got_no_reply) {\n        term.writeln(`${PREFABS.error}No response from ignition.${STYLE.reset_all}`);\n        return 2;\n    }\n\n    // TODO: all this logic is kinda jank, trying to be too clever with timeouts and async ipc\n\n    return return_code;\n}\n","import {ANSI} from \"../../kernel/term_ctl\";\nimport {ProgramMainData} from \"../../types\"\n\nimport type {IgnitionIPCReply} from \"../core/ignition\";\n\n// extract from ANSI to make code less verbose\nconst {STYLE, FG, PREFABS} = ANSI;\n\nexport const reload_services_subcommand = async (data: ProgramMainData) => {\n    // extract from data to make code less verbose\n    const {args, term, process, kernel} = data;\n\n    // remove subcommand name\n    args.shift();\n\n    // TODO: make function to do this back and forth with ignition rather than duplicating code for each subcommand\n\n    // open ipc with ignition\n    const ipc = kernel.get_ipc();\n    const channel_id = ipc.create_channel(\"init\");\n\n    if (!channel_id) {\n        term.writeln(`${PREFABS.error}Failed to communicate with ignition.${STYLE.reset_all}`);\n        return 1;\n    }\n\n    let reply_timeout: number;\n    let return_code = 0;\n\n    // listen for replies\n    ipc.channel_listen(channel_id, async (msg) => {\n        const payload = msg.data as IgnitionIPCReply;\n\n        if (payload.type === \"response\") {\n            term.writeln(`${FG.green}${payload.message}${STYLE.reset_all}`);\n        } else if (payload.type === \"error\") {\n            term.writeln(`${PREFABS.error}${payload.message}${STYLE.reset_all}`);\n            return_code = 1;\n        }\n\n        if (reply_timeout) {\n            process.cancel_timeout(reply_timeout);\n        }\n    });\n\n    // wait up to 3 seconds for a reply before erroring\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    reply_timeout = process.create_timeout(() => {}, 3000);\n\n    ipc.channel_send(channel_id, {\n        type: \"reload_services\"\n    });\n\n    if (!process.has_timeout(reply_timeout)) {\n        // timeout already cleared, meaning we got a response\n        return return_code;\n    }\n\n    const got_no_reply = await process.wait_for_timeout(reply_timeout);\n\n    if (got_no_reply) {\n        term.writeln(`${PREFABS.error}No response from ignition.${STYLE.reset_all}`);\n        return 2;\n    }\n\n    // TODO: all this logic is kinda jank, trying to be too clever with timeouts and async ipc\n\n    return return_code;\n}\n","import {ANSI} from \"../../kernel/term_ctl\";\nimport type {Program} from \"../../types\";\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\n\nimport {service_subcommand} from \"./service\";\nimport {reload_services_subcommand} from \"./reload_services\";\n\n// extract from ANSI to make code less verbose\nconst {STYLE, PREFABS} = ANSI;\n\n\nexport default {\n    name: \"spark\",\n    description: \"Manage your system with ignition.\",\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\n    arg_descriptions: {\n        \"Subcommands:\": {\n            \"service\": \"Manage running services.\",\n            \"reload-services\": \"Reload the service definition files.\",\n        },\n        \"Arguments:\": {\n            \"-h\": \"Displays this help message.\",\n            \"For service:\": {\n                \"action\": \"The action to perform (start, stop, restart, status).\",\n                \"service_id\": \"The ID of the service to manage.\",\n            },\n        }\n    },\n    compat: \"2.0.0\",\n    completion: async (data) => {\n        // TODO: smarter completion that understands flags for subcommands\n        switch (data.arg_index) {\n            case 0:\n                return helper_completion_options([\"service\"])(data);\n        }\n\n        return [];\n    },\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const {args, term, kernel, shell} = data;\n\n        if (args.length === 0) {\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\n            term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\n            return 1;\n        }\n\n        if (args.includes(\"-h\")) {\n            return await kernel.spawn(\"help\", [\"spark\"], shell).completion;\n        }\n\n        switch (args[0]) {\n            case \"service\":\n                return await service_subcommand(data);\n            case \"reload-services\":\n                return await reload_services_subcommand(data);\n            default:\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\n                term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\n                return 1;\n        }\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\n\nexport default {\n    name: \"ipc_bg_test\",\n    description: \"\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    hide_from_help: true,\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, term, process } = data;\n\n        process.detach();\n\n        const ipc = kernel.get_ipc();\n        ipc.service_register(\"ipc_bg_test\", async (channel_id, from_pid) => {\n            ipc.channel_listen(channel_id, async (msg) => {\n                term.writeln(`Received message on channel ${channel_id} from PID ${msg.from}: ${JSON.stringify(msg.data)}`);\n            });\n        });\n\n        term.writeln(\"ipc_bg_test service started and listening for messages.\");\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\n\nexport default {\n    name: \"ipc_fg_test\",\n    description: \"\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    hide_from_help: true,\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, term } = data;\n\n        const ipc = kernel.get_ipc();\n        const channel = ipc.create_channel(\"ipc_bg_test\");\n        \n        if (!channel) {\n            term.writeln(\"Failed to create IPC channel to service 'ipc_bg_test'.\");\n            return 1;\n        }\n\n        ipc.channel_send(channel, { message: \"Hello from ipc_fg_test!\" });\n\n        return 0;\n    }\n} as Program;","import type { Program } from \"../types\";\n\nexport default {\n    name: \"taskbar_test\",\n    description: \"\",\n    usage_suffix: \"\",\n    arg_descriptions: {},\n    compat: \"2.0.0\",\n    hide_from_help: true,\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, term, process, shell } = data;\n\n        if (!kernel.has_window_manager()) {\n            term.writeln(\"This program requires a window manager.\");\n            return 1;\n        }\n\n        const wind = process.create_window();\n\n        wind.title = \"Taskbar\";\n\n        wind.set_custom_flag(\"no-top-bar\", true);\n\n        wind.x = \"0vw\";\n        wind.y = \"92.5vh\";\n\n        wind.height = \"7.5vh\";\n        wind.width = \"100vw\";\n\n        const buttons = document.createElement(\"div\");\n        buttons.style.display = \"flex\";\n        buttons.style.height = \"100%\";\n        buttons.style.alignItems = \"center\";\n        buttons.style.gap = \"1vh\";\n        buttons.style.padding = \"0 1vh\";\n\n        wind.dom.appendChild(buttons);\n\n        const fsedit_button = document.createElement(\"button\");\n        fsedit_button.innerText = \"FSEdit\";\n        fsedit_button.style.height = \"100%\";\n        fsedit_button.style.fontSize = \"2vh\";\n        fsedit_button.onclick = () => {\n            kernel.spawn(\"fsedit\", [], shell);\n        };\n\n        buttons.appendChild(fsedit_button);\n\n        // if minecraft is installed, add a button for it\n        const prog_reg = kernel.get_program_registry();\n        if (prog_reg.getProgram(\"minecraft\")) {\n            const mc_button = document.createElement(\"button\");\n            mc_button.style.height = \"100%\";\n            mc_button.style.fontSize = \"2vh\";\n            mc_button.onclick = () => {\n                kernel.spawn(\"minecraft\", [], shell);\n            };\n\n            const mc_image = document.createElement(\"img\");\n            mc_image.src = \"https://brandlogos.net/wp-content/uploads/2022/07/minecraft-logo_brandlogos.net_faqdi-512x560.png\";\n            mc_image.style.height = \"100%\";\n            mc_image.style.objectFit = \"contain\";\n            mc_image.alt = \"Minecraft\";\n            mc_image.draggable = false;\n            mc_button.appendChild(mc_image);\n\n            buttons.appendChild(mc_button);\n        }\n\n        wind.show();\n\n        process.detach();\n        return 0;\n    }\n} as Program;","import type { Program } from \"../../../types\";\n\nexport default {\n    name: \"trigger_create_trigger\",\n    description: \"A trigger to create another trigger. Use this trigger to deploy custom triggers!\",\n    usage_suffix: \"pkg_name pkg_version trigger_file\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"pkg_name\": \"The name of the package creating the trigger, which will namespace the trigger. Passed automatically by the package manager.\",\n            \"pkg_version\": \"Ignored. Passed automatically by the package manager.\",\n            \"trigger_file\": \"The path to the trigger file to create. This is the string that you pass into the create_trigger trigger in your package's meta.json triggers section.\"\n        }\n    },\n    hide_from_help: true,\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term } = data;\n\n        if (args.length !== 3) {\n            term.writeln(\"Usage: trigger_create_trigger pkg_name pkg_version trigger_file\");\n            return 1;\n        }\n\n        const fs = kernel.get_fs();\n\n        const pkg_name = args[0];\n        const trigger_file = JSON.parse(args[2]);\n\n        // trigger must end with .json\n        if (!trigger_file.endsWith(\".json\")) {\n            term.writeln(\"Error: Trigger file must end with .json\");\n            return 1;\n        }\n\n        // source path will be /usr/bin/PKG_NAME/TRIGGER_FILE\n        const source_path = fs.join(\"/usr/bin\", pkg_name, trigger_file);\n\n        // check the path is valid\n        if (!await fs.exists(source_path)) {\n            term.writeln(`Error: Trigger file not found at ${source_path}`);\n            return 1;\n        }\n\n        // destination path will be /var/lib/pkg/triggers/PKG_NAME/TRIGGER_FILE\n        const dest_path = fs.join(\"/var/lib/pkg/triggers\", pkg_name, trigger_file);\n\n        // check the destination path does not already exist\n        if (await fs.exists(dest_path)) {\n            term.writeln(`Error: Trigger file already exists at ${dest_path}.`);\n            return 1;\n        }\n\n        // copy the trigger file to the destination\n        // TODO: make fs support copy operation\n        const content = await fs.read_file(source_path);\n        await fs.write_file(dest_path, content);\n\n        term.writeln(`Trigger created at ${dest_path}`);\n\n        return 0;\n    }\n} as Program;\n\n// TODO: way to pass trigger data as json and identify it. then a way to pass just program name to use as both create and remove trigger?\n","import type { Program } from \"../../../types\";\n\nexport default {\n    name: \"trigger_remove_trigger\",\n    description: \"A trigger to remove a trigger.\",\n    usage_suffix: \"pkg_name pkg_version trigger_file\",\n    arg_descriptions: {\n        \"Arguments:\": {\n            \"pkg_name\": \"The name of the package that created the trigger, which is used to namespace the trigger. Passed automatically by the package manager.\",\n            \"pkg_version\": \"Ignored. Passed automatically by the package manager.\",\n            \"trigger_file\": \"The path to the trigger file to remove. This is the string that you pass into the create_trigger trigger in your package's meta.json triggers section.\"\n        }\n    },\n    hide_from_help: true,\n    compat: \"2.0.0\",\n    completion: async () => [],\n    main: async (data) => {\n        // extract from data to make code less verbose\n        const { kernel, args, term } = data;\n\n        if (args.length !== 3) {\n            term.writeln(\"Usage: trigger_remove_trigger pkg_name pkg_version trigger_file\");\n            return 1;\n        }\n\n        const fs = kernel.get_fs();\n\n        const pkg_name = args[0];\n        const trigger_file = JSON.parse(args[2]);\n\n        // trigger must end with .json\n        if (!trigger_file.endsWith(\".json\")) {\n            term.writeln(\"Error: Trigger file must end with .json\");\n            return 1;\n        }\n\n        // destination path will be /var/lib/pkg/triggers/PKG_NAME/TRIGGER_FILE\n        const dest_path = fs.join(\"/var/lib/pkg/triggers\", pkg_name, trigger_file);\n\n        // check the destination path exists\n        if (!await fs.exists(dest_path)) {\n            return 0;\n        }\n\n        // remove the trigger file\n        await fs.delete_file(dest_path);\n\n        term.writeln(`Trigger removed from ${dest_path}`);\n\n        return 0;\n    }\n} as Program;\n\n// TODO: should triggers support using the same program as the uninstall trigger, an just passing different arguments?\n","import { AbstractFileSystem, FSEventType, NonRecursiveDirectoryError, PathNotFoundError } from \"../kernel/filesystem\";\n\n// TODO: may get laggy with large files and many files or dirs\n// NOTE: not using implements (TS) so the real methods can be used\n// indexeddb fs is superior\n// TODO: unsolveable prototype pollution without banning filenames. tried using map, but recursive traversal wont work as the instances are distinct (not writing to the original state dict)\nexport class LocalStorageFS extends AbstractFileSystem {\n    get_unique_fs_type_name(): string {\n        return \"localstorage\";\n    }\n\n    async is_ready() {\n        return true;\n    }\n\n    async erase_all() {\n        localStorage.removeItem(\"fs\");\n        localStorage.removeItem(\"fs_readonly_paths\");\n        localStorage.removeItem(\"fs_migrations\");\n    }\n\n    async make_dir(path: string) {\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\n        let current_dir = state;\n\n        // split path into parts, if root, use single empty string to avoid doubling\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\n\n        // create directory for each part inside the previous one\n        for (const part of parts) {\n            const absolute_path = parts.slice(0, parts.indexOf(part) + 1).join(\"/\");\n\n            if (!current_dir[part]) {\n                current_dir[part] = {};\n                this._call_callbacks(FSEventType.MADE_DIR, absolute_path);\n            }\n\n            current_dir = current_dir[part];\n        }\n\n        // save state\n        localStorage.setItem(\"fs\", JSON.stringify(state));\n    }\n\n    async delete_dir_direct(path: string, recursive: boolean) {\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\n        let current_dir = state;\n\n        // split path into parts, if root, use single empty string to avoid doubling\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\n\n        // delete innermost directory\n        for (let part_idx = 0; part_idx < parts.length; part_idx++) {\n            const part = parts[part_idx];\n            const absolute_path = parts.slice(0, parts.indexOf(part) + 1).join(\"/\");\n\n            if (!recursive && (await this.list_dir(absolute_path)).length > 0) {\n                throw new NonRecursiveDirectoryError(part);\n            }\n\n            // check if directory exists\n            if (!current_dir[part]) {\n                throw new PathNotFoundError(absolute_path);\n            }\n\n            // delete directory if it's the last part\n            if (part_idx === parts.length - 1) {\n                delete current_dir[part];\n                this._call_callbacks(FSEventType.DELETED_DIR, absolute_path);\n            }\n\n            // recurse into directory to discover the next part\n            current_dir = current_dir[part];\n        }\n\n        // save state\n        localStorage.setItem(\"fs\", JSON.stringify(state));\n    }\n\n    async move_dir_direct(src: string, dest: string, move_inside: boolean) {\n        // (yes, this was ai generated, i just wanted to bring this very outdated fs_impl up to par with opfs. although its idea to make a helper was good, i should have done that years ago)\n\n        const state = JSON.parse(localStorage.getItem(\"fs\") || \"{}\");\n\n        // Helper to traverse to a path and return the parent and the target key\n        // This allows us to modify the parent (delete/assign) later\n        const get_node = (path: string) => {\n            const parts = path.split(\"/\").filter(p => p.length > 0);\n            const basename = parts[parts.length - 1];\n            let current = state;\n\n            // Traverse to parent\n            for (let i = 0; i < parts.length - 1; i++) {\n                const part = parts[i];\n                if (!current[part] || typeof current[part] !== \"object\") {\n                    throw new Error(`Path not found: ${path}`); // Simulates Linux \"No such file or directory\"\n                }\n                current = current[part];\n            }\n\n            return { parent: current, basename: basename, value: current[basename] };\n        };\n\n        // 1. Resolve Source\n        // We need the parent so we can 'delete' the entry later\n        const src_node = get_node(src);\n        if (!src_node.value) throw new PathNotFoundError(src);\n        if (typeof src_node.value !== \"object\") throw new PathNotFoundError(src);\n\n        // 2. Resolve Destination Parent\n        // Unlike your original code, we do NOT auto-create the destination path.\n        // Linux 'mv' fails if you try to move to 'a/b/c' and 'a/b' doesn't exist.\n        const dest_parts = dest.split(\"/\").filter(p => p.length > 0);\n        const dest_basename = dest_parts[dest_parts.length - 1];\n\n        // Check if the generic destination path exists (e.g. is 'dest' already there?)\n        let dest_exists = false;\n        let dest_is_dir = false;\n        let dest_parent_obj = state; // Default to root\n\n        // Traverse to the parent of the destination\n        for (let i = 0; i < dest_parts.length - 1; i++) {\n            const part = dest_parts[i];\n            if (!dest_parent_obj[part] || typeof dest_parent_obj[part] !== \"object\") {\n                throw new Error(`Destination parent path not found: ${dest}`);\n            }\n            dest_parent_obj = dest_parent_obj[part];\n        }\n\n        // Check the actual destination node\n        if (dest_parent_obj[dest_basename]) {\n            dest_exists = true;\n            dest_is_dir = typeof dest_parent_obj[dest_basename] === \"object\";\n        }\n\n        // 3. Apply Logic (Rename vs Move Into)\n        let final_parent;\n        let final_name;\n\n        if (move_inside || (dest_exists && dest_is_dir)) {\n            // RULE: Move 'src' INTO 'dest'\n\n            if (!dest_exists) {\n                // \"mv dir1 dir2/\" but dir2 missing -> Error\n                throw new Error(`Destination directory not found: ${dest}`);\n            }\n\n            // Our new parent is the destination folder itself\n            final_parent = dest_parent_obj[dest_basename];\n            final_name = src_node.basename; // Keep original name\n        } else {\n            // RULE: Rename 'src' TO 'dest'\n\n            if (dest_exists && !dest_is_dir) {\n                // Trying to overwrite a file with a directory -> Error\n                throw new Error(`Cannot overwrite non-directory '${dest}' with directory.`);\n            }\n\n            // Our new parent is the destination's parent\n            final_parent = dest_parent_obj;\n            final_name = dest_basename; // New name\n        }\n\n        // 4. Collision Check (Strict Linux: No Merging)\n        if (final_parent[final_name]) {\n            // In Linux, 'mv' fails if the target directory is not empty.\n            // Since we are moving a directory, we strictly fail here.\n            throw new Error(`Directory not empty: ${final_name} already exists in destination.`);\n        }\n\n        // 5. Execute Move (Atomic Reference Change)\n        // This is the beauty of LocalStorage/JSON: No recursive copy needed.\n        // Just point the new key to the old object.\n\n        final_parent[final_name] = src_node.value;\n\n        // 6. Delete Source\n        delete src_node.parent[src_node.basename];\n\n        // 7. Save State\n        localStorage.setItem(\"fs\", JSON.stringify(state));\n    }\n\n    async list_dir(path: string, dirs_first = false) {\n        this._call_callbacks(FSEventType.LISTING_DIR, path);\n\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\n        let current_dir = state;\n\n        // split path into parts, if root, use single empty string to avoid doubling\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\n\n        // trim trailing slash\n        if (parts[parts.length - 1] === \"\") {\n            parts.pop();\n        }\n\n        // get directory for each part inside the previous one\n        for (const part of parts) {\n            if (current_dir[part]) {\n                current_dir = current_dir[part];\n            } else {\n                throw new PathNotFoundError(path);\n            }\n        }\n\n        // if this is the root we will have an empty parts array, so we need to access the root directory\n        // our whole fs is stored under an empty top level key because im stupid\n        // we might have to do this elsewhere\n        if (parts.length === 0) {\n            current_dir = state[\"\"];\n        }\n\n        // return list of files in directory\n        const keys = Object.keys(current_dir);\n\n        if (dirs_first) {\n            for (const key of keys) {\n                // promote directories to the front of the list\n                if (typeof current_dir[key] === \"object\") {\n                    keys.splice(keys.indexOf(key), 1);\n                    keys.unshift(key);\n                }\n            }\n        }\n\n        return keys;\n    }\n\n\n    async read_file_direct(path: string, as_uint = false) {\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\n\n        // split path into parts, if root, use single empty string to avoid doubling\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\n        let current_part = state;\n\n        // get directory for each part inside the previous one\n        for (const part of parts) {\n            // if this is not the last part, check if it is a directory\n            if (parts.indexOf(part) !== parts.length - 1 && !current_part[part]) {\n                throw new PathNotFoundError(path);\n            }\n\n            current_part = current_part[part];\n        }\n\n        // check if file exists\n        if (current_part !== undefined) {\n            // if file is empty, return empty string / uint8array (or else it will be read as null byte)\n            if (current_part.length === 0) {\n                if (as_uint) {\n                    return new Uint8Array();\n                } else {\n                    return \"\";\n                }\n            }\n\n            const binary_string = atob(current_part);\n            const bytes = Uint8Array.from(binary_string, m => m.charCodeAt(0));\n\n            if (as_uint) {\n                return bytes;\n            } else {\n                return new TextDecoder().decode(bytes);\n            }\n        }\n\n        throw new PathNotFoundError(path);\n    }\n\n    async write_file_direct(path: string, data: string | ArrayBuffer | Uint8Array) {\n        let uint: Uint8Array;\n\n        // convert string to uint8array\n        if (typeof data === \"string\") {\n            uint = new TextEncoder().encode(data);\n        }\n\n        // convert array buffer to uint8array\n        if (data instanceof ArrayBuffer) {\n            uint = new Uint8Array(data);\n        }\n\n        if (data instanceof Uint8Array) {\n            uint = data;\n        }\n\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\n        let current_dir = state;\n\n        // split path into parts, if root, use single empty string to avoid doubling\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\n        const file_name = parts[parts.length - 1];\n\n        // get directory for each part inside the previous one\n        for (const part of parts) {\n            // go until before the last part\n            if (parts.indexOf(part) !== parts.length - 1) {\n                if (!current_dir[part]) {\n                    throw new PathNotFoundError(path);\n                }\n\n                current_dir = current_dir[part];\n            }\n        }\n\n        // convert uint8array to base64\n        // uint.toBase64() isnt mainstream yet\n        current_dir[file_name] = btoa(String.fromCharCode.apply(null, uint));\n        localStorage.setItem(\"fs\", JSON.stringify(state));\n    }\n\n    async delete_file_direct(path: string) {\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\n        let current_dir = state;\n\n        // split path into parts, if root, use single empty string to avoid doubling\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\n        const file_name = parts[parts.length - 1];\n\n        // get directory for each part inside the previous one\n        for (const part of parts) {\n            // go until before the last part\n            if (parts.indexOf(part) !== parts.length - 1) {\n                if (!current_dir[part]) {\n                    throw new PathNotFoundError(path);\n                }\n\n                current_dir = current_dir[part];\n            }\n        }\n\n        // delete file from directory\n        delete current_dir[file_name];\n        localStorage.setItem(\"fs\", JSON.stringify(state));\n\n        // remove from readonly list if it is there\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\n        if (readonly_list.includes(path)) {\n            readonly_list.splice(readonly_list.indexOf(path), 1);\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\n        }\n    }\n\n    async move_file_direct(src: string, dest: string) {\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\n\n        // split paths into parts, if root, use single empty string to avoid doubling\n        const src_parts = src === this._root ? [\"\"] : src.split(\"/\");\n        const dest_parts = dest === this._root ? [\"\"] : dest.split(\"/\");\n        const file_name = src_parts[src_parts.length - 1];\n        const new_file_name = dest_parts[dest_parts.length - 1];\n\n        // get directory for each part inside the previous one\n        let current_dir = state;\n        for (const part of src_parts.slice(0, -1)) {\n            if (!current_dir[part]) {\n                throw new PathNotFoundError(src);\n            }\n            current_dir = current_dir[part];\n        }\n\n        // check if file exists\n        if (current_dir[file_name] === undefined) {\n            throw new PathNotFoundError(src);\n        }\n\n        // get directory for each part inside the previous one\n        let new_current_dir = state;\n        for (const part of dest_parts.slice(0, -1)) {\n            if (!new_current_dir[part]) {\n                throw new PathNotFoundError(dest);\n            }\n            new_current_dir = new_current_dir[part];\n        }\n\n        // if we have equivalent paths, do nothing (so we don't accidentally delete the file when calling delete after move)\n        if (file_name === new_file_name && current_dir === new_current_dir) {\n            console.warn(\"source and destination are the same\");\n            return;\n        }\n\n        // move file from source to destination\n        new_current_dir[new_file_name] = current_dir[file_name];\n        delete current_dir[file_name];\n        localStorage.setItem(\"fs\", JSON.stringify(state));\n\n        // relocate in readonly list if it is there\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\n        if (readonly_list.includes(src)) {\n            readonly_list.splice(readonly_list.indexOf(src), 1);\n            readonly_list.push(dest);\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\n        }\n    }\n\n    async set_readonly_direct(path: string, readonly: boolean) {\n        const state = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\n\n        if (readonly && !state.includes(path)) {\n            state.push(path);\n        } else if (!readonly && state.includes(path)) {\n            state.splice(state.indexOf(path), 1);\n        }\n\n        localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(state));\n    }\n\n    async is_readonly_direct(path: string) {\n        const state = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\n        return state.includes(path);\n    }\n\n    async exists_direct(path: string) {\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\n        let current_part = state;\n\n        // split path into parts, if root, use single empty string to avoid doubling\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\n\n        // remove trailing /\n        if (parts[parts.length - 1] === \"\") {\n            parts.pop();\n        }\n\n        // get directory for each part inside the previous one\n        for (const part of parts) {\n            // important! empty strings are falsy so we need to specifically check for undefined\n            if (current_part[part] !== undefined) {\n                current_part = current_part[part];\n            } else {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    async dir_exists(path: string) {\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\n        let current_part = state;\n\n        // if path ends with /, remove it\n        if (path.endsWith(\"/\")) {\n            path = path.slice(0, -1);\n        }\n\n        // split path into parts, if root, use single empty string to avoid doubling\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\n\n        // get directory for each part inside the previous one\n        for (const part of parts) {\n            if (current_part[part]) {\n                current_part = current_part[part];\n            } else {\n                return false;\n            }\n        }\n\n        return typeof current_part === \"object\";\n    }\n\n    constructor() {\n        super();\n\n        // initialise file system\n        if (!localStorage.getItem(\"fs\")) {\n            localStorage.setItem(\"fs\", JSON.stringify({}));\n        }\n\n        if (!localStorage.getItem(\"fs_readonly_paths\")) {\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify([]));\n        }\n\n        const existing_migrations = localStorage.getItem(\"fs_migrations\");\n        if (!existing_migrations) {\n            localStorage.setItem(\"fs_migrations\", JSON.stringify({\n                string_to_array: false,\n                array_to_b64: false,\n            }));\n        }\n\n        const migrations = JSON.parse(localStorage.getItem(\"fs_migrations\"));\n\n        if (!migrations.string_to_array) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            migrate_old_string_fs(JSON.parse(localStorage.getItem(\"fs\")), true);\n        }\n\n        if (!migrations.array_to_b64) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            migrate_old_array_fs(JSON.parse(localStorage.getItem(\"fs\")));\n        }\n\n        // mark all migrations as done\n        migrations.string_to_array = true;\n        migrations.array_to_b64 = true;\n        localStorage.setItem(\"fs_migrations\", JSON.stringify(migrations));\n\n        // initialise root and home directory\n        this.make_dir(this._home).then(() => {\n            this._initialised = true;\n        }).catch((err) => {\n            console.error(\"Failed to create home directory:\", err);\n        });\n    }\n}\n\nconst migrate_old_string_fs = (state: object, is_outer = false) => {\n    // migration step: we used to use a string but now we use an array for files\n    // need to iterate DEEPLY into nested objects and convert string values to arrays\n    // (so recurse)\n    // TODO make iterative\n\n    for (const key of Object.keys(state)) {\n        if (typeof state[key] === \"object\" && !Array.isArray(state[key])) {\n            migrate_old_string_fs(state[key]);\n        } else if (typeof state[key] === \"string\") {\n            console.log(`Migration: converting ${key} to array`);\n            state[key] = state[key].split(\",\").map((x) => parseInt(x));\n        }\n    }\n\n    if (is_outer) {\n        // only save if we are at the outermost level\n        localStorage.setItem(\"fs\", JSON.stringify(state));\n    }\n}\n\nconst migrate_old_array_fs = (state: object) => {\n    // migration step: we used to use an array for files but now we use base64 strings\n    // need to iterate DEEPLY into nested objects and convert array values to strings\n\n    // use a stack to avoid recursion limit issues\n    const stack = [state];\n\n    while (stack.length > 0) {\n        // get the next object to process\n        const current_obj = stack.pop();\n\n        if (current_obj === null || typeof current_obj !== \"object\" || Array.isArray(current_obj)) {\n            continue;\n        }\n\n        // iterate over the keys of the current object\n        for (const key of Object.keys(current_obj)) {\n            const value = current_obj[key];\n\n            if (!value) {\n                continue;\n            } else if (typeof value === \"object\" && !Array.isArray(value)) {\n                // if the value is a nested object, add it to the stack to be processed later (depth first)\n                stack.push(value);\n            } else if (Array.isArray(value)) {\n                console.log(`Migration: converting ${key} to b64 string`);\n\n                try {\n                    const values = value.map((x: string) => parseInt(x));\n                    const uint = new Uint8Array(values);\n                    // uint.toBase64() isnt mainstream yet\n                    current_obj[key] = btoa(String.fromCharCode.apply(null, uint));\n                } catch (e) {\n                    console.error(`Migration failed for key \"${key}\":`, e);\n                }\n            }\n        }\n    }\n\n    // only save after the whole traversal\n    localStorage.setItem(\"fs\", JSON.stringify(state));\n}\n","import {\n    AbstractFileSystem,\n    MoveDestinationDirectoryNotEmptyError,\n    NonRecursiveDirectoryError,\n    PathNotFoundError\n} from \"../kernel/filesystem\";\n\nexport class OPFSFileSystem extends AbstractFileSystem {\n    private _opfs_handle: FileSystemDirectoryHandle | null = null;\n\n    get_unique_fs_type_name(): string {\n        return \"opfs\";\n    }\n\n    constructor() {\n        super();\n\n        if (!localStorage.getItem(\"fs_readonly_paths\")) {\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify([]));\n        }\n\n        // get the root directory handle\n        navigator.storage.getDirectory().then((handle) => {\n            this._opfs_handle = handle;\n            this._initialised = true;\n        }).catch((err) => {\n            console.error(\"Failed to get OPFS directory handle:\", err);\n        });\n    }\n\n    async is_ready() {\n        return this._opfs_handle !== null;\n    }\n\n    private get_root_handle(): FileSystemDirectoryHandle {\n        if (!this._opfs_handle) {\n            throw new Error(\"OPFS directory handle is not initialised.\");\n        }\n\n        return this._opfs_handle;\n    }\n\n    async make_dir(path: string) {\n        const root = this.get_root_handle();\n        const parts = path.split(\"/\").filter(part => part.length > 0);\n\n        let current_handle = root;\n        for (const part of parts) {\n            current_handle = await current_handle.getDirectoryHandle(part, { create: true });\n        }\n    }\n\n    async dir_exists(path: string): Promise<boolean> {\n        // should return true only for directories\n\n        const root = this.get_root_handle();\n        const parts = path.split(\"/\").filter(part => part.length > 0);\n\n        let current_handle = root;\n        for (const part of parts) {\n            try {\n                current_handle = await current_handle.getDirectoryHandle(part);\n            } catch (err) {\n                if (err instanceof DOMException && (err.name === \"NotFoundError\" || err.name === \"TypeMismatchError\")) {\n                    return false;\n                }\n                throw err;\n            }\n        }\n\n        return true;\n    }\n\n    async exists_direct(path: string) {\n        // should return true for both files and directories\n\n        const root = this.get_root_handle();\n        const parts = path.split(\"/\").filter(part => part.length > 0);\n\n        let current_handle = root;\n        for (const part of parts) {\n            try {\n                current_handle = await current_handle.getDirectoryHandle(part);\n            } catch (err) {\n                try {\n                    await current_handle.getFileHandle(part);\n                    return true;\n                } catch (err2) {\n                    if (err2 instanceof DOMException && err2.name === \"NotFoundError\") {\n                        return false;\n                    }\n                    throw err2;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    async delete_dir_direct(path: string, recursive: boolean) {\n        const root = this.get_root_handle();\n        const parts = path.split(\"/\").filter(part => part.length > 0);\n\n        try {\n            // recurse into directories\n            let current_handle = root;\n            for (let i = 0; i < parts.length - 1; i++) {\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\n            }\n\n            await current_handle.removeEntry(parts[parts.length - 1], { recursive });\n        } catch (err) {\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                throw new PathNotFoundError(path);\n            }\n\n            if (err instanceof DOMException && err.name === \"InvalidModificationError\" && !recursive) {\n                throw new NonRecursiveDirectoryError(path);\n            }\n\n            throw err;\n        }\n    }\n\n    async list_dir(path: string) {\n        const root = this.get_root_handle();\n        const parts = path.split(\"/\").filter(part => part.length > 0);\n\n        let current_handle = root;\n        for (const part of parts) {\n            try {\n                current_handle = await current_handle.getDirectoryHandle(part);\n            } catch (err) {\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                    throw new PathNotFoundError(path);\n                }\n\n                throw err;\n            }\n        }\n\n        const entries: string[] = [];\n        for await (const [name, handle] of current_handle.entries()) {\n            entries.push(name);\n        }\n\n        return entries;\n    }\n\n    async is_readonly_direct(path: string) {\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\") || \"[]\");\n        return readonly_list.includes(path);\n    }\n\n    async set_readonly_direct(path: string, readonly: boolean) {\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\") || \"[]\");\n\n        if (readonly) {\n            if (!readonly_list.includes(path)) {\n                readonly_list.push(path);\n            }\n        } else {\n            if (readonly_list.includes(path)) {\n                readonly_list.splice(readonly_list.indexOf(path), 1);\n            }\n        }\n\n        localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\n    }\n\n    async move_dir_direct(src: string, dest: string, force_move_inside: boolean) {\n        const root = this.get_root_handle();\n\n        // using unix style rules, i.e\n        // mv dir1 dir2 ->\n        // (if dir2 exists or force_move_inside) move dir1 into dir2\n        // (if dir2 doesn't exist) rename dir1 to dir2\n        // fail if dir2 exists and dir2/dir1 already exists\n\n        const src_parts = src.split(\"/\").filter(part => part.length > 0);\n        const dest_parts = dest.split(\"/\").filter(part => part.length > 0);\n\n        const src_basename = src_parts[src_parts.length - 1];\n        const dest_basename = dest_parts[dest_parts.length - 1];\n\n        // get handle for source's parent and source directory\n        let src_parent_handle = root;\n        for (let i = 0; i < src_parts.length - 1; i++) {\n            try {\n                src_parent_handle = await src_parent_handle.getDirectoryHandle(src_parts[i]);\n            } catch (err) {\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                    throw new PathNotFoundError(src);\n                }\n                throw err;\n            }\n        }\n\n        let src_handle: FileSystemDirectoryHandle;\n        try {\n            src_handle = await src_parent_handle.getDirectoryHandle(src_basename);\n        } catch (err) {\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                throw new PathNotFoundError(src);\n            }\n            throw err;\n        }\n\n        // get handle for destination's parent and try to get destination directory (but not an error yet if it doesn't exist)\n        let dest_parent_handle = root;\n        for (let i = 0; i < dest_parts.length - 1; i++) {\n            try {\n                dest_parent_handle = await dest_parent_handle.getDirectoryHandle(dest_parts[i]);\n            } catch (err) {\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                    throw new PathNotFoundError(dest);\n                }\n                throw err;\n            }\n        }\n\n        let dest_handle: FileSystemDirectoryHandle | null = null;\n        try {\n            dest_handle = await dest_parent_handle.getDirectoryHandle(dest_basename);\n        } catch (err) {\n            if (err instanceof DOMException && err.name !== \"NotFoundError\") {\n                throw err;\n            }\n        }\n\n        // apply the rules to determine final destination\n        let final_dest_parent_handle: FileSystemDirectoryHandle;\n        let final_dest_name: string;\n\n        if (dest_handle || force_move_inside) {\n            // if destination already exists or force_move_inside is true, move source inside destination\n\n            if (!dest_handle) {\n                throw new PathNotFoundError(dest);\n            }\n\n            final_dest_parent_handle = dest_handle;\n            final_dest_name = src_basename;\n        } else {\n            // rename source to destination\n\n            final_dest_parent_handle = dest_parent_handle;\n            final_dest_name = dest_basename;\n        }\n\n        // ensure destination is empty\n        try {\n            await final_dest_parent_handle.getDirectoryHandle(final_dest_name);\n            throw new MoveDestinationDirectoryNotEmptyError(dest);\n        } catch (err) {\n            if (err instanceof DOMException && err.name !== \"NotFoundError\") {\n                throw err;\n            }\n        }\n\n        // perform move, first check if the browser supports handle.move, and if not recursively copy and delete\n        if (\"move\" in src_handle) {\n            // @ts-ignore - not part of spec yet\n            await src_handle.move(final_dest_parent_handle, final_dest_name);\n        } else {\n            // copy recursively\n            const new_dest_handle = await final_dest_parent_handle.getDirectoryHandle(final_dest_name, { create: true });\n            await this.#copy_directory_recursive(src_handle, new_dest_handle);\n\n            // delete source directory\n            await src_parent_handle.removeEntry(src_basename, { recursive: true });\n        }\n    }\n\n    async #copy_directory_recursive(src_handle: FileSystemDirectoryHandle, dest_handle: FileSystemDirectoryHandle) {\n        for await (const [name, handle] of src_handle.entries()) {\n            if (handle.kind === \"file\") {\n                const file_handle = await src_handle.getFileHandle(name);\n                const file = await file_handle.getFile();\n                const array_buffer = await file.arrayBuffer();\n                const dest_file_handle = await dest_handle.getFileHandle(name, { create: true });\n                const writable = await dest_file_handle.createWritable();\n                await writable.write(array_buffer);\n                await writable.close();\n            } else if (handle.kind === \"directory\") {\n                const src_subdir_handle = await src_handle.getDirectoryHandle(name);\n                const dest_subdir_handle = await dest_handle.getDirectoryHandle(name, { create: true });\n                await this.#copy_directory_recursive(src_subdir_handle, dest_subdir_handle);\n            }\n        }\n    }\n\n    async read_file_direct(path: string, as_uint: boolean) {\n        const root = this.get_root_handle();\n        const parts = path.split(\"/\").filter(part => part.length > 0);\n\n        // recurse into directories\n        let current_handle = root;\n        for (let i = 0; i < parts.length - 1; i++) {\n            try {\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\n            } catch (err) {\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                    throw new PathNotFoundError(path);\n                }\n\n                throw err;\n            }\n        }\n\n        let file_handle: FileSystemFileHandle;\n        try {\n            file_handle = await current_handle.getFileHandle(parts[parts.length - 1]);\n        } catch (err) {\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                throw new PathNotFoundError(path);\n            }\n            throw err;\n        }\n\n        const file = await file_handle.getFile();\n        const array_buffer = await file.arrayBuffer();\n\n        if (as_uint) {\n            return new Uint8Array(array_buffer);\n        } else {\n            const decoder = new TextDecoder();\n            return decoder.decode(array_buffer);\n        }\n    }\n\n    async write_file_direct(path: string, data: string | Uint8Array) {\n        const root = this.get_root_handle();\n        const parts = path.split(\"/\").filter(part => part.length > 0);\n        \n        // recurse into directories\n        let current_handle = root;\n        for (let i = 0; i < parts.length - 1; i++) {\n            current_handle = await current_handle.getDirectoryHandle(parts[i], { create: true });\n        }\n\n        const file_handle = await current_handle.getFileHandle(parts[parts.length - 1], { create: true });\n        const writable = await file_handle.createWritable();\n\n        const data_to_write = (data instanceof Uint8Array) ? data : new TextEncoder().encode(data);\n\n        await writable.write(data_to_write.buffer as ArrayBuffer);\n        await writable.close();\n    }\n\n    async delete_file_direct(path: string) {\n        const root = this.get_root_handle();\n        const parts = path.split(\"/\").filter(part => part.length > 0);\n\n        // recurse into directories\n        let current_handle = root;\n        for (let i = 0; i < parts.length - 1; i++) {\n            try {\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\n            } catch (err) {\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                    throw new PathNotFoundError(path);\n                }\n                throw err;\n            }\n        }\n\n        try {\n            await current_handle.removeEntry(parts[parts.length - 1]);\n        } catch (err) {\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                throw new PathNotFoundError(path);\n            }\n            throw err;\n        }\n\n        // remove from readonly list if it is there\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\n        if (readonly_list.includes(path)) {\n            readonly_list.splice(readonly_list.indexOf(path), 1);\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\n        }\n    }\n\n    async move_file_direct(src: string, dest: string) {\n        const root = this.get_root_handle();\n        const src_parts = src.split(\"/\").filter(part => part.length > 0);\n        const dest_parts = dest.split(\"/\").filter(part => part.length > 0);\n\n        // get source file handle\n        let current_handle = root;\n        for (let i = 0; i < src_parts.length - 1; i++) {\n            try {\n                current_handle = await current_handle.getDirectoryHandle(src_parts[i]);\n            } catch (err) {\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                    throw new PathNotFoundError(src);\n                }\n                throw err;\n            }\n        }\n\n        let file_handle: FileSystemFileHandle;\n        try {\n            file_handle = await current_handle.getFileHandle(src_parts[src_parts.length - 1]);\n        } catch (err) {\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\n                throw new PathNotFoundError(src);\n            }\n            throw err;\n        }\n\n        const file = await file_handle.getFile();\n        const array_buffer = await file.arrayBuffer();\n\n        // write to destination\n        current_handle = root;\n        for (let i = 0; i < dest_parts.length - 1; i++) {\n            current_handle = await current_handle.getDirectoryHandle(dest_parts[i], { create: true });\n        }\n\n        const dest_file_handle = await current_handle.getFileHandle(dest_parts[dest_parts.length - 1], { create: true });\n        const writable = await dest_file_handle.createWritable();\n        await writable.write(array_buffer);\n        await writable.close();\n\n        // delete source file\n        await this.delete_file_direct(src);\n    }\n\n    async erase_all() {\n        const root = this.get_root_handle();\n\n        for await (const [name, handle] of root.entries()) {\n            if (handle.kind === \"file\") {\n                await root.removeEntry(name);\n            } else if (handle.kind === \"directory\") {\n                await root.removeEntry(name, { recursive: true });\n            }\n        }\n\n        localStorage.removeItem(\"fs_readonly_paths\");\n    }\n}\n\n// TODO: emit events\n","import { AbstractFileSystem } from \"./kernel/filesystem\";\nimport { ANSI, NEWLINE } from \"./kernel/term_ctl\";\n\nconst setup_boot = async (fs: AbstractFileSystem) => {\n    // create boot directory if it doesn't exist\n    const absolute_boot = fs.absolute(\"/boot\");\n    if (!(await fs.dir_exists(absolute_boot))) {\n        await fs.make_dir(absolute_boot);\n    }\n\n    // create init file if it doesn't exist\n    const init_content = \"ignition\";\n    const absolute_init = fs.absolute(\"/boot/init\");\n    if (!(await fs.exists(absolute_init))) {\n        await fs.write_file(absolute_init, init_content);\n    }\n\n    // create etc directory if it doesn't exist\n    const absolute_etc = fs.absolute(\"/etc\");\n    if (!(await fs.dir_exists(absolute_etc))) {\n        await fs.make_dir(absolute_etc);\n    }\n\n    // create boot_target file if it doesn't exist\n    const boot_target_content = \"jetty\";\n    const absolute_boot_target = fs.absolute(\"/etc/boot_target\");\n    if (!(await fs.exists(absolute_boot_target))) {\n        await fs.write_file(absolute_boot_target, boot_target_content);\n    }\n\n    // create default_shell file if it doesn't exist\n    const default_shell_content = \"ash --login\";\n    const absolute_default_shell = fs.absolute(\"/etc/default_shell\");\n    if (!(await fs.exists(absolute_default_shell))) {\n        await fs.write_file(absolute_default_shell, default_shell_content);\n    }\n\n    // create sys directory if it doesn't exist\n    const absolute_sys = fs.absolute(\"/sys\");\n    if (!(await fs.dir_exists(absolute_sys))) {\n        await fs.make_dir(absolute_sys);\n    }\n\n    // create privilege_agent file if it doesn't exist\n    const privilege_agent_content = \"default_privilege_agent\";\n    const absolute_privilege_agent = fs.absolute(\"/sys/privilege_agent\");\n    if (!(await fs.exists(absolute_privilege_agent))) {\n        await fs.write_file(absolute_privilege_agent, privilege_agent_content);\n    }\n}\n\nconst setup_motd = async (fs: AbstractFileSystem) => {\n    // create etc directory if it doesn't exist\n    const absolute_etc = fs.absolute(\"/etc\");\n    if (!(await fs.dir_exists(absolute_etc))) {\n        await fs.make_dir(absolute_etc);\n    }\n\n    // create motd file if it doesn't exist\n    const motd_content = ` Welcome to ${ANSI.STYLE.italic + ANSI.STYLE.bold + ANSI.FG.magenta}OllieOS...${ANSI.STYLE.reset_all} \n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}help${ANSI.STYLE.no_italic + ANSI.FG.blue} for a list of commands.${ANSI.STYLE.reset_all}        \n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}mefetch${ANSI.STYLE.no_italic + ANSI.FG.blue} for info about me.${ANSI.STYLE.reset_all}          \n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}cd projects${ANSI.STYLE.no_italic + ANSI.FG.blue} to view project info.${ANSI.STYLE.reset_all}   \n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}bugreport${ANSI.STYLE.no_italic + ANSI.FG.blue} to open the bug reporter.${ANSI.STYLE.reset_all} \n`.replace(/\\n/g, NEWLINE);\n\n    const absolute_motd = fs.absolute(\"/etc/motd.txt\");\n    if (!(await fs.exists(absolute_motd))) {\n        await fs.write_file(absolute_motd, motd_content);\n    }\n};\n\nconst migrate_rc_profile = async (fs: AbstractFileSystem) => {\n    // if .ollie_profile exists, and .ash_profile doesn't, rename it to .ash_profile\n    const absolute_ollie_profile = fs.absolute(\"~/.ollie_profile\");\n    const absolute_ash_profile = fs.absolute(\"~/.ash_profile\");\n    if (await fs.exists(absolute_ollie_profile) && !(await fs.exists(absolute_ash_profile))) {\n        await fs.move_file(absolute_ollie_profile, absolute_ash_profile);\n    }\n\n    // if .ollierc exists, and .ashrc doesn't, rename it to .ashrc\n    const absolute_ollierc = fs.absolute(\"~/.ollierc\");\n    const absolute_ashrc = fs.absolute(\"~/.ashrc\");\n    if (await fs.exists(absolute_ollierc) && !(await fs.exists(absolute_ashrc))) {\n        await fs.move_file(absolute_ollierc, absolute_ashrc);\n    }\n};\n\nconst setup_credits = async (fs: AbstractFileSystem) => {\n    // create credits file\n    const credits_content = `\nCredits\n=======\n\nThis website was created by obfuscatedgenerated using the following technologies:\n\n- TypeScript\n- xterm.js\n- Handlebars.js\n- Webpack\n\nAs well as the following libraries:\n\n- imgToAscii (modified)\n- node-sixel\n- @xterm/addon-fit\n- @xterm/addon-web-links\n- @xterm/addon-image\n- xterm-link-provider\n- howler.js\n- html-to-text\n- some code from rss-parser (modified)\n\nPlease consult https://ollieg.codes/public/script/3rdpartylicenses.txt for full license information.\n\nAdditionally, fsedit uses:\n\n- Font Awesome\n\nThe source code is available on GitHub at https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io.\n`.replace(/\\n/g, NEWLINE);\n\n    // only overwrite the file if it doesn't exist or the content is different\n    const absolute_credits = fs.absolute(\"~/credits.txt\");\n    if (!(await fs.exists(absolute_credits)) || await fs.read_file(absolute_credits) !== credits_content) {\n        await fs.write_file(absolute_credits, credits_content, true);\n        await fs.set_readonly(absolute_credits, true);\n    }\n};\n\n// syncs the data repository from the data service (data.ollieg.codes)\nconst setup_data_repo = async (fs: AbstractFileSystem) => {\n    console.log(\"Syncing data repository...\");\n\n    // check if data dir exists locally\n    const data_dir = fs.absolute(\"/var/lib/data\");\n    let existing_rev = \"\";\n    if (!(await fs.dir_exists(data_dir))) {\n        await fs.make_dir(data_dir);\n    } else {\n        // read the existing revision from version.json\n        const version_file = fs.join(data_dir, \"version.json\");\n        if (await fs.exists(version_file)) {\n            const version_data = JSON.parse(await fs.read_file(version_file) as string);\n            existing_rev = version_data.rev;\n        }\n    }\n\n    try {\n        // fetch the latest revision from the data service\n        const svc_version = await fetch(\"https://data.ollieg.codes/version.json\").then(res => res.json());\n        const latest_rev = svc_version.rev;\n\n        // if the revisions match, no need to update\n        if (existing_rev === latest_rev) {\n            console.log(\"Data repository is already up to date.\");\n            return;\n        }\n\n        // back up existing data folder\n        const possible_backup_dir = fs.absolute(`/var/lib/.data.old_${existing_rev}`);\n        if (existing_rev) {\n            await fs.move_dir(data_dir, possible_backup_dir);\n            await fs.make_dir(data_dir);\n        }\n\n        // fetch the index file\n        const index = await fetch(\"https://data.ollieg.codes/index.json\").then(res => res.json());\n\n        // check if the index file has the optional \"groups\" field\n        if (!index.groups) {\n            throw new Error(\"Index file is missing 'groups' field.\");\n        }\n\n        // write the index and version file to the data folder\n        await fs.write_file(fs.join(data_dir, \"index.json\"), JSON.stringify(index, null, 2), true);\n        await fs.write_file(fs.join(data_dir, \"version.json\"), JSON.stringify(svc_version, null, 2), true);\n\n        // for each group, fetch the index and then fetch each file listed in its index\n        for (const group of index.groups) {\n            console.log(`Syncing data group: ${group}`);\n\n            // ensure the group directory exists\n            const group_dir = fs.join(data_dir, group);\n            if (!(await fs.dir_exists(group_dir))) {\n                await fs.make_dir(group_dir);\n            }\n\n            // fetch the group index\n            const group_index = await fetch(`https://data.ollieg.codes/${group}/index.json`).then(res => res.json());\n\n            // ensure the group index is an array\n            if (!Array.isArray(group_index)) {\n                throw new Error(`Group index for ${group} is not an array.`);\n            }\n\n            // write the group index to the group folder\n            await fs.write_file(fs.join(group_dir, \"index.json\"), JSON.stringify(group_index, null, 2), true);\n\n            // for each file in the group index, fetch the file and write it to the data folder\n            for (const entry of group_index) {\n                console.log(`  Fetching file: ${entry}.json`);\n\n                const file_data = await fetch(`https://data.ollieg.codes/${group}/${entry}.json`).then(res => res.text());\n                const file_path = fs.join(group_dir, `${entry}.json`);\n\n                await fs.write_file(file_path, file_data, true);\n            }\n        }\n\n        console.log(\"Data repository synced successfully.\");\n\n        // delete backup if exists\n        if (await fs.dir_exists(possible_backup_dir)) {\n            await fs.delete_dir(possible_backup_dir, true);\n        }\n\n        // return new rev\n        return latest_rev;\n    } catch (e) {\n        console.error(\"Failed to sync data repository:\");\n        console.error(e);\n\n        // restore backup if exists\n        const possible_backup_dir = fs.absolute(`/var/lib/.data.old_${existing_rev}`);\n        if (await fs.dir_exists(possible_backup_dir)) {\n            console.error(\"Restoring backup...\");\n            await fs.move_dir(data_dir, fs.absolute(\"/var/lib/data.discard\"));\n            await fs.move_dir(possible_backup_dir, data_dir);\n            await fs.delete_dir(fs.absolute(\"/var/lib/data.discard\"), true);\n        } else {\n            // just delete the data dir in progress to prevent partial data\n            await fs.delete_dir(data_dir, true);\n        }\n    }\n\n    return null;\n}\n\nconst fetch_file_with_ttl = async (url: string, skip_cache: boolean) => {\n    // check if url exists in TTL cache\n    const ttl_cache = localStorage.getItem(\"fetch_ttl_cache\");\n    const ttl_cache_obj = ttl_cache ? JSON.parse(ttl_cache) : {};\n\n    // if the url's TTL hasn't expired, don't fetch the file\n    // saves time acquiring heavy files at startup whilst still allowing for updates at some point\n    if (!skip_cache && ttl_cache_obj[url]) {\n        if (ttl_cache_obj[url] > Date.now()) {\n            return null;\n        }\n    }\n\n    // fetch the file and convert it to a Uint8Array\n    const response = await fetch(url);\n    const array_buffer = await response.arrayBuffer();\n\n    // add the url to the TTL cache\n    ttl_cache_obj[url] = Date.now() + 1000 * 60 * 60 * 24 * 7; // 1 week\n    localStorage.setItem(\"fetch_ttl_cache\", JSON.stringify(ttl_cache_obj));\n\n    return new Uint8Array(array_buffer);\n};\n\nconst generate_project_folder = async (fs: AbstractFileSystem, base_dir: string, data_projects_dir: string, project_entry: string, project_data: any = null): Promise<boolean> => {\n    console.log(`Generating project folder for ${project_entry}...`);\n\n    const project_dir = fs.join(base_dir, project_entry);\n    await fs.make_dir(project_dir);\n\n    // generate info.txt\n    const info_content = `\n${project_data.name}\n=${\"=\".repeat(project_data.name.length)}\n\n${project_data.primary_language ? `Primary Language: ${project_data.primary_language}\\n\\n` : \"\"}${project_data.description}\n${project_data.live_url ? `\\nLive URL: ${project_data.live_url}` : \"\"}${project_data.repo_url ? `\\nRepository: ${project_data.repo_url}` : \"\"}\n`.replace(/\\n/g, NEWLINE).trim();\n\n    await fs.write_file(fs.join(project_dir, \"info.txt\"), NEWLINE + info_content + NEWLINE, true);\n\n    // download image with ttl if defined\n    // not a fatal failure so don't return false on failure\n    if (project_data.image) {\n        const file_ext_regex = /\\.([a-zA-Z0-9]+)(?:\\?|$)/;\n        const match = project_data.image.match(file_ext_regex);\n\n        // if theres no file extension, default to png bc why not :)\n        const image_ext = match ? match[1] : \"png\";\n        if (image_ext) {\n            const absolute_file = fs.join(project_dir, `image.${image_ext}`);\n            let content: Uint8Array | null;\n\n            try {\n                // if the file doesn't exist, skip the TTL cache\n                const skip_cache = !(await fs.exists(absolute_file));\n\n                // fetch the file if TTL cache is expired or doesn't exist\n                content = await fetch_file_with_ttl(project_data.image, skip_cache);\n\n                // write the file if content is not null\n                if (content) {\n                    await fs.write_file(absolute_file, content, true);\n                }\n            } catch (e) {\n                console.error(`Failed to fetch image for project ${project_entry}:`);\n                console.error(e);\n            }\n        } else {\n            console.warn(`Project image for ${project_entry} has unsupported file extension; skipping image.`);\n        }\n    }\n\n    console.log(`Project folder for ${project_entry} generated successfully.`);\n\n    // recurse for sub_projects\n    if (project_data.sub_projects && Array.isArray(project_data.sub_projects)) {\n        for (const sub_project_entry of project_data.sub_projects) {\n            const success = await generate_project_folder(fs, project_dir, data_projects_dir, sub_project_entry.name, sub_project_entry);\n            if (!success) {\n                console.error(`Failed to generate sub-project folder for ${sub_project_entry}`);\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nconst setup_projects = async (fs: AbstractFileSystem, data_rev: string | null) => {\n    // if data_rev is null, try read it from the data repo\n    if (!data_rev) {\n        try {\n            const version_file = fs.absolute(\"/var/lib/data/version.json\");\n            if (await fs.exists(version_file)) {\n                const version_data = JSON.parse(await fs.read_file(version_file) as string);\n                data_rev = version_data.rev;\n            } else {\n                throw new Error(\"Version file does not exist.\");\n            }\n        } catch (e) {\n            console.error(\"Failed to read data revision from data repository:\");\n            console.error(e);\n            data_rev = null;\n        }\n    }\n\n    // if data rev is still null, skip project setup\n    if (!data_rev) {\n        console.warn(\"Data repo not synced; skipping project setup.\");\n        return;\n    }\n\n    // create projects directory if it doesn't exist\n    const absolute_projects = fs.absolute(\"~/projects\");\n    let project_rev = \"\";\n    if (!(await fs.dir_exists(absolute_projects))) {\n        await fs.make_dir(absolute_projects);\n    } else {\n        // read the existing revision from the hidden .rev file\n        const version_file = fs.join(absolute_projects, \".rev\");\n        if (await fs.exists(version_file)) {\n            project_rev = await fs.read_file(version_file) as string;\n        }\n    }\n\n    // if the revisions match, no need to update\n    if (project_rev === data_rev) {\n        console.log(\"Projects are already up to date.\");\n        return;\n    }\n\n    // back up existing projects folder\n    const possible_backup_dir = fs.absolute(`~/.projects.old_${project_rev}`);\n    if (project_rev) {\n        await fs.move_dir(absolute_projects, possible_backup_dir);\n        await fs.make_dir(absolute_projects);\n    }\n\n    try {\n        // for each project in the data repo, convert the json to the file structure in the projects folder\n        const data_projects_dir = fs.absolute(\"/var/lib/data/project\");\n        const project_index_file = fs.join(data_projects_dir, \"index.json\");\n\n        if (!(await fs.exists(project_index_file))) {\n            throw new Error(\"Project index file does not exist in data repository.\");\n        }\n\n        const projects = JSON.parse(await fs.read_file(project_index_file) as string);\n        if (!Array.isArray(projects)) {\n            throw new Error(\"Project index file is not an array.\");\n        }\n\n        for (const project_entry of projects) {\n            console.log(`Setting up project: ${project_entry}`);\n\n            const project_file = fs.join(data_projects_dir, `${project_entry}.json`);\n            if (!(await fs.exists(project_file))) {\n                console.warn(`Project file for ${project_entry} does not exist; skipping.`);\n                return false;\n            }\n\n            const project_data = JSON.parse(await fs.read_file(project_file) as string);\n\n            const success = await generate_project_folder(fs, absolute_projects, data_projects_dir, project_entry, project_data);\n            if (!success) {\n                // TODO: is it better to still keep partial data or throw an error?\n                throw new Error(`Failed to generate project folder for ${project_entry}`);\n            }\n        }\n\n        // write the new revision to the hidden .rev file\n        const version_file = fs.join(absolute_projects, \".rev\");\n        await fs.write_file(version_file, data_rev, true);\n\n        console.log(\"Projects set up successfully.\");\n    } catch (e) {\n        console.error(\"Failed to set up projects:\");\n        console.error(e);\n\n        // restore backup if exists\n        if (await fs.dir_exists(possible_backup_dir)) {\n            console.error(\"Restoring backup...\");\n            await fs.move_dir(absolute_projects, fs.absolute(\"~/projects.discard\"));\n            await fs.move_dir(possible_backup_dir, absolute_projects);\n            await fs.delete_dir(fs.absolute(\"~/projects.discard\"), true);\n        } else {\n            // just delete the projects dir in progress to prevent partial data\n            await fs.delete_dir(absolute_projects, true);\n        }\n\n        return;\n    }\n};\n\nexport const initial_fs_setup = async (fs: AbstractFileSystem) => {\n    await setup_boot(fs);\n    await setup_motd(fs);\n    await migrate_rc_profile(fs);\n    await setup_credits(fs);\n\n\n    const latest_rev = await setup_data_repo(fs);\n    await setup_projects(fs, latest_rev);\n};\n","export type WindowEvent = \"close\" | \"hide\" | \"show\" | \"focus\" | \"move\" | \"rename\" | \"resize\" | \"maximise\" | \"restore\";\n\nexport interface UserspaceOtherWindow {\n    readonly id: number;\n    readonly manager: UserspaceWindowManager;\n    readonly owner_pid: number;\n\n    readonly title: string;\n    readonly width: string;\n    readonly height: string;\n    readonly x: string | number;\n    readonly y: string | number;\n    readonly visible: boolean;\n    readonly maximised: boolean;\n}\n\nexport interface UserspaceWindow extends UserspaceOtherWindow {\n    readonly manager: UserspaceWindowManager;\n    readonly dom: ShadowRoot;\n\n    title: string;\n    width: string;\n    height: string;\n    x: string | number;\n    y: string | number;\n\n    visible: boolean;\n    maximised: boolean;\n\n    center(): void;\n    focus(): void;\n    show(): void;\n    hide(): void;\n    toggle(): void;\n    close(): void;\n\n    add_event_listener(event: WindowEvent, callback: () => void): void;\n    wait_for_event(event: WindowEvent): Promise<void>;\n}\n\nexport abstract class AbstractWindow {\n    abstract readonly id: number;\n\n    // TODO: more generic type somehow? depends if we ever need implementations that dont use shadow DOM\n    abstract readonly dom: ShadowRoot;\n\n    abstract readonly manager: AbstractWindowManager;\n\n    abstract moveable: boolean;\n\n    abstract resizable: boolean;\n\n    abstract maximisable: boolean;\n    abstract maximised: boolean;\n\n    private readonly _owner_pid: number;\n\n    protected constructor(owner_pid: number) {\n        this._owner_pid = owner_pid;\n    }\n\n    get owner_pid(): number {\n        return this._owner_pid;\n    }\n\n    abstract get title(): string;\n    abstract set title(new_title: string);\n\n    abstract get width(): string;\n    abstract set width(css_width: string);\n\n    abstract get height(): string;\n    abstract set height(css_height: string);\n\n    // number to be interpreted as pixels\n    abstract get x(): string | number;\n    abstract set x(css_pos: string | number);\n\n    // number to be interpreted as pixels\n    abstract get y(): string | number;\n    abstract set y(css_pos: string | number);\n\n    abstract center(): void;\n\n    abstract get visible(): boolean;\n    abstract set visible(is_visible: boolean);\n\n    abstract add_event_listener(event: WindowEvent, callback: () => Promise<void> | void): void;\n\n    abstract remove_event_listener(event: WindowEvent, callback: () => Promise<void> | void): void;\n\n    abstract dispose(): void;\n\n    abstract close(): void;\n\n    abstract focus(): void;\n\n    abstract show(): void;\n    abstract hide(): void;\n    abstract toggle(): void;\n\n    // best effort flags, may not be supported by all implementations (e.g. transparent flag)\n    abstract get_custom_flag(flag: string): boolean;\n    abstract set_custom_flag(flag: string, value: boolean): void;\n\n    abstract wait_for_event(event: WindowEvent): Promise<void>;\n\n    create_userspace_proxy_as_other_window(): UserspaceOtherWindow {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const proxy = Object.create(null);\n\n        Object.defineProperties(proxy, {\n            id: { get: () => self.id, enumerable: true },\n            manager: { get: () => self.manager.create_userspace_proxy(), enumerable: true },\n            owner_pid: { get: () => self.owner_pid, enumerable: true },\n            title: { get: () => self.title, enumerable: true },\n            width: { get: () => self.width, enumerable: true },\n            height: { get: () => self.height, enumerable: true },\n            x: { get: () => self.x, enumerable: true },\n            y: { get: () => self.y, enumerable: true },\n            visible: { get: () => self.visible, enumerable: true },\n            maximised: { get: () => self.maximised, enumerable: true }\n        });\n\n        return Object.freeze(proxy);\n    }\n\n    create_userspace_proxy_as_full_window(): UserspaceWindow {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const proxy = Object.create(null);\n\n        const manager_proxy = self.manager.create_userspace_proxy();\n\n        Object.defineProperties(proxy, {\n            id: { get: () => self.id, enumerable: true },\n            manager: { get: () => manager_proxy, enumerable: true },\n            owner_pid: { get: () => self.owner_pid, enumerable: true },\n            dom: { get: () => self.dom, enumerable: true },\n            title: {\n                get: () => self.title,\n                set: (new_title: string) => { self.title = new_title; },\n                enumerable: true\n            },\n            width: {\n                get: () => self.width,\n                set: (css_width: string) => { self.width = css_width; },\n                enumerable: true\n            },\n            height: {\n                get: () => self.height,\n                set: (css_height: string) => { self.height = css_height; },\n                enumerable: true\n            },\n            x: {\n                get: () => self.x,\n                set: (css_pos: string | number) => { self.x = css_pos; },\n                enumerable: true\n            },\n            y: {\n                get: () => self.y,\n                set: (css_pos: string | number) => { self.y = css_pos; },\n                enumerable: true\n            },\n            visible: {\n                get: () => self.visible,\n                set: (is_visible: boolean) => { self.visible = is_visible; },\n                enumerable: true\n            },\n            maximised: { get: () => self.maximised, enumerable: true },\n            center: { value: () => { self.center(); }, enumerable: true },\n            focus: { value: () => { self.focus(); }, enumerable: true },\n            show: { value: () => { self.show(); }, enumerable: true },\n            hide: { value: () => { self.hide(); }, enumerable: true },\n            toggle: { value: () => { self.toggle(); }, enumerable: true },\n            close: { value: () => { self.close(); }, enumerable: true },\n            add_event_listener: { value: (event: WindowEvent, callback: () => void) => { self.add_event_listener(event, callback); }, enumerable: true },\n            wait_for_event: { value: (event: WindowEvent) => self.wait_for_event(event), enumerable: true }\n        });\n\n        return Object.freeze(proxy);\n    }\n}\n\nexport interface UserspaceWindowManager {\n    get_unique_manager_type_name(): string;\n    get_all_windows(): UserspaceOtherWindow[];\n    get_window_by_id(id: number): UserspaceOtherWindow | null;\n}\n\nexport abstract class AbstractWindowManager {\n    abstract get_unique_manager_type_name(): string;\n\n    abstract get Window(): new (owner_pid: number) => AbstractWindow;\n\n    abstract get_all_windows(): AbstractWindow[];\n\n    abstract get_window_by_id(id: number): AbstractWindow | null;\n\n    abstract dispose_all(): void;\n\n    create_userspace_proxy(): UserspaceWindowManager {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const proxy = Object.create(null);\n\n        Object.defineProperties(proxy, {\n            get_unique_manager_type_name: { value: () => self.get_unique_manager_type_name(), enumerable: true },\n            get_all_windows: {\n                value: () => self.get_all_windows().map((win) => win.create_userspace_proxy_as_other_window()),\n                enumerable: true\n            },\n            get_window_by_id: {\n                value: (id: number) => {\n                    const win = self.get_window_by_id(id);\n                    return win ? win.create_userspace_proxy_as_other_window() : null;\n                },\n                enumerable: true\n            }\n        });\n\n        return Object.freeze(proxy);\n    }\n}\n\n// TODO: use separate interfaces so that only the process registry can create windows\n","import {AbstractWindow, AbstractWindowManager, WindowEvent} from \"../kernel/windowing\";\n\nexport class DOMWindowManager extends AbstractWindowManager {\n    #top_z_index = 10;\n\n    #window_id_counter = 1;\n    readonly #window_map: Map<number, AbstractWindow> = new Map();\n\n    readonly #WindowClass: new (owner_pid: number) => AbstractWindow;\n\n    get_unique_manager_type_name(): string {\n        return \"DOM\";\n    }\n\n    get Window() {\n        return this.#WindowClass;\n    }\n\n    get_all_windows = () => {\n        return Array.from(this.#window_map.values());\n    }\n\n    get_window_by_id = (id: number) => {\n        return this.#window_map.get(id) || null;\n    }\n\n    dispose_all() {\n        for (const window of this.#window_map.values()) {\n            window.dispose();\n        }\n\n        this.#window_map.clear();\n    }\n\n    constructor() {\n        super();\n\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const manager = this;\n\n        class DOMWindow extends AbstractWindow {\n            private readonly _manager = manager;\n\n            private readonly _window_id: number;\n\n            private readonly _window_root: HTMLDivElement;\n            private readonly _window_top_bar: HTMLDivElement;\n            private readonly _window_top_bar_title: HTMLSpanElement;\n            private readonly _window_top_bar_maximise_button: HTMLButtonElement;\n\n            private readonly _content_host: HTMLDivElement;\n            private readonly _shadow_dom: ShadowRoot;\n\n            private readonly _event_listeners: Map<WindowEvent, Array<() => Promise<void>>> = new Map();\n\n            private _title_text = \"New Window\";\n\n            moveable = true;\n            resizable = true;\n\n            private _maximisable = true;\n            private _maximised = false;\n\n            private readonly _custom_flags: Set<string> = new Set();\n\n            get manager() {\n                return this._manager;\n            }\n\n            constructor(owner_pid: number) {\n                super(owner_pid);\n\n                this._window_id = manager.#window_id_counter++;\n\n                // contains the entire window\n                this._window_root = document.createElement(\"div\");\n                this._window_root.classList.add(\"window\");\n                this._window_root.role = \"dialog\";\n                this._window_root.ariaHidden = \"true\";\n                this._window_root.id = `window-${this._window_id}`;\n                document.body.appendChild(this._window_root);\n\n                this._window_root.style.zIndex = manager.#top_z_index.toString();\n                this._window_root.addEventListener(\"mousedown\", () => this.focus(), { capture: true });\n                window.addEventListener(\"blur\", () => this._handle_window_blur());\n\n                // draggable top bar containing title and controls\n                this._window_top_bar = document.createElement(\"div\");\n                this._window_top_bar.classList.add(\"window-top-bar\");\n                this._window_root.appendChild(this._window_top_bar);\n\n                this._window_top_bar_title = document.createElement(\"span\");\n                this._window_top_bar_title.classList.add(\"window-top-bar-title\");\n                this._window_top_bar_title.innerText = this._title_text;\n                this._window_top_bar_title.id = `${this._window_root.id}-title`;\n                this._window_top_bar.appendChild(this._window_top_bar_title);\n                this._window_root.setAttribute(\"aria-labelledby\", this._window_top_bar_title.id);\n\n                const top_bar_controls = document.createElement(\"div\");\n                top_bar_controls.classList.add(\"window-top-bar-controls\");\n                top_bar_controls.addEventListener(\"mousedown\", (e) => e.stopPropagation());\n                this._window_top_bar.appendChild(top_bar_controls);\n\n                const minimise_button = document.createElement(\"button\");\n                minimise_button.title = \"Minimise window\";\n                minimise_button.classList.add(\"window-button\", \"window-minimise-button\");\n                minimise_button.innerText = \"\";\n                minimise_button.addEventListener(\"click\", () => this.hide());\n\n                this._window_top_bar_maximise_button = document.createElement(\"button\");\n                this._window_top_bar_maximise_button.title = \"Maximise window\";\n                this._window_top_bar_maximise_button.classList.add(\"window-button\", \"window-maximise-button\");\n                this._window_top_bar_maximise_button.innerText = \"\";\n                this._window_top_bar_maximise_button.addEventListener(\"click\", (ev) => {\n                    if (!this.maximisable) {\n                        return;\n                    }\n\n                    this.maximised = !this.maximised;\n                });\n\n                const close_button = document.createElement(\"button\");\n                close_button.title = \"Close window\";\n                close_button.classList.add(\"window-button\", \"window-close-button\");\n                close_button.innerText = \"\";\n                close_button.addEventListener(\"click\", this.close.bind(this));\n\n                top_bar_controls.appendChild(minimise_button);\n                top_bar_controls.appendChild(this._window_top_bar_maximise_button);\n                top_bar_controls.appendChild(close_button);\n\n                this._window_top_bar.addEventListener(\"mousedown\", (e) => this._start_drag(e));\n\n                // hosts the shadow dom where programs can add their content\n                this._content_host = document.createElement(\"div\");\n                this._content_host.classList.add(\"window-content-host\");\n\n                this._shadow_dom = this._content_host.attachShadow({ mode: \"closed\" });\n\n                this._window_root.appendChild(this._content_host);\n\n                // TODO: resize handles\n                // TODO: way to prevent windows existing when the program that created them exits? or is that not needed? theyll have to run background tasks to allow multitasking anyway\n\n                manager.#window_map.set(this._window_id, this);\n            }\n\n            get id() {\n                return this._window_id;\n            }\n\n            dispose() {\n                this._window_root.remove();\n                manager.#window_map.delete(this._window_id);\n            }\n\n            close() {\n                this._window_root.classList.add(\"animating-close\");\n                this._window_root.ariaHidden = \"true\";\n\n                this._emit_event(\"close\");\n\n                setTimeout(() => {\n                    this.dispose();\n                }, 200);\n            }\n\n            focus() {\n                this._emit_event(\"focus\");\n\n                manager.#top_z_index += 1;\n                this._window_root.style.zIndex = manager.#top_z_index.toString();\n            }\n\n            private _handle_window_blur() {\n                // TODO: fix for when focus jumps between iframes inside the window, this doesnt fire in that case\n\n                setTimeout(() => {\n                    if (document.activeElement === this._content_host) {\n                        this.focus();\n                    }\n                }, 0);\n            }\n\n            private async _emit_event(event: WindowEvent) {\n                if (!this._event_listeners.has(event)) {\n                    return;\n                }\n\n                const listeners = this._event_listeners.get(event)!;\n                await Promise.all(listeners.map(callback => callback()));\n            }\n\n            private _start_drag(start_event: MouseEvent) {\n                if (!this.moveable) {\n                    return;\n                }\n\n                this._content_host.classList.add(\"dragging\");\n\n                start_event.preventDefault();\n\n                const rect = this._window_root.getBoundingClientRect();\n                let offset_x = start_event.clientX - rect.left;\n                const offset_y = start_event.clientY - rect.top;\n\n                const mouse_move = (move_event: MouseEvent) => {\n                    move_event.preventDefault();\n\n                    if (this._maximised) {\n                        // break out of maximised, restoring size but not position\n                        this.maximised = false;\n\n                        // adjust offset_x to account for new window size\n                        const new_rect = this._window_root.getBoundingClientRect();\n                        const width_ratio = offset_x / rect.width;\n                        offset_x = new_rect.width * width_ratio;\n                    }\n\n                    this._window_root.style.left = `${move_event.clientX - offset_x}px`;\n                    this._window_root.style.top = `${move_event.clientY - offset_y}px`;\n\n                    this._emit_event(\"move\");\n                };\n\n                const mouse_up = (up_event: MouseEvent) => {\n                    document.removeEventListener(\"mousemove\", mouse_move);\n                    document.removeEventListener(\"mouseup\", mouse_up);\n\n                    this._content_host.classList.remove(\"dragging\");\n\n                    if (!this._maximised) {\n                        // if the mouse is at the top of the screen, maximise the window\n                        if (up_event.clientY <= 0 && this._maximisable) {\n                            this.maximised = true;\n                        }\n                    }\n\n                    // TODO: right and left side snapping to half the screen\n\n                    // if the rect is out of the top when released, snap it back in\n                    if (this._window_root.getBoundingClientRect().top < 0) {\n                        this._window_root.style.top = \"0px\";\n                    }\n                };\n\n                document.addEventListener(\"mousemove\", mouse_move);\n                document.addEventListener(\"mouseup\", mouse_up);\n            }\n\n            add_event_listener(event: WindowEvent, callback: () => Promise<void>) {\n                if (!this._event_listeners.has(event)) {\n                    this._event_listeners.set(event, []);\n                }\n\n                this._event_listeners.get(event)!.push(callback);\n            }\n\n            remove_event_listener(event: WindowEvent, callback: () => Promise<void>) {\n                if (!this._event_listeners.has(event)) {\n                    return;\n                }\n\n                const listeners = this._event_listeners.get(event)!;\n                const index = listeners.indexOf(callback);\n                if (index !== -1) {\n                    listeners.splice(index, 1);\n                }\n            }\n\n            get title() {\n                return this._title_text;\n            }\n\n            set title(new_title: string) {\n                this._window_top_bar_title.innerText = new_title;\n                this._title_text = new_title;\n\n                this._emit_event(\"rename\");\n            }\n\n            get width() {\n                return this._window_root.style.width;\n            }\n\n            set width(css_width: string) {\n                this._window_root.style.width = css_width;\n            }\n\n            get height() {\n                return this._window_root.style.height;\n            }\n\n            set height(css_height: string) {\n                this._window_root.style.height = css_height;\n            }\n\n            get maximisable() {\n                return this._maximisable;\n            }\n\n            set maximisable(value: boolean) {\n                this._maximisable = value;\n                this._window_top_bar_maximise_button.disabled = !value;\n            }\n\n            get maximised() {\n                return this._maximised;\n            }\n\n            set maximised(value: boolean) {\n                this._maximised = value;\n                this._window_root.classList.toggle(\"maximised\", value);\n\n                if (value) {\n                    this._window_top_bar_maximise_button.innerText = \"\";\n                    this._window_top_bar_maximise_button.title = \"Restore window\";\n\n                    this._emit_event(\"maximise\");\n                } else {\n                    this._window_top_bar_maximise_button.innerText = \"\";\n                    this._window_top_bar_maximise_button.title = \"Maximise window\";\n\n                    this._emit_event(\"restore\");\n                }\n            }\n\n            get x() {\n                return this._window_root.style.left;\n            }\n\n            set x(css_pos: string | number) {\n                if (typeof css_pos === \"number\") {\n                    css_pos = `${css_pos}px`;\n                }\n\n                this._window_root.style.left = css_pos;\n            }\n\n            get y() {\n                return this._window_root.style.top;\n            }\n\n            set y(css_pos: string | number) {\n                if (typeof css_pos === \"number\") {\n                    css_pos = `${css_pos}px`;\n                }\n\n                this._window_root.style.top = css_pos;\n            }\n\n            center() {\n                this.x = `calc(calc(100vw - ${this.width}) / 2)`;\n                this.y = `calc(calc(100vh - ${this.height}) / 2)`;\n            }\n\n            get dom() {\n                return this._shadow_dom;\n            }\n\n            show() {\n                this._window_root.classList.remove(\"animating-out\");\n                this._window_root.classList.add(\"visible\", \"animating-in\");\n                this._window_root.ariaHidden = \"false\";\n\n                setTimeout(() => {\n                    this._window_root.classList.remove(\"animating-in\");\n                }, 200);\n\n                this._emit_event(\"show\");\n            }\n\n            hide() {\n                this._window_root.classList.remove(\"animating-in\");\n                this._window_root.classList.add(\"animating-out\");\n                this._window_root.ariaHidden = \"true\";\n\n                setTimeout(() => {\n                    this._window_root.classList.remove(\"visible\", \"animating-out\");\n                }, 200);\n\n                this._emit_event(\"hide\");\n            }\n\n            toggle() {\n                this._window_root.classList.toggle(\"visible\");\n\n                if (this.visible) {\n                    this._emit_event(\"show\");\n                } else {\n                    this._emit_event(\"hide\");\n                }\n            }\n\n            get visible() {\n                return this._window_root.classList.contains(\"visible\");\n            }\n\n            set visible(is_visible: boolean) {\n                if (is_visible) {\n                    this.show();\n                } else {\n                    this.hide();\n                }\n            }\n\n            get_custom_flag(flag: string) {\n                return this._custom_flags.has(flag);\n            }\n\n            set_custom_flag(flag: string, value: boolean) {\n                if (value) {\n                    this._custom_flags.add(flag);\n                } else {\n                    this._custom_flags.delete(flag);\n                }\n\n                switch (flag) {\n                    case \"transparent\":\n                        if (value) {\n                            this._content_host.classList.add(\"transparent\");\n                        } else {\n                            this._content_host.classList.remove(\"transparent\");\n                        }\n                        break;\n                    case \"no-top-bar\":\n                        if (value) {\n                            this._window_top_bar.classList.add(\"hidden\");\n                        } else {\n                            this._window_top_bar.classList.remove(\"hidden\");\n                        }\n                        break;\n                }\n            }\n\n            wait_for_event(event: WindowEvent): Promise<void> {\n                return new Promise((resolve) => {\n                    const callback = async () => {\n                        this.remove_event_listener(event, callback);\n                        resolve();\n                    };\n\n                    this.add_event_listener(event, callback);\n                });\n            }\n        }\n\n        this.#WindowClass = DOMWindow;\n    }\n}\n","// provides expected externals of pkgbuild programs into global\n\nimport * as howler from \"howler\";\nimport * as htmlToText from \"html-to-text\";\nimport * as sixel from \"sixel\";\nimport * as xterm from \"@xterm/xterm\";\n\nglobalThis.ollieos = {};\nglobalThis.howler = howler;\nglobalThis[\"html-to-text\"] = htmlToText;\nglobalThis.sixel = sixel;\nglobalThis[\"@xterm/xterm\"] = xterm;\n\n// support old xterm names\nglobalThis[\"xterm\"] = xterm;\n\nif (typeof window !== \"undefined\") {\n    console.log(\"Loading browser-specific global externals...\");\n\n    (async() => {\n        const fitAddon = await import(\"@xterm/addon-fit\");\n        const webLinksAddon = await import(\"@xterm/addon-web-links\");\n        const imageAddon = await import(\"@xterm/addon-image\");\n        const xtermLinkProvider = await import(\"xterm-link-provider\");\n\n        const sweetalert2 = await import(\"sweetalert2\");\n\n        globalThis[\"@xterm/addon-fit\"] = fitAddon;\n        globalThis[\"@xterm/addon-web-links\"] = webLinksAddon;\n        globalThis[\"@xterm/addon-image\"] = imageAddon;\n        globalThis[\"xterm-link-provider\"] = xtermLinkProvider;\n\n        globalThis.sweetalert2 = sweetalert2;\n\n        globalThis[\"xterm-addon-fit\"] = fitAddon;\n        globalThis[\"xterm-addon-web-links\"] = webLinksAddon;\n        globalThis[\"xterm-addon-image\"] = imageAddon;\n\n        console.log(\"Browser-specific global externals loaded successfully.\");\n    })();\n}\n","import { FitAddon } from \"@xterm/addon-fit\";\nimport { WebLinksAddon } from \"@xterm/addon-web-links\";\nimport { ImageAddon } from \"@xterm/addon-image\";\n\nimport {ANSI, NEWLINE, WrappedTerminal} from \"./kernel/term_ctl\";\n\nimport {Kernel} from \"./kernel\";\n\nimport {ProgramRegistry} from \"./kernel/prog_registry\";\nimport * as programs from \"./programs/@ALL\";\n\nimport { SoundRegistry } from \"./kernel/sfx_registry\";\n\nimport type {AbstractFileSystem} from \"./kernel/filesystem\";\nimport { LocalStorageFS } from \"./fs_impl/localstorage\";\nimport { OPFSFileSystem } from \"./fs_impl/opfs\";\nimport { initial_fs_setup } from \"./initial_fs_setup\";\n\nimport {DOMWindowManager} from \"./window_impl/dom\";\n\nimport \"./load_global_externals\";\n\nexport const boot_os = async (on_init_spawned?: (kernel: Kernel) => Promise<void>) => {\n    // create a program registry by importing all programs\n    const prog_reg = new ProgramRegistry();\n    for (const prog of Object.values(programs)) {\n        await prog_reg.registerProgram({\n            program: prog,\n            built_in: true,\n        });\n    }\n\n\n    // create a sound registry\n    const sfx_reg = new SoundRegistry();\n    sfx_reg.register_file(\"reader_on\", \"public/sfx/reader_on.mp3\");\n    sfx_reg.register_file(\"reader_off\", \"public/sfx/reader_off.mp3\");\n\n\n    // create a filesystem\n    // try opfs but use localstorage if not available, or already in use\n    // TODO migrate from localstorage to opfs automatically\n    let fs: AbstractFileSystem;\n    if (!localStorage.getItem(\"fs\") && navigator.storage && \"getDirectory\" in navigator.storage) {\n        fs = new OPFSFileSystem();\n    } else {\n        fs = new LocalStorageFS();\n    }\n\n    if (!(await fs.is_ready())) {\n        // poll every 10ms until ready\n        await new Promise<void>((resolve) => {\n            const interval = setInterval(async () => {\n                if (await fs.is_ready()) {\n                    clearInterval(interval);\n                    resolve();\n                }\n            }, 10);\n        });\n    }\n\n    // create initial files\n    await initial_fs_setup(fs);\n\n    // create a dom window manager\n    const wm = new DOMWindowManager();\n\n    // create a terminal using the registry and filesystem\n    const term = new WrappedTerminal({\n        screenReaderMode: false,\n        cursorBlink: true,\n    });\n\n    // load addons\n    const fit = new FitAddon();\n    term.loadAddon(fit);\n\n    term.loadAddon(new WebLinksAddon());\n\n    term.loadAddon(new ImageAddon());\n\n\n    // open the terminal\n    const render = <HTMLElement>document.querySelector(\"#terminal\");\n    term.open(render);\n    fit.fit();\n\n\n    // if this is a small screen, show a message\n    if (window.innerWidth < 600) {\n        const wrapped = term.word_wrap(`${ANSI.BG.red + ANSI.FG.white}Warning: The screen that the terminal is running on is rather small!${NEWLINE + NEWLINE}Some programs may not display correctly, consider using a larger screen such as a computer or tablet.${NEWLINE + NEWLINE}An alternative interface is in the works. You can also use the command \"legacy\" to view the old (outdated) site.${ANSI.STYLE.reset_all}`, term.cols);\n        term.writeln(wrapped);\n    }\n\n\n    // disable F1 help\n    window.addEventListener(\"keydown\", function (e) {\n        if (e.code === \"F1\") {\n            e.preventDefault();\n        }\n    });\n\n\n    // on resize, resize the terminal\n    window.addEventListener(\"resize\", () => {\n        fit.fit();\n    });\n\n\n    // bind right click to copy/paste\n    window.addEventListener(\"contextmenu\", (e) => {\n        e.preventDefault();\n        term.copy_or_paste();\n    });\n\n    // create the kernel\n    const kernel = new Kernel(term, fs, prog_reg, sfx_reg, wm);\n    kernel.set_env_info(document.body.dataset.version, \"web\");\n\n    // boot the kernel and check for a false return (indicating boot failure). should probably never return true as the os should hopefully always run!\n    return await kernel.boot(on_init_spawned);\n}\n"],"names":["NEWLINE","NON_PRINTABLE_REGEX","ANSI_ESCAPE_REGEX","ANSI_UNESCAPED_REGEX","FG","reset","black","red","green","yellow","blue","magenta","cyan","white","gray","STYLE","reset_all","bold","dim","no_bold_or_dim","italic","no_italic","underline","double_underline","no_underline","inverse","no_inverse","hidden","no_hidden","strikethrough","no_strikethrough","negative","positive","CURSOR","invisible","visible","ANSI","BG","PREFABS","program_name","error","variable_name","file_path","dir_name","secret","WrappedTerminal","Terminal","Map","ansi","newline","non_printable_regex","ansi_escape_regex","ansi_unescaped_regex","read_line","async","custom_key_handlers","custom_printable_handler","buffer","current_line","current_index","set_current_line","new_line","set_current_index","new_index","handler_dispose","Promise","resolve","handlers","_e","term","write","length","before","slice","after","repeat","this","register_key_event_handler","e","key","match","before_cursor","after_cursor","console","warn","block","high_priority","_search_handlers","domEventCode","strict","pair","entries","identfier","handler","props","identifier","keyString","entry","existing_entries","set","unshift","push","get","splice","indexOf","delete","_handle_key_event","all_key_entries","undefined","domEvent","code","register_on_printable_key_event_handler","_enqueue_key_event","_handle_key_event_queue","shift","wait_for_keypress","dispose","onKey","get_text","max_length","text","unregister_handler","word_wrap","width","lines","split","wrapped_lines","line","words","word","join","copy","navigator","clipboard","writeText","getSelection","then","clearSelection","paste","readText","char","dom_event_code","toUpperCase","copy_or_paste","hasSelection","handle_kernel_panic","message","process_info","debug_info","textarea","disabled","writeln","Date","toISOString","window","location","origin","constructor","xterm_opts","super","build_registrant_from_js","js_code","built_in","warn_deprecation","startsWith","data_url","encodeURIComponent","encode_js_to_url","program","import","default","Error","name","globalThis","OLLIEOS_NODE","node_opt_out","description","usage_suffix","arg_descriptions","main","async_main","old_main","data","determine_program_name_from_js","mount_and_register_with_output","filename","content","prog_reg","output_success","reg","endsWith","registerProgram","recurse_mount_and_register_with_output","fs","dir_path","prog_registry","list_dir","entry_path","dir_exists","read_file","ProgramRegistry","program_reg","has","getProgramRegistrant","getProgram","listProgramRegistrants","includes_builtin","includes_mounted","arr","Array","from","values","filter","listProgramNames","keys","listPrograms","map","forceUnregister","unregister","create_userspace_proxy","init_program","self","proxy","Object","create","check_protected","privilege_agent_program","trim","defineProperties","value","enumerable","inc_builtin","inc_mounted","freeze","PathNotFoundError","path","NonRecursiveDirectoryError","MoveDestinationDirectoryNotEmptyError","ReadOnlyError","FSEventType","AbstractFileSystem","_initialised","_root","_home","_cwd","purge_cache","smart","exists_direct","clear","force_remove_from_cache","remote_purge_cache","localStorage","setItem","toString","remote_remove_from_cache","getItem","removeItem","remove_from_cache","register_callback","event_type","callback","_call_callbacks","as_uint","READING_FILE","cached","exists","read_file_direct","readonly","is_readonly","write_file","force","Uint8Array","write_file_direct","WROTE_FILE","delete_file","delete_file_direct","DELETED_FILE","move_file","new_path","move_file_direct","MOVED_FILE","set_readonly","set_readonly_direct","SET_READONLY","is_readonly_direct","delete_dir","recursive","delete_dir_direct","move_dir","src","dest","force_move_inside","move_dir_direct","get_cwd","GETTING_CWD","set_cwd","SET_CWD","get_home","GETTING_HOME","set_home","SET_HOME","get_root","GETTING_ROOT","set_root","SET_ROOT","CHECKING_EXISTS","absolute","includes","effective_cwd","lastIndexOf","base_dir","paths","setInterval","check_path","absolute_path","get_unique_fs_type_name","erase_all","dirs_first","base","make_dir","move_inside","ProcessAttachment","SoundRegistry","register_howl","howl","ready","register_file","file","Howl","onload","await_ready","interval","reject","timer","clearInterval","play","is_ready","wait_to_play","log","IPCManager","process_manager","service","get_process","pid","channel_id","channel","initiator_process","initiator","peer_process","peer","dispose_all","service_register","on_connection","service_unregister","service_lookup","create_direct_channel","initiator_pid","peer_pid","initiator_to_peer_queue","peer_to_initiator_queue","listeners","create_channel","service_name","catch","err","reserve_kernel_channel","assign_kernel_channel","destroy_channel","channel_listen","listening_pid","listener","Set","add","channel_unlisten","channel_send","from_pid","msg","to","to_pid","process_pid","ProcessContext","FOREGROUND","source_command","registry","shell","run_in_bg","BACKGROUND","created_at","is_detached","DETACHED","is_background","is_foreground","attachment","detaches_silently","detach","silently","dispose_resources","forEach","id","clearTimeout","win","kill","exit_code","mark_terminated","add_exit_listener","create_timeout","delay","on_cancel","setTimeout","resolvers","cancel_timeout","cancel_callback","has_timeout","create_interval","has_interval","clear_interval","wait_for_timeout","create_window","wm","window_manager","Window","add_event_listener","create_userspace_proxy_as_other_process","ProcessManager","ipc_manager","process","create_process","context","list_pids","ipc_mgr_proxy","Kernel","version","env","privileged","panicked","get_program_registry","get_sound_registry","get_fs","get_window_manager","has_window_manager","get_process_manager","get_ipc","get_env_info","set_env_info","spawn","cmd_or_parse","explicit_args","start_privileged","parsed_line","command","args","unsubbed_args","raw_parts","compat","result_promise","kernel","completion","panic","proc_mgr","pids","proc","trimEnd","boot","on_init_spawned","after_panic","usr_bin","init_args","init_parts","init","focus","stack","request_privilege","reason","agent_program","ipc","agent_proc","handling_request","approved","handling","granted","process_proxy","start_time","now","sound_registry","kernel_fs","proc_mgr_proxy","prog_reg_proxy","fs_proxy","SERVICES_DIR","CLEAN_EXIT_CODES","ServiceManager","load_service_files","service_files","file_name","file_content","service_data","JSON","parse","service_id","substring","existing_service_id","_calculate_service_start_order","visited","temp_mark","result","visit","dependencies","dep","start_initial_services","start_order","start_service","spawn_result","exec","_handle_service_exit","stop_service","restart_service","get_service_status","state","restart_policy","restart","on","delay_ms","hide_from_help","boot_target","boot_args","boot_target_parts","svc_mgr","payload","type","service_msg","action","status","current_tty_process","running","final_code","window_start","deaths_in_window","boot_target_proc","toLowerCase","recovery_proc","recovery_exit_code","default_shell","default_shell_args","default_shell_parts","current_shell_process","shell_proc","AshMemory","current_history_index","clear_history","get_previous_history_entry","get_next_history_entry","add_history_entry","list_variables","get_variable","set_variable","unset_variable","list_aliases","get_alias","set_alias","unset_alias","VAR_ASSIGNMENT_REGEX","parse_line","memory","sub","i","part","alias_value","alias_parts","pop","skip_variable_sub_idxs","arg","var_name","var_value","arg_idx","replace","var1","var2","AshShell","_discard_cached_matches","execute","edit_doc_title","program_final_completion_callback","old_title","document","title","on_execute_completion","color","insert_prompt","run_script","get_prompt_suffix","set_prompt_suffix","suffix","get_prompt_string","RegExp","cached_matches","current_cached_match_index","tab_complete","discard_cached_matches","updated_discard","completeable_arguments","completion_data","current_partial","arg_index","completion_result","obj","Symbol","asyncIterator","results","get_completeable_arguments","complete_argument","parts","current_arg_partial","fill_completed_argument","programs","complete_command","fill_completed_command","helper_completion_options","options","option","env_info","absolute_profile","absolute_rc","profile_content","rc_content","read_line_key_handlers","make_read_line_key_handlers","read_line_printable_handler","make_read_line_printable_handler","input","my_process","channel_id_str","parseInt","isNaN","finished","event","timeout_id","reload","header","single_column","visible_programs","programs_fmt","sort","max_allowable_length","Math","floor","cols","column1","_","column2","longest_program_length","max","new_args","paired_programs","program1","program2","program1_real_length","program2_real_length","recurse","descs","nest_level","output","time","time_arg","parsed_time","show_hidden","dir","max_width","setup","h_padding_l","ceil","h_padding_r","rows","footer","f_padding_l","f_padding_r","split_content","saved","cursor_y","normal","cursorY","line_length","cursor_x","cursorX","before_newline","after_newline","newline_content","left","right","test","url","proc_url","URL","protocol","overwrite","binary","method","headers","body","next_arg","abs_path","response","headers_obj","fetch","ok","arrayBuffer","filepath","hex","byte","padStart","idx","padded","concat","fill","MY_USERNAME","GH_USERNAME_REGEX","version_str","max_columns","asc_width","username","gh_info","res","json","bio","blog","followers","following","twitter","twitter_username","get_github_info","avatar_url","username_to_avatar_url","ascii_pfp","size","img","round","loadImage","stringANSI8BitColor","convert_to_ascii","known_data","data_index_str","user_data_str","pronouns","subject","object_or_alt","possessive","interests","websites","extra","known_info","stranger_info","txt_line_prefix","txt_line_suffix","asc_lines","txt_lines","max_lines","max_asc_line_length","max_txt_line_length","center_padding_size","side_padding_size","center_padding","side_padding","asc_line","txt_line","asc_line_padding","sfx_reg","screenReaderMode","sound_name","hint","querySelector","remove","pad","str","invis_codes","y_count","mime","width_arg","head_req","get_req","createObjectURL","Blob","data_out","canvas","createElement","ctx","getContext","Image","crossOrigin","onerror","height","drawImage","img_data","getImageData","array","convert_to_image_data","img_width","img_height","width_scale","new_height","scaled_img_data","x","y","scaled_x","scaled_i","sixel","image2sixel","blob","createImageBitmap","trusted_formats","ext","directory","fs_name","encoded_dir","open","iframe","style","border","wind","dom","appendChild","show","other_fsedit_running","processes","message_handler","source","contentWindow","close","removeEventListener","addEventListener","rimraf","type_suffixes","bug","feature","other","HTML_TAG_REGEX","fields","feed","item","DocType","author","publisher","date","link","summary","get_field","doc","doc_type","field","as_html","dict","FEED","field_value","isArray","sub_field","sub_field_doc","getElementsByTagName","sub_value","innerHTML","textContent","max_items","index","no_content","parser","DOMParser","parseFromString","feed_title","site_link","site_description","items","item_idx","item_title","ITEM","convert","formatters","elem","walk","builder","openBlock","addInline","opener","children","closeBlock","img_fmt","a_fmt","selectors","selector","format","_data","assign","wait_block","run_cmd","cmd","welcome","end","remove_subcommand","unique_args","error_count","total_pkgs","pkg","pkg_dir","meta_triggers","meta_version","meta_deps","meta_raw","meta","triggers","deps","dep_pkg","dep_pkg_name","graph_query","remove_pkg_dependent","remove_pkg","files","trigger_name","trigger_data","trigger_exists","process_uninstall_trigger","add_subcommand","depended_by","pkg_at_version","pkg_split","pkg_name","pkg_version","pkg_json","repo_query","get_pkg_json","latest_version","get_pkg_meta","externals","pkg_is_installed","get_pkg_version","remove_data","virtual_args","virtual_data","content_list","file_map","file_contents","get_pkg_file","stringify","json_convert_dep_sets_to_arrs","install_new_pkg","dep_name","add_pkg_dependent","process_install_trigger","print_info","pkg_data","installed","license","homepage_url","repo_url","long_desc","view_pkg_info","pkg_versions","get_pkg_versions","installed_version","printed_link_header","repo_url_obj","GRAPH_DIR","GRAPH_PATH","TRIGGER_DIR","append_url_pathnames","pathnames","new_url","urlpath","pathname","api_call","encodeURI","get_provided_list","json_convert_dep_arrs_to_sets","graph","get_pkg_info","list_pkgs","only_top_level","pkgs","top_level","get_pkg_dependents","dependents","get_pkg_dependencies","dependended_by","promote_pkg_to_top_level","demote_pkg_from_top_level","dependent_pkg","add_to_deps","remove_from_deps","skip_dep_check","list_unused_pkgs","get_file_path_in_pkg_bin","load_trigger_file","trigger_path","trigger","install_exec","data_str","uninstall_exec","local_graph","create_trigger_path","create_trigger_data","pkg_names","info","list_subcommand","always_fetch","installed_pkg","requested_version_installed","pkg_json_path","info_subcommand","provided","offset","selected_index","draw","quit","browse_subcommand","absolute_file","abs_dir","parent","no_overwrite","raw_destination","ended_with_slash","destination","dest_is_dir","window_ids","get_all_windows","all_windows","visible_windows","w","get_unique_manager_type_name","only_visible","only_invisible","visibility_text","owner_pid","userspace_kernel","window_id","get_window_by_id","show_subcommand","hide","hide_subcommand","close_subcommand","center","center_subcommand","aliases","value_parts","final_value","pm","toLocaleString","longest_command_length","get_command_space","subtract","on_data","reply_timeout","return_code","msg_data","service_subcommand","reload_services_subcommand","set_custom_flag","buttons","display","alignItems","gap","padding","fsedit_button","innerText","fontSize","onclick","mc_button","mc_image","objectFit","alt","draggable","trigger_file","source_path","dest_path","LocalStorageFS","current_dir","MADE_DIR","part_idx","DELETED_DIR","src_node","p","basename","current","get_node","dest_parts","dest_basename","final_parent","final_name","dest_exists","dest_parent_obj","LISTING_DIR","current_part","binary_string","atob","bytes","m","charCodeAt","TextDecoder","decode","uint","TextEncoder","encode","ArrayBuffer","btoa","String","fromCharCode","apply","readonly_list","src_parts","new_file_name","new_current_dir","string_to_array","array_to_b64","migrations","migrate_old_string_fs","migrate_old_array_fs","is_outer","current_obj","OPFSFileSystem","_opfs_handle","storage","getDirectory","handle","get_root_handle","root","current_handle","getDirectoryHandle","DOMException","getFileHandle","err2","removeEntry","src_basename","src_handle","src_parent_handle","dest_parent_handle","final_dest_parent_handle","final_dest_name","dest_handle","move","new_dest_handle","kind","file_handle","getFile","array_buffer","dest_file_handle","writable","createWritable","src_subdir_handle","dest_subdir_handle","data_to_write","generate_project_folder","data_projects_dir","project_entry","project_data","project_dir","info_content","primary_language","live_url","image","file_ext_regex","image_ext","skip_cache","ttl_cache","ttl_cache_obj","fetch_file_with_ttl","sub_projects","sub_project_entry","AbstractWindow","_owner_pid","create_userspace_proxy_as_other_window","manager","maximised","create_userspace_proxy_as_full_window","manager_proxy","new_title","css_width","css_height","css_pos","is_visible","toggle","wait_for_event","AbstractWindowManager","DOMWindowManager","_manager","_window_id","_window_root","_window_top_bar","_window_top_bar_title","_window_top_bar_maximise_button","_content_host","_shadow_dom","_event_listeners","_title_text","moveable","resizable","_maximisable","_maximised","_custom_flags","classList","role","ariaHidden","zIndex","capture","_handle_window_blur","setAttribute","top_bar_controls","stopPropagation","minimise_button","ev","maximisable","close_button","bind","_start_drag","attachShadow","mode","_emit_event","activeElement","all","start_event","preventDefault","rect","getBoundingClientRect","offset_x","clientX","offset_y","clientY","top","mouse_move","move_event","new_rect","width_ratio","mouse_up","up_event","remove_event_listener","contains","get_custom_flag","flag","ollieos","howler","xterm","fitAddon","webLinksAddon","imageAddon","xtermLinkProvider","sweetalert2","boot_os","prog","absolute_boot","absolute_init","absolute_etc","absolute_boot_target","absolute_default_shell","absolute_sys","absolute_privilege_agent","setup_boot","motd_content","absolute_motd","setup_motd","absolute_ollie_profile","absolute_ash_profile","absolute_ollierc","absolute_ashrc","migrate_rc_profile","credits_content","absolute_credits","setup_credits","latest_rev","data_dir","existing_rev","version_file","rev","svc_version","possible_backup_dir","groups","group","group_dir","group_index","file_data","setup_data_repo","data_rev","absolute_projects","project_rev","project_index_file","projects","project_file","setup_projects","initial_fs_setup","cursorBlink","fit","FitAddon","loadAddon","WebLinksAddon","ImageAddon","render","innerWidth","wrapped","dataset"],"sourceRoot":""}