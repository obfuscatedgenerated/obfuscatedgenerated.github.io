{"version":3,"file":"os.d40d264af96cdefbedfc.chunk.js","mappings":"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","sources":["webpack://ollieos/./src/term_ctl.ts","webpack://ollieos/./src/prog_registry.ts","webpack://ollieos/./src/filesystem.ts","webpack://ollieos/./src/processes.ts","webpack://ollieos/./src/sfx_registry.ts","webpack://ollieos/./src/kernel.ts","webpack://ollieos/./src/programs/core/ignition/services.ts","webpack://ollieos/./src/programs/core/ignition/index.ts","webpack://ollieos/./src/programs/core/jetty.ts","webpack://ollieos/./src/programs/core/ash/memory.ts","webpack://ollieos/./src/programs/core/ash/parser.ts","webpack://ollieos/./src/programs/core/ash/core.ts","webpack://ollieos/./src/programs/core/ash/tab_completion.ts","webpack://ollieos/./src/programs/core/ash/index.ts","webpack://ollieos/./src/programs/core/ash/key_handlers.ts","webpack://ollieos/./src/programs/core/default_privilege_agent.ts","webpack://ollieos/./src/programs/help.ts","webpack://ollieos/./src/programs/shutdown.ts","webpack://ollieos/./src/programs/clear.ts","webpack://ollieos/./src/programs/echo.ts","webpack://ollieos/./src/programs/unset.ts","webpack://ollieos/./src/programs/ls.ts","webpack://ollieos/./src/programs/cd.ts","webpack://ollieos/./src/programs/pwd.ts","webpack://ollieos/./src/programs/edit.ts","webpack://ollieos/./src/programs/webget.ts","webpack://ollieos/./src/programs/cat.ts","webpack://ollieos/./src/programs/hex.ts","webpack://ollieos/./src/programs/mefetch.ts","webpack://ollieos/./src/programs/reader.ts","webpack://ollieos/./src/programs/selfdestruct.ts","webpack://ollieos/./src/programs/imagine.ts","webpack://ollieos/./src/programs/ascmagine.ts","webpack://ollieos/./src/programs/fsedit.ts","webpack://ollieos/./src/programs/rm.ts","webpack://ollieos/./src/programs/bugreport.ts","webpack://ollieos/./src/programs/repo.ts","webpack://ollieos/./src/programs/rss.ts","webpack://ollieos/./src/programs/legacy.ts","webpack://ollieos/./src/programs/tour.ts","webpack://ollieos/./src/programs/pkg/remove.ts","webpack://ollieos/./src/programs/pkg/add.ts","webpack://ollieos/./src/programs/pkg/list.ts","webpack://ollieos/./src/programs/pkg/info.ts","webpack://ollieos/./src/programs/pkg/browse.ts","webpack://ollieos/./src/programs/pkg/index.ts","webpack://ollieos/./src/programs/touch.ts","webpack://ollieos/./src/programs/mkdir.ts","webpack://ollieos/./src/programs/mv.ts","webpack://ollieos/./src/programs/window/info.ts","webpack://ollieos/./src/programs/window/list.ts","webpack://ollieos/./src/programs/window/show.ts","webpack://ollieos/./src/programs/window/hide.ts","webpack://ollieos/./src/programs/window/close.ts","webpack://ollieos/./src/programs/window/center.ts","webpack://ollieos/./src/programs/window/index.ts","webpack://ollieos/./src/programs/alias.ts","webpack://ollieos/./src/programs/unalias.ts","webpack://ollieos/./src/programs/ps.ts","webpack://ollieos/./src/programs/kill.ts","webpack://ollieos/./src/programs/spark/service.ts","webpack://ollieos/./src/programs/spark/reload_services.ts","webpack://ollieos/./src/programs/spark/index.ts","webpack://ollieos/./src/programs/ipc_bg_test.ts","webpack://ollieos/./src/programs/ipc_fg_test.ts","webpack://ollieos/./src/programs/taskbar_test.ts","webpack://ollieos/./src/programs/pkg/triggers/create_trigger.ts","webpack://ollieos/./src/programs/pkg/triggers/remove_trigger.ts","webpack://ollieos/./src/fs_impl/localstorage.ts","webpack://ollieos/./src/fs_impl/opfs.ts","webpack://ollieos/./src/initial_fs_setup.ts","webpack://ollieos/./src/windowing.ts","webpack://ollieos/./src/window_impl/dom.ts","webpack://ollieos/./src/load_global_externals.ts","webpack://ollieos/./src/bootloader.ts"],"sourcesContent":["import {IDisposable, ITerminalOptions, Terminal} from \"@xterm/xterm\";\r\nimport type {KeyEvent, KeyEventHandler, RegisteredKeyEventIdentifier} from \"./types\";\r\n\r\nexport const NEWLINE = \"\\r\\n\";\r\n/* eslint-disable-next-line no-control-regex, no-misleading-character-class */\r\nexport const NON_PRINTABLE_REGEX = /[\\0-\\x1F\\x7F-\\x9F\\xAD\\u0378\\u0379\\u037F-\\u0383\\u038B\\u038D\\u03A2\\u0528-\\u0530\\u0557\\u0558\\u0560\\u0588\\u058B-\\u058E\\u0590\\u05C8-\\u05CF\\u05EB-\\u05EF\\u05F5-\\u0605\\u061C\\u061D\\u06DD\\u070E\\u070F\\u074B\\u074C\\u07B2-\\u07BF\\u07FB-\\u07FF\\u082E\\u082F\\u083F\\u085C\\u085D\\u085F-\\u089F\\u08A1\\u08AD-\\u08E3\\u08FF\\u0978\\u0980\\u0984\\u098D\\u098E\\u0991\\u0992\\u09A9\\u09B1\\u09B3-\\u09B5\\u09BA\\u09BB\\u09C5\\u09C6\\u09C9\\u09CA\\u09CF-\\u09D6\\u09D8-\\u09DB\\u09DE\\u09E4\\u09E5\\u09FC-\\u0A00\\u0A04\\u0A0B-\\u0A0E\\u0A11\\u0A12\\u0A29\\u0A31\\u0A34\\u0A37\\u0A3A\\u0A3B\\u0A3D\\u0A43-\\u0A46\\u0A49\\u0A4A\\u0A4E-\\u0A50\\u0A52-\\u0A58\\u0A5D\\u0A5F-\\u0A65\\u0A76-\\u0A80\\u0A84\\u0A8E\\u0A92\\u0AA9\\u0AB1\\u0AB4\\u0ABA\\u0ABB\\u0AC6\\u0ACA\\u0ACE\\u0ACF\\u0AD1-\\u0ADF\\u0AE4\\u0AE5\\u0AF2-\\u0B00\\u0B04\\u0B0D\\u0B0E\\u0B11\\u0B12\\u0B29\\u0B31\\u0B34\\u0B3A\\u0B3B\\u0B45\\u0B46\\u0B49\\u0B4A\\u0B4E-\\u0B55\\u0B58-\\u0B5B\\u0B5E\\u0B64\\u0B65\\u0B78-\\u0B81\\u0B84\\u0B8B-\\u0B8D\\u0B91\\u0B96-\\u0B98\\u0B9B\\u0B9D\\u0BA0-\\u0BA2\\u0BA5-\\u0BA7\\u0BAB-\\u0BAD\\u0BBA-\\u0BBD\\u0BC3-\\u0BC5\\u0BC9\\u0BCE\\u0BCF\\u0BD1-\\u0BD6\\u0BD8-\\u0BE5\\u0BFB-\\u0C00\\u0C04\\u0C0D\\u0C11\\u0C29\\u0C34\\u0C3A-\\u0C3C\\u0C45\\u0C49\\u0C4E-\\u0C54\\u0C57\\u0C5A-\\u0C5F\\u0C64\\u0C65\\u0C70-\\u0C77\\u0C80\\u0C81\\u0C84\\u0C8D\\u0C91\\u0CA9\\u0CB4\\u0CBA\\u0CBB\\u0CC5\\u0CC9\\u0CCE-\\u0CD4\\u0CD7-\\u0CDD\\u0CDF\\u0CE4\\u0CE5\\u0CF0\\u0CF3-\\u0D01\\u0D04\\u0D0D\\u0D11\\u0D3B\\u0D3C\\u0D45\\u0D49\\u0D4F-\\u0D56\\u0D58-\\u0D5F\\u0D64\\u0D65\\u0D76-\\u0D78\\u0D80\\u0D81\\u0D84\\u0D97-\\u0D99\\u0DB2\\u0DBC\\u0DBE\\u0DBF\\u0DC7-\\u0DC9\\u0DCB-\\u0DCE\\u0DD5\\u0DD7\\u0DE0-\\u0DF1\\u0DF5-\\u0E00\\u0E3B-\\u0E3E\\u0E5C-\\u0E80\\u0E83\\u0E85\\u0E86\\u0E89\\u0E8B\\u0E8C\\u0E8E-\\u0E93\\u0E98\\u0EA0\\u0EA4\\u0EA6\\u0EA8\\u0EA9\\u0EAC\\u0EBA\\u0EBE\\u0EBF\\u0EC5\\u0EC7\\u0ECE\\u0ECF\\u0EDA\\u0EDB\\u0EE0-\\u0EFF\\u0F48\\u0F6D-\\u0F70\\u0F98\\u0FBD\\u0FCD\\u0FDB-\\u0FFF\\u10C6\\u10C8-\\u10CC\\u10CE\\u10CF\\u1249\\u124E\\u124F\\u1257\\u1259\\u125E\\u125F\\u1289\\u128E\\u128F\\u12B1\\u12B6\\u12B7\\u12BF\\u12C1\\u12C6\\u12C7\\u12D7\\u1311\\u1316\\u1317\\u135B\\u135C\\u137D-\\u137F\\u139A-\\u139F\\u13F5-\\u13FF\\u169D-\\u169F\\u16F1-\\u16FF\\u170D\\u1715-\\u171F\\u1737-\\u173F\\u1754-\\u175F\\u176D\\u1771\\u1774-\\u177F\\u17DE\\u17DF\\u17EA-\\u17EF\\u17FA-\\u17FF\\u180F\\u181A-\\u181F\\u1878-\\u187F\\u18AB-\\u18AF\\u18F6-\\u18FF\\u191D-\\u191F\\u192C-\\u192F\\u193C-\\u193F\\u1941-\\u1943\\u196E\\u196F\\u1975-\\u197F\\u19AC-\\u19AF\\u19CA-\\u19CF\\u19DB-\\u19DD\\u1A1C\\u1A1D\\u1A5F\\u1A7D\\u1A7E\\u1A8A-\\u1A8F\\u1A9A-\\u1A9F\\u1AAE-\\u1AFF\\u1B4C-\\u1B4F\\u1B7D-\\u1B7F\\u1BF4-\\u1BFB\\u1C38-\\u1C3A\\u1C4A-\\u1C4C\\u1C80-\\u1CBF\\u1CC8-\\u1CCF\\u1CF7-\\u1CFF\\u1DE7-\\u1DFB\\u1F16\\u1F17\\u1F1E\\u1F1F\\u1F46\\u1F47\\u1F4E\\u1F4F\\u1F58\\u1F5A\\u1F5C\\u1F5E\\u1F7E\\u1F7F\\u1FB5\\u1FC5\\u1FD4\\u1FD5\\u1FDC\\u1FF0\\u1FF1\\u1FF5\\u1FFF\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u2072\\u2073\\u208F\\u209D-\\u209F\\u20BB-\\u20CF\\u20F1-\\u20FF\\u218A-\\u218F\\u23F4-\\u23FF\\u2427-\\u243F\\u244B-\\u245F\\u2700\\u2B4D-\\u2B4F\\u2B5A-\\u2BFF\\u2C2F\\u2C5F\\u2CF4-\\u2CF8\\u2D26\\u2D28-\\u2D2C\\u2D2E\\u2D2F\\u2D68-\\u2D6E\\u2D71-\\u2D7E\\u2D97-\\u2D9F\\u2DA7\\u2DAF\\u2DB7\\u2DBF\\u2DC7\\u2DCF\\u2DD7\\u2DDF\\u2E3C-\\u2E7F\\u2E9A\\u2EF4-\\u2EFF\\u2FD6-\\u2FEF\\u2FFC-\\u2FFF\\u3040\\u3097\\u3098\\u3100-\\u3104\\u312E-\\u3130\\u318F\\u31BB-\\u31BF\\u31E4-\\u31EF\\u321F\\u32FF\\u4DB6-\\u4DBF\\u9FCD-\\u9FFF\\uA48D-\\uA48F\\uA4C7-\\uA4CF\\uA62C-\\uA63F\\uA698-\\uA69E\\uA6F8-\\uA6FF\\uA78F\\uA794-\\uA79F\\uA7AB-\\uA7F7\\uA82C-\\uA82F\\uA83A-\\uA83F\\uA878-\\uA87F\\uA8C5-\\uA8CD\\uA8DA-\\uA8DF\\uA8FC-\\uA8FF\\uA954-\\uA95E\\uA97D-\\uA97F\\uA9CE\\uA9DA-\\uA9DD\\uA9E0-\\uA9FF\\uAA37-\\uAA3F\\uAA4E\\uAA4F\\uAA5A\\uAA5B\\uAA7C-\\uAA7F\\uAAC3-\\uAADA\\uAAF7-\\uAB00\\uAB07\\uAB08\\uAB0F\\uAB10\\uAB17-\\uAB1F\\uAB27\\uAB2F-\\uABBF\\uABEE\\uABEF\\uABFA-\\uABFF\\uD7A4-\\uD7AF\\uD7C7-\\uD7CA\\uD7FC-\\uF8FF\\uFA6E\\uFA6F\\uFADA-\\uFAFF\\uFB07-\\uFB12\\uFB18-\\uFB1C\\uFB37\\uFB3D\\uFB3F\\uFB42\\uFB45\\uFBC2-\\uFBD2\\uFD40-\\uFD4F\\uFD90\\uFD91\\uFDC8-\\uFDEF\\uFDFE\\uFDFF\\uFE1A-\\uFE1F\\uFE27-\\uFE2F\\uFE53\\uFE67\\uFE6C-\\uFE6F\\uFE75\\uFEFD-\\uFF00\\uFFBF-\\uFFC1\\uFFC8\\uFFC9\\uFFD0\\uFFD1\\uFFD8\\uFFD9\\uFFDD-\\uFFDF\\uFFE7\\uFFEF-\\uFFFB\\uFFFE\\uFFFF]/g;\r\nexport const ANSI_ESCAPE_REGEX = /(\\\\u001b|\\\\x1b)(8|7|H|>|\\[(\\?\\d+(h|l)|[0-2]?(K|J)|\\d*(A|B|C|D\\D|E|F|G|g|i|m|n|S|s|T|u)|1000D\\d+|\\d*;\\d*(f|H|r|m)|\\d+;\\d+;\\d+m))/g;\r\n\r\n// eslint-disable-next-line no-control-regex, no-misleading-character-class\r\nexport const ANSI_UNESCAPED_REGEX = /(\\u001b|\\x1b)\\[(\\d+)?(;\\d+)*m/g;\r\n\r\n\r\nconst FG = {\r\n    reset: \"\\x1B[39m\",\r\n    black: \"\\x1B[30m\",\r\n    red: \"\\x1B[31m\",\r\n    green: \"\\x1B[32m\",\r\n    yellow: \"\\x1B[33m\",\r\n    blue: \"\\x1B[34m\",\r\n    magenta: \"\\x1B[35m\",\r\n    cyan: \"\\x1B[36m\",\r\n    white: \"\\x1B[37m\",\r\n    gray: \"\\x1B[90m\"\r\n};\r\n\r\nconst BG = {\r\n    reset: \"\\x1B[49m\",\r\n    black: \"\\x1B[40m\",\r\n    red: \"\\x1B[41m\",\r\n    green: \"\\x1B[42m\",\r\n    yellow: \"\\x1B[44m\",\r\n    blue: \"\\x1B[44m\",\r\n    magenta: \"\\x1B[45m\",\r\n    cyan: \"\\x1B[46m\",\r\n    white: \"\\x1B[47m\",\r\n    gray: \"\\x1B[100m\"\r\n}\r\n\r\nconst STYLE = {\r\n    reset_all: \"\\x1B[0m\",\r\n    bold: \"\\x1B[1m\",\r\n    dim: \"\\x1B[2m\",\r\n    no_bold_or_dim: \"\\x1B[22m\",\r\n    italic: \"\\x1B[3m\",\r\n    no_italic: \"\\x1B[23m\",\r\n    underline: \"\\x1B[4m\",\r\n    double_underline: \"\\x1B[21m\",\r\n    no_underline: \"\\x1B[24m\",\r\n    inverse: \"\\x1B[7m\",\r\n    no_inverse: \"\\x1B[27m\",\r\n    hidden: \"\\x1B[8m\",\r\n    no_hidden: \"\\x1B[28m\",\r\n    strikethrough: \"\\x1B[9m\",\r\n    no_strikethrough: \"\\x1B[29m\",\r\n    negative: \"\\x1B[7m\",\r\n    positive: \"\\x1B[27m\"\r\n}\r\n\r\nconst CURSOR = {\r\n    // TODO: move cursor manipulation from edit to substitution functions here\r\n    invisible: \"\\x1B[?25l\",\r\n    visible: \"\\x1B[?25h\",\r\n}\r\n\r\nconst PREFABS = {\r\n    program_name: FG.cyan + STYLE.italic + STYLE.bold,\r\n    error: FG.red + STYLE.bold,\r\n    variable_name: FG.yellow + STYLE.bold,\r\n    file_path: FG.green + STYLE.bold,\r\n    dir_name: FG.blue + STYLE.bold,\r\n    secret: STYLE.hidden + CURSOR.invisible,\r\n}\r\n\r\nexport const ANSI = {\r\n    FG,\r\n    BG,\r\n    STYLE,\r\n    CURSOR,\r\n    PREFABS\r\n}\r\n\r\n\r\n// TODO: docstrings everywhere\r\n\r\nexport interface ReadLineBuffer {\r\n    current_line: string;\r\n    current_index: number;\r\n    set_current_line: (new_line: string) => void;\r\n    set_current_index: (new_index: number) => void;\r\n}\r\n\r\nexport type ReadLineKeyHandler = (event: KeyEvent, term: WrappedTerminal, buffer: ReadLineBuffer) => void | Promise<void> | boolean | Promise<boolean>;\r\n\r\nexport class WrappedTerminal extends Terminal {\r\n    #disposable_onkey: IDisposable;\r\n\r\n    readonly #key_handlers: Map<RegisteredKeyEventIdentifier, { handler: KeyEventHandler, block: boolean }[]> = new Map();\r\n    readonly #on_printable_handlers: KeyEventHandler[] = [];\r\n    readonly #key_event_queue: KeyEvent[] = [];\r\n    #is_handling_key_events = false;\r\n\r\n    #kernel_has_panicked = false;\r\n\r\n    // TODO: this exporting is a bit lazy, but it works for now\r\n\r\n    get ansi() {\r\n        return ANSI;\r\n    }\r\n\r\n    get newline() {\r\n        return NEWLINE;\r\n    }\r\n\r\n    get non_printable_regex() {\r\n        return NON_PRINTABLE_REGEX;\r\n    }\r\n\r\n    get ansi_escape_regex() {\r\n        return ANSI_ESCAPE_REGEX;\r\n    }\r\n\r\n    get ansi_unescaped_regex() {\r\n        return ANSI_UNESCAPED_REGEX;\r\n    }\r\n\r\n    // line discipline now completely handled by read_line, no global event loop\r\n    read_line = async (custom_key_handlers: { [key_string: string]: ReadLineKeyHandler } = {}, custom_printable_handler?: ReadLineKeyHandler): Promise<string> => {\r\n        const buffer: ReadLineBuffer = {\r\n            current_line: \"\",\r\n            current_index: 0,\r\n\r\n            set_current_line: (new_line: string) => {\r\n                buffer.current_line = new_line;\r\n            },\r\n\r\n            set_current_index: (new_index: number) => {\r\n                buffer.current_index = new_index;\r\n            }\r\n        };\r\n\r\n        let handler_dispose: (() => void) | null = null;\r\n\r\n        return new Promise<string>((resolve) => {\r\n            const handlers: { [key_string: string]: KeyEventHandler } = {\r\n                // arrow left - move cursor left\r\n                \"\\x1b[D\": (_e, term) => {\r\n                    if (buffer.current_index > 0) {\r\n                        term.write(\"\\b\");\r\n                        buffer.current_index--;\r\n                    }\r\n                },\r\n\r\n                // arrow right - move cursor right\r\n                \"\\x1b[C\": (_e, term) => {\r\n                    if (buffer.current_index < buffer.current_line.length) {\r\n                        term.write(buffer.current_line[buffer.current_index]);\r\n                        buffer.current_index++;\r\n                    }\r\n                },\r\n\r\n                // backspace - delete character\r\n                \"\\x7F\": (_e, term) => {\r\n                    if (buffer.current_line.length > 0 && buffer.current_index > 0) {\r\n                        // get everything before the cursor\r\n                        const before = buffer.current_line.slice(0, buffer.current_index - 1);\r\n\r\n                        // get everything after the cursor\r\n                        const after = buffer.current_line.slice(buffer.current_index);\r\n\r\n                        // update current line\r\n                        buffer.current_line = before + after;\r\n\r\n                        // move cursor back one\r\n                        term.write(\"\\b\");\r\n\r\n                        // overwrite with after content and a space (remove last character)\r\n                        term.write(after + \" \");\r\n\r\n                        // move cursor back to original position\r\n                        term.write(\"\\b\".repeat(after.length + 1));\r\n                        buffer.current_index--;\r\n                    }\r\n                },\r\n\r\n                // enter - finish line\r\n                \"\\r\": (_e, term) => {\r\n                    if (handler_dispose) {\r\n                        handler_dispose();\r\n                    }\r\n\r\n                    term.write(NEWLINE);\r\n                    resolve(buffer.current_line);\r\n                }\r\n            }\r\n\r\n            // register blocking catch all key handler which handles all keys during read_line\r\n            handler_dispose = this.register_key_event_handler(\r\n                async (e) => {\r\n                    // check for custom handlers first\r\n                    if (e.key in custom_key_handlers) {\r\n                        const block = await custom_key_handlers[e.key](e, this, buffer);\r\n\r\n                        if (block) {\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    // check for builtin handlers\r\n                    if (e.key in handlers) {\r\n                        await handlers[e.key](e, this);\r\n                        return;\r\n                    }\r\n\r\n                    // check for printable characters\r\n                    if (e.key.match(NON_PRINTABLE_REGEX) === null) {\r\n                        if (custom_printable_handler) {\r\n                            const block = await custom_printable_handler(e, this, buffer);\r\n\r\n                            if (block) {\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        // if at the end of the line, just append the character\r\n                        if (buffer.current_index === buffer.current_line.length) {\r\n                            buffer.current_line += e.key;\r\n                            this.write(e.key);\r\n                            buffer.current_index++;\r\n                            return;\r\n                        }\r\n\r\n                        // insert the character at the cursor, shift the rest of the line to the right\r\n                        const before_cursor = buffer.current_line.slice(0, buffer.current_index);\r\n                        const after_cursor = buffer.current_line.slice(buffer.current_index);\r\n                        buffer.current_line = before_cursor + e.key + after_cursor;\r\n\r\n                        // write the new right of the line over the old one\r\n                        this.write(e.key + after_cursor);\r\n\r\n                        // move back to the cursor position\r\n                        this.write(`\\x1b[${after_cursor.length}D`);\r\n\r\n                        // increment the cursor position\r\n                        buffer.current_index++;\r\n                    } else {\r\n                        console.warn(\"Ignored key event:\", e);\r\n                        // TODO: handle more special keys and sequences (probably in shells)\r\n                    }\r\n                },\r\n                {\r\n                    block: true,\r\n                    high_priority: true\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    _search_handlers = (key: string | undefined, domEventCode: string | undefined, strict = false): { handler: KeyEventHandler, block: boolean }[] => {\r\n        for (const pair of this.#key_handlers.entries()) {\r\n            const identfier = pair[0] as RegisteredKeyEventIdentifier;\r\n\r\n            // if strict matching is required, both key and domEventCode must match\r\n            if (strict) {\r\n                if (identfier.key === key && identfier.domEventCode === domEventCode) {\r\n                    return pair[1] as { handler: KeyEventHandler, block: boolean }[];\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // if the identifier matches, return the entries\r\n            if (identfier.key === key || identfier.domEventCode === domEventCode) {\r\n                return pair[1] as { handler: KeyEventHandler, block: boolean }[];\r\n            }\r\n        }\r\n\r\n        // if no match is found, return an empty array\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Registers a key event handler.\r\n     * Handlers with no filter run BEFORE filtered handlers.\r\n     *\r\n     * @param {KeyEventHandler} handler The handler to register\r\n     * @param {{ keyString?: string, domEventCode?: string, block: boolean, high_priority: boolean }} props The properties of the handler. Key is the key as a string to filter by, domEventCode is the DOM event code to filter by. Block determines whether the event should be blocked from bubbling up to following handlers and/or the terminal display. High priority determines whether the handler should be placed at the beginning of the handler list.\r\n     * @returns {() => () => void} A function to unregister the handler\r\n     */\r\n    register_key_event_handler = (handler: KeyEventHandler, props: { keyString?: string, domEventCode?: string, block?: boolean, high_priority?: boolean }) => {\r\n        // build the identifier\r\n        const identifier: RegisteredKeyEventIdentifier = {\r\n            key: props.keyString,\r\n            domEventCode: props.domEventCode\r\n        };\r\n\r\n        const entry = { handler, block: props.block ?? false };\r\n\r\n        // if the identifier has not already been registered, create a new array for it\r\n        const existing_entries = this._search_handlers(props.keyString, props.domEventCode, true);\r\n        if (existing_entries.length === 0) {\r\n            this.#key_handlers.set(identifier, [entry]);\r\n        } else {\r\n            // otherwise, add the handler to the existing array\r\n            // NOTE: reference is retained so no need to search\r\n            if (props.high_priority) {\r\n                existing_entries.unshift(entry);\r\n            } else {\r\n                existing_entries.push(entry);\r\n            }\r\n        }\r\n\r\n        // return a function to unregister the handler\r\n        // NOTE: reference is retained so no need to search\r\n        return () => {\r\n            const handlers = this.#key_handlers.get(identifier);\r\n            if (!handlers) {\r\n                return;\r\n            }\r\n\r\n            handlers.splice(handlers.indexOf(entry), 1);\r\n\r\n            // if there are no more handlers for the identifier, remove the identifier from the map\r\n            if (handlers.length === 0) {\r\n                this.#key_handlers.delete(identifier);\r\n            }\r\n        }\r\n    }\r\n\r\n    _handle_key_event = async (e: KeyEvent): Promise<void> => {\r\n        // TODO: supress builtin key events when program is running, create ctrl+c handler\r\n\r\n        // look for any handlers against all keys\r\n        const all_key_entries = this._search_handlers(undefined, undefined, true);\r\n        if (all_key_entries) {\r\n            for (const entry of all_key_entries) {\r\n                // await if the handler is async\r\n                await entry.handler(e, this);\r\n\r\n                if (entry.block) {\r\n                    // if the handler is blocking, don't go to next handler or display logic\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // search the handlers for the key\r\n        const entries = this._search_handlers(e.key, e.domEvent.code);\r\n\r\n        // if there are any handlers, run them\r\n        for (const entry of entries) {\r\n            // await if the handler is async\r\n            await entry.handler(e, this);\r\n\r\n            if (entry.block) {\r\n                // if the handler is blocking, don't go to next handler or display logic\r\n                return;\r\n            }\r\n        }\r\n\r\n        // check if the key is printable\r\n        if (e.key.match(NON_PRINTABLE_REGEX) === null) {\r\n            // call any registered printable key handlers\r\n            for (const handler of this.#on_printable_handlers) {\r\n                await handler(e, this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers a handler that is called when any printable key is pressed.\r\n     * @param handler  - The handler to register\r\n     * @param high_priority - If true, the handler will be placed at the beginning of the handler list (cannot run before the default printable key handler)\r\n     */\r\n    register_on_printable_key_event_handler = (handler: KeyEventHandler, high_priority = false) => {\r\n        if (high_priority) {\r\n            this.#on_printable_handlers.unshift(handler);\r\n        } else {\r\n            this.#on_printable_handlers.push(handler);\r\n        }\r\n    }\r\n\r\n    _enqueue_key_event = (e: KeyEvent) => {\r\n        this.#key_event_queue.push(e);\r\n\r\n        // if the queue is not being handled, handle it\r\n        if (!this.#is_handling_key_events) {\r\n            this.#is_handling_key_events = true;\r\n            this._handle_key_event_queue();\r\n        }\r\n    }\r\n\r\n    _handle_key_event_queue = async () => {\r\n        // if there are no events in the queue, return\r\n        if (this.#key_event_queue.length === 0) {\r\n            this.#is_handling_key_events = false;\r\n            return;\r\n        }\r\n\r\n        if (this.#is_handling_key_events) {\r\n            // handle the first event in the queue\r\n            await this._handle_key_event(this.#key_event_queue.shift()!);\r\n\r\n            // handle the rest of the events in the queue\r\n            this._handle_key_event_queue();\r\n        }\r\n    }\r\n\r\n\r\n    // note that this does not recieve pasted input, use a key event handler for that\r\n    wait_for_keypress = async (): Promise<KeyEvent> => {\r\n        // dispose of the current key handler (block bubbling)\r\n        this.#disposable_onkey.dispose();\r\n\r\n        return new Promise((resolve) => {\r\n            this.#disposable_onkey = this.onKey((e) => {\r\n                // dispose of this handler\r\n                this.#disposable_onkey.dispose();\r\n\r\n                // re-register the original handler\r\n                this.#disposable_onkey = this.onKey(this._enqueue_key_event);\r\n\r\n                // resolve the promise\r\n                resolve(e);\r\n            });\r\n        });\r\n    }\r\n\r\n    get_text = async (max_length?: number): Promise<string> => {\r\n        let text = \"\";\r\n\r\n        return new Promise((resolve) => {\r\n            const unregister_handler = this.register_key_event_handler(\r\n                (e) => {\r\n                    if (e.key === \"\\r\") {\r\n                        // if the key is enter, return the text\r\n                        unregister_handler();\r\n                        resolve(text);\r\n                    } else if (e.key === \"\\x7F\") {\r\n                        // if the key is backspace, remove the last character\r\n                        if (text.length > 0) {\r\n                            text = text.slice(0, -1);\r\n                            this.write(\"\\b \\b\");\r\n                        }\r\n                    } else if (e.key.match(NON_PRINTABLE_REGEX) === null) {\r\n                        // if the key is printable, add it to the text\r\n                        if (max_length === undefined || text.length < max_length) {\r\n                            text += e.key;\r\n                            this.write(e.key);\r\n                        }\r\n                    }\r\n                },\r\n                {\r\n                    block: true,\r\n                    high_priority: true\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    word_wrap(text: string, width: number): string {\r\n        const lines = text.split(NEWLINE);\r\n        const wrapped_lines: string[] = [];\r\n\r\n        for (const line of lines) {\r\n            const words = line.split(\" \");\r\n            let current_line = \"\";\r\n\r\n            for (const word of words) {\r\n                if (current_line.length + word.length + 1 > width) {\r\n                    // push word by word until the line is full\r\n                    wrapped_lines.push(current_line);\r\n                    current_line = word;\r\n                } else {\r\n                    // if the current line is empty, don't add a space\r\n                    if (current_line.length === 0) {\r\n                        current_line = word;\r\n                    } else {\r\n                        current_line += \" \" + word;\r\n                    }\r\n                }\r\n            }\r\n\r\n            wrapped_lines.push(current_line);\r\n        }\r\n\r\n        return wrapped_lines.join(NEWLINE);\r\n    }\r\n\r\n    copy() {\r\n        // copy the selected text to the clipboard\r\n        navigator.clipboard.writeText(this.getSelection()).then(() => {\r\n            // clear the selection\r\n            this.clearSelection();\r\n        });\r\n    }\r\n\r\n    paste() {\r\n        if (this.#kernel_has_panicked) {\r\n            return;\r\n        }\r\n\r\n        // TODO: sometimes has issues with large text (queue consumption not restarted properly after execution)\r\n        // read the clipboard\r\n        navigator.clipboard.readText().then((text) => {\r\n            // simulate key events for each character (lazy but it works great, no need to rewrite the key handler)\r\n            for (const char of text) {\r\n                let dom_event_code = `Key${char.toUpperCase()}`;\r\n                let key = char;\r\n\r\n                if (char === \"\\r\") {\r\n                    // skip, its CRLF\r\n                    continue;\r\n                }\r\n\r\n                if (char === \"\\n\") {\r\n                    key = \"\\r\";\r\n                    dom_event_code = \"Enter\";\r\n                }\r\n\r\n                if (char === \" \") {\r\n                    dom_event_code = \"Space\";\r\n                }\r\n\r\n                this.#key_event_queue.push(({ key, domEvent: { code: dom_event_code } } as KeyEvent));\r\n            }\r\n\r\n            // if the queue is not being handled, handle it\r\n            if (!this.#is_handling_key_events) {\r\n                this.#is_handling_key_events = true;\r\n                this._handle_key_event_queue();\r\n            }\r\n        });\r\n    }\r\n\r\n    copy_or_paste() {\r\n        // if there is a selection, copy it\r\n        if (this.hasSelection()) {\r\n            this.copy();\r\n        } else {\r\n            this.paste();\r\n        }\r\n    }\r\n\r\n    handle_kernel_panic = (message: string, process_info: string, debug_info?: string) => {\r\n        if (this.#kernel_has_panicked) {\r\n            return;\r\n        }\r\n\r\n        this.#kernel_has_panicked = true;\r\n\r\n        this.reset();\r\n\r\n        // stop reading key events\r\n        this.#disposable_onkey.dispose();\r\n        this.write(ANSI.CURSOR.invisible);\r\n\r\n        if (this.textarea) {\r\n            this.textarea.disabled = true;\r\n        }\r\n\r\n        this.writeln(`${ANSI.BG.red + ANSI.FG.white}Panic: ${message}`);\r\n        this.writeln(`at time: ${new Date().toISOString()}`);\r\n\r\n        this.write(NEWLINE);\r\n        this.writeln(\"Debug info:\");\r\n        if (debug_info) {\r\n            this.writeln(debug_info);\r\n        } else {\r\n            this.writeln(\"No debug info provided.\");\r\n        }\r\n\r\n        this.write(NEWLINE);\r\n        this.writeln(\"Processes running at time of panic:\");\r\n        this.writeln(process_info || \"None.\");\r\n\r\n        if (typeof window !== \"undefined\") {\r\n            this.write(NEWLINE);\r\n            this.writeln(\"OS unrecoverable?\")\r\n            this.writeln(`Visit ${window.location.origin}/recover_fs if stuck.`);\r\n        }\r\n\r\n        this.writeln(ANSI.STYLE.reset_all);\r\n    }\r\n\r\n    constructor(xterm_opts?: ITerminalOptions) {\r\n        super(xterm_opts);\r\n        this.#disposable_onkey = this.onKey(this._enqueue_key_event);\r\n    }\r\n}\r\n\r\n// TODO: term needs hardening and possibly userspace protection to ensure programs cant dispatch keys to auto accept elevation prompts\r\n\r\n// as of 09/01/2026, the god class of WrappedTerminal is no more!\r\n// this used to be the kernel, shell, tty, and bootstrap all in one\r\n","import type { Program, ProgramRegistrant } from \"./types\";\r\nimport type { AbstractFileSystem } from \"./filesystem\";\r\nimport { ANSI, WrappedTerminal } from \"./term_ctl\";\r\n\r\nconst encode_js_to_url = (js_code: string): string => {\r\n    const encoded = encodeURIComponent(js_code);\r\n    return `data:text/javascript;charset=utf-8,${encoded}`;\r\n}\r\n\r\nexport const build_registrant_from_js = async (js_code: string, built_in = false): Promise<ProgramRegistrant> => {\r\n    // inspect the js code to see if it starts with \"import\". if so, this is outdated, put a deprecation warning\r\n    let warn_deprecation = false;\r\n    if (js_code.startsWith(\"import\")) {\r\n        // delay the warning as we might find out the program name later\r\n        warn_deprecation = true;\r\n    }\r\n\r\n    // note: the webpackIgnore bypasses webpack's import() function and uses the browser's native import() function\r\n    // this is because webpack's import() function does not support data urls\r\n\r\n    const data_url = encode_js_to_url(js_code);\r\n    // note: risk to user, show warning\r\n    // TODO: explore sandboxing via webworkers or other methods\r\n    const imp = await import(/* webpackIgnore: true */data_url);\r\n    let program = imp.default;\r\n\r\n    if (program === undefined) {\r\n        if (warn_deprecation) {\r\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\r\n        }\r\n\r\n        throw new Error(\"Program is not the default export.\");\r\n    }\r\n\r\n    // validate program\r\n    if (typeof program !== \"object\") {\r\n        if (warn_deprecation) {\r\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\r\n        }\r\n\r\n        throw new Error(\"Program is not an object.\");\r\n    }\r\n\r\n    program = program as object;\r\n\r\n    if (typeof program.name !== \"string\") {\r\n        if (warn_deprecation) {\r\n            console.warn(\"Program has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.\");\r\n        }\r\n\r\n        throw new Error(\"Program does not have a name.\");\r\n    }\r\n\r\n    if (warn_deprecation) {\r\n        console.warn(`Program ${program.name} has JS code starts with 'import'. Please update the package to use the new global externals system. This will be removed in the future.`);\r\n    }\r\n\r\n    // not warning about compat here to make it more obvious to end users when they try to run an incompatible program\r\n\r\n    if (globalThis.OLLIEOS_NODE && program.node_opt_out) {\r\n        throw new Error(`Program ${program.name} is not compatible with Node.js.`);\r\n    }\r\n\r\n    if (typeof program.description !== \"string\") {\r\n        throw new Error(`Program ${program.name} does not have a description.`);\r\n    }\r\n\r\n    if (typeof program.usage_suffix !== \"string\") {\r\n        throw new Error(`Program ${program.name} does not have a usage suffix.`);\r\n    }\r\n\r\n    if (typeof program.arg_descriptions !== \"object\") {\r\n        throw new Error(`Program ${program.name} does not have argument descriptions.`);\r\n    }\r\n\r\n    // migration: we got rid of syncprogram (with main) and asyncprogram (async_main)\r\n    // now there is a single async type called program\r\n    // problem: older packages have a field called async_main, and some have main that doesn't return a promise\r\n    if (!program.main) {\r\n        if (!program.async_main) {\r\n            throw new Error(`Program ${program.name} does not have a main function.`);\r\n        }\r\n\r\n        console.warn(`Program ${program.name} has an async_main function. This is deprecated and will be removed in the future. Please use main instead.`);\r\n\r\n        // migrate: rename async_main to main\r\n        program.main = program.async_main;\r\n        delete program.async_main;\r\n    }\r\n\r\n    if (program.main !== undefined && program.async_main !== undefined) {\r\n        throw new Error(`Program ${program.name} has both a main and async_main (deprecated) function.`);\r\n    }\r\n\r\n    // check if main is async\r\n    if (program.main !== undefined && program.main.constructor.name !== \"AsyncFunction\") {\r\n        console.warn(`Program ${program.name} has a main function that is not async. This is deprecated and will be removed in the future. Please make main async.`);\r\n\r\n        // migrate: wrap main in an async function\r\n        const old_main = program.main;\r\n        program.main = async (data) => {\r\n            return old_main(data);\r\n        }\r\n    }\r\n\r\n    program = program as Program;\r\n\r\n    // can't check what it takes and returns because javascript!\r\n    // just register it and the user can deal with the error if it doesn't work\r\n\r\n    return {\r\n        program,\r\n        built_in,\r\n    };\r\n}\r\n\r\nexport const determine_program_name_from_js = async (js_code: string): Promise<string> => {\r\n    const reg = await build_registrant_from_js(js_code);\r\n    return reg.program.name;\r\n}\r\n\r\n\r\n// mounts and registers a program and outputs errors to the terminal\r\nexport const mount_and_register_with_output = async (filename: string, content: string, prog_reg: ProgramRegistry | UserspaceProgramRegistry, term: WrappedTerminal, output_success = false) => {\r\n    const { PREFABS, FG, STYLE } = ANSI;\r\n\r\n    let reg: ProgramRegistrant;\r\n\r\n    try {\r\n        reg = await build_registrant_from_js(content);\r\n    } catch (e) {\r\n        if (e.message.endsWith(\"is not compatible with Node.js.\")) {\r\n            // silently skip node.js incompatible programs\r\n            // yes this is a weird way to do it, but better than changing how build_registrant works\r\n            return;\r\n        }\r\n\r\n        term.writeln(`${PREFABS.error}Failed to prepare program from '${filename}'.${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}${e}${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}Skipping mount...${STYLE.reset_all}`);\r\n        return;\r\n    }\r\n\r\n    try {\r\n        await prog_reg.registerProgram(reg);\r\n\r\n        if (output_success) {\r\n            term.writeln(`${FG.cyan}(+) ${reg.program.name}${STYLE.reset_all}`);\r\n        }\r\n    } catch (e) {\r\n        term.writeln(`${PREFABS.error}Failed to mount program '${reg.program.name}'.${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}${e}${STYLE.reset_all}`);\r\n        term.writeln(`${PREFABS.error}Skipping mount...${STYLE.reset_all}`);\r\n    }\r\n}\r\n\r\n// recurses through a directory and mounts and registers all programs in it as well as its subdirectories\r\nexport const recurse_mount_and_register_with_output = async (fs: AbstractFileSystem, dir_path: string, prog_registry: ProgramRegistry | UserspaceProgramRegistry, term: WrappedTerminal) => {\r\n    const entries = await fs.list_dir(dir_path);\r\n\r\n    for (const entry of entries) {\r\n        const entry_path = fs.join(dir_path, entry);\r\n\r\n        if (await fs.dir_exists(entry_path)) {\r\n            await recurse_mount_and_register_with_output(fs, entry_path, prog_registry, term);\r\n        } else {\r\n            if (!entry.endsWith(\".js\")) {\r\n                continue;\r\n            }\r\n\r\n            const content = await fs.read_file(entry_path) as string;\r\n            await mount_and_register_with_output(entry, content, prog_registry, term);\r\n        }\r\n    }\r\n}\r\n\r\n// TODO: these 2 methods are a bit messy! perhaps remove the output stuff and just have the user deal with it\r\n\r\nexport interface UserspaceProgramRegistry {\r\n    getProgram(name: string): Program | undefined;\r\n    listProgramNames(includes_builtin?: boolean, includes_mounted?: boolean): string[];\r\n    registerProgram(program_reg: ProgramRegistrant): Promise<void>;\r\n    unregister(name: string): Promise<void>;\r\n    forceUnregister(name: string): Promise<void>;\r\n    build_registrant_from_js(js_code: string, built_in?: boolean): Promise<ProgramRegistrant>;\r\n    determine_program_name_from_js(js_code: string): Promise<string>;\r\n    mount_and_register_with_output(filename: string, content: string, term: WrappedTerminal, output_success?: boolean): Promise<void>;\r\n    recurse_mount_and_register_with_output(fs: AbstractFileSystem, dir_path: string, term: WrappedTerminal): Promise<void>;\r\n}\r\n\r\nexport class ProgramRegistry {\r\n    readonly #program_regs: Map<string, ProgramRegistrant> = new Map();\r\n\r\n    async registerProgram(program_reg: ProgramRegistrant) {\r\n        const program = program_reg.program;\r\n\r\n        if (this.#program_regs.has(program.name)) {\r\n            throw new Error(`Program with name ${program.name} already exists.`);\r\n        }\r\n\r\n        if (globalThis.OLLIEOS_NODE && program.node_opt_out) {\r\n            // don't register this program if it is not compatible with node.js\r\n            return;\r\n        }\r\n\r\n        this.#program_regs.set(program.name, program_reg);\r\n    }\r\n\r\n\r\n    getProgramRegistrant(name: string): ProgramRegistrant | undefined {\r\n        return this.#program_regs.get(name);\r\n    }\r\n\r\n    getProgram(name: string): Program | undefined {\r\n        const program_reg = this.getProgramRegistrant(name);\r\n        if (program_reg === undefined) {\r\n            return undefined;\r\n        }\r\n\r\n        return program_reg.program;\r\n    }\r\n\r\n\r\n    listProgramRegistrants(includes_builtin = true, includes_mounted = false): ProgramRegistrant[] {\r\n        const arr = Array.from(this.#program_regs.values());\r\n\r\n        if (includes_builtin && includes_mounted) {\r\n            return arr;\r\n        }\r\n\r\n        if (includes_builtin && !includes_mounted) {\r\n            return arr.filter((program_reg) => program_reg.built_in);\r\n        }\r\n\r\n        if (!includes_builtin && includes_mounted) {\r\n            return arr.filter((program_reg) => !program_reg.built_in);\r\n        }\r\n    }\r\n\r\n    listProgramNames(includes_builtin = true, includes_mounted = false): string[] {\r\n        const arr = Array.from(this.#program_regs.keys());\r\n\r\n        if (includes_builtin && includes_mounted) {\r\n            return arr;\r\n        }\r\n\r\n        if (includes_builtin && !includes_mounted) {\r\n            return arr.filter((program_name) => this.getProgramRegistrant(program_name)?.built_in);\r\n        }\r\n\r\n        if (!includes_builtin && includes_mounted) {\r\n            return arr.filter((program_name) => !this.getProgramRegistrant(program_name)?.built_in);\r\n        }\r\n    }\r\n\r\n    listPrograms(includes_builtin = true, includes_mounted = false): Program[] {\r\n        return this.listProgramRegistrants(includes_builtin, includes_mounted).map((program_reg) => program_reg.program);\r\n    }\r\n\r\n\r\n    async forceUnregister(name: string) {\r\n        this.#program_regs.delete(name);\r\n    }\r\n\r\n    async unregister(name: string) {\r\n        if (!this.#program_regs.has(name)) {\r\n            throw new Error(`Program with name ${name} does not exist.`);\r\n        }\r\n\r\n        await this.forceUnregister(name);\r\n    }\r\n\r\n    // note that some methods above are async because the userspace proxy needs them to be async\r\n\r\n    // TODO: move usage of above methods to use class methods instead of the standalone functions\r\n\r\n    async build_registrant_from_js(js_code: string, built_in = false): Promise<ProgramRegistrant> {\r\n        return build_registrant_from_js(js_code, built_in);\r\n    }\r\n\r\n    async determine_program_name_from_js(js_code: string): Promise<string> {\r\n        return determine_program_name_from_js(js_code);\r\n    }\r\n\r\n    async mount_and_register_with_output(filename: string, content: string, term: WrappedTerminal, output_success = false) {\r\n        return mount_and_register_with_output(filename, content, this, term, output_success);\r\n    }\r\n\r\n    async recurse_mount_and_register_with_output(fs: AbstractFileSystem, dir_path: string, term: WrappedTerminal) {\r\n        return recurse_mount_and_register_with_output(fs, dir_path, this, term);\r\n    }\r\n\r\n    create_userspace_proxy(init_program: string, fs: AbstractFileSystem): UserspaceProgramRegistry {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        const check_protected = async (name: string) => {\r\n            const reg = self.getProgramRegistrant(name);\r\n\r\n            // userspace cannot unregister built-in programs\r\n            if (reg?.built_in) {\r\n                throw new Error(`Security Error: Built-in program '${name}' is protected and cannot be modified.`);\r\n            }\r\n\r\n            // userspace cannot unregister the loaded init system\r\n            // TODO: is this actually necessary security wise? it wont get run as kernel til next boot anyway. maybe the boot file should be protected instead?\r\n            if (name === init_program) {\r\n                throw new Error(`Security Error: The init system program '${name}' cannot be modified.`);\r\n            }\r\n\r\n            // userspace cannot unregister program referenced by /sys/privilege_agent\r\n            let privilege_agent_program = \"default_privilege_agent\";\r\n            try {\r\n                const pa_data = await fs.read_file(\"/sys/privilege_agent\") as string;\r\n                privilege_agent_program = pa_data.trim();\r\n            } catch {\r\n                // ignore error\r\n            }\r\n\r\n            if (!privilege_agent_program) {\r\n                privilege_agent_program = \"default_privilege_agent\";\r\n            }\r\n\r\n            if (name === privilege_agent_program) {\r\n                throw new Error(`Security Error: The privilege agent program '${name}' cannot be modified.`);\r\n            }\r\n        }\r\n\r\n        Object.defineProperties(proxy, {\r\n            getProgram: {\r\n                value: (name: string) => self.getProgram(name),\r\n                enumerable: true\r\n            },\r\n            listProgramNames: {\r\n                value: (inc_builtin?: boolean, inc_mounted?: boolean) =>\r\n                    self.listProgramNames(inc_builtin, inc_mounted),\r\n                enumerable: true\r\n            },\r\n            registerProgram: {\r\n                value: async (program_reg: ProgramRegistrant) => {\r\n                    if (program_reg.built_in) {\r\n                        throw new Error(\"Security Error: Cannot register built-in programs from userspace.\");\r\n                    }\r\n\r\n                    await check_protected(program_reg.program.name);\r\n                    await self.registerProgram(program_reg);\r\n                },\r\n                enumerable: true\r\n            },\r\n            unregister: {\r\n                value: async (name: string) => {\r\n                    await check_protected(name);\r\n                    await self.unregister(name);\r\n                },\r\n                enumerable: true\r\n            },\r\n            forceUnregister: {\r\n                value: async (name: string) => {\r\n                    await check_protected(name);\r\n                    await self.forceUnregister(name);\r\n                },\r\n                enumerable: true\r\n            },\r\n\r\n            // its fine to build the registrant as builtin, but not fine to register it\r\n            build_registrant_from_js: {\r\n                value: async (js_code: string, built_in = false) =>\r\n                    self.build_registrant_from_js(js_code, built_in),\r\n                enumerable: true\r\n            },\r\n            determine_program_name_from_js: {\r\n                value: async (js_code: string) =>\r\n                    self.determine_program_name_from_js(js_code),\r\n                enumerable: true\r\n            },\r\n\r\n            // ensure the proxy is used for these methods to enforce protections\r\n            mount_and_register_with_output: {\r\n                value: async (filename: string, content: string, term: WrappedTerminal, output_success = false) =>\r\n                    mount_and_register_with_output(filename, content, proxy, term, output_success),\r\n                enumerable: true\r\n            },\r\n            recurse_mount_and_register_with_output: {\r\n                value: async (dir_path: string, term: WrappedTerminal) =>\r\n                    recurse_mount_and_register_with_output(fs, dir_path, proxy, term),\r\n                enumerable: true\r\n            },\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\n// TODO: restructure methods to not need fs (i.e. move this closer to the kernel where fs is accessible)\r\n\r\n","export class PathNotFoundError extends Error {\r\n    constructor(path: string) {\r\n        super(`Path not found: ${path}`);\r\n    }\r\n}\r\n\r\nexport class NonRecursiveDirectoryError extends Error {\r\n    constructor(path: string) {\r\n        super(`Refusing to delete non-empty directory: ${path}`);\r\n    }\r\n}\r\n\r\nexport class ReadOnlyError extends Error {\r\n    constructor(path: string) {\r\n        super(`Path is read-only: ${path}`);\r\n    }\r\n}\r\n\r\nexport enum FSEventType {\r\n    READING_FILE,\r\n    WROTE_FILE,\r\n    DELETED_FILE,\r\n    MOVED_FILE,\r\n    SET_READONLY,\r\n\r\n    LISTING_DIR,\r\n    MADE_DIR,\r\n    DELETED_DIR,\r\n    MOVED_DIR,\r\n\r\n    SET_CWD,\r\n    GETTING_CWD,\r\n    SET_HOME,\r\n    GETTING_HOME,\r\n    SET_ROOT,\r\n    GETTING_ROOT,\r\n\r\n    CHECKING_EXISTS,\r\n    CHECKING_DIR_EXISTS,\r\n}\r\n\r\n// TODO: ensure all functions fire these events... or do we even need this system other than for cwd changing?\r\n\r\nexport type FSEventHandler = (data: string, fs: AbstractFileSystem) => void;\r\n\r\nexport interface UserspaceFileSystem {\r\n    get_unique_fs_type_name(): string;\r\n    erase_all(): Promise<void>;\r\n    purge_cache(smart?: boolean): void;\r\n    read_file(path: string, as_uint?: boolean): Promise<string | Uint8Array>;\r\n    write_file(path: string, data: string | Uint8Array, force?: boolean): Promise<void>;\r\n    delete_file(path: string): Promise<void>;\r\n    move_file(path: string, new_path: string): Promise<void>;\r\n    list_dir(path: string, dirs_first?: boolean): Promise<string[]>;\r\n    make_dir(path: string): Promise<void>;\r\n    delete_dir(path: string, recursive?: boolean): Promise<void>;\r\n    move_dir(src: string, dest: string, no_overwrite?: boolean, move_inside?: boolean): Promise<void>;\r\n    set_readonly(path: string, readonly: boolean): Promise<void>;\r\n    is_readonly(path: string): Promise<boolean>;\r\n    exists(path: string): Promise<boolean>;\r\n    dir_exists(path: string): Promise<boolean>;\r\n    join(base_dir: string, ...paths: string[]): string;\r\n    absolute(path: string): string;\r\n    get_cwd(): string;\r\n    set_cwd(path: string): void;\r\n    get_home(): string;\r\n    get_root(): string;\r\n}\r\n\r\n// TODO: could protect erase_all but then also need to check recursive deletion, doesnt really gain much\r\n\r\nexport abstract class AbstractFileSystem {\r\n    //TODO: dry\r\n\r\n    // note some members are conventionally private with _ prefix to allow implementations to access them\r\n    // they wont be exposed to userspace though\r\n\r\n    _initialised = false;\r\n\r\n    readonly #cache: Map<string, { readonly: boolean, content: string | Uint8Array, as_uint: boolean }> = new Map();\r\n    readonly #callbacks: Map<FSEventType, FSEventHandler[]> = new Map();\r\n\r\n    _root = \"/\";\r\n    _home = \"/home\";\r\n    _cwd = this._home;\r\n\r\n    abstract get_unique_fs_type_name(): string;\r\n    abstract erase_all(): Promise<void>;\r\n\r\n    abstract is_ready(): Promise<boolean>;\r\n\r\n    purge_cache(smart = false): void {\r\n        if (smart) {\r\n            for (const path in this.#cache) {\r\n                if (!this.exists_direct(path)) {\r\n                    this.#cache.delete(path);\r\n                }\r\n            }\r\n        } else {\r\n            this.#cache.clear();\r\n        }\r\n    }\r\n\r\n    force_remove_from_cache(path: string): void {\r\n        this.#cache.delete(path);\r\n    }\r\n\r\n    remote_purge_cache(smart: boolean): void {\r\n        localStorage.setItem(\"purge_cache\", smart.toString());\r\n    }\r\n\r\n    remote_remove_from_cache(path: string): void {\r\n        localStorage.setItem(\"remove_from_cache\", path);\r\n    }\r\n\r\n    #remote_listener(): void {\r\n        const purge_cache = localStorage.getItem(\"purge_cache\");\r\n        if (purge_cache) {\r\n            this.purge_cache(purge_cache === \"true\");\r\n            localStorage.removeItem(\"purge_cache\");\r\n        }\r\n\r\n        const remove_from_cache = localStorage.getItem(\"remove_from_cache\");\r\n        if (remove_from_cache) {\r\n            this.force_remove_from_cache(remove_from_cache);\r\n            localStorage.removeItem(\"remove_from_cache\");\r\n        }\r\n    }\r\n\r\n\r\n    register_callback(event_type: FSEventType, callback: FSEventHandler): () => void {\r\n        // if there are no callbacks for this event type, create an empty array\r\n        if (!this.#callbacks.has(event_type)) {\r\n            this.#callbacks.set(event_type, []);\r\n        }\r\n\r\n        // add callback to array\r\n        this.#callbacks.get(event_type).push(callback);\r\n\r\n        // return function to remove callback\r\n        return () => {\r\n            this.#callbacks.get(event_type).splice(this.#callbacks.get(event_type).indexOf(callback), 1);\r\n        }\r\n    }\r\n\r\n    _call_callbacks(event_type: FSEventType, data: string): void {\r\n        // call all callbacks\r\n        for (const callback of this.#callbacks.get(event_type) ?? []) {\r\n            callback(data, this);\r\n        }\r\n    }\r\n\r\n\r\n    abstract read_file_direct(path: string, as_uint: boolean): Promise<string | Uint8Array>;\r\n    abstract write_file_direct(path: string, data: string | Uint8Array): Promise<void>;\r\n    abstract delete_file_direct(path: string): Promise<void>;\r\n    // does not check if destination exists\r\n    abstract move_file_direct(src: string, new_path: string): Promise<void>;\r\n    abstract set_readonly_direct(path: string, readonly: boolean): Promise<void>;\r\n    abstract is_readonly_direct(path: string): Promise<boolean>;\r\n\r\n\r\n    async read_file(path: string, as_uint = false): Promise<string | Uint8Array> {\r\n        // prevent prototype pollution\r\n\r\n        this._call_callbacks(FSEventType.READING_FILE, path);\r\n\r\n        // check if file is in cache and still exists, as well as if it's the correct type\r\n        const cached = this.#cache.get(path);\r\n        if (cached && await this.exists(path) && cached.as_uint === as_uint) {\r\n            return this.#cache.get(path).content;\r\n        }\r\n\r\n        // if not, read it from disk and cache it\r\n        const content = await this.read_file_direct(path, as_uint);\r\n        this.#cache.set(path, { readonly: await this.is_readonly(path), content, as_uint });\r\n        return content;\r\n    }\r\n\r\n    async write_file(path: string, data: string | Uint8Array, force = false): Promise<void> {\r\n        // check if file is readonly\r\n        let readonly = false;\r\n        if (await this.exists(path)) {\r\n            readonly = await this.is_readonly(path);\r\n            \r\n            if (!force && readonly) {\r\n                throw new ReadOnlyError(path);\r\n            }\r\n        }\r\n\r\n        // write to disk and cache\r\n        this.#cache.set(path, { readonly, content: data, as_uint: data instanceof Uint8Array });\r\n        await this.write_file_direct(path, data);\r\n        this._call_callbacks(FSEventType.WROTE_FILE, path);\r\n    }\r\n\r\n    async delete_file(path: string): Promise<void> {\r\n        // delete from cache and disk\r\n        if (this.#cache.has(path)) {\r\n            this.#cache.delete(path);\r\n        }\r\n        await this.delete_file_direct(path);\r\n        this._call_callbacks(FSEventType.DELETED_FILE, path);\r\n    }\r\n\r\n    // does not check if destination exists\r\n    async move_file(path: string, new_path: string): Promise<void> {\r\n        // move in cache and disk\r\n        this.#cache.set(new_path, this.#cache.get(path));\r\n        this.#cache.delete(path);\r\n        await this.move_file_direct(path, new_path);\r\n        this._call_callbacks(FSEventType.MOVED_FILE, path);\r\n    }\r\n\r\n    async set_readonly(path: string, readonly: boolean): Promise<void> {\r\n        // check if file exists\r\n        if (!await this.exists(path)) {\r\n            throw new PathNotFoundError(path);\r\n        }\r\n\r\n        // set readonly in cache and disk\r\n        const entry = this.#cache.get(path);\r\n        if (entry) {\r\n            entry.readonly = readonly;\r\n            this.#cache.set(path, entry);\r\n        } else {\r\n            this.#cache.set(path, {readonly, content: await this.read_file(path), as_uint: false});\r\n        }\r\n\r\n        await this.set_readonly_direct(path, readonly);\r\n        this._call_callbacks(FSEventType.SET_READONLY, path);\r\n    }\r\n\r\n    async is_readonly(path: string): Promise<boolean> {\r\n        // check if file exists\r\n        if (!await this.exists(path)) {\r\n            throw new PathNotFoundError(path);\r\n        }\r\n\r\n        // check if file is in cache\r\n        const cached = this.#cache.get(path);\r\n        if (cached) {\r\n            return cached.readonly;\r\n        }\r\n\r\n        // if not, check on disk (cannot cache as would need to read content, causes recursive call)\r\n        return this.is_readonly_direct(path);\r\n    }\r\n\r\n\r\n    abstract list_dir(path: string, dirs_first?: boolean): Promise<string[]>;\r\n    // (recursive)\r\n    abstract make_dir(path: string): Promise<void>;\r\n    abstract delete_dir_direct(path: string, recursive: boolean): Promise<void>;\r\n    abstract move_dir_direct(src: string, dest: string, no_overwrite: boolean, move_inside: boolean): Promise<void>;\r\n\r\n    async delete_dir(path: string, recursive = false): Promise<void> {\r\n        await this.delete_dir_direct(path, recursive);\r\n\r\n        // smart purge cache\r\n        this.purge_cache(true);\r\n    }\r\n\r\n    async move_dir(src: string, dest: string, no_overwrite = false, move_inside = false): Promise<void> {\r\n        await this.move_dir_direct(src, dest, no_overwrite, move_inside);\r\n\r\n        // smart purge cache\r\n        this.purge_cache(true);\r\n    }\r\n\r\n    get_cwd(): string {\r\n        this._call_callbacks(FSEventType.GETTING_CWD, this._cwd);\r\n        return this._cwd;\r\n    }\r\n\r\n    set_cwd(path: string): void {\r\n        // if path ends with /, remove it\r\n        if (path.endsWith(\"/\")) {\r\n            path = path.slice(0, -1);\r\n        }\r\n\r\n        // if path is empty, set to root\r\n        if (path === \"\") {\r\n            path = this._root;\r\n        }\r\n\r\n        this._cwd = path;\r\n        this._call_callbacks(FSEventType.SET_CWD, path);\r\n    }\r\n\r\n\r\n    get_home(): string {\r\n        this._call_callbacks(FSEventType.GETTING_HOME, this._home);\r\n        return this._home;\r\n    }\r\n\r\n    set_home(path: string): void {\r\n        this._home = path;\r\n        this._call_callbacks(FSEventType.SET_HOME, path);\r\n    }\r\n\r\n    get_root(): string {\r\n        this._call_callbacks(FSEventType.GETTING_ROOT, this._root);\r\n        return this._root;\r\n    }\r\n\r\n    set_root(path: string): void {\r\n        this._root = path;\r\n        this._call_callbacks(FSEventType.SET_ROOT, path);\r\n    }\r\n\r\n\r\n    abstract exists_direct(path: string): Promise<boolean>;\r\n    abstract dir_exists(path: string): Promise<boolean>;\r\n\r\n    async exists(path: string): Promise<boolean> {\r\n        // check if file is in cache\r\n        if (this.#cache.has(path)) {\r\n            return true;\r\n        }\r\n\r\n        // if not, check if it exists on disk\r\n        this._call_callbacks(FSEventType.CHECKING_EXISTS, path);\r\n        return this.exists_direct(path);\r\n    }\r\n\r\n    absolute(path: string): string {\r\n        // if path is blank, path is root\r\n        if (path === \"\") {\r\n            return this._root;\r\n        }\r\n\r\n        // if path is ., return cwd\r\n        // TODO: is it safer to run this assumption then do the rest of the code rather than do the following root/cwd checks?\r\n        if (path === \".\") {\r\n            return this._cwd;\r\n        }\r\n\r\n        // if path is ~, return home\r\n        // TODO: again, same for this and the later ~/ check\r\n        if (path === \"~\") {\r\n            return this._home;\r\n        }\r\n\r\n        // if path starts with cwd and doesn't contain .., it is absolute\r\n        if (path.startsWith(this._cwd) && !path.includes(\"..\")) {\r\n            return path;\r\n        }\r\n\r\n        // if path starts with root and doesn't contain .., it is absolute\r\n        if (path.startsWith(this._root) && !path.includes(\"..\")) {\r\n            return path;\r\n        }\r\n\r\n        // drop leading ./\r\n        if (path.startsWith(\"./\")) {\r\n            path = path.slice(2);\r\n        }\r\n\r\n\r\n        let effective_cwd = this._cwd;\r\n\r\n        // if path starts with .., step up the cwd\r\n        while (path.startsWith(\"..\") && effective_cwd !== this._root) {\r\n            path = path.slice(2);\r\n\r\n            // drop leading /\r\n            if (path.startsWith(\"/\")) {\r\n                path = path.slice(1);\r\n            }\r\n\r\n            effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\r\n        }\r\n\r\n        // TODO: doesn't support middle of path ..\r\n        // if path ends with .., remove the last part of the full path\r\n        while (path.endsWith(\"..\")) {\r\n            path = path.slice(0, path.lastIndexOf(\"..\"));\r\n\r\n            // drop trailing /\r\n            if (path.endsWith(\"/\")) {\r\n                path = path.slice(0, path.length - 1);\r\n            }\r\n\r\n            // slice path, slicing effective_cwd if path is empty\r\n            if (path === \"\") {\r\n                effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\r\n            } else {\r\n                path = path.slice(0, path.lastIndexOf(\"/\"));\r\n\r\n                if (path === \"\") {\r\n                    effective_cwd = effective_cwd.slice(0, effective_cwd.lastIndexOf(\"/\"));\r\n                }\r\n            }\r\n        }\r\n\r\n        // if path starts with ~/, replace it with home\r\n        if (path.startsWith(\"~/\")) {\r\n            path = path.slice(2);\r\n            effective_cwd = this._home;\r\n        }\r\n\r\n        // if path still starts with /, drop it\r\n        if (path.startsWith(\"/\")) {\r\n            path = path.slice(1);\r\n        }\r\n\r\n        return this.join(effective_cwd, path);\r\n    }\r\n\r\n    join(base_dir: string, ...paths: string[]): string {\r\n        // drop trailing /\r\n        if (base_dir.endsWith(\"/\")) {\r\n            base_dir = base_dir.slice(0, base_dir.length - 1);\r\n        }\r\n\r\n        // join base_dir and path, using slash if path is not empty\r\n        for (let path of paths) {\r\n            if (path.startsWith(\"/\")) {\r\n                path = path.slice(1);\r\n            }\r\n\r\n            if (path === \"\") {\r\n                continue;\r\n            }\r\n\r\n            base_dir += \"/\" + path;\r\n        }\r\n\r\n        return base_dir;\r\n    }\r\n\r\n    protected constructor() {\r\n        // check if the cache should be purged from remote changes\r\n        setInterval(() => this.#remote_listener(), 100);\r\n    }\r\n\r\n    static create_userspace_proxy(fs: AbstractFileSystem): UserspaceFileSystem {\r\n        const self = fs;\r\n        const proxy = Object.create(null);\r\n\r\n        // write protect certain kernel secured paths\r\n        const check_path = (path: string): string => {\r\n            const absolute_path = self.absolute(path);\r\n\r\n            const is_protected =\r\n                absolute_path === \"/sys\" ||\r\n                absolute_path.startsWith(\"/sys/\") ||\r\n                absolute_path === \"/boot\" ||\r\n                absolute_path.startsWith(\"/boot/\");\r\n\r\n            if (is_protected) {\r\n                throw new ReadOnlyError(absolute_path);\r\n            }\r\n\r\n            return absolute_path;\r\n        };\r\n\r\n        Object.defineProperties(proxy, {\r\n            get_unique_fs_type_name: { value: () => self.get_unique_fs_type_name(), enumerable: true },\r\n            erase_all: { value: () => self.erase_all(), enumerable: true },\r\n            purge_cache: { value: (smart?: boolean) => self.purge_cache(smart), enumerable: true },\r\n            read_file: { value: (path: string, as_uint?: boolean) => self.read_file(self.absolute(path), as_uint), enumerable: true },\r\n            list_dir: { value: (path: string, dirs_first?: boolean) => self.list_dir(self.absolute(path), dirs_first), enumerable: true },\r\n            exists: { value: (path: string) => self.exists(self.absolute(path)), enumerable: true },\r\n            dir_exists: { value: (path: string) => self.dir_exists(self.absolute(path)), enumerable: true },\r\n            is_readonly: {\r\n                value: async (path: string) => {\r\n                    try {\r\n                        check_path(path);\r\n                    } catch (e) {\r\n                        if (e instanceof ReadOnlyError) {\r\n                            return true;\r\n                        }\r\n\r\n                        throw e;\r\n                    }\r\n\r\n                    return await self.is_readonly(self.absolute(path));\r\n                },\r\n                enumerable: true\r\n            },\r\n            join: { value: (base: string, ...paths: string[]) => self.join(base, ...paths), enumerable: true },\r\n            absolute: { value: (path: string) => self.absolute(path), enumerable: true },\r\n            get_cwd: { value: () => self.get_cwd(), enumerable: true },\r\n            get_home: { value: () => self.get_home(), enumerable: true },\r\n            get_root: { value: () => self.get_root(), enumerable: true },\r\n            write_file: {\r\n                value: (path: string, data: string | Uint8Array, force?: boolean) =>\r\n                    self.write_file(check_path(path), data, force),\r\n                enumerable: true\r\n            },\r\n            delete_file: {\r\n                value: (path: string) => self.delete_file(check_path(path)),\r\n                enumerable: true\r\n            },\r\n            move_file: {\r\n                value: (path: string, new_path: string) => {\r\n                    return self.move_file(check_path(path), check_path(new_path));\r\n                },\r\n                enumerable: true\r\n            },\r\n            make_dir: {\r\n                value: (path: string) => self.make_dir(check_path(path)),\r\n                enumerable: true\r\n            },\r\n            delete_dir: {\r\n                value: (path: string, recursive?: boolean) => self.delete_dir(check_path(path), recursive),\r\n                enumerable: true\r\n            },\r\n            move_dir: {\r\n                value: (src: string, dest: string, no_overwrite?: boolean, move_inside?: boolean) => {\r\n                    return self.move_dir(check_path(src), check_path(dest), no_overwrite, move_inside);\r\n                },\r\n                enumerable: true\r\n            },\r\n            set_readonly: {\r\n                value: (path: string, readonly: boolean) => self.set_readonly(check_path(path), readonly),\r\n                enumerable: true\r\n            },\r\n            set_cwd: { value: (path: string) => self.set_cwd(path), enumerable: true }\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\n// TODO: need a way to block programs from accessing the localstorage/OPFS themselves directly, maybe need a function wrapper for that to shadow it away?\r\n","import type {AbstractWindow, AbstractWindowManager} from \"./windowing\";\r\nimport type {AbstractShell} from \"./abstract_shell\";\r\nimport type {ParsedCommandLine} from \"./kernel\";\r\n\r\nexport interface IPCMessage {\r\n    from: number;\r\n    to: number;\r\n\r\n    data: unknown;\r\n}\r\n\r\nexport type IPCChannelListener = (msg: IPCMessage) => Promise<void>;\r\n\r\ninterface IPCChannel {\r\n    initiator: number;\r\n    peer: number;\r\n\r\n    initiator_to_peer_queue: IPCMessage[];\r\n    peer_to_initiator_queue: IPCMessage[];\r\n\r\n    // pid -> set of listeners\r\n    listeners: Map<number, Set<IPCChannelListener>>;\r\n}\r\n\r\nexport type IPCServiceOnConnectionCallback = (channel_id: number, from_pid: number) => Promise<void>;\r\n\r\ninterface IPCService {\r\n    pid: number;\r\n    on_connection: IPCServiceOnConnectionCallback;\r\n}\r\n\r\nexport const KERNEL_FAKE_PID = 0;\r\nconst UNASSIGNED_FAKE_PID = -1;\r\n\r\nexport interface UserspaceIPCManager {\r\n    service_register(name: string, on_connection: IPCServiceOnConnectionCallback): void;\r\n    service_unregister(name: string): void;\r\n    service_lookup(name: string): number | undefined;\r\n    create_channel(service_name: string): number | null;\r\n    destroy_channel(channel_id: number): void;\r\n    channel_listen(channel_id: number, listener: IPCChannelListener): boolean;\r\n    channel_unlisten(channel_id: number, listener: IPCChannelListener): boolean;\r\n    channel_send(channel_id: number, data: unknown): boolean;\r\n}\r\n\r\nexport class IPCManager {\r\n    readonly #process_manager: ProcessManager;\r\n\r\n    // service name -> IPCService\r\n    readonly #services: Map<string, IPCService> = new Map();\r\n\r\n    // channel id -> IPCChannel\r\n    readonly #channels: Map<number, IPCChannel> = new Map();\r\n    #next_channel_id = 1;\r\n\r\n    constructor(process_manager: ProcessManager) {\r\n        this.#process_manager = process_manager;\r\n\r\n        // clean up dead services and channels periodically\r\n        // TODO: add a global exit listener to process manager to be immediately notified of process exits\r\n        setInterval(() => {\r\n            // clean up services\r\n            for (const [name, service] of this.#services) {\r\n                const process = this.#process_manager.get_process(service.pid);\r\n                if (!process) {\r\n                    this.#services.delete(name);\r\n                }\r\n            }\r\n\r\n            // clean up channels\r\n            for (const [channel_id, channel] of this.#channels) {\r\n                const initiator_process = this.#process_manager.get_process(channel.initiator);\r\n                const peer_process = this.#process_manager.get_process(channel.peer);\r\n\r\n                if (!initiator_process || !peer_process) {\r\n                    this.#channels.delete(channel_id);\r\n                }\r\n            }\r\n        }, 10000);\r\n    }\r\n\r\n    dispose_all(): void {\r\n        this.#services.clear();\r\n        this.#channels.clear();\r\n    }\r\n\r\n    service_register(name: string, pid: number, on_connection: IPCServiceOnConnectionCallback): void {\r\n        this.#services.set(name, { pid, on_connection });\r\n    }\r\n\r\n    // TODO: disconnect callback? or change the on_connection to on_event with different event types\r\n\r\n    service_unregister(name: string): void {\r\n        this.#services.delete(name);\r\n    }\r\n\r\n    service_lookup(name: string): number | undefined {\r\n        const service = this.#services.get(name);\r\n\r\n        if (!service) {\r\n            return undefined;\r\n        }\r\n\r\n        // check if process is still running\r\n        const process = this.#process_manager.get_process(service.pid);\r\n        if (!process) {\r\n            this.#services.delete(name);\r\n            return undefined;\r\n        }\r\n\r\n        return service.pid;\r\n    }\r\n\r\n    create_direct_channel(initiator_pid: number, peer_pid: number): number {\r\n        const channel_id = this.#next_channel_id++;\r\n\r\n        this.#channels.set(channel_id, {\r\n            initiator: initiator_pid,\r\n            peer: peer_pid,\r\n\r\n            initiator_to_peer_queue: [],\r\n            peer_to_initiator_queue: [],\r\n\r\n            listeners: new Map(),\r\n        });\r\n\r\n        return channel_id;\r\n    }\r\n\r\n    create_channel(initiator_pid: number, service_name: string): number | null {\r\n        const peer_pid = this.service_lookup(service_name);\r\n\r\n        if (!peer_pid) {\r\n            return null;\r\n        }\r\n\r\n        const channel_id = this.create_direct_channel(initiator_pid, peer_pid);\r\n\r\n        // notify service of new connection without blocking\r\n        const service = this.#services.get(service_name)!;\r\n        service.on_connection(channel_id, initiator_pid).catch((err) => {\r\n            console.error(\"IPC service on_connection error:\", err);\r\n        });\r\n\r\n        return channel_id;\r\n    }\r\n\r\n    reserve_kernel_channel(): number {\r\n        return this.create_direct_channel(KERNEL_FAKE_PID, UNASSIGNED_FAKE_PID);\r\n    }\r\n\r\n    assign_kernel_channel(channel_id: number, peer_pid: number): boolean {\r\n        const channel = this.#channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        if (channel.initiator !== KERNEL_FAKE_PID || channel.peer !== UNASSIGNED_FAKE_PID) {\r\n            return false;\r\n        }\r\n\r\n        channel.peer = peer_pid;\r\n        return true;\r\n    }\r\n\r\n    destroy_channel(channel_id: number): void {\r\n        this.#channels.delete(channel_id);\r\n    }\r\n\r\n    channel_listen(channel_id: number, listening_pid: number, listener: IPCChannelListener): boolean {\r\n        const channel = this.#channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        if (channel.initiator !== listening_pid && channel.peer !== listening_pid) {\r\n            return false;\r\n        }\r\n\r\n        if (!channel.listeners.has(listening_pid)) {\r\n            channel.listeners.set(listening_pid, new Set());\r\n        }\r\n\r\n        channel.listeners.get(listening_pid)!.add(listener);\r\n        return true;\r\n    }\r\n\r\n    channel_unlisten(channel_id: number, listening_pid: number, listener: IPCChannelListener): boolean {\r\n        const channel = this.#channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        if (channel.initiator !== listening_pid && channel.peer !== listening_pid) {\r\n            return false;\r\n        }\r\n\r\n        const listeners = channel.listeners.get(listening_pid);\r\n        if (!listeners) {\r\n            return false;\r\n        }\r\n\r\n        listeners.delete(listener);\r\n        return true;\r\n    }\r\n\r\n    channel_send(channel_id: number, from_pid: number, data: unknown): boolean {\r\n        const channel = this.#channels.get(channel_id);\r\n        if (!channel) {\r\n            return false;\r\n        }\r\n\r\n        let msg: IPCMessage;\r\n        if (channel.initiator === from_pid) {\r\n            msg = {\r\n                from: from_pid,\r\n                to: channel.peer,\r\n                data,\r\n            };\r\n\r\n            channel.initiator_to_peer_queue.push(msg);\r\n        } else if (channel.peer === from_pid) {\r\n            msg = {\r\n                from: from_pid,\r\n                to: channel.initiator,\r\n                data,\r\n            };\r\n\r\n            channel.peer_to_initiator_queue.push(msg);\r\n        } else {\r\n            return false;\r\n        }\r\n\r\n        // notify listeners on the receiving end without blocking\r\n        const to_pid = msg.to;\r\n        const listeners = channel.listeners.get(to_pid);\r\n        if (listeners) {\r\n            for (const listener of listeners) {\r\n                listener(msg).catch((err) => {\r\n                    console.error(\"IPC channel listener error:\", err);\r\n                });\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    create_userspace_proxy(process_pid: number): UserspaceIPCManager {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        Object.defineProperties(proxy, {\r\n            service_register: { value: (name: string, on_connection: IPCServiceOnConnectionCallback) => {\r\n                self.service_register(name, process_pid, on_connection);\r\n            }, enumerable: true },\r\n            service_unregister: { value: (name: string) => {\r\n                self.service_unregister(name);\r\n            }, enumerable: true },\r\n            service_lookup: { value: (name: string) => {\r\n                return self.service_lookup(name);\r\n            }, enumerable: true },\r\n            create_channel: { value: (service_name: string) => {\r\n                return self.create_channel(process_pid, service_name);\r\n            }, enumerable: true },\r\n            destroy_channel: { value: (channel_id: number) => {\r\n                self.destroy_channel(channel_id);\r\n            }, enumerable: true },\r\n            channel_listen: { value: (channel_id: number, listener: IPCChannelListener) => {\r\n                return self.channel_listen(channel_id, process_pid, listener);\r\n            }, enumerable: true },\r\n            channel_unlisten: { value: (channel_id: number, listener: IPCChannelListener) => {\r\n                return self.channel_unlisten(channel_id, process_pid, listener);\r\n            }, enumerable: true },\r\n            channel_send: { value: (channel_id: number, data: unknown) => {\r\n                return self.channel_send(channel_id, process_pid, data);\r\n            }, enumerable: true },\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\n// TODO: could migrate the stuff where programs grab \"scary\" stuff like WindowManager and ProcessManager to be services\r\n\r\nenum ProcessAttachment {\r\n    FOREGROUND,\r\n    BACKGROUND,\r\n    DETACHED,\r\n}\r\n\r\nexport interface UserspaceOtherProcessContext {\r\n    readonly pid: number;\r\n    readonly created_at: Date;\r\n    readonly is_detached: boolean;\r\n    readonly is_background: boolean;\r\n    readonly is_foreground: boolean;\r\n    readonly attachment: ProcessAttachment;\r\n    readonly source_command: ParsedCommandLine;\r\n}\r\n\r\nexport interface UserspaceProcessContext extends UserspaceOtherProcessContext {\r\n    detach(silently?: boolean): void;\r\n    kill(exit_code?: number): void;\r\n    create_timeout(callback: () => void, delay: number): number;\r\n    cancel_timeout(id: number): void;\r\n    create_interval(callback: () => void, interval: number): number;\r\n    clear_interval(id: number): void;\r\n    create_window(): AbstractWindow | null;\r\n}\r\n\r\nexport class ProcessContext {\r\n    readonly #pid: number;\r\n    readonly #manager: ProcessManager;\r\n\r\n    readonly #source_command: ParsedCommandLine;\r\n    readonly #created_at: Date = new Date();\r\n    readonly #shell: AbstractShell | undefined;\r\n\r\n    readonly #exit_listeners: Set<(exit_code: number) => Promise<void> | void> = new Set();\r\n\r\n    #attachment: ProcessAttachment = ProcessAttachment.FOREGROUND;\r\n    #detach_silently = false;\r\n\r\n    readonly #timeouts: Set<number> = new Set();\r\n    readonly #timeout_promises: Map<number, Set<{resolve: (finished: boolean) => void}>> = new Map(); // timeout id -> promise resolvers (for waiting on timeouts but listening to cancellation)\r\n    readonly #timeout_cancel_callbacks: Map<number, () => void> = new Map(); // timeout id -> cancel callback\r\n\r\n    readonly #intervals: Set<number> = new Set();\r\n\r\n    readonly #windows: Set<AbstractWindow> = new Set();\r\n\r\n    constructor(pid: number, source_command: ParsedCommandLine, registry: ProcessManager, shell?: AbstractShell) {\r\n        this.#pid = pid;\r\n        this.#source_command = source_command;\r\n        this.#manager = registry;\r\n\r\n        if (shell) {\r\n            this.#shell = shell;\r\n        }\r\n\r\n        if (source_command.run_in_bg) {\r\n            this.#attachment = ProcessAttachment.BACKGROUND;\r\n        }\r\n    }\r\n\r\n    get pid(): number {\r\n        return this.#pid;\r\n    }\r\n    get source_command(): ParsedCommandLine {\r\n        return this.#source_command;\r\n    }\r\n\r\n    get created_at(): Date {\r\n        return this.#created_at;\r\n    }\r\n\r\n    get shell(): AbstractShell | undefined {\r\n        return this.#shell;\r\n    }\r\n\r\n    get is_detached(): boolean {\r\n        return this.#attachment === ProcessAttachment.DETACHED;\r\n    }\r\n\r\n    get is_background(): boolean {\r\n        return this.#attachment === ProcessAttachment.BACKGROUND;\r\n    }\r\n\r\n    get is_foreground(): boolean {\r\n        return this.#attachment === ProcessAttachment.FOREGROUND;\r\n    }\r\n\r\n    get attachment(): ProcessAttachment {\r\n        return this.#attachment;\r\n    }\r\n\r\n    get detaches_silently(): boolean {\r\n        return this.#detach_silently;\r\n    }\r\n\r\n    detach(silently = false): void {\r\n        this.#attachment = ProcessAttachment.DETACHED;\r\n        this.#detach_silently = silently;\r\n    }\r\n\r\n    dispose_resources(): void {\r\n        this.#intervals.forEach((id) => {\r\n            clearInterval(id);\r\n        });\r\n\r\n        this.#timeouts.forEach((id) => {\r\n            clearTimeout(id);\r\n        });\r\n\r\n        this.#timeout_promises.clear();\r\n        this.#timeout_cancel_callbacks.clear();\r\n\r\n        this.#windows.forEach((win) => {\r\n            win.dispose();\r\n        });\r\n    }\r\n\r\n    kill(exit_code = 0): void {\r\n        this.dispose_resources();\r\n\r\n        this.#manager.mark_terminated(this.#pid);\r\n\r\n        for (const listener of this.#exit_listeners) {\r\n            listener(exit_code);\r\n        }\r\n    }\r\n\r\n    add_exit_listener(listener: (exit_code: number) => Promise<void> | void): void {\r\n        this.#exit_listeners.add(listener);\r\n    }\r\n\r\n    create_timeout(callback: () => void, delay: number, on_cancel? : () => void): number {\r\n        const id = window.setTimeout(() => {\r\n            this.#timeouts.delete(id);\r\n\r\n            // resolve any waiters\r\n            if (this.#timeout_promises.has(id)) {\r\n                const resolvers = this.#timeout_promises.get(id)!;\r\n                for (const { resolve } of resolvers) {\r\n                    resolve(true);\r\n                }\r\n                this.#timeout_promises.delete(id);\r\n            }\r\n\r\n            callback();\r\n\r\n            if (on_cancel) {\r\n                this.#timeout_cancel_callbacks.delete(id);\r\n            }\r\n        }, delay);\r\n\r\n        this.#timeouts.add(id);\r\n\r\n        if (on_cancel) {\r\n            this.#timeout_cancel_callbacks.set(id, on_cancel);\r\n        }\r\n\r\n        return id;\r\n    }\r\n\r\n    cancel_timeout(id: number): void {\r\n        if (this.#timeouts.has(id)) {\r\n            clearTimeout(id);\r\n            this.#timeouts.delete(id);\r\n\r\n            // resolve any waiters as cancelled\r\n            if (this.#timeout_promises.has(id)) {\r\n                const resolvers = this.#timeout_promises.get(id)!;\r\n                for (const {resolve} of resolvers) {\r\n                    resolve(false);\r\n                }\r\n                this.#timeout_promises.delete(id);\r\n            }\r\n\r\n            // call cancel callback if exists\r\n            if (this.#timeout_cancel_callbacks.has(id)) {\r\n                const cancel_callback = this.#timeout_cancel_callbacks.get(id)!;\r\n                cancel_callback();\r\n                this.#timeout_cancel_callbacks.delete(id);\r\n            }\r\n        }\r\n    }\r\n\r\n    has_timeout(id: number): boolean {\r\n        return this.#timeouts.has(id);\r\n    }\r\n\r\n    create_interval(callback: () => void, interval: number): number {\r\n        const id = window.setInterval(callback, interval);\r\n        this.#intervals.add(id);\r\n        return id;\r\n    }\r\n\r\n    has_interval(id: number): boolean {\r\n        return this.#intervals.has(id);\r\n    }\r\n\r\n    clear_interval(id: number): void {\r\n        if (this.#intervals.has(id)) {\r\n            clearInterval(id);\r\n            this.#intervals.delete(id);\r\n        }\r\n    }\r\n\r\n    async wait_for_timeout(id: number): Promise<boolean> {\r\n        if (!this.#timeouts.has(id)) {\r\n            throw new Error(`Timeout ID ${id} does not exist.`);\r\n        }\r\n\r\n        return new Promise<boolean>((resolve) => {\r\n            if (!this.#timeout_promises.has(id)) {\r\n                this.#timeout_promises.set(id, new Set());\r\n            }\r\n\r\n            this.#timeout_promises.get(id)!.add({ resolve });\r\n        });\r\n    }\r\n\r\n    create_window(): AbstractWindow | null {\r\n        const wm = this.#manager.window_manager;\r\n        if (!wm) {\r\n            return null;\r\n        }\r\n\r\n        const win = new wm.Window(this.#pid);\r\n        this.#windows.add(win);\r\n\r\n        // clean up on close\r\n        win.add_event_listener(\"close\", () => {\r\n            this.#windows.delete(win);\r\n        });\r\n\r\n        return win;\r\n    }\r\n\r\n\r\n    create_userspace_proxy_as_other_process(): UserspaceOtherProcessContext {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        Object.defineProperties(proxy, {\r\n            pid: { get: () => self.pid, enumerable: true },\r\n            created_at: { get: () => self.created_at, enumerable: true },\r\n            is_detached: { get: () => self.is_detached, enumerable: true },\r\n            is_background: { get: () => self.is_background, enumerable: true },\r\n            is_foreground: { get: () => self.is_foreground, enumerable: true },\r\n            attachment: { get: () => self.attachment, enumerable: true },\r\n            source_command: { get: () => self.source_command, enumerable: true },\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n\r\n    create_userspace_proxy(): UserspaceProcessContext {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        Object.defineProperties(proxy, {\r\n            pid: { get: () => self.pid, enumerable: true },\r\n            created_at: { get: () => self.created_at, enumerable: true },\r\n            is_detached: { get: () => self.is_detached, enumerable: true },\r\n            is_background: { get: () => self.is_background, enumerable: true },\r\n            is_foreground: { get: () => self.is_foreground, enumerable: true },\r\n            attachment: { get: () => self.attachment, enumerable: true },\r\n            source_command: { get: () => self.source_command, enumerable: true },\r\n\r\n            detach: { value: (silently = false) => { self.detach(silently); }, enumerable: true },\r\n            kill: { value: (exit_code = 0) => { self.kill(exit_code); }, enumerable: true },\r\n            create_timeout: { value: (callback: () => void, delay: number) => self.create_timeout(callback, delay), enumerable: true },\r\n            cancel_timeout: { value: (id: number) => { self.cancel_timeout(id); }, enumerable: true },\r\n            create_interval: { value: (callback: () => void, interval: number) => self.create_interval(callback, interval), enumerable: true },\r\n            clear_interval: { value: (id: number) => { self.clear_interval(id); }, enumerable: true },\r\n            create_window: { value: () => self.create_window(),  enumerable: true },\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\nexport interface UserspaceProcessManager {\r\n    readonly ipc_manager: UserspaceIPCManager;\r\n    list_pids(): number[];\r\n    get_process(pid: number): UserspaceOtherProcessContext | undefined;\r\n    kill(pid: number, exit_code?: number): boolean;\r\n}\r\n\r\nexport class ProcessManager {\r\n    readonly #processes: Map<number, ProcessContext> = new Map();\r\n    #next_pid = 1;\r\n\r\n    readonly #wm: AbstractWindowManager | null;\r\n    readonly #ipc_manager: IPCManager = new IPCManager(this);\r\n\r\n    constructor(wm: AbstractWindowManager | null = null) {\r\n        this.#wm = wm;\r\n    }\r\n\r\n    get window_manager(): AbstractWindowManager | null {\r\n        return this.#wm;\r\n    }\r\n\r\n    get ipc_manager(): IPCManager {\r\n        return this.#ipc_manager;\r\n    }\r\n\r\n    dispose_all(): void {\r\n        this.#ipc_manager.dispose_all();\r\n\r\n        for (const process of this.#processes.values()) {\r\n            process.dispose_resources();\r\n        }\r\n\r\n        this.#processes.clear();\r\n    }\r\n\r\n    create_process(source_command: ParsedCommandLine, shell?: AbstractShell): ProcessContext {\r\n        const pid = this.#next_pid++;\r\n        const context = new ProcessContext(pid, source_command, this, shell);\r\n        this.#processes.set(pid, context);\r\n        return context;\r\n    }\r\n\r\n    get_process(pid: number): ProcessContext | undefined {\r\n        return this.#processes.get(pid);\r\n    }\r\n\r\n    list_pids(): number[] {\r\n        return Array.from(this.#processes.keys());\r\n    }\r\n\r\n    mark_terminated(pid: number): void {\r\n        this.#processes.delete(pid);\r\n    }\r\n\r\n    kill(pid: number, exit_code = 0): boolean {\r\n        const process = this.#processes.get(pid);\r\n        if (!process) {\r\n            return false;\r\n        }\r\n\r\n        process.kill(exit_code);\r\n        return true;\r\n    }\r\n\r\n    create_userspace_proxy(process_pid: number): UserspaceProcessManager {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        const ipc_mgr_proxy = self.#ipc_manager.create_userspace_proxy(process_pid);\r\n\r\n        Object.defineProperties(proxy, {\r\n            ipc_manager: { get: () => ipc_mgr_proxy, enumerable: true },\r\n            list_pids: { value: () => self.list_pids(), enumerable: true },\r\n            get_process: { value: (pid: number) => {\r\n                const process = self.get_process(pid);\r\n                return process ? process.create_userspace_proxy_as_other_process() : undefined;\r\n            }, enumerable: true },\r\n            kill: { value: (pid: number, exit_code?: number) => self.kill(pid, exit_code), enumerable: true },\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n","import { Howl } from \"howler\";\r\n\r\nexport class SoundRegistry {\r\n    readonly #registry: Map<string, { ready: boolean, howl: Howl }> = new Map();\r\n\r\n    register_howl(name: string, howl: Howl, ready = false) {\r\n        this.#registry.set(name, { ready, howl });\r\n    }\r\n\r\n    register_file(name: string, file: string) {\r\n        const howl = new Howl({\r\n            src: [file],\r\n            onload: () => {\r\n                const entry = this.#registry.get(name);\r\n                entry.ready = true;\r\n                this.#registry.set(name, entry);\r\n            },\r\n        });\r\n\r\n        this.register_howl(name, howl);\r\n    }\r\n\r\n    async await_ready(name: string, interval = 100): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            const timer = setInterval(() => {\r\n                if (this.#registry.get(name).ready) {\r\n                    clearInterval(timer);\r\n                    resolve();\r\n                }\r\n            }, interval);\r\n        });\r\n    }\r\n\r\n    play(name: string) {\r\n        if (!this.#registry.has(name)) {\r\n            throw new Error(`Sound \"${name}\" is not registered.`);\r\n        }\r\n\r\n        if (!this.#registry.get(name).ready) {\r\n            throw new Error(`Sound \"${name}\" is not ready yet.`);\r\n        }\r\n\r\n        this.#registry.get(name).howl.play();\r\n    }\r\n\r\n    get(name: string) {\r\n        if (!this.#registry.has(name)) {\r\n            throw new Error(`Sound \"${name}\" is not registered.`);\r\n        }\r\n\r\n        return this.#registry.get(name).howl;\r\n    }\r\n\r\n    is_ready(name: string) {\r\n        return this.#registry.get(name).ready;\r\n    }\r\n\r\n    wait_to_play(name: string, interval = 100) {\r\n        if (this.is_ready(name)) {\r\n            this.play(name);\r\n        } else {\r\n            console.log(`Sound ${name} is not ready yet, waiting...`);\r\n            this.await_ready(name, interval).then(() => {\r\n                this.play(name);\r\n            });\r\n        }\r\n    }\r\n}","import {ProgramRegistry, recurse_mount_and_register_with_output, UserspaceProgramRegistry} from \"./prog_registry\";\r\nimport {AbstractFileSystem, type UserspaceFileSystem} from \"./filesystem\";\r\n\r\n// TODO: organise this stuff to a kernel directory?\r\nimport {SoundRegistry} from \"./sfx_registry\";\r\nimport {AbstractWindowManager, UserspaceWindowManager} from \"./windowing\";\r\nimport {\r\n    IPCManager,\r\n    KERNEL_FAKE_PID,\r\n    ProcessContext,\r\n    ProcessManager,\r\n    UserspaceIPCManager, UserspaceOtherProcessContext,\r\n    UserspaceProcessManager\r\n} from \"./processes\";\r\nimport type {AbstractShell} from \"./abstract_shell\";\r\n\r\nimport {NEWLINE, type WrappedTerminal} from \"./term_ctl\";\r\n\r\nimport semver_validate from \"semver/functions/valid\";\r\nimport semver_compare from \"semver/functions/compare\"\r\n\r\nconst CURRENT_API_COMPAT = \"2.0.0\";\r\n\r\nexport interface SpawnResult {\r\n    process: ProcessContext;\r\n    completion: Promise<number>;\r\n}\r\n\r\nexport interface UserspaceKernel {\r\n    get_program_registry(): UserspaceProgramRegistry;\r\n    get_sound_registry(): SoundRegistry;\r\n    get_fs(): UserspaceFileSystem;\r\n    get_window_manager(): UserspaceWindowManager | null;\r\n    has_window_manager(): boolean;\r\n    get_process_manager(): UserspaceProcessManager;\r\n    get_ipc(): UserspaceIPCManager;\r\n    get_env_info(): {version: string, env: string};\r\n    spawn(cmd_or_line_parse: string | ParsedCommandLine, explicit_args?: string[], shell?: AbstractShell): SpawnResult; // TODO: how safe will this be to expose?\r\n    request_privilege(reason: string): Promise<Kernel | false>;\r\n}\r\n\r\nexport interface ParsedCommandLine {\r\n    command: string;\r\n    args: string[];\r\n    unsubbed_args: string[];\r\n    raw_parts: string[];\r\n    run_in_bg: boolean;\r\n}\r\n\r\nexport class Kernel {\r\n    readonly #term: WrappedTerminal;\r\n    readonly #process_manager: ProcessManager;\r\n    readonly #prog_registry: ProgramRegistry;\r\n    readonly #sfx_registry: SoundRegistry;\r\n    readonly #fs: AbstractFileSystem;\r\n    readonly #wm: AbstractWindowManager | null = null;\r\n\r\n    #panicked = false;\r\n\r\n    #env_info = {\r\n        version: \"unknown\",\r\n        env: \"unknown\"\r\n    };\r\n\r\n    #init_program_name: string | null = null;\r\n\r\n    get panicked(): boolean {\r\n        return this.#panicked;\r\n    }\r\n\r\n    get_program_registry(): ProgramRegistry {\r\n        return this.#prog_registry;\r\n    }\r\n\r\n    get_sound_registry(): SoundRegistry {\r\n        return this.#sfx_registry;\r\n    }\r\n\r\n    get_fs(): AbstractFileSystem {\r\n        return this.#fs;\r\n    }\r\n\r\n    get_window_manager(): AbstractWindowManager | null {\r\n        return this.#wm;\r\n    }\r\n\r\n    has_window_manager(): boolean {\r\n        return this.#wm !== null;\r\n    }\r\n\r\n    get_process_manager(): ProcessManager {\r\n        return this.#process_manager;\r\n    }\r\n\r\n    get_ipc(): IPCManager {\r\n        return this.#process_manager.ipc_manager;\r\n    }\r\n\r\n    get_env_info(): {version: string, env: string} {\r\n        return {...this.#env_info};\r\n    }\r\n\r\n    set_env_info(version: string, env: string) {\r\n        this.#env_info.version = version;\r\n        this.#env_info.env = env;\r\n    }\r\n\r\n    // TODO: cleaner interface, shame theres no function overloading (but could make two more methods)\r\n    spawn = (cmd_or_parse: string | ParsedCommandLine, explicit_args?: string[], shell?: AbstractShell, start_privileged?: boolean): SpawnResult => {\r\n        // TODO: is passing shell around annoying? how can it be alleviated without affecting separation of concerns?\r\n        // TODO: replace the above with process ownership :)\r\n\r\n        // we may not be provided a parsed line (if this is a direct call, not from execute()), but we can create one by assumption\r\n        // args are only used if cmd_or_parse is a string\r\n        // by ensuring only 1 source of truth is used at a time, we avoid manipulation from conflicting data\r\n        let parsed_line: ParsedCommandLine;\r\n        if (typeof cmd_or_parse === \"string\") {\r\n            if (!explicit_args) {\r\n                explicit_args = [];\r\n            }\r\n\r\n            parsed_line = {\r\n                command: cmd_or_parse,\r\n                args: [...explicit_args],\r\n                unsubbed_args: [...explicit_args],\r\n                raw_parts: [cmd_or_parse, ...explicit_args],\r\n                run_in_bg: false\r\n            };\r\n        } else {\r\n            parsed_line = cmd_or_parse;\r\n        }\r\n\r\n        const {command} = parsed_line;\r\n\r\n        // shallow clone args to avoid mutation exploits (you never know)\r\n        const args = parsed_line.args.slice();\r\n\r\n        // search for the command in the registry\r\n        const program = this.#prog_registry.getProgram(command);\r\n        if (program === undefined) {\r\n            throw new Error(`Command not found: ${command}`);\r\n        }\r\n\r\n        // validate that the name stored in the program matches the command called\r\n        // under normal circumstances this should always be true, but doing this prevents obscure spoofing exploits\r\n        if (program.name !== command) {\r\n            throw new Error(`Program name mismatch for command ${command}: expected ${command}, got ${program.name}`);\r\n        }\r\n\r\n        let compat = \"1.0.0\";\r\n        if (typeof program.compat === \"string\") {\r\n            compat = program.compat;\r\n        }\r\n\r\n        if (!semver_validate(compat)) {\r\n            throw new Error(`Program ${program.name} has an invalid compat SemVer: ${compat}`);\r\n        }\r\n\r\n        if (semver_compare(compat, CURRENT_API_COMPAT) < 0) {\r\n            throw new Error(`Program ${program.name} is not compatible with OllieOS 2. (Add compat: \"2.0.0\" to the program object to mark it as ported.)`);\r\n        }\r\n\r\n        // create new process context\r\n        const process = this.#process_manager.create_process(parsed_line, shell);\r\n\r\n        // protect from pollution\r\n        const data = Object.create(null);\r\n\r\n        // provide either privileged or userspace kernel access\r\n        if (start_privileged) {\r\n            data.kernel = this;\r\n        } else {\r\n            data.kernel = this.create_userspace_proxy(process);\r\n        }\r\n\r\n        data.term = this.#term;\r\n        data.args = args;\r\n        data.shell = shell;\r\n        data.unsubbed_args = parsed_line.unsubbed_args;\r\n        data.raw_parts = parsed_line.raw_parts;\r\n        data.process = process;\r\n\r\n        Object.freeze(data);\r\n\r\n        // create a promise that resolves when the program completes\r\n        let result_promise: Promise<number>;\r\n        if (\"main\" in program) {\r\n            result_promise = Promise.resolve(program.main(data));\r\n        } else {\r\n            throw new Error(\"Invalid program type\");\r\n        }\r\n\r\n        return {\r\n            process,\r\n            completion: result_promise\r\n        };\r\n    }\r\n\r\n    panic(message: string, debug_info?: string) {\r\n        if (this.#panicked) {\r\n            return;\r\n        }\r\n\r\n        this.#panicked = true;\r\n\r\n        // print formatted panic to js console\r\n        console.error(`%cPANIC: ${message}\\n${debug_info || \"\"}`, \"background: red; color: white; font-weight: bold;\");\r\n\r\n        const proc_mgr = this.get_process_manager();\r\n        const pids = proc_mgr.list_pids();\r\n\r\n        let process_info = \"\"\r\n\r\n        for (const pid of pids) {\r\n            const proc = proc_mgr.get_process(pid);\r\n\r\n            if (proc) {\r\n                process_info += `- PID ${proc.pid}: ${proc.source_command.command} (started at ${proc.created_at.toISOString()})${NEWLINE}`;\r\n            }\r\n        }\r\n\r\n        // remove last NEWLINE\r\n        process_info = process_info.trimEnd();\r\n\r\n        proc_mgr.dispose_all();\r\n        this.#term.handle_kernel_panic(message, process_info, debug_info);\r\n    }\r\n\r\n    async boot(on_init_spawned?: (kernel: Kernel) => Promise<void>): Promise<boolean> {\r\n        const fs = this.get_fs();\r\n\r\n        // mount all programs in any subdirectory of /usr/bin\r\n        // TODO: get rid of the concept of a programregistry being the sole way to run programs. mounting is a bad concept. it should be a cache, not the sole execution method. may need to redesign how programs are stored to have it be more part of the filesystem\r\n        // TODO: smarter system that has files to be mounted so any stray js files don't get mounted? or maybe it doesn't matter and is better mounting everything for hackability!\r\n        const usr_bin = fs.absolute(\"/usr/bin\");\r\n        if (await fs.exists(usr_bin)) {\r\n            await recurse_mount_and_register_with_output(fs, usr_bin, this.get_program_registry(), this.#term);\r\n        }\r\n\r\n        // read /boot/init to determine init system\r\n        let init_program: string;\r\n        let init_args: string[] = [];\r\n\r\n        try {\r\n            const init_data = await fs.read_file(\"/boot/init\") as string;\r\n            init_program = init_data.trim();\r\n        } catch {\r\n            this.panic(\"Failed to read /boot/init to determine init system!\");\r\n            return false;\r\n        }\r\n\r\n        if (!init_program) {\r\n            this.panic(\"No init program specified in /boot/init!\");\r\n            return false;\r\n        }\r\n\r\n        // separate args if any\r\n        const init_parts = init_program.split(\" \");\r\n        init_program = init_parts[0];\r\n\r\n        if (init_parts.length > 1) {\r\n            init_args = init_parts.slice(1);\r\n        }\r\n\r\n        // run init program\r\n        try {\r\n            const init = this.spawn(init_program, init_args, undefined, true);\r\n            this.#init_program_name = init_program;\r\n\r\n            if (on_init_spawned) {\r\n                on_init_spawned(this).catch((e) => {\r\n                    console.error(e);\r\n                });\r\n            }\r\n\r\n            if (init.process.pid !== 1) {\r\n                this.panic(`init program ${init_program} did not start as PID 1!`);\r\n                return false;\r\n            }\r\n\r\n            try {\r\n                const exit_code = await init.completion;\r\n\r\n                this.panic(`init program ${init_program} exited ${exit_code === 0 ? \"unexpectedly\" : \"with an error\"}!`, `Exit code: ${exit_code}`);\r\n                return false;\r\n            } catch (e) {\r\n                console.error(e);\r\n                this.panic(`init program ${init_program} error!`, e.toString());\r\n                return false;\r\n            }\r\n        } catch (e) {\r\n            console.error(e);\r\n            this.panic(`Failed to start init program ${init_program}!`, e.toString());\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async request_privilege(reason: string, process: ProcessContext): Promise<Kernel | false> {\r\n        // TODO: remember my answer option when /sys security is implemented\r\n        // TODO: implement killing in the proxies so that when the process dies, any privileged access is revoked\r\n\r\n        // read /sys/privilege_agent to determine privilege agent\r\n        const fs = this.get_fs();\r\n        let agent_program = \"default_privilege_agent\";\r\n        try {\r\n            const agent_data = await fs.read_file(\"/sys/privilege_agent\") as string;\r\n            agent_program = agent_data.trim();\r\n        } catch {\r\n            // ignore, use default\r\n            console.warn(\"Failed to read /sys/privilege_agent, using default privilege agent.\");\r\n        }\r\n\r\n        if (!agent_program) {\r\n            agent_program = \"default_privilege_agent\";\r\n            console.warn(\"/sys/privilege_agent is empty, using default privilege agent.\");\r\n        }\r\n\r\n        // create an unassigned ipc channel\r\n        const ipc = this.get_ipc();\r\n        const channel_id = ipc.reserve_kernel_channel();\r\n\r\n        // spawn the privilege agent program, passing the channel id, and assign the channel to it\r\n        const agent_proc = this.spawn(agent_program, [channel_id.toString()]);\r\n        ipc.assign_kernel_channel(channel_id, agent_proc.process.pid);\r\n\r\n        let handling_request = false;\r\n        let approved: boolean | null = null;\r\n\r\n        // listen for response on the channel\r\n        ipc.channel_listen(channel_id, KERNEL_FAKE_PID, async (msg) => {\r\n            const data = msg.data as { process: UserspaceOtherProcessContext; granted?: boolean; handling?: boolean; };\r\n\r\n            // validate approved pid matches requesting pid\r\n            if (data.process.pid !== process.pid) {\r\n                console.warn(`Privilege request response pid ${data.process.pid} does not match requesting pid ${process.pid}, ignoring response.`);\r\n                return;\r\n            }\r\n\r\n            // check if handling acknowledgement\r\n            if (data.handling) {\r\n                handling_request = true;\r\n                return;\r\n            }\r\n\r\n            // otherwise, check for granted/denied\r\n            if (data.granted !== undefined) {\r\n                approved = data.granted;\r\n            }\r\n        });\r\n\r\n        const process_proxy = process.create_userspace_proxy_as_other_process();\r\n\r\n        // wait to handle for up to 10 seconds, repeating the request if not yet being handled\r\n        // overall timeout up to 60 seconds\r\n        const start_time = Date.now();\r\n        // TODO: cleaner logic here\r\n        while ((Date.now() - start_time) < 60000 && approved === null && (handling_request || (Date.now() - start_time) < 10000)) {\r\n            if (!handling_request) {\r\n                ipc.channel_send(channel_id, KERNEL_FAKE_PID, {\r\n                    process: process_proxy,\r\n                    reason\r\n                });\r\n            }\r\n\r\n            await new Promise((resolve) => setTimeout(resolve, 500));\r\n        }\r\n\r\n        ipc.destroy_channel(channel_id);\r\n\r\n        if (approved === null) {\r\n            console.warn(\"Privilege request timed out.\");\r\n        }\r\n\r\n        agent_proc.process.kill(approved === null ? 1 : 0);\r\n\r\n        // return result\r\n        if (approved) {\r\n            return this;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    constructor(term: WrappedTerminal, fs: AbstractFileSystem, prog_registry?: ProgramRegistry, sound_registry?: SoundRegistry, wm?: AbstractWindowManager) {\r\n        this.#term = term;\r\n        this.#fs = fs;\r\n        this.#prog_registry = prog_registry || new ProgramRegistry();\r\n        this.#sfx_registry = sound_registry || new SoundRegistry();\r\n        this.#wm = wm || null;\r\n        this.#process_manager = new ProcessManager(this.#wm);\r\n    }\r\n\r\n    create_userspace_proxy(process: ProcessContext): Promise<UserspaceKernel> {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        const kernel_fs = self.get_fs();\r\n\r\n        const proc_mgr_proxy = self.get_process_manager().create_userspace_proxy(process.pid);\r\n        const prog_reg_proxy = self.get_program_registry().create_userspace_proxy(this.#init_program_name, kernel_fs);\r\n        const fs_proxy = AbstractFileSystem.create_userspace_proxy(kernel_fs);\r\n\r\n        Object.defineProperties(proxy, {\r\n            get_program_registry: { value: () => prog_reg_proxy, enumerable: true },\r\n            get_sound_registry: { value: () => self.get_sound_registry(), enumerable: true },\r\n            get_fs: { value: () => fs_proxy, enumerable: true },\r\n            get_window_manager: {\r\n                value: () => {\r\n                    const wm = self.get_window_manager();\r\n                    return wm ? wm.create_userspace_proxy() : null;\r\n                },\r\n                enumerable: true\r\n            },\r\n            has_window_manager: { value: () => self.has_window_manager(), enumerable: true },\r\n            get_process_manager: { value: () => proc_mgr_proxy, enumerable: true },\r\n            get_ipc: { value: () => proc_mgr_proxy.ipc_manager, enumerable: true },\r\n            get_env_info: { value: () => self.get_env_info(), enumerable: true },\r\n            spawn: {\r\n                value: (command: string | ParsedCommandLine, args?: string[], shell?: AbstractShell) =>\r\n                    self.spawn(command, args, shell, false),\r\n                enumerable: true\r\n            },\r\n            request_privilege: {\r\n                value: (reason: string) => self.request_privilege(reason, process),\r\n                enumerable: true\r\n            }\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n","import type {Kernel, SpawnResult} from \"../../../kernel\";\r\n\r\nconst SERVICES_DIR = \"/etc/services/\";\r\n\r\ninterface ServiceRestartPolicyBase {\r\n    on: \"failure\" | \"always\" | \"never\";\r\n}\r\n\r\ninterface ServiceRestartPolicyWithRules extends ServiceRestartPolicyBase {\r\n    on: \"failure\" | \"always\";\r\n    max_retries?: number;\r\n    delay_ms?: number;\r\n}\r\n\r\ntype ServiceRestartPolicy = ServiceRestartPolicyBase | ServiceRestartPolicyWithRules;\r\n\r\ninterface ServiceFile {\r\n    name?: string;\r\n    dependencies?: string[];\r\n    exec: string;\r\n    args?: string[];\r\n    oneshot?: boolean;\r\n    restart?: ServiceRestartPolicy;\r\n}\r\n\r\n// TODO: support oneshot\r\n// TODO: do something with name\r\n// TODO: do something with max_retries\r\n\r\ninterface ServiceFileWithId extends ServiceFile {\r\n    id: string;\r\n}\r\n\r\nconst CLEAN_EXIT_CODES = new Set([0, 143]); // 0 = success, 143 = SIGTERM\r\n\r\ninterface ServiceStatusBase {\r\n    state: \"running\" | \"stopped\" | \"failed\";\r\n}\r\n\r\ninterface ServiceStatusNotRunning extends ServiceStatusBase {\r\n    state: \"stopped\" | \"failed\";\r\n}\r\n\r\ninterface ServiceStatusRunning extends ServiceStatusBase {\r\n    state: \"running\";\r\n    pid: number;\r\n}\r\n\r\n// TODO: store stop code for failed services\r\n// TODO: store start time for running services\r\n\r\nexport type ServiceStatus = ServiceStatusRunning | ServiceStatusNotRunning;\r\n\r\nexport class ServiceManager {\r\n    readonly #kernel: Kernel;\r\n\r\n    readonly #service_files: Map<string, ServiceFileWithId> = new Map();\r\n    readonly #running_services: Map<string, SpawnResult> = new Map(); // service ID to spawn result\r\n    readonly #should_be_running_services: Set<string> = new Set();\r\n    readonly #failed_services: Set<string> = new Set();\r\n\r\n    constructor(kernel: Kernel) {\r\n        this.#kernel = kernel;\r\n    }\r\n\r\n    async load_service_files() {\r\n        const fs = this.#kernel.get_fs();\r\n\r\n        if (!await fs.exists(SERVICES_DIR)) {\r\n            console.warn(`Services directory ${SERVICES_DIR} does not exist. Skipping service loading.`);\r\n            return;\r\n        }\r\n\r\n        const service_files = await fs.list_dir(SERVICES_DIR);\r\n\r\n        // load each service file\r\n        for (const file_name of service_files) {\r\n            if (file_name.endsWith(\".service.json\")) {\r\n                const file_path = fs.join(SERVICES_DIR, file_name);\r\n                const file_content = await fs.read_file(file_path) as string;\r\n\r\n                try {\r\n                    const service_data = JSON.parse(file_content) as ServiceFile;\r\n                    const service_id = file_name.substring(0, file_name.length - \".service.json\".length);\r\n\r\n                    // TODO: validate service_data here\r\n\r\n                    const service: ServiceFileWithId = {\r\n                        id: service_id,\r\n                        ...service_data\r\n                    };\r\n\r\n                    // add or update service file\r\n                    this.#service_files.set(service_id, service);\r\n                } catch (e) {\r\n                    console.error(`Failed to parse service file ${file_name}:`, e);\r\n                }\r\n            }\r\n        }\r\n\r\n        // remove any services that no longer exist\r\n        for (const existing_service_id of this.#service_files.keys()) {\r\n            if (!service_files.includes(existing_service_id + \".service.json\")) {\r\n                this.#service_files.delete(existing_service_id);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _calculate_service_start_order(): string[] {\r\n        const visited: Set<string> = new Set();\r\n        const temp_mark: Set<string> = new Set();\r\n        const result: string[] = [];\r\n\r\n        const visit = (service_id: string) => {\r\n            if (visited.has(service_id)) {\r\n                return;\r\n            }\r\n            if (temp_mark.has(service_id)) {\r\n                throw new Error(`Circular dependency detected involving service: ${service_id}`);\r\n            }\r\n\r\n            temp_mark.add(service_id);\r\n\r\n            const service = this.#service_files.get(service_id);\r\n            if (service && service.dependencies) {\r\n                for (const dep of service.dependencies) {\r\n                    visit(dep);\r\n                }\r\n            }\r\n\r\n            temp_mark.delete(service_id);\r\n            visited.add(service_id);\r\n            result.push(service_id);\r\n        };\r\n\r\n        for (const service_id of this.#service_files.keys()) {\r\n            visit(service_id);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    start_initial_services() {\r\n        const start_order = this._calculate_service_start_order();\r\n        for (const service_id of start_order) {\r\n            this.start_service(service_id);\r\n        }\r\n    }\r\n\r\n    start_service(service_id: string) {\r\n        // TODO: check dependencies are running\r\n\r\n        if (this.#running_services.has(service_id)) {\r\n            console.warn(`Service ${service_id} is already running.`);\r\n            return;\r\n        }\r\n\r\n        const service = this.#service_files.get(service_id);\r\n        if (!service) {\r\n            console.error(`Service ${service_id} not found.`);\r\n            return;\r\n        }\r\n\r\n        // mark service as should be running, so exit handlers know to restart it\r\n        this.#should_be_running_services.add(service_id);\r\n\r\n        let spawn_result: SpawnResult;\r\n        try {\r\n            spawn_result = this.#kernel.spawn(service.exec, service.args || []);\r\n        } catch (e) {\r\n            console.error(`Failed to start service ${service_id}:`, e);\r\n            return;\r\n        }\r\n\r\n        this.#running_services.set(service_id, spawn_result);\r\n        this.#failed_services.delete(service_id);\r\n\r\n        const { process, completion } = spawn_result;\r\n\r\n        // mark process as detached\r\n        process.detach(true);\r\n\r\n        // check for errors\r\n        completion.catch((e) => {\r\n            console.error(`Service ${service_id} encountered an error:`, e);\r\n            this.#running_services.delete(service_id);\r\n            this.#failed_services.add(service_id);\r\n            this._handle_service_exit(service_id, -1);\r\n        });\r\n\r\n        // handle normal exit\r\n        process.add_exit_listener((exit_code) => {\r\n            this.#running_services.delete(service_id);\r\n            this._handle_service_exit(service_id, exit_code);\r\n        });\r\n    }\r\n\r\n    stop_service(service_id: string) {\r\n        if (!this.#running_services.has(service_id)) {\r\n            console.warn(`Service ${service_id} is not running.`);\r\n            return;\r\n        }\r\n\r\n        const spawn_result = this.#running_services.get(service_id);\r\n        if (!spawn_result) {\r\n            console.error(`Service ${service_id} spawn result not found.`);\r\n            return;\r\n        }\r\n\r\n        const { process } = spawn_result;\r\n\r\n        // mark service as should not be running\r\n        this.#should_be_running_services.delete(service_id);\r\n\r\n        // send SIGTERM\r\n        process.kill(143);\r\n\r\n        // removal from running services will be handled in exit listener\r\n    }\r\n\r\n    restart_service(service_id: string) {\r\n        this.stop_service(service_id);\r\n        this.start_service(service_id); // TODO: will this conflict with the exit listener?\r\n    }\r\n\r\n    get_service_status(service_id: string): ServiceStatus | null {\r\n        if (!this.#service_files.has(service_id)) {\r\n            return null;\r\n        }\r\n\r\n        if (this.#running_services.has(service_id)) {\r\n            const spawn_result = this.#running_services.get(service_id);\r\n            if (spawn_result) {\r\n                return {\r\n                    state: \"running\",\r\n                    pid: spawn_result.process.pid\r\n                };\r\n            }\r\n        } else {\r\n            if (this.#failed_services.has(service_id)) {\r\n                return {\r\n                    state: \"failed\"\r\n                };\r\n            } else {\r\n                return {\r\n                    state: \"stopped\"\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private _handle_service_exit(service_id: string, exit_code: number) {\r\n        console.warn(`Service ${service_id} exited with code ${exit_code}.`);\r\n\r\n        if (!this.#should_be_running_services.has(service_id)) {\r\n            return;\r\n        }\r\n\r\n        const service = this.#service_files.get(service_id);\r\n        if (!service) {\r\n            return;\r\n        }\r\n\r\n        const restart_policy = service.restart;\r\n        if (!restart_policy || restart_policy.on === \"never\") {\r\n            return;\r\n        }\r\n\r\n        if (restart_policy.on === \"always\" || (restart_policy.on === \"failure\" && !CLEAN_EXIT_CODES.has(exit_code))) {\r\n            console.log(`Restarting service ${service_id} as per restart policy.`);\r\n\r\n            let delay_ms = 0;\r\n            if (\"delay_ms\" in restart_policy && restart_policy.delay_ms) {\r\n                delay_ms = restart_policy.delay_ms;\r\n            }\r\n\r\n            setTimeout(() => {\r\n                this.start_service(service_id);\r\n            }, delay_ms);\r\n        }\r\n    }\r\n}\r\n","import type { PrivilegedProgram } from \"../../../types\";\r\n\r\nimport {ServiceManager} from \"./services\";\r\nimport type {ProcessContext} from \"../../../processes\";\r\n\r\ninterface IgnitionIPCMessageBase {\r\n    type: string;\r\n}\r\n\r\ninterface IgnitionIPCPowerMessage extends IgnitionIPCMessageBase {\r\n    type: \"power\";\r\n    action: \"shutdown\" | \"reboot\";\r\n    hard?: boolean;\r\n}\r\n\r\ninterface IgnitionIPCServiceMessage extends IgnitionIPCMessageBase {\r\n    type: \"service\";\r\n    action: \"start\" | \"stop\" | \"restart\" | \"status\";\r\n    service_id: string;\r\n}\r\n\r\ninterface IgnitionIPCReloadServicesMessage extends IgnitionIPCMessageBase {\r\n    type: \"reload_services\";\r\n}\r\n\r\nexport type IgnitionIPCMessage =\r\n    IgnitionIPCPowerMessage |\r\n    IgnitionIPCServiceMessage |\r\n    IgnitionIPCReloadServicesMessage;\r\n\r\ninterface IgnitionIPCResponse extends IgnitionIPCMessageBase {\r\n    type: \"response\";\r\n    message: string;\r\n}\r\n\r\ninterface IgnitionIPCDataResponse extends IgnitionIPCMessageBase {\r\n    type: \"data\";\r\n    data: unknown;\r\n}\r\n\r\ninterface IgnitionIPCError extends IgnitionIPCMessageBase {\r\n    type: \"error\";\r\n    message: string;\r\n}\r\n\r\nexport type IgnitionIPCReply =\r\n    IgnitionIPCResponse |\r\n    IgnitionIPCDataResponse |\r\n    IgnitionIPCError;\r\n\r\n// TODO: split ipc handling etc into files\r\n\r\nexport default {\r\n    name: \"ignition\",\r\n    description: \"System init process\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const { kernel, term, process } = data;\r\n\r\n        // check if ignition is already running (only allowed to be PID 1)\r\n        if (process.pid !== 1) {\r\n            term.writeln(\"Cannot run ignition.\");\r\n            return 1;\r\n        }\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        // determine boot target from /etc/boot_target\r\n        let boot_target = \"jetty\";\r\n        let boot_args: string[] = [];\r\n\r\n        try {\r\n            const boot_target_data = await fs.read_file(\"/etc/boot_target\") as string;\r\n            boot_target = boot_target_data.trim();\r\n        } catch (e) {\r\n            term.writeln(\"Warning: /etc/boot_target not found, defaulting to 'jetty' target!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        if (!boot_target) {\r\n            term.writeln(\"Warning: /etc/boot_target is empty, defaulting to 'jetty' target!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        // separate args if any\r\n        const boot_target_parts = boot_target.split(\" \");\r\n        boot_target = boot_target_parts[0];\r\n\r\n        if (boot_target_parts.length > 1) {\r\n            boot_args = boot_target_parts.slice(1);\r\n        }\r\n\r\n        // create service manager\r\n        const svc_mgr = new ServiceManager(kernel);\r\n\r\n        // load service files but don't start them yet\r\n        await svc_mgr.load_service_files();\r\n\r\n        // open and handle ipc communication\r\n        const ipc = kernel.get_ipc();\r\n\r\n        ipc.service_register(\"init\", process.pid, async (channel_id) => {\r\n            ipc.channel_listen(channel_id, process.pid, async (msg) => {\r\n                const payload = msg.data as IgnitionIPCMessage;\r\n\r\n                // TODO: clean up when it gets more complex\r\n\r\n                switch (payload.type) {\r\n                    case \"reload_services\": {\r\n                        await svc_mgr.load_service_files();\r\n                        ipc.channel_send(channel_id, process.pid, {\r\n                            type: \"response\",\r\n                            message: \"Service files reloaded.\"\r\n                        });\r\n                        break;\r\n                    }\r\n                    case \"service\": {\r\n                        const service_msg = payload as IgnitionIPCServiceMessage;\r\n                        switch (service_msg.action) {\r\n                            case \"start\": {\r\n                                svc_mgr.start_service(service_msg.service_id);\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"response\",\r\n                                    message: `Service ${service_msg.service_id} started.`\r\n                                });\r\n                                break;\r\n                            }\r\n                            case \"stop\": {\r\n                                svc_mgr.stop_service(service_msg.service_id);\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"response\",\r\n                                    message: `Service ${service_msg.service_id} stopped.`\r\n                                });\r\n                                break;\r\n                            }\r\n                            case \"restart\": {\r\n                                svc_mgr.restart_service(service_msg.service_id);\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"response\",\r\n                                    message: `Service ${service_msg.service_id} restarted.`\r\n                                });\r\n                                break;\r\n                            }\r\n                            case \"status\": {\r\n                                const status = svc_mgr.get_service_status(service_msg.service_id);\r\n\r\n                                if (!status) {\r\n                                    ipc.channel_send(channel_id, process.pid, {\r\n                                        type: \"error\",\r\n                                        message: `Service ${service_msg.service_id} not found.`\r\n                                    });\r\n                                    break;\r\n                                }\r\n\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"data\",\r\n                                    data: status\r\n                                });\r\n                                break;\r\n                            }\r\n                            default:\r\n                                ipc.channel_send(channel_id, process.pid, {\r\n                                    type: \"error\",\r\n                                    message: `Unknown service action: ${service_msg.action}`\r\n                                });\r\n                        }\r\n                    }\r\n                        break;\r\n                    default:\r\n                        ipc.channel_send(channel_id, process.pid, {\r\n                            type: \"error\",\r\n                            message: `Unknown message type: ${payload.type}`\r\n                        });\r\n                }\r\n            });\r\n        });\r\n\r\n        let running = true;\r\n        let final_code = 0;\r\n        let current_tty_process: ProcessContext;\r\n\r\n        // on exit, force boot target to exit too\r\n        // TODO: add process ownership to automatically kill child processes\r\n        const proc_mgr = kernel.get_process_manager();\r\n        process.add_exit_listener(async (exit_code) => {\r\n            if (current_tty_process && proc_mgr.get_process(current_tty_process.pid)) {\r\n                current_tty_process.kill(exit_code);\r\n            }\r\n\r\n            final_code = exit_code;\r\n            running = false;\r\n        });\r\n\r\n        // start initial services\r\n        svc_mgr.start_initial_services();\r\n\r\n        // execute boot target in a respawn loop\r\n        while (running) {\r\n            const boot_target_proc = kernel.spawn(boot_target, boot_args);\r\n            current_tty_process = boot_target_proc.process;\r\n\r\n            const exit_code = await boot_target_proc.completion;\r\n            console.log(`boot target ${boot_target} exited with code ${exit_code}`);\r\n\r\n            // TODO: error recovery logic if boot target fails multiple times in a row\r\n        }\r\n\r\n        return final_code;\r\n    }\r\n} as PrivilegedProgram;\r\n","import type {Program} from \"../../types\";\r\nimport type {ProcessContext} from \"../../processes\";\r\nimport {ANSI} from \"../../term_ctl\";\r\n\r\nexport default {\r\n    name: \"jetty\",\r\n    description: \"TTY init process\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const {kernel, term, process} = data;\r\n\r\n        term.reset();\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        // determine default shell from /etc/default_shell\r\n        let default_shell = \"ash\";\r\n        let default_shell_args: string[] = [];\r\n\r\n        try {\r\n            const default_shell_data = await fs.read_file(\"/etc/default_shell\") as string;\r\n            default_shell = default_shell_data.trim();\r\n        } catch (e) {\r\n            term.writeln(\"Warning: /etc/default_shell not found, defaulting to 'ash' shell!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        if (!default_shell) {\r\n            term.writeln(\"Warning: /etc/default_shell is empty, defaulting to 'ash' shell!\");\r\n\r\n            // wait 3 seconds\r\n            await new Promise((resolve) => setTimeout(resolve, 3000));\r\n        }\r\n\r\n        // separate shell args if any\r\n        const default_shell_parts = default_shell.split(\" \");\r\n        default_shell = default_shell_parts[0];\r\n\r\n        if (default_shell_parts.length > 1) {\r\n            default_shell_args = default_shell_parts.slice(1);\r\n        }\r\n\r\n        let running = true;\r\n        let final_code = 0;\r\n        let current_shell_process: ProcessContext;\r\n\r\n        // on exit, force shell to exit too\r\n        // TODO: add process ownership to automatically kill child processes\r\n        const proc_mgr = kernel.get_process_manager();\r\n        process.add_exit_listener(async (exit_code) => {\r\n            if (current_shell_process && proc_mgr.get_process(current_shell_process.pid)) {\r\n                current_shell_process.kill(exit_code);\r\n            }\r\n\r\n            final_code = exit_code;\r\n            running = false;\r\n        });\r\n\r\n        // execute shell in a respawn loop\r\n        while (running) {\r\n            const shell_proc = kernel.spawn(default_shell, default_shell_args);\r\n            current_shell_process = shell_proc.process;\r\n\r\n            const exit_code = await shell_proc.completion;\r\n            // TODO: why is this needed? is spawn not managing process death correctly?\r\n            shell_proc.process.kill(exit_code);\r\n\r\n            console.log(`default shell ${default_shell} exited with code ${exit_code}`);\r\n\r\n            // early break in case jetty is being killed\r\n            if (!running) {\r\n                break;\r\n            }\r\n\r\n            term.reset();\r\n\r\n            term.writeln(exit_code === 0 ? \"Logged out.\" : `Shell exited with code ${exit_code}!`);\r\n            term.writeln(`Press any key to log back in.${ANSI.CURSOR.invisible}`);\r\n\r\n            await term.wait_for_keypress();\r\n            term.write(ANSI.CURSOR.visible);\r\n\r\n            term.reset();\r\n        }\r\n\r\n        return final_code;\r\n    }\r\n} as Program;\r\n","import type {AbstractShellMemory} from \"../../../abstract_shell\";\r\n\r\nexport class AshMemory implements AbstractShellMemory {\r\n    // TODO: backup history in a file\r\n    #history: string[] = [];\r\n\r\n    current_history_index = 0;\r\n\r\n    readonly #vars: Map<string, string> = new Map();\r\n    readonly #aliases: Map<string, string> = new Map();\r\n\r\n    clear_history(): void {\r\n        this.#history = [];\r\n        this.current_history_index = 0;\r\n    }\r\n\r\n    get_previous_history_entry(): string | undefined {\r\n        if (this.#history.length === 0 || this.current_history_index >= this.#history.length) {\r\n            return undefined;\r\n        }\r\n\r\n        const entry = this.#history[this.#history.length - 1 - this.current_history_index];\r\n        this.current_history_index += 1;\r\n        return entry;\r\n    }\r\n\r\n    get_next_history_entry(): string | undefined {\r\n        if (this.#history.length === 0 || this.current_history_index <= 0) {\r\n            return undefined;\r\n        }\r\n\r\n        this.current_history_index -= 1;\r\n        if (this.current_history_index === 0) {\r\n            return \"\";\r\n        }\r\n\r\n        return this.#history[this.#history.length - 1 - this.current_history_index];\r\n    }\r\n\r\n    add_history_entry(entry: string): void {\r\n        this.#history.push(entry);\r\n        this.current_history_index = 0;\r\n    }\r\n\r\n    list_variables(): Map<string, string> {\r\n        return this.#vars;\r\n    }\r\n\r\n    get_variable(name: string): string | undefined {\r\n        return this.#vars.get(name);\r\n    }\r\n\r\n    set_variable(name: string, value: string): void {\r\n        this.#vars.set(name, value);\r\n    }\r\n\r\n    unset_variable(name: string): boolean {\r\n        return this.#vars.delete(name);\r\n    }\r\n\r\n    list_aliases(): Map<string, string> {\r\n        return this.#aliases;\r\n    }\r\n\r\n    get_alias(name: string): string | undefined {\r\n        return this.#aliases.get(name);\r\n    }\r\n\r\n    set_alias(name: string, value: string): void {\r\n        this.#aliases.set(name, value);\r\n    }\r\n\r\n    unset_alias(name: string): boolean {\r\n        return this.#aliases.delete(name);\r\n    }\r\n}\r\n","import {AshMemory} from \"./memory\";\r\nimport type {ParsedCommandLine} from \"../../../kernel\";\r\n\r\nexport interface LineParseResultCommand extends ParsedCommandLine {\r\n    type: \"command\";\r\n}\r\n\r\nexport interface LineParseResultVarAssignment {\r\n    type: \"var\";\r\n\r\n    var_name: string;\r\n    var_value: string;\r\n}\r\n\r\nexport type LineParseResult = LineParseResultCommand | LineParseResultVarAssignment | null;\r\n\r\nconst VAR_ASSIGNMENT_REGEX = /^([a-zA-Z0-9_]+)=(.+)$/;\r\n\r\nexport const parse_line = (line: string, memory?: AshMemory): LineParseResult => {\r\n    if (line.length === 0) {\r\n        // if the line is empty, nothing to parse\r\n        return null;\r\n    }\r\n\r\n    // TODO: handle multiple commands separated by semicolons\r\n\r\n    // remove leading and trailing whitespace and split by spaces, unless contained in single or double quotes\r\n    // TODO: use a proper stack based parser for readability and maintainability\r\n    const raw_parts = line.split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\r\n    const sub = line.trim().split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\r\n\r\n    // handle aliases\r\n    // for each part, check if it's an alias, and if so, replace it with the value\r\n    // if the value ends with a space, check the next part as well\r\n    for (let i = 0; i < sub.length; i++) {\r\n        const part = sub[i];\r\n        const alias_value = memory ? memory.get_alias(part) : undefined;\r\n\r\n        if (!alias_value) {\r\n            // not an alias, abort (alias only applies to the first word unless chaining)\r\n            break;\r\n        }\r\n\r\n        // split the alias value into parts\r\n        const alias_parts = alias_value.split(/ +(?=(?:(?:[^\"']*[\"'][^\"']*[\"'])*[^\"']*$))/);\r\n\r\n        // if ends with a space, remove the trailing empty part\r\n        if (alias_value.endsWith(\" \")) {\r\n            alias_parts.pop();\r\n        }\r\n\r\n        // remove the current part and insert the alias parts\r\n        sub.splice(i, 1, ...alias_parts);\r\n\r\n        // adjust the index to account for the new parts\r\n        i += alias_parts.length - 1;\r\n\r\n        // if the alias value ends with a space, check the next part as well\r\n        if (!alias_value.endsWith(\" \")) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    const skip_variable_sub_idxs = [];\r\n\r\n    // remove quotes from arguments if starting and ending with quotes\r\n    // if they are single quotes then disable substitution\r\n    for (let i = 0; i < sub.length; i++) {\r\n        if (i === 0) {\r\n            // skip the first argument (the command)\r\n            continue;\r\n        }\r\n\r\n        const arg = sub[i];\r\n\r\n        if (arg.startsWith(\"\\\"\") && arg.endsWith(\"\\\"\")) {\r\n            sub[i] = arg.slice(1, -1);\r\n        }\r\n\r\n        if (arg.startsWith(\"'\") && arg.endsWith(\"'\")) {\r\n            sub[i] = arg.slice(1, -1);\r\n            skip_variable_sub_idxs.push(i - 1); // skip variable substitution for this argument (adjust for slice)\r\n        }\r\n    }\r\n\r\n    // the first word is the command, the rest are arguments\r\n    const command = sub[0];\r\n\r\n    if (command === \"#\") {\r\n        // if the command is a comment, just ignore\r\n        return null;\r\n    }\r\n\r\n    // determine if the line is a variable assignment with regex\r\n    if (command.includes(\"=\")) {\r\n        const match = line.match(VAR_ASSIGNMENT_REGEX);\r\n\r\n        if (match) {\r\n            const var_name = match[1];\r\n            let var_value = match[2];\r\n\r\n            // remove single or double quotes from the value\r\n            // TODO: make this more unixy when we add semicolons\r\n            if (var_value.startsWith(\"'\") || var_value.startsWith(\"\\\"\")) {\r\n                var_value = var_value.slice(1, -1);\r\n            }\r\n\r\n            // this is a variable assignment\r\n            return {\r\n                type: \"var\",\r\n\r\n                var_name,\r\n                var_value\r\n            }\r\n        }\r\n    }\r\n\r\n    const args = sub.slice(1);\r\n\r\n    // if the last arg value is &, run in bg and remove it from args BEFORE variable substitution\r\n    let run_in_bg = false;\r\n    if (args.length > 0 && args[args.length - 1] === \"&\") {\r\n        run_in_bg = true;\r\n        args.pop();\r\n    }\r\n\r\n    const unsubbed_args = args.slice();\r\n\r\n    // substitute args with variables\r\n    for (let arg_idx = 0; arg_idx < args.length; arg_idx++) {\r\n        if (skip_variable_sub_idxs.includes(arg_idx)) {\r\n            // skip variable substitution for this argument\r\n            continue;\r\n        }\r\n\r\n        let arg = args[arg_idx];\r\n\r\n        // replaces any instance of $VAR or ${VAR} with the value of the variable VAR (alphabetical only except special var $?)\r\n        // TODO: backslash to escape dollar sign without using single quotes\r\n        arg = arg.replace(/\\$(\\w+|\\?)|\\$\\{([^}]+)\\}/g, (match, var1, var2) => {\r\n            const var_name = var1 || var2;\r\n            const var_value = memory ? memory.get_variable(var_name) : undefined;\r\n\r\n            if (!var_value) {\r\n                // if the variable is not set, return the original match\r\n                return match;\r\n            }\r\n\r\n            return var_value;\r\n        });\r\n\r\n        args[arg_idx] = arg;\r\n    }\r\n\r\n    // this is a command\r\n    return {\r\n        type: \"command\",\r\n\r\n        command,\r\n        args,\r\n        unsubbed_args,\r\n        raw_parts,\r\n        run_in_bg\r\n    };\r\n}\r\n","import type {AbstractShell} from \"../../../abstract_shell\";\r\nimport type {UserspaceKernel, SpawnResult} from \"../../../kernel\";\r\n\r\nimport {ANSI, NEWLINE, type WrappedTerminal} from \"../../../term_ctl\";\r\n\r\nimport {AshMemory} from \"./memory\";\r\nimport {parse_line} from \"./parser\";\r\n\r\nconst {PREFABS, FG, STYLE} = ANSI;\r\n\r\nexport class AshShell implements AbstractShell {\r\n    readonly #kernel: UserspaceKernel;\r\n    readonly #term: WrappedTerminal;\r\n    readonly #memory = new AshMemory();\r\n\r\n    #prompt_suffix = \"$ \";\r\n\r\n    // TODO: find a better place/way to handle this, maybe tab completion should be a class that stores its own state\r\n    _discard_cached_matches = false;\r\n\r\n    constructor(term: WrappedTerminal, kernel: UserspaceKernel) {\r\n        this.#term = term;\r\n        this.#kernel = kernel;\r\n    }\r\n\r\n    get memory(): AshMemory {\r\n        return this.#memory;\r\n    }\r\n\r\n    // returns success flag (or error if critical)\r\n    execute = async (line: string, edit_doc_title = true, program_final_completion_callback?: (exit_code?: number) => void): Promise<boolean> => {\r\n        const kernel = this.#kernel;\r\n        const term = this.#term;\r\n        const memory = this.#memory;\r\n\r\n        // TODO: semicolon to run multiple commands regardless of success\r\n        // TODO: double ampersand to run multiple commands only if previous succeeded\r\n        // TODO: double pipe to run multiple commands only if previous failed\r\n        // TODO: single pipe to pipe output of previous command to next command\r\n        // TODO: allow certain control characters to be escaped e.g. $\r\n        // TODO: support sh files\r\n\r\n        if (line.length === 0) {\r\n            // if the line is empty, just move to the next line (additional check if called from external source)\r\n            return true;\r\n        }\r\n\r\n        const parsed_line = parse_line(line, memory);\r\n\r\n        if (parsed_line === null) {\r\n            // if the line is a comment or empty, do nothing\r\n            return true;\r\n        }\r\n\r\n        // handle variable assignment\r\n        if (parsed_line.type === \"var\") {\r\n            memory.set_variable(parsed_line.var_name, parsed_line.var_value);\r\n            return true;\r\n        }\r\n\r\n        // otherwise, it's a command. destructure it\r\n        const { command } = parsed_line;\r\n\r\n        // check if the command exists\r\n        const prog_reg = kernel.get_program_registry();\r\n        if (!prog_reg.getProgram(command)) {\r\n            term.writeln(`${PREFABS.error}Command not found: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n            return false;\r\n        }\r\n\r\n        let old_title = \"\";\r\n        if (edit_doc_title) {\r\n            old_title = document.title;\r\n            document.title = command;\r\n        }\r\n\r\n        // spawn the process\r\n        let spawn_result: SpawnResult;\r\n        try {\r\n            spawn_result = kernel.spawn(parsed_line, undefined, this);\r\n        } catch (e) {\r\n            if (edit_doc_title) {\r\n                document.title = old_title;\r\n            }\r\n\r\n            term.writeln(`${PREFABS.error}Failed to execute command: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}.`);\r\n            term.writeln(`${FG.red + STYLE.italic}${(e as Error).message}${STYLE.reset_all}`);\r\n\r\n            console.error(e);\r\n\r\n            return false;\r\n        }\r\n\r\n        const { process, completion } = spawn_result;\r\n\r\n        const on_execute_completion = (exit_code?: number) => {\r\n            if (exit_code === undefined) {\r\n                exit_code = -2;\r\n                console.warn(`Program ${command} did not return an exit code. Defaulting to -2.`)\r\n            }\r\n\r\n            memory.current_history_index = 0;\r\n\r\n            if (edit_doc_title) {\r\n                document.title = old_title;\r\n            }\r\n\r\n            if (process.is_detached) {\r\n                process.add_exit_listener((code) => {\r\n                    if (program_final_completion_callback) {\r\n                        try {\r\n                            program_final_completion_callback(code);\r\n                        } catch (e) {\r\n                            console.error(\"Error in program final completion callback for detached process:\", e);\r\n                        }\r\n                    }\r\n\r\n                    if (process.detaches_silently) {\r\n                        return;\r\n                    }\r\n\r\n                    const status = code === 0 ? \"Done\" : `Exit ${code}`;\r\n                    const color = code === 0 ? FG.green : FG.red;\r\n\r\n                    // TODO: erase existing prompt and line\r\n                    term.writeln(\"\");\r\n                    term.writeln(`${FG.gray}[${process.pid}] + ${color}${status}${FG.gray} \\t ${command}${STYLE.reset_all}`);\r\n\r\n                    // reinsert the prompt and current line\r\n                    // TODO: respect running programs, maybe need a notification queue\r\n                    this.insert_prompt(false);\r\n                });\r\n\r\n                // don't kill the process\r\n                return;\r\n            }\r\n\r\n            process.kill(exit_code);\r\n\r\n            if (program_final_completion_callback) {\r\n                try {\r\n                    program_final_completion_callback(exit_code);\r\n                } catch (e) {\r\n                    console.error(\"Error in program final completion callback:\", e);\r\n                }\r\n            }\r\n\r\n            if (process.is_background) {\r\n                term.writeln(`\\n${FG.gray}[${process.pid}] + Done \\t ${command}${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        // now handle awaiting program completion\r\n        try {\r\n            if (process.is_detached) {\r\n                if (!process.detaches_silently) {\r\n                    term.writeln(`${FG.gray}[${process.pid}] process detached${STYLE.reset_all}`);\r\n                }\r\n\r\n                completion.then((exit_code) => {\r\n                    on_execute_completion(exit_code);\r\n                }).catch((e) => {\r\n                    term.writeln(`${PREFABS.error}An unhandled error occurred in detached process [${process.pid}]: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n                    console.error(e);\r\n                    on_execute_completion(-1);\r\n                });\r\n            } else if (process.is_foreground) {\r\n                const exit_code = await completion;\r\n                on_execute_completion(exit_code);\r\n\r\n                // set the exit code variable\r\n                memory.set_variable(\"?\", exit_code.toString());\r\n            } else {\r\n                this.#term.writeln(`${FG.gray}[${process.pid}] ${STYLE.italic}running in background${STYLE.reset_all}`);\r\n\r\n                completion.then((exit_code) => {\r\n                    on_execute_completion(exit_code);\r\n                }).catch((e) => {\r\n                    this.#term.writeln(`${PREFABS.error}An unhandled error occurred in background process [${process.pid}]: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n                    console.error(e);\r\n\r\n                    on_execute_completion(-1);\r\n                });\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}An unhandled error occurred while running the command: ${FG.white + STYLE.italic}${command}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            on_execute_completion(-1);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async run_script(path: string) {\r\n        const fs = this.#kernel.get_fs();\r\n\r\n        if (await fs.exists(path)) {\r\n            // iter through the lines of the file and execute them\r\n            const content = await fs.read_file(path) as string;\r\n            for (const line of content.split(NEWLINE)) {\r\n                // TODO: catch errors\r\n                await this.execute(line);\r\n            }\r\n        }\r\n    }\r\n\r\n    get_prompt_suffix(): string {\r\n        return this.#prompt_suffix;\r\n    }\r\n\r\n    set_prompt_suffix(suffix: string): void {\r\n        this.#prompt_suffix = suffix;\r\n    }\r\n\r\n    get_prompt_string(): string {\r\n        const fs = this.#kernel.get_fs();\r\n\r\n        let path = fs.get_cwd();\r\n\r\n        if (path.startsWith(fs.get_home())) {\r\n            // replace home with ~ at start of path only\r\n            path = path.replace(new RegExp(`^${fs.get_home()}`), \"~\");\r\n        }\r\n\r\n        // build result e.g. ~$\r\n        return `${PREFABS.dir_name}${path}${STYLE.reset_all}${this.#prompt_suffix}`;\r\n    }\r\n\r\n    async insert_prompt(newline = true) {\r\n        const term = this.#term;\r\n\r\n        if (newline) {\r\n            term.write(NEWLINE);\r\n        }\r\n\r\n        // resolve a promise when writing is complete\r\n        await new Promise<void>((resolve) => {\r\n            term.write(this.get_prompt_string(), () => {\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n}\r\n","import type {UserspaceKernel} from \"../../../kernel\";\r\nimport type {ReadLineBuffer, WrappedTerminal} from \"../../../term_ctl\";\r\nimport type {CompletionData} from \"../../../types\";\r\n\r\nimport {parse_line} from \"./parser\";\r\nimport {AbstractShell} from \"../../../abstract_shell\";\r\n\r\n// TODO this is really poor OOP\r\nlet cached_matches: string[] = [];\r\nlet current_cached_match_index = 0;\r\n\r\nconst complete_command = (buffer: ReadLineBuffer, discard_cached_matches: boolean, kernel: UserspaceKernel) => {\r\n    // get the program registry\r\n    const registry = kernel.get_program_registry();\r\n    const programs = registry.listProgramNames(true, true);\r\n\r\n    // check for existing matches\r\n    let match: string;\r\n    if (!discard_cached_matches && cached_matches.length > 0) {\r\n        // if the current line hasn't changed, just get the next match\r\n        current_cached_match_index = (current_cached_match_index + 1) % cached_matches.length;\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n    } else {\r\n        // if the current line has changed, refresh the matches\r\n        cached_matches = programs.filter((program) => program.startsWith(buffer.current_line));\r\n        current_cached_match_index = 0;\r\n\r\n        // get the first match\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n\r\n        // mark as unmodified\r\n        discard_cached_matches = false;\r\n    }\r\n\r\n    return {match, discard_cached_matches};\r\n}\r\n\r\nconst is_async_generator = (obj: unknown): obj is AsyncGenerator<string> => {\r\n    return obj && typeof obj[Symbol.asyncIterator] === \"function\";\r\n}\r\n\r\nconst get_completeable_arguments = async (buffer: ReadLineBuffer, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\r\n    // parse the line\r\n\r\n    const parsed_line = parse_line(buffer.current_line);\r\n    if (parsed_line.type !== \"command\") {\r\n        console.warn(\"Tab completion for non-command lines is not yet implemented\");\r\n        return null;\r\n    }\r\n\r\n    // destructure parsed line\r\n    const {command, args, unsubbed_args, raw_parts} = parsed_line;\r\n\r\n    // get the command from the registry\r\n    const registry = kernel.get_program_registry();\r\n    const program = registry.getProgram(command);\r\n    if (!program) {\r\n        console.warn(`Tab completion for unknown command \"${command}\"`);\r\n        return null;\r\n    }\r\n\r\n    // if the program has no completion generator, complete based on file paths\r\n    if (!program.completion) {\r\n        // TODO need to change data structure first\r\n        console.warn(`Tab completion for command \"${command}\" with no completion generator is not yet implemented`);\r\n        return null;\r\n    }\r\n\r\n    const completion_data = {\r\n        term,\r\n        kernel,\r\n        shell,\r\n        command,\r\n        args,\r\n        raw_parts: raw_parts,\r\n        unsubbed_args,\r\n        current_partial: raw_parts[raw_parts.length - 1] || \"\",\r\n        arg_index: raw_parts.length - 2, // -1 for current arg, -1 for program name\r\n    };\r\n\r\n    const completion_result = await program.completion(completion_data);\r\n\r\n    // if the result is an async generator, get all values for now\r\n    // in future this will be done incrementally, but the current data structure doesn't support that yet\r\n    if (is_async_generator(completion_result)) {\r\n        const results: string[] = [];\r\n        for await (const value of completion_result) {\r\n            results.push(value);\r\n        }\r\n        return results;\r\n    } else {\r\n        if (completion_result === null) {\r\n            // TODO fall back to file path completion\r\n            console.warn(`Tab completion for command \"${command}\" with null completion result is not yet implemented`);\r\n            return null;\r\n        }\r\n\r\n        return completion_result;\r\n    }\r\n}\r\n\r\nconst complete_argument = async (buffer: ReadLineBuffer, discard_cached_matches: boolean, kernel: UserspaceKernel, term: WrappedTerminal, shell?: AbstractShell) => {\r\n    // get the completeable arguments\r\n    const completeable_arguments = await get_completeable_arguments(buffer, term, kernel, shell);\r\n    if (!completeable_arguments) {\r\n        return {match: \"\", discard_cached_matches};\r\n    }\r\n\r\n    // check for existing matches\r\n    let match: string;\r\n    if (!discard_cached_matches && cached_matches.length > 0) {\r\n        // if the current line hasn't changed, just get the next match\r\n        current_cached_match_index = (current_cached_match_index + 1) % cached_matches.length;\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n    } else {\r\n        // if the current line has changed, refresh the matches\r\n        cached_matches = completeable_arguments.filter((arg) => arg.startsWith(buffer.current_line.split(\" \").pop() || \"\"));\r\n        current_cached_match_index = 0;\r\n\r\n        // get the first match\r\n        match = cached_matches[current_cached_match_index] || \"\";\r\n\r\n        // mark as unmodified\r\n        discard_cached_matches = false;\r\n    }\r\n\r\n    return {match, discard_cached_matches};\r\n}\r\n\r\nconst fill_completed_command = (term: WrappedTerminal, buffer: ReadLineBuffer, match: string) => {\r\n    // erase the current line\r\n    term.write(\"\\b \\b\".repeat(buffer.current_index));\r\n\r\n    // write the match\r\n    term.write(match);\r\n\r\n    // NOTE: above is done rather than filling what is remaining because if tab is hit again, the next match will be written\r\n\r\n    // update current line and index\r\n    buffer.set_current_line(match);\r\n    buffer.set_current_index(match.length);\r\n}\r\n\r\nconst fill_completed_argument = (term: WrappedTerminal, buffer: ReadLineBuffer, match: string) => {\r\n    // get the current line parts\r\n    const parts = buffer.current_line.split(\" \");\r\n    const current_arg_partial = parts.pop() || \"\";\r\n\r\n    // erase the current argument partial\r\n    term.write(\"\\b \\b\".repeat(current_arg_partial.length));\r\n\r\n    // write the match\r\n    term.write(match);\r\n\r\n    // NOTE: above is done rather than filling what is remaining because if tab is hit again, the next match will be written\r\n\r\n    // update current line and index\r\n    parts.push(match);\r\n    buffer.set_current_line(parts.join(\" \"));\r\n    buffer.set_current_index(buffer.current_line.length);\r\n}\r\n\r\n// TODO: how does this work? would be good to make it linked to the terminal instance. what is discard_cached_matches even for?\r\nexport const tab_complete = async (buffer: ReadLineBuffer, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell, discard_cached_matches = false): Promise<boolean> => {\r\n    // if the current line is empty, do nothing\r\n    if (buffer.current_line.length === 0) {\r\n        return;\r\n    }\r\n\r\n    // if the current line has no spaces, tab complete the command\r\n    if (!buffer.current_line.includes(\" \")) {\r\n        const {match, discard_cached_matches: updated_discard} = complete_command(buffer, discard_cached_matches, kernel);\r\n        discard_cached_matches = updated_discard;\r\n\r\n        // if there is a match, tab complete\r\n        if (match) {\r\n            fill_completed_command(term, buffer, match);\r\n        }\r\n    } else {\r\n        // otherwise, tab complete the argument\r\n        const {match, discard_cached_matches: updated_discard} = await complete_argument(buffer, discard_cached_matches, kernel, term, shell);\r\n        discard_cached_matches = updated_discard;\r\n\r\n        // if there is a match, tab complete\r\n        if (match) {\r\n            fill_completed_argument(term, buffer, match);\r\n        }\r\n    }\r\n\r\n    return discard_cached_matches;\r\n}\r\n\r\n// TODO: the discard cache arg is janky. come up with a better solution. should also be using generators directly instead of arrays for completions\r\n// TODO: would be much better as a class that maintains its own state and remembers term, kernel etc.\r\n\r\nexport const helper_completion_options = (options: string[]) => {\r\n    return async function* (data: CompletionData): AsyncGenerator<string> {\r\n        const {current_partial} = data;\r\n        for (const option of options) {\r\n            if (option.startsWith(current_partial)) {\r\n                yield option;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nexport const helper_completion_options_ordered = (options: string[][]) => {\r\n    return async function* (data: CompletionData): AsyncGenerator<string> {\r\n        const {current_partial, raw_parts} = data;\r\n        const index = raw_parts.length - 1;\r\n        const options_at_index = options[index] || [];\r\n        for (const option of options_at_index) {\r\n            if (option.startsWith(current_partial)) {\r\n                yield option;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// TODO: make these helpers available to 3rd party programs","import type {Program} from \"../../../types\";\r\nimport {NEWLINE} from \"../../../term_ctl\";\r\n\r\nimport {AshShell} from \"./core\";\r\nimport {make_read_line_key_handlers, make_read_line_printable_handler} from \"./key_handlers\";\r\n\r\nexport default {\r\n    name: \"ash\",\r\n    description: \"A shell.\",\r\n    usage_suffix: \"[--login]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"--login\": \"Start the shell as a login shell. Don't pass this flag manually, it's handled by the system.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const {kernel, term, process, args} = data;\r\n\r\n        const shell = new AshShell(term, kernel);\r\n\r\n        const env_info = kernel.get_env_info();\r\n        shell.memory.set_variable(\"VERSION\", env_info.version);\r\n        shell.memory.set_variable(\"ENV\", env_info.env);\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        const absolute_profile = fs.absolute(\"~/.ash_profile\");\r\n        const absolute_rc = fs.absolute(\"~/.ashrc\");\r\n\r\n        // create .ash_profile file if it doesn't exist\r\n        const profile_content = `# ash configuration file${NEWLINE}# This file is run at login.${NEWLINE}${NEWLINE}cat /etc/motd.txt${NEWLINE}echo \"OllieOS v$VERSION ($ENV)\"${NEWLINE}`;\r\n        if (!(await fs.exists(absolute_profile))) {\r\n            await fs.write_file(absolute_profile, profile_content);\r\n        }\r\n\r\n        // create .ashrc file if it doesn't exist\r\n        const rc_content = `# ash configuration file${NEWLINE}# This file is run when a shell is created.${NEWLINE}${NEWLINE}`;\r\n        if (!(await fs.exists(absolute_rc))) {\r\n            await fs.write_file(absolute_rc, rc_content);\r\n        }\r\n\r\n        if (args.includes(\"--login\")) {\r\n            // enable screen reader mode if stored in local storage\r\n            if (localStorage.getItem(\"reader\") === \"true\") {\r\n                await shell.execute(\"reader -s on\");\r\n            }\r\n\r\n            // run .ash_profile, checking it exists again just in case (because why not)\r\n            if (await fs.exists(absolute_profile)) {\r\n                await shell.run_script(absolute_profile);\r\n            }\r\n        }\r\n\r\n        // run .ashrc, checking it exists again just in case (could be deleted in profile)\r\n        if (await fs.exists(absolute_rc)) {\r\n            await shell.run_script(absolute_rc);\r\n        }\r\n\r\n        let running = true;\r\n        let final_code = 0;\r\n        process.add_exit_listener((exit_code) => {\r\n            final_code = exit_code;\r\n            running = false;\r\n        });\r\n\r\n        const read_line_key_handlers = make_read_line_key_handlers(shell, kernel);\r\n        const read_line_printable_handler = make_read_line_printable_handler(shell);\r\n\r\n        term.focus();\r\n\r\n        while (running) {\r\n            await shell.insert_prompt(true);\r\n\r\n            const input = await term.read_line(read_line_key_handlers, read_line_printable_handler);\r\n            if (!input.trim()) {\r\n                continue;\r\n            }\r\n\r\n            // TODO: have an actual builtin processor instead of just reading input here\r\n            if (input === \"exit\") {\r\n                running = false;\r\n                break;\r\n            }\r\n\r\n            shell.memory.add_history_entry(input);\r\n            await shell.execute(input);\r\n        }\r\n\r\n        return final_code;\r\n    }\r\n} as Program;\r\n","import type {ReadLineKeyHandler} from \"../../../term_ctl\";\r\n\r\nimport type {AshShell} from \"./core\";\r\nimport type {UserspaceKernel} from \"../../../kernel\";\r\nimport {tab_complete} from \"./tab_completion\";\r\n\r\nexport const make_read_line_key_handlers = (shell: AshShell, kernel: UserspaceKernel): { [key: string]: ReadLineKeyHandler } => ({\r\n    // arrow up - previous history\r\n    \"\\x1b[A\": (_e, term, buffer) => {\r\n        const command = shell.memory.get_previous_history_entry();\r\n\r\n        if (command) {\r\n            shell._discard_cached_matches = true;\r\n\r\n            // bring cursor to end of line\r\n            term.write(\" \".repeat(buffer.current_line.length - buffer.current_index));\r\n\r\n            // clear current line (and move cursor back to start)\r\n            term.write(\"\\b \\b\".repeat(buffer.current_line.length));\r\n\r\n            // write command\r\n            term.write(command);\r\n\r\n            // update current line and index\r\n            buffer.set_current_line(command);\r\n            buffer.set_current_index(command.length);\r\n        }\r\n    },\r\n\r\n    // arrow down - next history\r\n    \"\\x1b[B\": (_e, term, buffer) => {\r\n        const command = shell.memory.get_next_history_entry();\r\n\r\n        shell._discard_cached_matches = true;\r\n\r\n        // bring cursor to end of line\r\n        term.write(\" \".repeat(buffer.current_line.length - buffer.current_index));\r\n\r\n        // clear current line (and move cursor back to start)\r\n        term.write(\"\\b \\b\".repeat(buffer.current_line.length));\r\n\r\n        if (command) {\r\n            // write command\r\n            term.write(command);\r\n\r\n            // update current line and index\r\n            buffer.set_current_line(command);\r\n            buffer.set_current_index(command.length);\r\n        } else {\r\n            // end of history, just clear line\r\n            buffer.set_current_line(\"\");\r\n            buffer.set_current_index(0);\r\n        }\r\n    },\r\n\r\n    // tab - tab completion\r\n    \"\\t\": async (_e, term, buffer) => {\r\n        shell._discard_cached_matches = await tab_complete(buffer, term, kernel, shell, shell._discard_cached_matches);\r\n    },\r\n\r\n    // backspace - discard cached matches\r\n    \"\\x7f\": () => {\r\n        // TODO: doesnt work quite the same, if they tab with nothing and hit backspace it will reset. need a way to check current line discipline\r\n        shell._discard_cached_matches = true;\r\n    }\r\n});\r\n\r\nexport const make_read_line_printable_handler = (shell: AshShell) => () => {\r\n    shell._discard_cached_matches = true;\r\n};\r\n","import type { Program } from \"../../types\";\r\nimport type {UserspaceOtherProcessContext} from \"../../processes\";\r\n\r\nimport {ANSI, NEWLINE} from \"../../term_ctl\";\r\n\r\ninterface PrivilegeRequestMessage {\r\n    process: UserspaceOtherProcessContext;\r\n    reason: string;\r\n}\r\n\r\nexport default {\r\n    name: \"default_privilege_agent\",\r\n    description: \"Default agent for handling kernel privilege requests\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        const { kernel, term, args, process: my_process } = data;\r\n\r\n        // expect arg for channel id\r\n        const channel_id_str = args[0];\r\n        if (!channel_id_str) {\r\n            term.writeln(\"Error in privilege agent: No channel ID provided.\");\r\n            return 1;\r\n        }\r\n\r\n        const channel_id = parseInt(channel_id_str, 10);\r\n        if (isNaN(channel_id)) {\r\n            term.writeln(\"Error in privilege agent: Invalid channel ID.\");\r\n            return 1;\r\n        }\r\n\r\n        // wait briefly to ensure the channel is assigned to us\r\n        // TODO: a way to fix the race condition without making the kernel expose ipc, could at least use a retry mechanism\r\n        await new Promise((resolve) => setTimeout(resolve, 250));\r\n\r\n        // listen to the channel\r\n        const ipc = kernel.get_ipc();\r\n\r\n        let finished = false;\r\n        let handling_request = false;\r\n\r\n        ipc.channel_listen(channel_id, async (msg) => {\r\n            if (handling_request) {\r\n                // already handling a request, ignore new ones\r\n                return;\r\n            }\r\n\r\n            handling_request = true;\r\n\r\n            const { process, reason } = msg.data as PrivilegeRequestMessage;\r\n\r\n            // immediately acknowledge the request is being handled\r\n            ipc.channel_send(channel_id, {\r\n                process,\r\n                handling: true\r\n            });\r\n\r\n            term.writeln(`${NEWLINE}${ANSI.STYLE.bold}${ANSI.BG.blue}${ANSI.FG.white}KERNEL PRIVILEGE REQUEST${ANSI.STYLE.reset_all}${ANSI.BG.gray}${NEWLINE}`);\r\n\r\n            term.writeln(`Process PID ${process.pid} (${process.source_command.command}) is requesting elevated kernel privileges.`);\r\n            term.writeln(`The process gave the following reason for the request:${NEWLINE}`);\r\n\r\n            term.writeln(`${ANSI.STYLE.bold}${ANSI.FG.yellow}\"${reason}\"${ANSI.FG.reset}${ANSI.STYLE.no_bold_or_dim}${NEWLINE}`);\r\n\r\n            term.writeln(\"Granting this request will allow the process full access to the kernel, which may compromise system security and stability.\");\r\n            term.writeln(\"It may also be able to temporarily share this access with other running processes.\");\r\n\r\n            term.writeln(`${NEWLINE}Do you wish to grant elevated privileges to PID ${process.pid}? (y/n)${ANSI.STYLE.reset_all}${ANSI.CURSOR.invisible}`);\r\n\r\n            const event = await term.wait_for_keypress();\r\n            term.write(ANSI.CURSOR.visible);\r\n\r\n            if (event.key.toLowerCase() === \"y\") {\r\n                term.writeln(`${NEWLINE}${ANSI.BG.green}${ANSI.FG.white}Privilege request granted.${ANSI.STYLE.reset_all}${NEWLINE}`);\r\n                ipc.channel_send(channel_id, {\r\n                    process,\r\n                    granted: true\r\n                });\r\n            } else {\r\n                term.writeln(`${NEWLINE}${ANSI.BG.red}${ANSI.FG.white}Privilege request denied.${ANSI.STYLE.reset_all}${NEWLINE}`);\r\n                ipc.channel_send(channel_id, {\r\n                    process,\r\n                    granted: false\r\n                });\r\n            }\r\n\r\n            finished = true;\r\n        });\r\n\r\n        my_process.add_exit_listener(() => {\r\n            finished = true;\r\n        });\r\n\r\n        // wait to handle for up to 10 seconds\r\n        // overall timeout up to 60 seconds\r\n        const start_time = Date.now();\r\n        // TODO: clean up logic here\r\n        while ((Date.now() - start_time) < 60000 && !finished && (handling_request || (Date.now() - start_time) < 10000)) {\r\n            const timeout_id = my_process.create_timeout(() => {}, 100);\r\n            await my_process.wait_for_timeout(timeout_id);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import { ANSI, NEWLINE, ANSI_ESCAPE_REGEX } from \"../term_ctl\";\r\nimport type { Program, ArgDescriptions } from \"../types\";\r\n\r\n\r\n// deferred to prevent double printing of header if program has to re-execute itself\r\nconst header = (term, includes_mounted: boolean) => {\r\n    // write header\r\n\r\n    if (!includes_mounted) {\r\n        term.writeln(`${ANSI.STYLE.italic}(Only built-in programs are included. Use the -m flag to include only mounted programs, or the -a flag to include all.)${ANSI.STYLE.reset_all}`);\r\n    }\r\n\r\n    term.writeln(`For help on a specific command, type ${ANSI.PREFABS.program_name}help${ANSI.STYLE.reset_all} [command].`)\r\n    term.writeln(`The exit code of the most recently executed program is stored in the ${ANSI.PREFABS.variable_name}$?${ANSI.STYLE.reset_all} variable.`)\r\n    term.writeln(`You can set variables with the syntax ${ANSI.PREFABS.variable_name}variable${ANSI.STYLE.reset_all}=value and unset them with ${ANSI.PREFABS.program_name}unset${ANSI.STYLE.reset_all}.`)\r\n    term.writeln(`To persist the variables, define them in the ${ANSI.PREFABS.file_path}.ollierc${ANSI.STYLE.reset_all} file in your ${ANSI.PREFABS.dir_name}home${ANSI.STYLE.reset_all} directory.`)\r\n    term.writeln(`You can run commands in the background by appending ${ANSI.STYLE.bold}${ANSI.FG.magenta}&${ANSI.STYLE.reset_all} to the end of the command.`)\r\n    term.write(NEWLINE);\r\n}\r\n\r\n// TODO: this should also probably be part of the shell rather than a program? i guess it doesn't matter much, it just acts more like man\r\nexport default {\r\n    name: \"help\",\r\n    description: \"List programs or get help for a specific program.\",\r\n    usage_suffix: \"[command | -s] [-a | -m]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"command\": \"The name of the program to get help for.\",\r\n        },\r\n        \"Flags:\": {\r\n            \"-s\": \"Single-column mode. Forces the program list to be displayed in a single column.\",\r\n            \"-a\": \"All programs. Includes all programs, built-in and mounted.\",\r\n            \"-m\": \"Mounted programs. Includes only mounted programs.\",\r\n        },\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // TODO smarter completion to handle number of args and flags\r\n        const programs = data.kernel.get_program_registry().listProgramNames();\r\n        return programs.filter((program) => program.startsWith(data.current_partial));\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        const registry = kernel.get_program_registry();\r\n\r\n        let single_column = false;\r\n        let includes_mounted = false;\r\n        let includes_builtin = true;\r\n\r\n        // parse and remove flags from args\r\n        for (let i = 0; i < args.length; i++) {\r\n            switch (args[i]) {\r\n                case \"-s\":\r\n                    single_column = true;\r\n                    args.splice(i, 1);\r\n                    i--;\r\n                    break;\r\n                case \"-a\":\r\n                    includes_mounted = true;\r\n                    includes_builtin = true;\r\n                    args.splice(i, 1);\r\n                    i--;\r\n                    break;\r\n                case \"-m\":\r\n                    includes_mounted = true;\r\n                    includes_builtin = false;\r\n                    args.splice(i, 1);\r\n                    i--;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // if no arguments remain, use list mode\r\n        if (args.length === 0) {\r\n            // get program names\r\n            const programs = registry.listProgramNames(includes_builtin, includes_mounted);\r\n\r\n            // remove hidden programs\r\n            const visible_programs = programs.filter((program_name) => {\r\n                const program = registry.getProgram(program_name);\r\n                return program !== undefined && !program.hide_from_help;\r\n            });\r\n\r\n            // add usage suffix and styling to each program name\r\n            const programs_fmt = visible_programs.map((program) => {\r\n                return `${PREFABS.program_name}${program}${STYLE.reset_all} ${registry.getProgram(program).usage_suffix}`;\r\n            });\r\n\r\n            // sort the programs alphabetically (usually already sorted alphabetically by Object.keys, but not guaranteed)\r\n            programs_fmt.sort();\r\n\r\n\r\n            if (single_column) {\r\n                // FORMAT THE PROGRAMS INTO 1 COLUMN\r\n\r\n                header(term, includes_mounted);\r\n                term.writeln(programs_fmt.join(NEWLINE));\r\n            } else {\r\n                // FORMAT THE PROGRAMS INTO 2 COLUMNS\r\n\r\n\r\n                // get the maximum length of a column\r\n                const max_allowable_length = Math.floor(term.cols / 2) - 1;\r\n\r\n\r\n                // split the programs into 2 columns\r\n                const column1 = programs_fmt.filter((_, i) => i <= programs_fmt.length / 2);\r\n                const column2 = programs_fmt.filter((_, i) => i > programs_fmt.length / 2);\r\n\r\n\r\n                // compute the length of the longest program name\r\n                const longest_program_length = Math.max(...programs_fmt.map((program) => program.replace(ANSI_ESCAPE_REGEX, \"\").length));\r\n\r\n                // compute the smallest padding length\r\n                const min_padding_length = max_allowable_length - longest_program_length;\r\n\r\n                // if there is negative padding (overlap, terminal too small), re-execute the program in single-column mode\r\n                if (min_padding_length < 0) {\r\n                    term.writeln(\"Terminal too small to display programs in 2 columns. Re-executing in single-column mode.\");\r\n                    term.write(NEWLINE);\r\n                    \r\n                    const new_args = [\"-s\"];\r\n\r\n                    if (includes_mounted) {\r\n                        new_args.push(\"-m\");\r\n                    }\r\n\r\n                    if (includes_builtin) {\r\n                        new_args.push(\"-a\");\r\n                    }\r\n                    \r\n                    return await kernel.spawn(\"help\", new_args, shell).completion;\r\n                }\r\n\r\n\r\n                // pair the programs in the 2 columns\r\n                const paired_programs = column1.map((program1, i) => {\r\n                    let program2 = column2[i] ?? \"\";\r\n\r\n                    const program1_real_length = program1.replace(ANSI_ESCAPE_REGEX, \"\").length;\r\n                    const program2_real_length = program2.replace(ANSI_ESCAPE_REGEX, \"\").length;\r\n\r\n                    // if the program name is too long, truncate it\r\n                    if (program1_real_length > max_allowable_length) {\r\n                        program1 = program1.slice(0, max_allowable_length / 2 - 3) + \"...\";\r\n                    }\r\n                    if (program2_real_length > max_allowable_length) {\r\n                        program2 = program2.slice(0, max_allowable_length / 2 - 3) + \"...\";\r\n                    }\r\n\r\n                    // pad the programs so that they are both left-aligned\r\n                    const padding = \" \".repeat(max_allowable_length - program1_real_length);\r\n                    return program1 + padding + program2;\r\n                });\r\n\r\n\r\n                // write the programs to the terminal\r\n                header(term, includes_mounted);\r\n                term.writeln(paired_programs.join(NEWLINE));\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        // if an argument remains, get help for it\r\n        const program = registry.getProgram(args[0]);\r\n\r\n        if (program === undefined) {\r\n            term.writeln(`${PREFABS.error}Could not resolve help for ${args[0]}.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        term.writeln(`${NEWLINE}${PREFABS.program_name}${program.name}${STYLE.reset_all}`);\r\n        term.writeln(`${program.description}`);\r\n        term.write(NEWLINE);\r\n        term.writeln(`Usage: ${PREFABS.program_name}${program.name}${STYLE.reset_all} ${program.usage_suffix}`);\r\n\r\n        if (Object.keys(program.arg_descriptions).length > 0) {\r\n            // recurse each level of nesting\r\n            // each level is a section title, until the innermost object, in which they are pairs of argument name and description.\r\n            // add indents depending on the level of nesting\r\n            const recurse = (descs: ArgDescriptions, nest_level: number): string => {\r\n                let output = \"\";\r\n\r\n                for (const [key, value] of Object.entries(descs)) {\r\n                    if (typeof value === \"string\") {\r\n                        // argument, innermost nest\r\n                        output += `${\" \".repeat(nest_level * 4)}${key} - ${value}${NEWLINE}`;\r\n                    } else {\r\n                        // title, deeper nest\r\n                        output += `${NEWLINE}${\" \".repeat(nest_level * 4)}${STYLE.bold + STYLE.italic}${key}${STYLE.reset_all}${NEWLINE}`;\r\n                        output += recurse(value, nest_level + 1);\r\n                    }\r\n                }\r\n\r\n                return output;\r\n            }\r\n\r\n\r\n            term.write(NEWLINE);\r\n            term.write(recurse(program.arg_descriptions, 0));\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"shutdown\",\r\n    description: \"Stops the OS.\",\r\n    usage_suffix: \"[-h] [-r] [-t ms]\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-r\": \"Reboot the terminal.\",\r\n            \"-t\": \"Set the time before shutdown in milliseconds. Default is 1000.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { FG, STYLE } = ANSI;\r\n\r\n        let time = 1000;\r\n        let restart = false;\r\n\r\n        for (const arg of args) {\r\n            switch (arg) {\r\n                case \"-h\":\r\n                    return await kernel.spawn(\"help\", [\"shutdown\"], shell).completion;\r\n                case \"-r\":\r\n                    restart = true;\r\n                    break;\r\n                case \"-t\": {\r\n                    // get the next argument\r\n                    const time_arg = args[args.indexOf(arg) + 1];\r\n                    if (time_arg === undefined) {\r\n                        term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    // parse the time\r\n                    const parsed_time = parseInt(time_arg);\r\n                    if (isNaN(parsed_time)) {\r\n                        term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    time = parsed_time;\r\n\r\n                    // skip the next argument\r\n                    args.splice(args.indexOf(arg) + 1, 1);\r\n                    break;\r\n                }\r\n                default:\r\n                    term.writeln(`${FG.red}Invalid argument: ${arg}${STYLE.reset_all}`);\r\n                    return 1;\r\n            }\r\n        }\r\n\r\n        if (restart) {\r\n            term.writeln(`${FG.red}Restarting...${STYLE.reset_all}`);\r\n        } else {\r\n            term.writeln(`${FG.red}Shutting down...${STYLE.reset_all}`);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            if (restart) {\r\n                window.location.reload();\r\n            } else {\r\n                term.dispose();\r\n            }\r\n        }, time);\r\n\r\n        // hang the terminal until it is shut down or restarted (dont allow any more commands)\r\n        // await an event that will never happen\r\n        await new Promise(() => {});\r\n    }\r\n} as Program;\r\n\r\n// TODO: move this to talk to ignition to perform a soft (or hard) shutdown via IPC\r\n","import { ANSI } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"clear\",\r\n    description: \"Clears the screen, and/or the scrollback.\",\r\n    usage_suffix: \"[-h | -s | -so]\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-s\": \"Clear the screen and the scrollback.\",\r\n            \"-so\": \"Only clear the scrollback.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: helper_completion_options([\"-h\", \"-s\", \"-so\"]),\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { FG, STYLE, PREFABS } = ANSI;\r\n\r\n        switch (args[0]) {\r\n            case undefined:\r\n                term.reset();\r\n                break;\r\n            case \"-s\":\r\n                term.reset();\r\n\r\n                if (shell) {\r\n                    shell.memory.clear_history();\r\n                } else {\r\n                    term.writeln(`${PREFABS.error}Cannot clear scrollback: no shell available.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                break;\r\n            case \"-so\":\r\n                if (!shell) {\r\n                    term.writeln(`${PREFABS.error}Cannot clear scrollback: no shell available.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                shell.memory.clear_history();\r\n                term.writeln(`${STYLE.bold + FG.gray}Scrollback cleared.${STYLE.reset_all}`);\r\n                break;\r\n            case \"-h\":\r\n                return await kernel.spawn(\"help\", [\"clear\"], shell).completion;\r\n            default:\r\n                term.writeln(`${FG.red}Invalid argument: ${args[0]}${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"echo\",\r\n    description: \"Echos a string to the terminal.\",\r\n    usage_suffix: \"string\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"string\": \"The string to echo.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { args, term } = data;\r\n\r\n        const content = args.join(\" \");\r\n        term.writeln(content);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"unset\",\r\n    description: \"Unsets a list of variables.\",\r\n    usage_suffix: \"[names...]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"names\": \"The names of each variable to unset.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (!data.shell) {\r\n            return [];\r\n        }\r\n\r\n        const var_names = [...data.shell.memory.list_variables().keys()];\r\n        // TODO: check type to see why helper_completion_options wont work here\r\n        return var_names.filter(name => name.startsWith(data.current_partial));\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, args, term } = data;\r\n\r\n        if (!shell) {\r\n            term.writeln(\"No shell available\");\r\n            return 1;\r\n        }\r\n\r\n        // TODO: move to shell builtin, not actual program\r\n\r\n        // for each variable name, unset it, with no regards to whether it exists or not\r\n        for (const name of args) {\r\n            shell.memory.unset_variable(name);\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI, ANSI_ESCAPE_REGEX, ANSI_UNESCAPED_REGEX } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"ls\",\r\n    description: \"List files in the current or another directory.\",\r\n    usage_suffix: \"[-h] [-a] [path]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the directory to list. Defaults to the current directory.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-a\": \"Show hidden files.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // parse arguments\r\n        let show_hidden = false;\r\n        let path = fs.get_cwd();\r\n\r\n        for (const arg of args) {\r\n            switch (arg) {\r\n                case \"-a\":\r\n                    show_hidden = true;\r\n                    break;\r\n                case \"-h\":\r\n                    return await kernel.spawn(\"help\", [\"ls\"], shell).completion;\r\n                default:\r\n                    path = fs.absolute(arg);\r\n            }\r\n        }\r\n\r\n        // check if path is a directory and exists\r\n        if (!(await fs.dir_exists(path))) {\r\n            term.writeln(`${PREFABS.error}No such directory: ${path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // list dir\r\n        let dir = await fs.list_dir(path);\r\n\r\n        // sort alphabetically (usually already sorted by Object.keys but just in case)\r\n        dir.sort();\r\n\r\n        // filter out hidden files\r\n        if (!show_hidden) {\r\n            dir = dir.filter((file) => !file.startsWith(\".\"));\r\n        }\r\n\r\n        // fit as many files as possible on one line, with a space between each, otherwise wrap\r\n        const max_width = term.cols;\r\n        let line = \"\";\r\n\r\n        for (const file of dir) {\r\n            // check if file will fit on current line\r\n            const real_length = line.replace(ANSI_ESCAPE_REGEX, \"\").replace(ANSI_UNESCAPED_REGEX, \"\").length;\r\n            if (real_length + file.length + 1 > max_width) {\r\n                // write line and reset\r\n                term.writeln(line);\r\n                line = \"\";\r\n            }\r\n\r\n            // add to line\r\n            if (await fs.dir_exists(fs.join(path, file))) {\r\n                line += `${PREFABS.dir_name}${file}${STYLE.reset_all} `;\r\n            } else {\r\n                line += `${PREFABS.file_path}${file}${STYLE.reset_all} `;\r\n            }\r\n        }\r\n\r\n        // write last line\r\n        term.writeln(line);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"cd\",\r\n    description: \"Change directory.\",\r\n    usage_suffix: \"[path]\",\r\n    arg_descriptions: {\r\n        path: \"Path to directory to change to. If no path is given, change to home directory.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n        \r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        \r\n        // if no arguments, go to home directory\r\n        if (args.length === 0) {\r\n            fs.set_cwd(fs.get_home());\r\n            return 0;\r\n        }\r\n\r\n        // if more than one argument, print error\r\n        if (args.length > 1) {\r\n            term.writeln(`${PREFABS.error}Too many arguments${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // check if path is a directory and exists\r\n        const path = args[0];\r\n        const absolute_path = fs.absolute(path);\r\n\r\n        if (!(await fs.dir_exists(absolute_path))) {\r\n            term.writeln(`${PREFABS.error}No such directory: ${path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // change directory\r\n        fs.set_cwd(absolute_path);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import { ANSI } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"pwd\",\r\n    description: \"Print working directory.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n        \r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // print working directory\r\n        term.writeln(PREFABS.dir_name + fs.get_cwd() + STYLE.reset_all);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE, WrappedTerminal, NON_PRINTABLE_REGEX } from \"../term_ctl\";\r\n\r\nconst HEADER = 2;\r\n\r\nconst setup = (term: WrappedTerminal, content: string, path: string, readonly: boolean) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, BG, FG } = ANSI;\r\n\r\n    // clear the screen\r\n    term.clear();\r\n\r\n    // write the file name centered in the header, showing the read-only status if the file is read-only\r\n    const filename = path.split(\"/\").pop() || \"\";\r\n    const header = readonly ? `Viewing read-only file: ${filename}` : `Editing file: ${filename}`;\r\n    const h_padding_l = \" \".repeat(Math.ceil((term.cols - header.length) / 2));\r\n    const h_padding_r = \" \".repeat(Math.floor((term.cols - header.length) / 2));\r\n\r\n    term.write(BG.white + FG.black + STYLE.bold);\r\n    term.write(h_padding_l);\r\n    term.write(header);\r\n    term.write(h_padding_r);\r\n    term.write(STYLE.reset_all)\r\n\r\n    // go to the bottom of the screen with ansi\r\n    term.write(`\\x1b[${term.rows - 1};0H`);\r\n\r\n    // write the footer, showing the save and exit key if the file is not read-only\r\n    const footer = `${readonly ? \"\" : \"F1: Save & Exit | \"}ESC: Exit without saving | F2: Debug Redraw`;\r\n    const f_padding_l = \" \".repeat(Math.ceil((term.cols - footer.length) / 2));\r\n    const f_padding_r = \" \".repeat(Math.floor((term.cols - footer.length) / 2));\r\n\r\n    term.write(BG.white + FG.black + STYLE.bold);\r\n    term.write(f_padding_l);\r\n    term.write(footer);\r\n    term.write(f_padding_r);\r\n    term.write(STYLE.reset_all)\r\n\r\n    // reset the cursor position to under the header\r\n    term.write(\"\\x1b[2;0H\");\r\n    term.write(NEWLINE);\r\n\r\n    // write the content\r\n    term.write(content);\r\n\r\n    // reset the cursor position to under the header\r\n    term.write(\"\\x1b[2;0H\");\r\n    term.write(NEWLINE);\r\n}\r\n\r\n\r\n// TODO: expose ANSI cursor control codes as functions in term_ctl\r\n// TODO: consider instead using a hidden textarea to store the character buffer, or using a queue and reimplementing the terminal's keypress handler\r\n// TODO: provide method in terminal to set up the above ^^^\r\n// TODO: none of this accounts for scrolling!! use of cursorPos will not function properly if the terminal is scrolled\r\n// TODO: it would be nice to not \"cheat\" at enter and backspace, but to actually handle them properly. this is fine for now i guess\r\n\r\nexport default {\r\n    name: \"edit\",\r\n    description: \"Edits the specified file.\",\r\n    usage_suffix: \"path\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // parse argument\r\n        if (args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}A single argument, the path, is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        const path = fs.absolute(args[0]);\r\n\r\n\r\n        let content = \"\";\r\n\r\n        // if the file exists, load it in. otherwise, keep the content empty\r\n        let readonly = false;\r\n        if (await fs.exists(path)) {\r\n            content = await fs.read_file(path) as string;\r\n            readonly = await fs.is_readonly(path);\r\n\r\n            // lock the file by making it read-only\r\n            // TODO: the user can lock the file permanently if edit crashes, they close the tab, reload, or their computer loses power! perhaps use a separate flag for this and have the os erase the lock on boot, not the same as readonly\r\n            // TODO: i'm disabling this for now for my own sanity (when it crashes and dies). its incredibly unlikely the user will concurrent write with fsedit and if they do they're stupid\r\n            //fs.set_readonly(path, true);\r\n        }\r\n\r\n        // temporary note\r\n        // TODO: remove when scrolling is implemented properly\r\n        term.writeln(`${FG.yellow}Note: This program is still in development and has numerous issues, including no scrolling!${NEWLINE}Pressing F2 to redraw may help some visual issues, but not any file writing related issues.${NEWLINE}Consider using ${PREFABS.program_name}cat${STYLE.reset_all + FG.yellow} or the ${PREFABS.program_name}fsedit${STYLE.reset_all + FG.yellow} UI for your purposes.${NEWLINE}Please don't report issues in this program unless you know a fix :)${NEWLINE}Press any key to proceed.${STYLE.reset_all}`);\r\n        await term.wait_for_keypress();\r\n\r\n        // setup the screen\r\n        setup(term, content, path, readonly);\r\n\r\n        const split_content = content.split(NEWLINE);\r\n\r\n        // wait for keypresses\r\n        let exit_code: number | null = null;\r\n        let saved = false;\r\n        while (exit_code === null) {\r\n            const key = await term.wait_for_keypress();\r\n\r\n            switch (key.domEvent.code) {\r\n                case \"Escape\":\r\n                    // revert the file to its original read-only status\r\n                    if (await fs.exists(path)) {\r\n                        await fs.set_readonly(path, readonly);\r\n                    }\r\n\r\n                    exit_code = 0;\r\n                    break;\r\n                case \"F1\":\r\n                    // if readonly, don't allow saving\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n                    await fs.write_file(path, split_content.join(NEWLINE));\r\n                    saved = true;\r\n\r\n                    // revert the file to its original read-only status\r\n                    await fs.set_readonly(path, readonly);\r\n\r\n                    exit_code = 0;\r\n                    break;\r\n                case \"F2\":\r\n                    term.reset();\r\n                    setup(term, split_content.join(NEWLINE), path, readonly);\r\n                    console.log(split_content.join(\"\\n\"));\r\n                    break;\r\n                case \"ArrowUp\": {\r\n                    // determine the current cursor position\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    if (cursor_y === 2) {\r\n                        // TODO: scroll file\r\n                        // we're at the top of the file, so we can't move up\r\n                        break;\r\n                    }\r\n\r\n                    // pass through to the terminal\r\n                    term.write(key.key);\r\n\r\n                    // determine the current line's length (sub 2 for header, sub 1 for moving up)\r\n                    const line_length = split_content[cursor_y - HEADER - 1].length;\r\n\r\n                    // determine the cursor's x position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n\r\n                    // move cursor to the end of the line, typing backspaces if it is past the end or the right arrow code if it is not\r\n                    if (cursor_x >= line_length) {\r\n                        term.write(\"\\b\".repeat(cursor_x - line_length));\r\n                    } else {\r\n                        term.write(\"\\x1b[C\".repeat(line_length - cursor_x));\r\n                    }\r\n                }\r\n                    break;\r\n                case \"ArrowDown\": {\r\n                    // determine the current cursor position\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    if (cursor_y === term.rows - 4) {\r\n                        // TODO: scroll file\r\n                        // we're at the bottom of the screen, so we can't move down\r\n                        break;\r\n                    }\r\n\r\n                    if (cursor_y === split_content.length + HEADER - 1) { // (add 2 for header, sub 1 for 0-indexing)\r\n                        // we're at the bottom of the file, so we can't move down\r\n                        break;\r\n                    }\r\n\r\n                    // pass through to the terminal\r\n                    term.write(key.key);\r\n\r\n                    // determine the current line's length (sub 2 for header, add 1 for moving down)\r\n                    const line_length = split_content[cursor_y - HEADER + 1].length;\r\n\r\n                    // determine the cursor's x position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n\r\n                    // move cursor to the end of the line, typing backspaces if it is past the end or the right arrow code if it is not\r\n                    if (cursor_x >= line_length) {\r\n                        term.write(\"\\b\".repeat(cursor_x - line_length));\r\n                    } else {\r\n                        term.write(\"\\x1b[C\".repeat(line_length - cursor_x));\r\n                    }\r\n                }\r\n                    break;\r\n                case \"ArrowLeft\":\r\n                    // left arrow can always be passed through to the terminal as the terminal will handle the left margin\r\n                    term.write(key.key);\r\n                    break;\r\n                case \"ArrowRight\": {\r\n                    // determine cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // determine the current line's length (sub 2 for header)\r\n                    const line_length = split_content[cursor_y - HEADER].length;\r\n\r\n                    if (cursor_x < line_length) {\r\n                        // pass through to the terminal\r\n                        // NOTE: no need to check right margin, because the terminal will handle that\r\n                        term.write(key.key);\r\n                    }\r\n                }\r\n                    break;\r\n                case \"Enter\": {\r\n                    // if readonly, don't allow editing\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n\r\n                    // determine cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    let cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // split the current line at the cursor position\r\n                    const line = split_content[cursor_y - HEADER];\r\n\r\n                    const before_newline = line.slice(0, cursor_x);\r\n                    const after_newline = line.slice(cursor_x);\r\n\r\n                    const old_split_content = split_content.slice();\r\n\r\n                    // insert the new line into the content, between the before_newline and after_newline\r\n                    split_content.splice(cursor_y - HEADER, 1, before_newline, after_newline);\r\n\r\n                    // the code below to redraw selectively is a mess and doesn't work properly for all cases, but is improving\r\n                    // for now, just to get edit in a somewhat working state, we'll just clear the screen and redraw everything (debug redraw but restoring cursor position)\r\n\r\n                    // debug redraw\r\n                    term.reset();\r\n                    setup(term, split_content.join(NEWLINE), path, readonly);\r\n\r\n                    // move the cursor to the start of the new line\r\n                    term.write(`\\x1b[${cursor_y + 2};1H`);\r\n\r\n                    break;\r\n\r\n                    // clear text past the cursor\r\n                    term.write(\" \".repeat(line.length - cursor_x));\r\n\r\n                    // move the cursor down one line and to the beginning of the line\r\n                    term.write(\"\\x1b[1B\\x1b[1G\");\r\n\r\n                    // we are now on the new line. clear it using the old line length and write the new content from after_newline\r\n                    // TODO: could just clear what overruns the new content, but the logic is more confusing. clearing everything is simpler but less efficient\r\n                    term.write(\" \".repeat(old_split_content[cursor_y - HEADER].length)); // doesnt work for all cases, sometime leaves longer line stray\r\n                    term.write(\"\\x1b[1G\")\r\n                    term.write(after_newline);\r\n\r\n                    // adjust cursor y to reflect the real newline being handled\r\n                    cursor_y++;\r\n\r\n                    // clear all the lines below the new cursor position, then write the new content into them\r\n                    // TODO: could just clear what overruns the new content, but the logic is more confusing. clearing everything is simpler but less efficient\r\n                    let lines_redrawn = 0;\r\n                    for (let i = cursor_y - HEADER + 1; i < split_content.length; i++) {\r\n                        term.write(\"\\x1b[1B\\x1b[1G\");\r\n                        if (old_split_content[i]) {\r\n                            term.write(\" \".repeat(old_split_content[i].length));\r\n                            term.write(\"\\x1b[1G\");\r\n                        }\r\n                        term.write(split_content[i]);\r\n                        lines_redrawn++;\r\n                    }\r\n\r\n                    // move the cursor back to the original line at the start of the new line\r\n                    term.write(\"\\x1b[1G\");\r\n                    if (lines_redrawn > 0) {\r\n                        term.write(`\\x1b[${lines_redrawn}A`);\r\n                    }\r\n                }\r\n                    break;\r\n                case \"Backspace\": {\r\n                    // if readonly, don't allow editing\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n                    // get the current cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // do nothing at the start of the file\r\n                    if (cursor_x === 0 && cursor_y === 2) {\r\n                        break;\r\n                    }\r\n\r\n                    // if at the beginning of the line, remove the newline\r\n                    if (cursor_x === 0) {\r\n                        // move previous line's content to the end of the current line\r\n                        const newline_content = split_content[cursor_y - HEADER];\r\n                        split_content[cursor_y - HEADER - 1] += newline_content;\r\n\r\n                        split_content.splice(cursor_y - HEADER, 1);\r\n\r\n                        // the code below to handle backspacing a newline ever only partly worked\r\n                        // for now, just to get edit in a somewhat working state, we'll just clear the screen and redraw everything (debug redraw but restoring cursor position)\r\n\r\n                        // debug redraw\r\n                        term.reset();\r\n                        setup(term, split_content.join(NEWLINE), path, readonly);\r\n\r\n                        // move the cursor to the previous line to the right length across (N from the end where N is the length of the line we just merged, newline_content)\r\n                        // TODO: why isn't this working in all cases??????????????????????????????????\r\n                        term.write(`\\x1b[${cursor_y};${split_content[cursor_y - HEADER - 1].length - newline_content.length + 1}G`);\r\n\r\n                        break;\r\n\r\n                        // move the cursor up one line\r\n                        term.write(\"\\x1b[1A\");\r\n\r\n                        // move the cursor to the end of the line\r\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER - 1].length + 1}G`);\r\n\r\n                        // write the rest of the line\r\n                        term.write(split_content[cursor_y - HEADER]);\r\n\r\n                        // move the cursor back to the original position\r\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER].length + 1}D`);\r\n\r\n                        // TODO: redraw following lines properly\r\n\r\n                        break;\r\n                    }\r\n\r\n\r\n                    // otherwise, remove the character to the left of the cursor\r\n                    const left = split_content[cursor_y - HEADER].slice(0, cursor_x - 1);\r\n                    const right = split_content[cursor_y - HEADER].slice(cursor_x);\r\n\r\n                    split_content[cursor_y - HEADER] = left + right;\r\n\r\n                    // move the cursor back one space\r\n                    term.write(\"\\b\");\r\n\r\n                    // write the rest of the line\r\n                    term.write(right + \" \");\r\n\r\n                    // move the cursor back to the original position\r\n                    term.write(`\\x1b[${right.length + 1}D`);\r\n\r\n                    // if the line is now empty, remove it, unless it's the first line\r\n                    if (cursor_y !== 2 && split_content[cursor_y - HEADER] === \"\") {\r\n                        split_content.splice(cursor_y - HEADER, 1);\r\n                        term.write(\"\\x1b[1M\");\r\n                        break;\r\n                    }\r\n\r\n                    // if the cursor is now past the end of the line, move it to the end of the line\r\n                    if (cursor_x > split_content[cursor_y - HEADER].length) {\r\n                        term.write(`\\x1b[${split_content[cursor_y - HEADER].length + 1}G`);\r\n                    }\r\n                }\r\n                    break;\r\n                default: {\r\n                    // if readonly, don't allow editing\r\n                    if (readonly) {\r\n                        break;\r\n                    }\r\n\r\n                    // get the current cursor position\r\n                    const cursor_x = term.buffer.normal.cursorX;\r\n                    const cursor_y = term.buffer.normal.cursorY;\r\n\r\n                    // if the key is a printable character, write it in\r\n                    if (!NON_PRINTABLE_REGEX.test(key.key)) {\r\n                        // if at the end of the line, append to the line\r\n                        if (cursor_x === split_content[cursor_y - HEADER].length + 1) {\r\n                            split_content[cursor_y - HEADER] += key.key;\r\n                            term.write(key.key);\r\n                        } else {\r\n                            // otherwise, insert it and shift the rest of the line\r\n                            const left = split_content[cursor_y - HEADER].slice(0, cursor_x);\r\n                            const right = split_content[cursor_y - HEADER].slice(cursor_x);\r\n\r\n                            split_content[cursor_y - HEADER] = left + key.key + right;\r\n\r\n                            // overwrite the line\r\n                            term.write(key.key + right);\r\n\r\n                            // move the cursor back to the correct position + 1\r\n                            term.write(`\\x1b[${cursor_x + 2}G`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        term.reset();\r\n\r\n        if (saved) {\r\n            term.writeln(`${FG.green}File saved!${STYLE.reset_all}`);\r\n        } else {\r\n            // TODO: cant exit without saving, crashes the program when trying to set readonly status\r\n            term.writeln(`${FG.red}Exited without saving!${STYLE.reset_all}`);\r\n        }\r\n\r\n        return exit_code;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE } from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"webget\",\r\n    description: \"Downloads a file from the World Wide Web.\",\r\n    usage_suffix: \"url filepath [-o] [-n] [-X method] [-H header] [-B body]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"url\": \"The URL to download from.\",\r\n            \"filepath\": \"The path to save the file to.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"System flags:\": {\r\n                \"-h\": \"Print this help message.\",\r\n                \"-o\": \"Overwrite existing files.\",\r\n                \"-n\": \"Do not replace newlines with the current system's newline character, store as a binary (binary mode).\",\r\n            },\r\n            \"Request flags:\": {\r\n                \"-X\": \"Specify a custom HTTP method. (default: GET)\",\r\n                \"-H\": \"Add a custom header to the request.\",\r\n                \"-B\": \"Specify a custom request body. (only works with POST and PUT methods)\"\r\n            }\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // TODO: replace filename with using piping and send content to stdout\r\n        // TODO: automatically guess binary mode based on file extension or recieved header\r\n\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        if (args[0] === \"-h\") {\r\n            return await kernel.spawn(\"help\", [\"webget\"], shell).completion;\r\n        }\r\n\r\n        // check if the user provided a URL\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}A URL is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // parse url\r\n        const url = args.shift();\r\n\r\n        // validate url\r\n        try {\r\n            const proc_url = new URL(url);\r\n\r\n            if (proc_url.protocol !== \"http:\" && proc_url.protocol !== \"https:\") {\r\n                throw new Error(\"Invalid protocol\");\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Invalid URL. Expected a valid HTTP or HTTPS protocol URL.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        let file_path = \"\";\r\n        let overwrite = false;\r\n        let binary = false;\r\n        let method = \"GET\";\r\n        const headers: Map<string, string> = new Map();\r\n        let body = null;\r\n\r\n        for (let arg_idx = 0; arg_idx < args.length; arg_idx++) {\r\n            const arg = args[arg_idx];\r\n\r\n            switch (arg) {\r\n                case \"-X\": {\r\n                    // consume next argument\r\n                    const next_arg = args[arg_idx + 1];\r\n\r\n                    if (next_arg === undefined) {\r\n                        term.writeln(`${PREFABS.error}Expected a method after -X.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    method = next_arg;\r\n                    args.splice(arg_idx + 1, 1);\r\n                }\r\n                    break;\r\n                case \"-H\": {\r\n                    // consume next argument\r\n                    const header = args[arg_idx + 1];\r\n\r\n                    if (header === undefined) {\r\n                        term.writeln(`${PREFABS.error}Expected a header after -H.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    const split = header.split(\": \");\r\n\r\n                    if (split.length !== 2 || split[0].includes(\" \")) {\r\n                        term.writeln(`${PREFABS.error}Invalid header. Expected a header in the format \"Header-Name: Header-Value\".${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    headers.set(split[0], split[1]);\r\n                    args.splice(arg_idx + 1, 1);\r\n                }\r\n                    break;\r\n                case \"-B\": {\r\n                    // consume next argument\r\n                    const next_arg = args[arg_idx + 1];\r\n\r\n                    if (next_arg === undefined) {\r\n                        term.writeln(`${PREFABS.error}Expected a body after -B.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    body = next_arg;\r\n                    args.splice(arg_idx + 1, 1);\r\n                }\r\n                    break;\r\n                case \"-o\":\r\n                    overwrite = true;\r\n                    break;\r\n                case \"-n\":\r\n                    binary = true;\r\n                    break;\r\n                default:\r\n                    if (file_path === \"\") {\r\n                        file_path = arg;\r\n                    } else {\r\n                        term.writeln(`${PREFABS.error}Unexpected string argument.${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n            }\r\n        }\r\n\r\n        // check if the user provided a filename and i it is not a directory\r\n        if (file_path === \"\") {\r\n            term.writeln(`${PREFABS.error}A file path is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (file_path.endsWith(\"/\")) {\r\n            term.writeln(`${PREFABS.error}Cannot write to a directory.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // check if the file already exists\r\n        const abs_path = fs.absolute(file_path);\r\n\r\n        if (await fs.exists(abs_path) && !overwrite) {\r\n            term.writeln(`${PREFABS.error}File already exists.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // if overwriting, run initial check of readonly status\r\n        if (overwrite) {\r\n            if (await fs.is_readonly(abs_path)) {\r\n                term.writeln(`${PREFABS.error}File is readonly.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        // lock the file, creating it if it does not exist\r\n        if (!(await fs.exists(abs_path))) {\r\n            await fs.write_file(abs_path, \"\");\r\n        }\r\n        await fs.set_readonly(abs_path, true);\r\n\r\n        // fetch the file\r\n        let response: Response;\r\n\r\n        term.writeln(`${FG.green}Downloading file...${STYLE.reset_all}`);\r\n\r\n        try {\r\n            // convert headers to object\r\n            const headers_obj: Record<string, string> = {};\r\n            headers.forEach((value, key) => {\r\n                headers_obj[key] = value;\r\n            });\r\n\r\n            response = await fetch(url, { method, headers: headers_obj, body });\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to fetch file.${STYLE.reset_all}`);\r\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            // reset readonly state\r\n            await fs.set_readonly(abs_path, false);\r\n\r\n            //  if this wasn't an overwrite, delete the file that was created\r\n            if (!overwrite) {\r\n                await fs.delete_file(abs_path);\r\n            }\r\n\r\n            return 1;\r\n        }\r\n\r\n        if (!response.ok) {\r\n            term.writeln(`${PREFABS.error}Request not OK.${STYLE.reset_all}`);\r\n\r\n            // get the error message\r\n            const text = await response.text();\r\n\r\n            if (text !== \"\") {\r\n                term.writeln(`${PREFABS.error}${text}${STYLE.reset_all}`);\r\n            }\r\n\r\n            // reset readonly state\r\n            await fs.set_readonly(abs_path, false);\r\n\r\n            //  if this wasn't an overwrite, delete the file that was created\r\n            if (!overwrite) {\r\n                await fs.delete_file(abs_path);\r\n            }\r\n\r\n            return 1;\r\n        }\r\n\r\n        if (binary) {\r\n            // write the file as binary\r\n            const buffer = await response.arrayBuffer();\r\n\r\n            await fs.write_file(abs_path, new Uint8Array(buffer), true);\r\n        } else {\r\n            // write the file as text\r\n            const text = await response.text();\r\n\r\n            await fs.write_file(abs_path, text.replace(/\\r?\\n/g, NEWLINE), true);\r\n        }\r\n\r\n        // reset readonly state (must've be writable or else this wouldn't be reached)\r\n        await fs.set_readonly(abs_path, false);\r\n\r\n        term.writeln(`${FG.green}File downloaded successfully.${STYLE.reset_all}`);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"cat\",\r\n    description: \"Reads files and prints their contents to the terminal.\",\r\n    usage_suffix: \"[filepaths...]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"filepaths\": \"The paths of the files to read.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // get each file's content and print it to the terminal\r\n        for (const filepath of args) {\r\n            const abs_path = fs.absolute(filepath);\r\n\r\n            // check if the file exists and is a file\r\n            if (await fs.dir_exists(abs_path)) {\r\n                term.writeln(`${PREFABS.error}Cannot read a directory: ${abs_path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            if (!(await fs.exists(abs_path))) {\r\n                term.writeln(`${PREFABS.error}File not found: ${abs_path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // get file\r\n            const content = await fs.read_file(abs_path);\r\n\r\n            // print file content to terminal\r\n            term.writeln(content);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\n// TODO: when edit is done, add a flag to edit the file in the editor\r\n\r\nexport default {\r\n    name: \"hex\",\r\n    description: \"Reads a file as hexadecimal.\",\r\n    usage_suffix: \"[-h] path [-i]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the file to read.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-h\": \"Print this help message.\",\r\n            \"-i\": \"Print indexes.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // use default logic for first argument\r\n        if (data.arg_index === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (data.arg_index === 1) {\r\n            if (\"-i\".startsWith(data.current_partial)) {\r\n                return [\"-i\"];\r\n            }\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // check if the user provided a filepath\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}A file path is required.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args[0] === \"-h\") {\r\n            await kernel.spawn(\"help\", [\"hex\"], shell).completion;\r\n        }\r\n\r\n        // get filepath\r\n        const filepath = args[0];\r\n\r\n        // get absolute path\r\n        const abs_path = fs.absolute(filepath);\r\n\r\n        // check if the file exists and is a file\r\n        if (abs_path.endsWith(\"/\")) {\r\n            term.writeln(`${PREFABS.error}Cannot read a directory: ${abs_path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (!(await fs.exists(abs_path))) {\r\n            term.writeln(`${PREFABS.error}File not found: ${abs_path}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get file\r\n        const content = await fs.read_file(abs_path, true) as Uint8Array;\r\n\r\n        // convert uint8array to hex string\r\n        const hex = Array.from(content).map((byte) => byte.toString(16).toUpperCase().padStart(2, \"0\"));\r\n\r\n        // if printing indexes, print the header\r\n        if (args[1] === \"-i\") {\r\n            term.writeln(`         ${FG.blue}00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F${STYLE.reset_all}`);\r\n        }\r\n\r\n        // print hex bytes to terminal up to 16 bytes per line, padding the end with .. in place of the missing bytes\r\n        // if printing indexes, print the index of the first byte on the line, in hexadecimal up to 8 bytes\r\n        for (let i = 0; i < hex.length; i += 16) {\r\n            const line = hex.slice(i, i + 16);\r\n\r\n            if (args[1] === \"-i\") {\r\n                const idx = i <= 0xffffffff ? i.toString(16).toUpperCase() : \"........\";\r\n\r\n\r\n                term.write(`${FG.blue}${idx.padStart(8, \"0\")}${STYLE.reset_all} `);\r\n            }\r\n\r\n            const padded = line.concat(Array(16 - line.length).fill(`${FG.gray}..${STYLE.reset_all}`));\r\n            term.writeln(padded.join(\" \"));\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { NEWLINE, ANSI, ANSI_UNESCAPED_REGEX } from \"../term_ctl\";\r\n\r\nimport { default as img2ascii } from \"imgToAscii\";\r\n\r\n\r\nconst MY_USERNAME = \"obfuscatedgenerated\";\r\nconst GH_USERNAME_REGEX = /^[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}$/i;\r\n\r\nconst username_to_avatar_url = (username: string): string => {\r\n    return `https://avatars.githubusercontent.com/${username}`;\r\n}\r\n\r\ntype GHInfo = { name: string, bio: string, location: string, blog: string, followers: number, following: number, twitter: string };\r\nconst get_github_info = async (username: string): Promise<GHInfo> => {\r\n    const url = `https://api.github.com/users/${username}`;\r\n    const res = await fetch(url);\r\n\r\n    if (!res.ok) {\r\n        return null;\r\n    }\r\n\r\n    const json = await res.json();\r\n\r\n    return {\r\n        name: json.name,\r\n        bio: json.bio,\r\n        location: json.location,\r\n        blog: json.blog,\r\n        followers: json.followers,\r\n        following: json.following,\r\n        twitter: json.twitter_username\r\n    };\r\n}\r\n\r\nconst convert_to_ascii = async (url: string, size: number): Promise<string> => {\r\n    const img = new img2ascii(url, size, Math.round(size / 2));\r\n    await img.loadImage;\r\n\r\n    // convert newlines in string\r\n    const ascii = img.stringANSI8BitColor.replace(/\\n/g, NEWLINE);\r\n    return ascii;\r\n}\r\n\r\n\r\nconst known_info = (username: string, data: { [key: string]: any }, gh_info: GHInfo | null, version_str: string) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, FG, PREFABS } = ANSI;\r\n\r\n    return `\r\n${STYLE.bold}${username}\r\n-------------------\r\n${STYLE.bold}OS${STYLE.reset_all + FG.cyan}: OllieOS v${version_str}\r\n\r\n${STYLE.bold}Name${STYLE.reset_all + FG.cyan}: ${data.name || gh_info?.name || \"Unknown\"}\r\n${STYLE.bold}Pronouns${STYLE.reset_all + FG.cyan}: ${data.pronouns.subject}/${data.pronouns.object_or_alt}${data.pronouns.possessive ? `/${data.pronouns.possessive}` : \"\"}\r\n${STYLE.bold}Location${STYLE.reset_all + FG.cyan}: ${data.location || gh_info?.location || \"Unknown\"}\r\n${STYLE.bold}Interests${STYLE.reset_all + FG.cyan}: ${data.interests.join(\", \") || \"None listed\"}\r\n\r\n${data.websites ? Object.entries(data.websites).map(\r\n    ([name, url]) => `${STYLE.bold}${name}${STYLE.reset_all + FG.cyan}: ${url}`\r\n).join(NEWLINE) : \"\"}\r\n\r\n${STYLE.bold}GitHub Followers${STYLE.reset_all + FG.cyan}: ${gh_info.followers || 0}\r\n${STYLE.bold}GitHub Following${STYLE.reset_all + FG.cyan}: ${gh_info.following || 0}\r\n\r\n${data.extra ? Object.entries(data.extra).map(\r\n    ([name, value]) => `${STYLE.bold}${name}${STYLE.reset_all + FG.cyan}: ${value}`\r\n).join(NEWLINE) : \"\"}\r\n        `.replace(/\\n/g, NEWLINE);\r\n}\r\n\r\nconst stranger_info = (username: string, gh_info: GHInfo | null, cols: number, version_str: string) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, FG } = ANSI;\r\n\r\n    // line wrap the bio and make sure newlines ARE NOT CRLF (to retain columns)\r\n    if (gh_info.bio) {\r\n        gh_info.bio = gh_info.bio.replace(/\\r\\n/g, \"\\n\").replace(new RegExp(`(.{${Math.floor(cols * 0.25)}})\\\\s`, \"g\"), \"$1\\n\");\r\n    }\r\n\r\n    // TODO: messy, clean up\r\n    // insert known data or move up a line if not known (to undo the newline added by the ternary operator)\r\n    return `\r\n${STYLE.bold}${username}\r\n${\"-\".repeat(username.length)}\r\n${STYLE.bold}OS${STYLE.reset_all + FG.cyan}: OllieOS v${version_str}\r\n\r\n${gh_info.name ? `${STYLE.bold}Name${STYLE.reset_all + FG.cyan}: ${gh_info.name}` : \"\\x1b[1A\"}\r\n${gh_info.location ? `${STYLE.bold}Location${STYLE.reset_all + FG.cyan}: ${gh_info.location}` : \"\\x1b[1A\"}\r\n${gh_info.bio ? `${STYLE.bold}Bio${STYLE.reset_all + FG.cyan}: ${gh_info.bio}` : \"\\x1b[1A\"}\r\n\r\n${gh_info.blog ? `${STYLE.bold}Website${STYLE.reset_all + FG.cyan}: ${gh_info.blog}` : \"\\x1b[1A\"}\r\n\r\n${STYLE.bold}GitHub${STYLE.reset_all + FG.cyan}: https://github.com/${username}\r\n${gh_info.twitter ? `${STYLE.bold}Twitter${STYLE.reset_all + FG.cyan}: https://twitter.com/${gh_info.twitter}` : \"\\x1b[1A\"}\r\n\r\n${STYLE.bold}GitHub Followers${STYLE.reset_all + FG.cyan}: ${gh_info.followers || 0}\r\n${STYLE.bold}GitHub Following${STYLE.reset_all + FG.cyan}: ${gh_info.following || 0}\r\n    `.replace(/\\n/g, NEWLINE);\r\n}\r\n\r\nexport default {\r\n    name: \"mefetch\",\r\n    description: \"Shows information about me (or you!)\",\r\n    usage_suffix: \"[username]\",\r\n    arg_descriptions: {\r\n        \"username\": \"The GitHub username to show basic info about. Defaults to my username, with the special info shown.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term, args } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, FG } = ANSI;\r\n\r\n        // get version string\r\n        const version_str = kernel.get_env_info().version;\r\n\r\n        // restrict to first 3 quarters of screen\r\n        const max_columns = Math.floor(term.cols * 0.75);\r\n\r\n        // set image size\r\n        const asc_width = Math.floor(max_columns / 3);\r\n\r\n        // get username\r\n        const username = args[0] || MY_USERNAME;\r\n\r\n        // check if username is valid\r\n        if (!username.match(GH_USERNAME_REGEX)) {\r\n            term.write(`${STYLE.bold}${FG.red}Invalid username.${STYLE.reset_all}\\n`);\r\n            return 1;\r\n        }\r\n\r\n        // get info from GitHub\r\n        const gh_info = await get_github_info(username);\r\n\r\n        // if info is null, then the user doesn't exist\r\n        if (gh_info === null) {\r\n            term.write(`${STYLE.bold}${FG.red}User not found.${STYLE.reset_all}\\n`);\r\n            return 1;\r\n        }\r\n\r\n        // use local logo for efficiency if username is mine\r\n        const avatar_url = MY_USERNAME === username ? \"https://ollieg.codes/public/logo.png\" : username_to_avatar_url(username);\r\n\r\n        // convert image to ascii\r\n        const ascii_pfp = await convert_to_ascii(avatar_url, asc_width);\r\n\r\n        // check synced data if username exists in data repo\r\n        let known_data = null;\r\n        const fs = kernel.get_fs();\r\n        if (await fs.exists(\"/var/lib/data/person/index.json\")) {\r\n            const data_index_str = await fs.read_file(\"/var/lib/data/person/index.json\") as string;\r\n            const data_index = JSON.parse(data_index_str) as string[];\r\n\r\n            if (data_index.includes(username)) {\r\n                const user_data_str = await fs.read_file(`/var/lib/data/person/${username}.json`) as string;\r\n                known_data = JSON.parse(user_data_str);\r\n            }\r\n        }\r\n\r\n        // text is written with \\n as newlines for simplicity, replaced with NEWLINE\r\n        let text: string;\r\n        if (known_data) {\r\n            text = known_info(username, known_data, gh_info, version_str);\r\n        } else {\r\n            text = stranger_info(username, gh_info, term.cols, version_str);\r\n        }\r\n\r\n        // reapply style each line as image will override it\r\n        const txt_line_prefix = FG.cyan;\r\n        const txt_line_suffix = STYLE.reset_all;\r\n\r\n        // go line by line through both text and ascii\r\n        const asc_lines = ascii_pfp.split(NEWLINE);\r\n        const txt_lines = text.split(NEWLINE);\r\n\r\n        // get the greater of the two lengths\r\n        const max_lines = Math.max(asc_lines.length, txt_lines.length);\r\n\r\n        // get the longest length of a line of ascii ignoring ansi characters, and the longest length of a line of text\r\n        const max_asc_line_length = Math.max(...asc_lines.map(line => line.replace(ANSI_UNESCAPED_REGEX, \"\").length));\r\n        const max_txt_line_length = Math.max(...txt_lines.map(line => line.length));\r\n\r\n        // determine padding around and between text and ascii\r\n        const center_padding_size = Math.floor(max_columns / 15);\r\n        const side_padding_size = Math.floor((max_columns - max_txt_line_length - (max_asc_line_length / 2) - center_padding_size) / 2);\r\n\r\n        // generate padding strings, if positive\r\n        const center_padding = \" \".repeat(center_padding_size > 0 ? center_padding_size : 0);\r\n        const side_padding = \" \".repeat(side_padding_size > 0 ? side_padding_size : 0);\r\n\r\n        // print each line\r\n        for (let i = 0; i < max_lines; i++) {\r\n            const asc_line = asc_lines[i] || \"\";\r\n            const txt_line = txt_lines[i] || \"\";\r\n\r\n            // add additional padding so the width of the ascii line is always the same\r\n            const asc_line_padding = \" \".repeat(max_asc_line_length - asc_line.replace(ANSI_UNESCAPED_REGEX, \"\").length);\r\n\r\n            // print side by side with padding\r\n            term.writeln(side_padding + asc_line + asc_line_padding + center_padding + txt_line_prefix + txt_line + txt_line_suffix);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import { ANSI } from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"reader\",\r\n    description: \"Toggles screen reader mode. Due to a technical limitation, on-screen links will not be clickable in screen reader mode.\",\r\n    usage_suffix: \"[-h] [-q] [-s on|off]\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-h\": \"Show this help message.\",\r\n            \"-q\": \"Query the current screen reader mode.\",\r\n            \"-s\": \"Explicitly set the screen reader mode to on or off, rather than toggling it.\"\r\n        }\r\n    },\r\n    node_opt_out: true,\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (data.arg_index === 0) {\r\n            return helper_completion_options([\"-h\", \"-q\", \"-s\"])(data);\r\n        }\r\n\r\n        if (data.arg_index === 1 && data.args[0] === \"-s\") {\r\n            return helper_completion_options([\"on\", \"off\"])(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get sound registry\r\n        const sfx_reg = kernel.get_sound_registry();\r\n\r\n        switch (args[0]) {\r\n            case \"-h\":\r\n                return await kernel.spawn(\"help\", [\"clear\"], shell).completion;\r\n            case \"-q\":\r\n                // query screen reader mode\r\n                term.writeln(`Screen reader mode is currently ${term.options.screenReaderMode ? \"on\" : \"off\"}.`);\r\n                return 0;\r\n            case \"-s\":\r\n                // set screen reader mode\r\n                switch (args[1]) {\r\n                    case \"on\":\r\n                        term.options.screenReaderMode = true;\r\n                        break;\r\n                    case \"off\":\r\n                        term.options.screenReaderMode = false;\r\n                        break;\r\n                    default:\r\n                        term.writeln(\"Invalid argument. Expected \\\"on\\\" or \\\"off\\\".\");\r\n                        return 1;\r\n                }\r\n                break;\r\n            default:\r\n                // toggle screen reader mode\r\n                term.options.screenReaderMode = !term.options.screenReaderMode;\r\n        }\r\n\r\n        const state = term.options.screenReaderMode ? \"on\" : \"off\";\r\n\r\n        // play sound\r\n        const sound_name = `reader_${state}`;\r\n        sfx_reg.wait_to_play(sound_name);\r\n\r\n        // print message\r\n        term.writeln(`Screen reader mode was turned ${state}. This setting is saved in your browser's local storage. Use the ${PREFABS.program_name}reader${STYLE.reset_all} command to toggle it.`);\r\n\r\n        // remove hint element if screen reader mode is on\r\n        if (term.options.screenReaderMode) {\r\n            const hint = document.querySelector(\"#screenreader_hint\");\r\n\r\n            if (hint) {\r\n                hint.remove();\r\n            }\r\n        }\r\n\r\n        // save into local storage\r\n        localStorage.setItem(\"reader\", term.options.screenReaderMode.toString());\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE } from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"selfdestruct\",\r\n    description: \"Permanently erases the filesystem and other data, then restarts the terminal.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { FG, BG, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        const pad = (str: string, invis_codes = \"\") => {\r\n            if (str.length >= term.cols) {\r\n                return str;\r\n            }\r\n\r\n            return str + \" \".repeat(term.cols - str.length + invis_codes.length);\r\n        }\r\n\r\n        // make sure the user really wants to do this\r\n        term.writeln(BG.red + FG.white + STYLE.bold);\r\n        term.write(pad(\"WARNING: This will permanently erase the filesystem and other data, and restart the terminal.\"));\r\n        term.writeln(pad(\"This data cannot be recovered. Are you sure you want to do this?\"));\r\n        term.writeln(pad(`Press ${BG.blue}Y${BG.red} 3 times to continue, or anything else to cancel.`, BG.blue + BG.red));\r\n        term.write(STYLE.reset_all);\r\n\r\n        // wait for the user to press Y 3 times\r\n        let y_count = 0;\r\n        while (y_count < 3) {\r\n            const key = await term.wait_for_keypress();\r\n            if (key.key === \"y\" || key.key === \"Y\") {\r\n                y_count++;\r\n            } else {\r\n                term.writeln(\"Cancelled.\");\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        // clear the screen and erase the filesystem\r\n        term.reset();\r\n\r\n        term.writeln(\"Erasing filesystem and other data...\");\r\n        await fs.erase_all();\r\n        localStorage.removeItem(\"fetch_ttl_cache\");\r\n\r\n        term.writeln(`${NEWLINE}Thank you for using OllieOS!${NEWLINE}`);\r\n\r\n        // TODO: talk to ignition instead of using shutdown command\r\n        return await kernel.spawn(\"shutdown\", [\"-r\", \"-t\", \"3000\"], shell).completion;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\n\r\nimport { image2sixel } from \"sixel\";\r\n\r\n\r\n// returns null if image is invalid\r\nconst convert_to_image_data = async (url: string) => {\r\n    // create a canvas to draw the image on\r\n    const canvas = document.createElement(\"canvas\");\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    // create an image to draw the png data on\r\n    const img = new Image();\r\n    img.crossOrigin = \"anonymous\";\r\n    img.src = url;\r\n\r\n    // wait for the image to load via promise\r\n    try {\r\n        await new Promise((resolve, reject) => {\r\n            img.onload = () => {\r\n                resolve(null);\r\n            };\r\n\r\n            img.onerror = () => {\r\n                reject(null);\r\n            };\r\n        });\r\n    } catch (e) {\r\n        return null;\r\n    }\r\n\r\n    // draw the image on the canvas\r\n    canvas.width = img.width;\r\n    canvas.height = img.height;\r\n    ctx.drawImage(img, 0, 0);\r\n\r\n    // get the image data\r\n    const img_data = ctx.getImageData(0, 0, img.width, img.height);\r\n\r\n    // convert image data to uint8array\r\n    const data_arr = new Uint8Array(img_data.data);\r\n\r\n    return { array: data_arr, width: img.width, height: img.height };\r\n};\r\n\r\nexport default {\r\n    name: \"imagine\",\r\n    description: \"Views images natively in the terminal.\",\r\n    usage_suffix: \"path [-w width] [-u]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the image to view.\"\r\n        },\r\n        \"Options:\": {\r\n            \"-w\": \"The width of the image in PIXELS. Defaults to the width of the image.\",\r\n            \"-u\": \"Path is an web URL instead of a local filesystem path.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // get the path to the image\r\n        const path = args[0];\r\n\r\n        if (!path) {\r\n            term.writeln(`${PREFABS.error}No path specified.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get the width of the image specified or the terminal width\r\n        let width_arg = args.includes(\"-w\") ? parseInt(args[args.indexOf(\"-w\") + 1]) : undefined;\r\n        const is_web_url = args.includes(\"-u\");\r\n\r\n        let url: string;\r\n        let mime: string;\r\n        if (!is_web_url) {\r\n            // process the path\r\n            url = fs.absolute(path);\r\n            if (!(await fs.exists(url))) {\r\n                term.writeln(`${PREFABS.error}No such file or directory: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // get the extension\r\n            const ext = url.slice(-4).toLowerCase();\r\n\r\n            // get the mime type\r\n            switch (ext) {\r\n                case \".png\":\r\n                    mime = \"image/png\";\r\n                    break;\r\n                case \".jpg\":\r\n                case \"jpeg\":\r\n                    mime = \"image/jpeg\";\r\n                    break;\r\n                case \".gif\":\r\n                    mime = \"image/gif\";\r\n                    break;\r\n                default:\r\n                    term.writeln(`${PREFABS.error}File is not known to be a .png, .jpg/.jpeg or .gif: ${url}${STYLE.reset_all}`);\r\n                    return 1;\r\n            }\r\n\r\n\r\n            // convert to blob URL\r\n            const content = await fs.read_file(url, true) as Uint8Array;\r\n            //@ts-expect-error\r\n            url = URL.createObjectURL(new Blob([content]));\r\n\r\n        } else {\r\n            // check path is a valid URL\r\n            try {\r\n                new URL(path);\r\n                url = path;\r\n            } catch (e) {\r\n                term.writeln(`${PREFABS.error}Invalid URL: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // do a HEAD request to get the mime type\r\n            try {\r\n                const head_req = await fetch(url, { method: \"HEAD\" });\r\n\r\n                // if the HEAD request failed, try a GET request\r\n                if (!head_req.ok) {\r\n                    console.log(\"HEAD request failed, trying GET request\");\r\n                    const get_req = await fetch(url);\r\n\r\n                    // if the GET request failed, error\r\n                    if (!get_req.ok) {\r\n                        term.writeln(`${PREFABS.error}URL is not accessible: ${url}${STYLE.reset_all}`);\r\n                        return 1;\r\n                    }\r\n\r\n                    mime = get_req.headers.get(\"content-type\");\r\n                } else {\r\n                    mime = head_req.headers.get(\"content-type\");\r\n                }\r\n\r\n                // check the mime type is valid\r\n                if ([\"image/png\", \"image/jpeg\", \"image/gif\"].indexOf(mime) === -1) {\r\n                    term.writeln(`${PREFABS.error}URL does not point to a .png, .jpg/.jpeg or .gif: ${url}${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n            } catch (e) {\r\n                term.writeln(`${PREFABS.error}Error accessing URL: ${url}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        const data_out = await convert_to_image_data(url);\r\n\r\n        if (!data_out) {\r\n            term.writeln(`${PREFABS.error}Failed to convert image to data. Did you download it as a binary file?${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        const { array: img_data, width: img_width, height: img_height } = data_out\r\n\r\n        if (!width_arg) {\r\n            width_arg = img_width;\r\n        }\r\n\r\n        // scale the height to fit the width\r\n        const width_scale = width_arg / img_width;\r\n        const new_height = img_height * width_scale;\r\n\r\n        // scale the image data by chopping every nth pixel\r\n        const scaled_img_data = new Uint8Array(width_arg * new_height * 4);\r\n        for (let i = 0; i < scaled_img_data.length; i++) {\r\n            const x = Math.floor(i / 4) % width_arg;\r\n            const y = Math.floor(Math.floor(i / 4) / width_arg);\r\n\r\n            const scaled_x = Math.floor(x / width_scale);\r\n            const scaled_y = Math.floor(y / width_scale);\r\n\r\n            const scaled_i = (scaled_y * img_width + scaled_x) * 4 + (i % 4);\r\n\r\n            scaled_img_data[i] = img_data[scaled_i];\r\n        }\r\n\r\n        try {\r\n            // convert the Uint8Array to a sixel image\r\n            const sixel = image2sixel(scaled_img_data, width_arg, new_height);\r\n\r\n            // write the sixel image to the terminal\r\n            term.write(sixel);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to convert image to sixel.${STYLE.reset_all}`);\r\n            console.error(e);\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI, NEWLINE } from \"../term_ctl\";\r\n\r\nimport { default as img2ascii } from \"imgToAscii\";\r\n\r\n\r\n// TODO: DRY with mefetch\r\nconst convert_to_ascii = async (url: string, size: number): Promise<string> => {\r\n    const img = new img2ascii(url, size, Math.round(size / 2));\r\n    await img.loadImage;\r\n\r\n    // convert newlines in string\r\n    const ascii = img.stringANSI8BitColor.replace(/\\n/g, NEWLINE);\r\n    return ascii;\r\n}\r\n\r\nexport default {\r\n    name: \"ascmagine\",\r\n    description: \"Views images as ANSI/ASCII art.\",\r\n    usage_suffix: \"path [-w width] [-u]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the image to view.\"\r\n        },\r\n        \"Options:\": {\r\n            \"-w\": \"The width of the image in COLUMNS. Defaults to the width of the terminal.\",\r\n            \"-u\": \"Path is an web URL instead of a local filesystem path.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // get the path to the image\r\n        const path = args[0];\r\n\r\n        if (!path) {\r\n            term.writeln(`${PREFABS.error}No path specified.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get the width of the image specified or the terminal width\r\n        const width_arg = args.includes(\"-w\") ? parseInt(args[args.indexOf(\"-w\") + 1]) : undefined;\r\n        const is_web_url = args.includes(\"-u\");\r\n\r\n        let url: string;\r\n        if (!is_web_url) {\r\n            // process the path\r\n            url = fs.absolute(path);\r\n            if (!(await fs.exists(url))) {\r\n                term.writeln(`${PREFABS.error}No such file or directory: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // convert to blob\r\n            const content = await fs.read_file(url, true) as Uint8Array;\r\n            //@ts-expect-error\r\n            const blob = new Blob([content]);\r\n\r\n            // attempt createImageBitmap on the file to determine if it's a canvas-compatible image in the browser\r\n            if (typeof createImageBitmap === \"function\") {\r\n                try {\r\n                    // using tiny region at low res for efficiency\r\n                    await createImageBitmap(blob, 0, 0, 1, 1);\r\n                } catch (e) {\r\n                    term.writeln(`${PREFABS.error}File is not a valid image: ${path}. Did you download it as a binary file?${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n            } else {\r\n                term.writeln(`${FG.yellow}Warning: ${STYLE.reset_all}createImageBitmap is not supported in this browser. Falling back to list of trusted image formats.${STYLE.reset_all}`)\r\n                \r\n                const trusted_formats = [\".png\", \".jpg\", \".jpeg\", \".gif\", \".bmp\", \".ico\", \".svg\"];\r\n                const ext = url.slice(-4).toLowerCase();\r\n\r\n                if (!(trusted_formats.includes(ext))) {\r\n                    term.writeln(`${PREFABS.error}File is not a valid image: ${path}. Did you download it as a binary file?${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n            }\r\n\r\n            // create a blob URL\r\n            //@ts-expect-error\r\n            url = URL.createObjectURL(new Blob([content]));\r\n\r\n        } else {\r\n            // check path is a valid URL\r\n            try {\r\n                new URL(path);\r\n                url = path;\r\n            } catch (e) {\r\n                term.writeln(`${PREFABS.error}Invalid URL: ${path}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // do a HEAD request to check the mime type\r\n            const head_req = await fetch(url, { method: \"HEAD\" });\r\n            let mime: string;\r\n\r\n            // if the HEAD request failed, try a GET request\r\n            if (!head_req.ok) {\r\n                console.log(\"HEAD request failed, trying GET request\");\r\n                const get_req = await fetch(url);\r\n\r\n                // if the GET request failed, error\r\n                if (!get_req.ok) {\r\n                    term.writeln(`${PREFABS.error}URL is not accessible: ${url}${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                mime = get_req.headers.get(\"content-type\");\r\n            } else {\r\n                mime = head_req.headers.get(\"content-type\");\r\n            }\r\n\r\n            // check the mime type is valid\r\n            if (!mime.startsWith(\"image/\")) {\r\n                term.writeln(`${PREFABS.error}URL is not an image: ${url}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        // get the image\r\n        const img = await convert_to_ascii(url, width_arg || term.cols - 1);\r\n\r\n        // write the image\r\n        term.write(img);\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"fsedit\",\r\n    description: \"Opens the fsedit program to edit the filesystem.\",\r\n    usage_suffix: \"[directory]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            directory: \"The directory to open fsedit in. Defaults to the current working directory.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term, process } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // get fs name\r\n        const fs_name = fs.get_unique_fs_type_name();\r\n\r\n        // check args\r\n        let dir = fs.get_cwd();\r\n        if (args.length > 1) {\r\n            term.writeln(`${PREFABS.error}Too many arguments.${STYLE.reset_all}`);\r\n            return 1;\r\n        } else if (args.length === 1) {\r\n            // set dir\r\n            dir = fs.absolute(args[0]);\r\n        }\r\n\r\n        // check if directory exists\r\n        if (!(await fs.dir_exists(dir))) {\r\n            term.writeln(`${PREFABS.error}Directory '${args[0]}' does not exist.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // url encode the directory\r\n        const encoded_dir = encodeURIComponent(dir);\r\n\r\n        if (!kernel.has_window_manager()) {\r\n            // fallback to opening in a popup window\r\n            window.open(`./fsedit?type=${fs_name}&dir=${encoded_dir}`, \"_blank\", \"popup=true\");\r\n            term.writeln(\"Opened fsedit in a new popup window.\");\r\n            return 0;\r\n        }\r\n\r\n        const iframe = document.createElement(\"iframe\");\r\n        iframe.src = `./fsedit?type=${fs_name}&dir=${encoded_dir}`;\r\n        iframe.style.border = \"none\";\r\n        iframe.style.width = \"100%\";\r\n        iframe.style.height = \"100%\";\r\n\r\n        const wind = process.create_window();\r\n        wind.title = \"fsedit\";\r\n\r\n        wind.width = \"75vw\";\r\n        wind.height = \"75vh\";\r\n\r\n        wind.x = \"12.5vw\";\r\n        wind.y = \"12.5vh\";\r\n\r\n        wind.dom.appendChild(iframe);\r\n        wind.show();\r\n\r\n        // send message\r\n        term.writeln(\"Opened fsedit in a new window.\");\r\n\r\n        wind.add_event_listener(\"close\", async () => {\r\n            // backup unlock logic TODO improve the design of fsedit in general\r\n            if (await fs.exists(\"/.fs.lock\")) {\r\n                // check that no other fsedit processes are running\r\n                let other_fsedit_running = false;\r\n                const processes = kernel.get_process_manager().list_pids();\r\n                for (const pid of processes) {\r\n                    if (pid === process.pid) {\r\n                        continue;\r\n                    }\r\n\r\n                    const proc = kernel.get_process_manager().get_process(pid);\r\n                    if (proc && proc.source_command.command === \"fsedit\") {\r\n                        other_fsedit_running = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!other_fsedit_running) {\r\n                    await fs.delete_file(\"/.fs.lock\");\r\n                }\r\n            }\r\n\r\n            process.kill(0);\r\n        });\r\n\r\n        // listen for message from iframe to close window\r\n        const message_handler = (event: MessageEvent) => {\r\n            if (event.source === iframe.contentWindow && event.data === \"closing-fsedit\") {\r\n                wind.close();\r\n                window.removeEventListener(\"message\", message_handler);\r\n            }\r\n        };\r\n        window.addEventListener(\"message\", message_handler);\r\n\r\n        process.detach();\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\nimport { NonRecursiveDirectoryError, PathNotFoundError } from \"../filesystem\";\r\n\r\nexport default {\r\n    name: \"rm\",\r\n    description: \"Deletes a file or directory.\",\r\n    usage_suffix: \"[-rf | -f] path\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"path\": \"The path to the file or directory to delete.\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-rf\": \"Recursively and forcibly delete directories (ignoring if directory has content, treated as -f if a file is passed).\",\r\n            \"-f\": \"Forcibly delete files (ignoring readonly state, NOT treated as -rf if a directory is passed).\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // determine if -rf OR -f was passed\r\n        let rimraf = false;\r\n        let force = false;\r\n\r\n        if (args[0] === \"-rf\") {\r\n            rimraf = true;\r\n            force = true;\r\n            args.shift();\r\n        } else if (args[0] === \"-f\") {\r\n            force = true;\r\n            args.shift();\r\n        }\r\n\r\n        // check if there is only one argument after parsing flag\r\n        if (args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}Invalid arguments.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get path\r\n        const path = args[0];\r\n        const abs_path = fs.absolute(path);\r\n\r\n        // check if path exists\r\n        if (!(await fs.exists(abs_path))) {\r\n            term.writeln(`${PREFABS.error}Path does not exist.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // check if path is a directory\r\n        const is_dir = await fs.dir_exists(abs_path);\r\n\r\n        // perform deletion\r\n        if (is_dir) {\r\n            try {\r\n                await fs.delete_dir(abs_path, rimraf);\r\n            } catch (e) {\r\n                if (e instanceof NonRecursiveDirectoryError) {\r\n                    term.writeln(`${PREFABS.error}Directory is not empty. Refusing to delete without -rf flag.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                if (e instanceof PathNotFoundError) {\r\n                    term.writeln(`${PREFABS.error}Path no longer exists.${STYLE.reset_all}`);\r\n                    return 1;\r\n                }\r\n\r\n                throw e;\r\n            }\r\n        } else {\r\n            // if not forcing, check if file is readonly\r\n            if (!force && await fs.is_readonly(abs_path)) {\r\n                term.writeln(`${PREFABS.error}File is readonly. Refusing to delete without -f flag.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            await fs.delete_file(abs_path);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nconst type_suffixes = {\r\n    bug: \"?assignees=&labels=awaiting+effort+estimate%2C+awaiting+triage%2C+bug%2C+unreviewed&template=bug-report-%F0%9F%90%9B.md&title=%5B%F0%9F%90%9B%5D+-+Descriptive%2C+short+title\",\r\n    feature: \"?assignees=&labels=awaiting+effort+estimate%2C+awaiting+triage%2C+feature%2C+unreviewed&template=feature-request-%F0%9F%92%A1.md&title=%5B%F0%9F%92%A1%5D+-+Descriptive%2C+short+title\",\r\n    other: \"/choose\",\r\n}\r\n\r\nexport default {\r\n    name: \"bugreport\",\r\n    description: \"Opens the bug reporter.\",\r\n    usage_suffix: \"[bug|feature|other]\",\r\n    arg_descriptions: {\r\n        bug: \"Opens the bug reporter with the bug report template.\",\r\n        feature: \"Opens the bug reporter with the feature request template.\",\r\n        other: \"Opens the bug reporter with the template chooser (default).\",\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: helper_completion_options([\"bug\", \"feature\", \"other\"]),\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { term, args } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // if no arguments are provided, default to bug\r\n        let type = \"other\";\r\n        if (args.length > 0) {\r\n            type = args[0].toLowerCase();\r\n\r\n            // check if the type is valid (don't use in, it won't filter __proto__ etc.)\r\n            if (!Object.keys(type_suffixes).includes(type)) {\r\n                term.writeln(`${PREFABS.error} Invalid type: ${type}. Please choose bug, feature, or other.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        window.open(`https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io/issues/new${type_suffixes[type]}`, \"_blank\", \"\");\r\n\r\n        term.writeln(\"Opened bug reporter in a new tab.\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"repo\",\r\n    description: \"Opens the GitHub repository for OllieOS.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { term } = data;\r\n\r\n        window.open(\"https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io\", \"_blank\", \"\");\r\n\r\n        term.writeln(\"Opened repo in a new tab.\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import type { Program } from \"../types\";\r\n\r\nimport { ANSI, NEWLINE } from \"../term_ctl\";\r\n\r\nimport { convert as convert_html_to_text } from \"html-to-text\";\r\n\r\nconst HTML_TAG_REGEX = /<\\/?[a-z][\\s\\S]*>/i;\r\n\r\n// modified from source: https://github.com/rbren/rss-parser/blob/master/lib/fields.js\r\nconst fields = { feed: {}, item: {} };\r\n\r\n// known feed fields\r\nfields.feed = {\r\n    author: [\"author\", \"creator\"],\r\n    publisher: [\"dc:publisher\", \"publisher\"],\r\n    title: [\"dc:title\", \"title\"],\r\n    description: \"description\",\r\n    date: \"pubDate\",\r\n    link: \"link\",\r\n};\r\n\r\n// known item fields\r\nfields.item = {\r\n    author: [\"author\", \"creator\"],\r\n    date: [\"dc:date\", \"date\", \"pubDate\"],\r\n    title: [\"dc:title\", \"title\"],\r\n    link: \"link\",\r\n    summary: \"summary\",\r\n    description: [\"content:encoded\", \"content\", \"description\"],\r\n};\r\n// end source: https://github.com/rbren/rss-parser/blob/master/lib/fields.js\r\n\r\nenum DocType {\r\n    FEED,\r\n    ITEM\r\n}\r\n\r\nconst get_field = (doc: Document | Element, doc_type: DocType, field: string, as_html = false) => {\r\n    // get the fields object\r\n    const dict = doc_type === DocType.FEED ? fields.feed : fields.item;\r\n\r\n    // check if the field is known (don't use in, it won't filter out __proto__ etc.)\r\n    if (!Object.keys(dict).includes(field)) {\r\n        return undefined;\r\n    }\r\n\r\n    // get the field\r\n    const field_value = dict[field];\r\n\r\n    // if the field is an array, concatenate the values\r\n    if (Array.isArray(field_value)) {\r\n        let value = \"\";\r\n\r\n        for (const sub_field of field_value) {\r\n            const sub_field_doc = doc.getElementsByTagName(sub_field)[0];\r\n            let sub_value: string;\r\n\r\n            if (as_html) {\r\n                sub_value = sub_field_doc?.innerHTML;\r\n            } else {\r\n                sub_value = sub_field_doc?.textContent;\r\n            }\r\n\r\n            if (sub_value) {\r\n                value += sub_value;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    } else {\r\n        // otherwise, get the value\r\n        if (as_html) {\r\n            return doc.getElementsByTagName(field_value)[0]?.innerHTML;\r\n        } else {\r\n            return doc.getElementsByTagName(field_value)[0]?.textContent;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport default {\r\n    name: \"rss\",\r\n    description: \"Reads from an RSS feed.\",\r\n    usage_suffix: \"[-h] [url] [-m items] [-x]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"url\": \"The URL to the XML feed (plaintext feed recommended, unless the HTML is basic). Defaults to https://blog.ollieg.codes/rss/feed.xml\"\r\n        },\r\n        \"Flags:\": {\r\n            \"-h\": \"Print this help message.\",\r\n            \"-m\": \"The maximum number of items to display. Defaults to no limit.\",\r\n            \"-x\": \"Only display titles, links and publishing dates, not descriptions.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    // TODO: completion\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, shell, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"rss\"], shell).completion;\r\n        }\r\n\r\n        let max_items: number | undefined = undefined;\r\n        if (args.includes(\"-m\")) {\r\n            // get the index of the flag\r\n            const index = args.indexOf(\"-m\");\r\n\r\n            // get the value after the flag\r\n            const value = args[index + 1];\r\n\r\n            // check if the value is valid\r\n            if (!value || isNaN(parseInt(value)) || parseInt(value) < 0) {\r\n                term.writeln(`${PREFABS.error}Invalid value for -m flag. Expected a positive integer.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            // set the max items\r\n            max_items = parseInt(value);\r\n\r\n            // remove the flag and value from the args\r\n            args.splice(index, 2);\r\n        }\r\n\r\n        const no_content = args.includes(\"-x\");\r\n\r\n\r\n        // check if the user provided a URL\r\n        let url = \"https://blog.ollieg.codes/rss/feed.xml\";\r\n        if (args.length !== 0) {\r\n            url = args.shift();\r\n        }\r\n\r\n        // validate url\r\n        try {\r\n            const proc_url = new URL(url);\r\n\r\n            if (proc_url.protocol !== \"http:\" && proc_url.protocol !== \"https:\") {\r\n                throw new Error(\"Invalid protocol\");\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Invalid URL. Expected a valid HTTP or HTTPS protocol URL.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // fetch the feed\r\n        // TODO: potential DRY with webget\r\n        let response: Response;\r\n\r\n        term.writeln(`${FG.green}Fetching feed...${STYLE.reset_all}`);\r\n\r\n        try {\r\n            response = await fetch(url);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to fetch feed.${STYLE.reset_all}`);\r\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            return 1;\r\n        }\r\n\r\n        if (!response.ok) {\r\n            term.writeln(`${PREFABS.error}Request not OK.${STYLE.reset_all}`);\r\n\r\n            // get the error message\r\n            const text = await response.text();\r\n\r\n            if (text !== \"\") {\r\n                term.writeln(`${PREFABS.error}${text}${STYLE.reset_all}`);\r\n            }\r\n\r\n            return 1;\r\n        }\r\n\r\n        // get the text and convert newlines (\\r\\n or \\n) to the terminal's newline\r\n        const text = (await response.text()).replace(/\\r\\n|\\n/g, NEWLINE);\r\n\r\n        // parse the text\r\n        const parser = new DOMParser();\r\n\r\n        let doc: Document;\r\n\r\n        try {\r\n            doc = parser.parseFromString(text, \"text/xml\");\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to parse feed.${STYLE.reset_all}`);\r\n            term.writeln(`${PREFABS.error}${\"message\" in e ? e.message : e}${STYLE.reset_all}`);\r\n            console.error(e);\r\n\r\n            return 1;\r\n        }\r\n\r\n        term.write(NEWLINE);\r\n\r\n        // print the title if it exists\r\n        const feed_title = get_field(doc, DocType.FEED, \"title\") ?? \"Untitled feed\";\r\n        term.writeln(`${FG.cyan + STYLE.bold + STYLE.italic}${feed_title}${STYLE.reset_all}`);\r\n\r\n        // print the site link if it exists\r\n        const site_link = get_field(doc, DocType.FEED, \"link\") ?? \"\";\r\n        term.writeln(`${FG.cyan}${site_link}${STYLE.reset_all}`);\r\n\r\n        // print the site description if it exists\r\n        const site_description = get_field(doc, DocType.FEED, \"description\") ?? \"\";\r\n        term.writeln(`${site_description}`);\r\n\r\n        term.write(NEWLINE);\r\n        term.writeln(`${FG.gray}------${STYLE.reset_all}`);\r\n        term.write(NEWLINE);\r\n\r\n        // get the items\r\n        const items = doc.getElementsByTagName(\"item\");\r\n\r\n        if (max_items === undefined) {\r\n            max_items = items.length;\r\n        }\r\n\r\n        // print the items\r\n        for (let item_idx = 0; item_idx < max_items; item_idx++) {\r\n            const item = items.item(item_idx);\r\n\r\n            // check if the item exists\r\n            if (!item) {\r\n                // hit the end of the items, break\r\n                break;\r\n            }\r\n\r\n            // get each field of the item if they exist\r\n\r\n            // title\r\n            const item_title = get_field(item, DocType.ITEM, \"title\") ?? \"Untitled item\";\r\n\r\n            // link\r\n            const link = get_field(item, DocType.ITEM, \"link\") ?? \"\";\r\n\r\n\r\n            let description = \"\";\r\n            if (!no_content) {\r\n                description = get_field(item, DocType.ITEM, \"description\") ?? \"\";\r\n\r\n                // if the description is html, attempt to convert it to plaintext\r\n                if (HTML_TAG_REGEX.test(description)) {\r\n                    term.writeln(`${FG.gray}(interpreting description as HTML)${STYLE.reset_all}`)\r\n                    term.write(NEWLINE);\r\n\r\n                    // reparse as html\r\n                    description = get_field(item, DocType.ITEM, \"description\", true) ?? \"\";\r\n\r\n                    // remove CDATA tags if present\r\n                    description = description.replace(/<!\\[CDATA\\[|\\]\\]>/g, \"\");\r\n\r\n                    // parse the description using custom highlighters\r\n                    description = convert_html_to_text(description,\r\n                        {\r\n                            formatters: {\r\n                                \"ansi_formatter\": (elem, walk, builder, options) => {\r\n                                    builder.openBlock();\r\n                                    builder.addInline(options.opener);\r\n                                    walk(elem.children, builder);\r\n                                    builder.addInline(STYLE.reset_all);\r\n                                    builder.closeBlock();\r\n                                },\r\n                                \"img_highlight\": (elem, walk, builder, options) => {\r\n                                    const img_fmt = builder.options.formatters[\"image\"];\r\n                                    if (img_fmt) {\r\n                                        builder.addInline(STYLE.bold + FG.magenta);\r\n                                        img_fmt(elem, walk, builder, options);\r\n                                        builder.addInline(STYLE.reset_all);\r\n                                    }\r\n                                },\r\n                                \"a_highlight\": (elem, walk, builder, options) => {\r\n                                    const a_fmt = builder.options.formatters[\"anchor\"];\r\n                                    if (a_fmt) {\r\n                                        builder.addInline(STYLE.bold + FG.blue);\r\n                                        a_fmt(elem, walk, builder, options);\r\n                                        builder.addInline(STYLE.reset_all);\r\n                                    }\r\n                                }\r\n                            },\r\n                            selectors: [\r\n                                {\r\n                                    selector: \"b\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.bold\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"strong\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.bold\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"i\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.italic\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"em\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.italic\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"u\",\r\n                                    format: \"ansi_formatter\",\r\n                                    options: {\r\n                                        opener: STYLE.underline\r\n                                    }\r\n                                },\r\n                                {\r\n                                    selector: \"img\",\r\n                                    format: \"img_highlight\"\r\n                                },\r\n                                {\r\n                                    selector: \"a\",\r\n                                    format: \"a_highlight\"\r\n                                },\r\n                                {\r\n                                    selector: \"table\",\r\n                                    format: \"dataTable\"\r\n                                }\r\n                            ]\r\n                        }\r\n                    );\r\n                }\r\n\r\n                // trim start and end whitespace\r\n                description = description.trim();\r\n\r\n                // replace newlines again in case the description was html\r\n                description = description.replace(/\\r\\n|\\n/g, NEWLINE);\r\n            }\r\n\r\n            // pubDate\r\n            const date = get_field(item, DocType.ITEM, \"date\") ?? \"\";\r\n\r\n            // print the item\r\n            term.writeln(`${FG.green + STYLE.bold + STYLE.underline}${item_title}${STYLE.reset_all}`);\r\n            term.writeln(`${FG.cyan}${link}${STYLE.reset_all}`);\r\n            term.writeln(`${FG.yellow}${date}${STYLE.reset_all}`);\r\n            term.write(NEWLINE);\r\n\r\n            if (!no_content) {\r\n                term.writeln(`${description}`);\r\n                term.write(NEWLINE);\r\n            }\r\n\r\n            term.writeln(`${FG.gray}------${STYLE.reset_all}`);\r\n            term.write(NEWLINE);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"legacy\",\r\n    description: \"Opens the legacy ollieg.codes site if you're having trouble with this version.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (_data) => {\r\n        window.location.assign(\"https://legacy.ollieg.codes/\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: keep this or not?\r\n","import type {Program, ProgramMainData} from \"../types\";\r\nimport { ANSI, NEWLINE, type WrappedTerminal } from \"../term_ctl\";\r\n\r\n\r\nconst wait_block = (term: WrappedTerminal) => {\r\n    term.write(NEWLINE);\r\n    term.writeln(`${ANSI.STYLE.italic}Press any key to continue...${ANSI.STYLE.reset_all}`)\r\n    return term.wait_for_keypress();\r\n};\r\n\r\nconst run_cmd = async (data: ProgramMainData, cmd: string, args: string[] = []) => {\r\n    data.term.writeln(`${ANSI.STYLE.bold}$ ${cmd}${ANSI.STYLE.reset_all}${NEWLINE}`);\r\n    await data.kernel.spawn(cmd, args, data.shell).completion;\r\n    data.term.write(NEWLINE);\r\n};\r\n\r\n\r\nconst welcome = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}Welcome to OllieOS!`);\r\n    term.writeln(`===================${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"This tour covers the basic commands and features of OllieOS.\");\r\n    term.writeln(`First, let's use ${PREFABS.program_name}mefetch${STYLE.reset_all} to view info about me.`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"Normally, you would type the command into the terminal and press RETURN, but for this tour, the command will be run automatically.\");\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst mefetch = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}mefetch`);\r\n    term.writeln(`=======${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"mefetch\");\r\n\r\n    term.writeln(`The ${PREFABS.program_name}mefetch${STYLE.reset_all} command is used to display information about a GitHub user.`);\r\n    term.writeln(\"By default, it uses my username, obfuscatedgenerated. You can also specify a different username as an argument.\");\r\n    term.writeln(\"If another username is used, less information will be displayed.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.write(`Now, let's use ${PREFABS.program_name}rss${STYLE.reset_all} to read my blog.`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst rss = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}rss`);\r\n    term.writeln(`===${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"rss\", [\"-m\", \"1\"]);\r\n\r\n    term.writeln(`The ${PREFABS.program_name}rss${STYLE.reset_all} command is used to read RSS feeds.`);\r\n    term.writeln(\"By default, it uses my blog's RSS feed. You can also specify a different RSS feed as an argument.\");\r\n    term.writeln(\"A plaintext RSS feed is recommended, but the program can also parse basic HTML.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"For the output above, the -m 1 flag was used to only display the first item in the feed. Without it, all items would be displayed.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`Let's use the ${PREFABS.program_name}help${STYLE.reset_all} command to view a list of all available commands, and to get help with a specific command.`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst fs = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}Filesystem`);\r\n    term.writeln(`==========${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"OllieOS has a filesystem, which is used to store files and folders.\");\r\n    term.writeln(\"The filesystem is persistent, so files and folders will not be deleted when the OS is restarted.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`Let's use the ${PREFABS.program_name}ls${STYLE.reset_all} command to view the contents of the home directory.`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"ls\");\r\n\r\n    term.writeln(`There's a file in the directory called ${PREFABS.file_path}credits.txt${STYLE.reset_all}. Let's use the ${PREFABS.program_name}cat${STYLE.reset_all} command to view its contents.`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n    await run_cmd(data, \"cat\", [\"credits.txt\"]);\r\n\r\n    term.writeln(`The ${PREFABS.program_name}cat${STYLE.reset_all} command is used to view the contents of one or more files.`);\r\n    term.writeln(\"If multiple files are specified, their contents will be concatenated together.\");\r\n    term.write(NEWLINE);\r\n    \r\n    term.writeln(`There are many other commands that can be used to interact with the filesystem, such as ${PREFABS.program_name}cd${STYLE.reset_all}, ${PREFABS.program_name}fsedit${STYLE.reset_all}, ${PREFABS.program_name}rm${STYLE.reset_all}, and more.`);\r\n    term.writeln(NEWLINE);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\nconst help = async (data: ProgramMainData) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, PREFABS, FG } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}help`);\r\n    term.writeln(`====${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    await run_cmd(data, \"help\");\r\n\r\n    term.write(NEWLINE);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`The ${PREFABS.program_name}help${STYLE.reset_all} command is used to view a list of all available commands, and to get help with a specific command.`);\r\n    term.writeln(\"If a command is specified as an argument, the help text for that command will be displayed.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`For example, let's view the help text for the ${PREFABS.program_name}rss${STYLE.reset_all} command:`);\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n    await run_cmd(data, \"help\", [\"rss\"]);\r\n\r\n    await wait_block(term);\r\n};\r\n\r\n\r\nconst end = async (data: ProgramMainData,) => {\r\n    // extract from ANSI to make code less verbose\r\n    const { STYLE, FG, PREFABS } = ANSI;\r\n\r\n    const { term } = data;\r\n\r\n    term.reset();\r\n\r\n    term.writeln(`${STYLE.bold + FG.magenta}Thanks for using OllieOS!`);\r\n    term.writeln(`=========================${STYLE.reset_all}`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"That's all for now!\");\r\n    term.writeln(\"There is a lot more to explore, so feel free to play around with the OS and try out different commands.\");\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"Things to try:\");\r\n    term.writeln(` - Use ${PREFABS.program_name}mefetch${STYLE.reset_all}, passing your GitHub username as an argument.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}cd${STYLE.reset_all} to enter the ${PREFABS.dir_name}projects${STYLE.reset_all} directory, and then use ${PREFABS.program_name}ls${STYLE.reset_all} to view its contents.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}imagine${STYLE.reset_all} and ${PREFABS.program_name}ascmagine${STYLE.reset_all} to view an image.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}fsedit${STYLE.reset_all} to explore the filesystem.`);\r\n    term.writeln(` - Use ${PREFABS.program_name}webget${STYLE.reset_all} to download a file from the Internet into the OS.`);\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(\"Thanks for using OllieOS.\");\r\n    term.writeln(\"The OS will now restart.\");\r\n    term.write(NEWLINE);\r\n\r\n    await wait_block(term);\r\n\r\n    await run_cmd(data, \"shutdown\", [\"-r\", \"-t\", \"0\"]);\r\n};\r\n\r\n\r\nexport default {\r\n    name: \"tour\",\r\n    description: \"Runs the onboarding tour.\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        await welcome(data);\r\n\r\n        await mefetch(data);\r\n        await rss(data);\r\n        await fs(data);\r\n        await help(data);\r\n\r\n        await end(data);\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import {determine_program_name_from_js} from \"../../prog_registry\";\r\nimport { ANSI, NEWLINE } from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {graph_query, triggers} from \"./index\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, PREFABS, FG } = ANSI;\r\n\r\n// TODO: resolve unused deps?\r\n\r\nexport const remove_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel, shell } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing package name.`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // remove duplicate args\r\n    let unique_args = [...new Set(args)];\r\n\r\n    // if any args contain @, trim to before @ and show warning\r\n    // TODO: accept version specifier and check that the requested version is the one installed before removing\r\n    for (const arg of unique_args) {\r\n        if (arg.includes(\"@\")) {\r\n            term.writeln(`${FG.yellow}Warning: ${arg} contains a version specifier.`);\r\n            term.writeln(`This will be ignored.${STYLE.reset_all}`);\r\n        }\r\n    }\r\n\r\n    // perform removal\r\n    unique_args = unique_args.map(arg => arg.split(\"@\")[0]);\r\n\r\n    // remove duplicates again\r\n    unique_args = [...new Set(unique_args)];\r\n\r\n    let error_count = 0;\r\n    // returns 0 for success, 1 for failure, 2 for fatal error\r\n\r\n    const fs = kernel.get_fs();\r\n    const prog_reg = kernel.get_program_registry();\r\n\r\n    // iter over remaining args\r\n    const total_pkgs = unique_args.length;\r\n    while (unique_args.length >= 1) {\r\n        term.writeln(`${NEWLINE}${FG.gray}------------------------${STYLE.reset_all}${NEWLINE}`);\r\n\r\n        const pkg = unique_args.shift();\r\n\r\n        term.writeln(`${FG.yellow}Checking for ${pkg}...${STYLE.reset_all}`);\r\n\r\n        // if .., /, or \\ in pkg, skip\r\n        if (pkg.includes(\"..\") || pkg.includes(\"/\") || pkg.includes(\"\\\\\")) {\r\n            term.writeln(`${PREFABS.error}Illegal package name '${pkg}'.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        const pkg_dir = `/usr/bin/${pkg}`;\r\n\r\n        // check if pkg exists\r\n        if (!(await fs.dir_exists(pkg_dir))) {\r\n            term.writeln(`${PREFABS.error}Package '${pkg}' not installed.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Updating graph...${STYLE.reset_all}`);\r\n\r\n        let meta_triggers = {};\r\n        let meta_version = \"unknown\";\r\n        let meta_deps: string[] = [];\r\n\r\n        if (await fs.exists(fs.join(pkg_dir, \"meta.json\"))) {\r\n            try {\r\n                const meta_raw = await fs.read_file(fs.join(pkg_dir, \"meta.json\")) as string;\r\n                const meta = JSON.parse(meta_raw);\r\n\r\n                meta_triggers = meta.triggers || {};\r\n                meta_version = meta.version || \"unknown\";\r\n                meta_deps = meta.deps || [];\r\n            } catch (e) {\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Could not read meta.json for package ${pkg}: ${e.message}${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        // remove self as a dependent from packages listed as dependencies\r\n        for (const dep_pkg of meta_deps) {\r\n            try {\r\n                // split into name and version if @ present\r\n                const dep_pkg_name = dep_pkg.split(\"@\")[0];\r\n                await graph_query.remove_pkg_dependent(fs, dep_pkg_name, pkg);\r\n            } catch (e) {\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Could not remove dependent ${pkg} from package ${dep_pkg}: ${e.message}${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        try {\r\n            await graph_query.remove_pkg(fs, pkg);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Error removing package '${pkg}': ${e.message}${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        term.writeln(`${FG.cyan}Unmounting programs...${STYLE.reset_all}`);\r\n\r\n        const files = await fs.list_dir(pkg_dir);\r\n\r\n        for (const file of files) {\r\n            if (!file.endsWith(\".js\")) {\r\n                continue;\r\n            }\r\n\r\n            const file_path = fs.join(pkg_dir, file);\r\n\r\n            let program_name: string;\r\n            try {\r\n                const content = await fs.read_file(file_path) as string;\r\n                program_name = await determine_program_name_from_js(content);\r\n            } catch (e) {\r\n                if (e.message.endsWith(\"is not compatible with Node.js.\")) {\r\n                    // silently skip node.js incompatible programs (they wouldn't have been mounted anyway)\r\n                    // yes this is a weird way to do it, but better than changing how build_registrant works\r\n                    continue;\r\n                }\r\n\r\n                term.writeln(`${PREFABS.error}Error determining program name for ${file}: ${e.message}${STYLE.reset_all}`);\r\n                term.writeln(`${FG.yellow}Skipping program (will remain mounted until restart)...${STYLE.reset_all}`);\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                await prog_reg.unregister(program_name);\r\n                term.writeln(`${FG.cyan}(-) ${program_name}${STYLE.reset_all}`);\r\n            } catch (e) {\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: Program ${program_name} was never registered.${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Removing package data...${STYLE.reset_all}`);\r\n        await fs.delete_dir(pkg_dir, true);\r\n        fs.purge_cache();\r\n\r\n        term.writeln(`${FG.green}Package '${pkg}' removed.${STYLE.reset_all}`);\r\n\r\n        // check for any removal triggers\r\n        // check for any triggers\r\n        if (meta_triggers && Object.keys(meta_triggers).length > 0) {\r\n            term.writeln(`${FG.cyan}Processing uninstall triggers...${STYLE.reset_all}`);\r\n\r\n            for (const [trigger_name, trigger_data] of Object.entries(meta_triggers)) {\r\n                if (!await triggers.trigger_exists(fs, trigger_name)) {\r\n                    term.writeln(`${FG.yellow}Warning: trigger '${trigger_name}' is not recognised and will be skipped.${STYLE.reset_all}`);\r\n                    continue;\r\n                }\r\n\r\n                term.writeln(`${FG.cyan}Processing uninstall trigger: ${trigger_name}...${STYLE.reset_all}`);\r\n                await triggers.process_uninstall_trigger(trigger_name, trigger_data, pkg, meta_version, term, kernel, shell)\r\n            }\r\n\r\n            term.writeln(`${FG.cyan}Uninstall trigger processing complete.${STYLE.reset_all}`);\r\n        }\r\n    }\r\n\r\n    term.writeln(`${NEWLINE}${FG.magenta + STYLE.bold}========================${STYLE.reset_all}${NEWLINE}`);\r\n\r\n    if (error_count > 0) {\r\n        term.writeln(`${PREFABS.error}Failed to remove ${error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.green}Successfully removed ${total_pkgs - error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.cyan}Total packages: ${total_pkgs}${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`${FG.green}Successfully removed all ${total_pkgs} package(s).${STYLE.reset_all}`);\r\n\r\n    return 0;\r\n}\r\n","import {graph_query, json_convert_dep_sets_to_arrs, repo_query, triggers} from \".\";\r\n\r\nimport {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport {ProgramMainData} from \"../../types\"\r\nimport {remove_subcommand} from \"./remove\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS, FG} = ANSI;\r\n\r\n// we arent allowing multiple versions of the same package to be installed at once to simplify things significantly\r\n// TODO: write to a file that tracks installed packages and their dependents (for list and smart removal/cleanup)\r\n\r\nexport const add_subcommand = async (data: ProgramMainData, depended_by?: string) => {\r\n    // extract from data to make code less verbose\r\n    const {args, term, kernel, shell} = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing package name.`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // remove duplicate args\r\n    const unique_args = [...new Set(args)];\r\n\r\n    let error_count = 0;\r\n    // returns 0 for success, 1 for failure, 2 for fatal error\r\n\r\n    const fs = kernel.get_fs();\r\n    const prog_reg = kernel.get_program_registry();\r\n\r\n    // iter over remaining args\r\n    const total_pkgs = unique_args.length;\r\n    while (unique_args.length >= 1) {\r\n        term.writeln(`${NEWLINE}${FG.gray}------------------------${STYLE.reset_all}${NEWLINE}`);\r\n\r\n        const pkg_at_version = unique_args.shift();\r\n\r\n        // if in the format of pkg@version, split it up\r\n        const pkg_split = pkg_at_version.split(\"@\");\r\n        if (pkg_split.length > 2) {\r\n            term.writeln(`${PREFABS.error}Invalid package name: ${pkg_at_version}`);\r\n            term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n            return 2;\r\n        }\r\n\r\n        const pkg_name = pkg_split[0];\r\n        let pkg_version = pkg_split[1];\r\n\r\n        term.writeln(`${FG.yellow}Checking for ${pkg_name}...${STYLE.reset_all}`);\r\n\r\n        const pkg_json = await repo_query.get_pkg_json(pkg_name);\r\n\r\n        if (!pkg_json) {\r\n            term.writeln(`${PREFABS.error}Package '${pkg_name}' not found.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        // if no version specified, use latest\r\n        if (!pkg_version) {\r\n            pkg_version = pkg_json.latest_version;\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Using ${pkg_name}@${pkg_version}...${STYLE.reset_all}`);\r\n\r\n        // check if version exists (and get metadata)\r\n        const meta = await repo_query.get_pkg_meta(pkg_name, pkg_version);\r\n\r\n        if (!meta) {\r\n            term.writeln(`${PREFABS.error}Version '${pkg_version}' of '${pkg_name}' not found.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        if (!meta.externals || meta.externals !== \"global\") {\r\n            term.writeln(`${PREFABS.error}Package '${pkg_name}' is not using the new global externals system. Please build the package with a newer version of pkgbuild.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        const pkg_dir = `/usr/bin/${pkg_name}`;\r\n\r\n        // check version file if already installed\r\n        // TODO: switch to pkg graph?\r\n        if (graph_query.pkg_is_installed(pkg_name)) {\r\n            const installed_version = graph_query.get_pkg_version(pkg_name);\r\n\r\n            if (installed_version === pkg_version) {\r\n                // if exact version already installed, check dep graph then skip\r\n                // ie if depended_by is set but that isn't a dependent yet then add it\r\n\r\n                term.writeln(`${FG.yellow + STYLE.bold}Warning: ${pkg_name}@${pkg_version} already installed. If you wish to reinstall the package, remove it first.${STYLE.reset_all}`);\r\n\r\n                // cant do this here as top level package isn't installed yet. it's the caller's job to do this. it wouldn't be safe to refactor the method in a way that allows this\r\n                // if (depended_by) {\r\n                //     graph_query.add_pkg_dependent(fs, pkg_name, depended_by);\r\n                //     term.writeln(`${FG.yellow}(dep graph updated)${STYLE.reset_all}`);\r\n                // }\r\n\r\n                continue;\r\n            } else {\r\n                // uninstall old version\r\n                term.writeln(`${FG.yellow}Uninstalling old ${pkg_name}@${pkg_version}...${STYLE.reset_all}`);\r\n\r\n                const remove_data = {kernel, term, process: data.process, args: [\"remove\", pkg_name], unsubbed_args: [\"remove\", pkg_name], raw_parts: [...data.raw_parts, \"remove\", pkg_name]};\r\n                const remove_exit_code = await remove_subcommand(remove_data);\r\n                if (remove_exit_code !== 0) {\r\n                    term.writeln(`${PREFABS.error}Failed to uninstall old version.${STYLE.reset_all}`);\r\n                    error_count++;\r\n                    term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        // firstly, install dependencies\r\n        if (meta.deps && meta.deps.size > 0) {\r\n            term.writeln(`${NEWLINE + FG.magenta + STYLE.bold}Installing dependencies...${STYLE.reset_all}`);\r\n\r\n            // simulate a call to this function with the deps as arguments\r\n            // TODO: is it worth doing this properly and decomposing each stage to a function and calling it?\r\n            // TODO: clearer logs\r\n            // TODO: unshifting add is silly, should this func be changed to accept args with add removed?\r\n            // TODO: parallelism with promise.all???\r\n            const virtual_args: string[] = [...meta.deps];\r\n            virtual_args.unshift(\"add\");\r\n\r\n            // we need to also pass the name of the dependent package to the virtual call to let the graph know\r\n            const virtual_data = {kernel, term, process: data.process, args: virtual_args, unsubbed_args: virtual_args, raw_parts: [...data.raw_parts, ...virtual_args]};\r\n            const virtual_exit_code = await add_subcommand(virtual_data, pkg_name);\r\n\r\n            if (virtual_exit_code !== 0) {\r\n                term.writeln(`${PREFABS.error}Failed to install dependencies.${STYLE.reset_all}`);\r\n                error_count++;\r\n                term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n                continue;\r\n                // TODO: remove partial installation\r\n            }\r\n\r\n            term.writeln(`${FG.magenta + STYLE.bold}Dependencies installed.${STYLE.reset_all + NEWLINE}`);\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Enumerating contents...${STYLE.reset_all}`);\r\n\r\n        const content_list = meta.files;\r\n\r\n        if (content_list.length === 0 || content_list.length === 1 && content_list[0] === \"\") {\r\n            term.writeln(`${PREFABS.error}Empty package.${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        // get each file in contents and load it into memory\r\n        const file_map = new Map<string, string>();\r\n\r\n        for (const file of content_list) {\r\n            if (file === \"\") {\r\n                continue;\r\n            }\r\n\r\n            term.writeln(`${FG.yellow}Downloading ${file}...${STYLE.reset_all}`);\r\n\r\n            const file_contents = await repo_query.get_pkg_file(pkg_name, pkg_version, file);\r\n\r\n            if (!file_contents) {\r\n                term.writeln(`${PREFABS.error}Not found.${STYLE.reset_all}`);\r\n                error_count++;\r\n                term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n                continue;\r\n            }\r\n\r\n            file_map.set(file, file_contents);\r\n        }\r\n\r\n        // add pkg.json and meta.json to file map\r\n        file_map.set(\"pkg.json\", JSON.stringify(pkg_json));\r\n        // TODO: adding this might be redundant, we could just move build timestamp to the graph. could also use file array to help mounting? prob not needed.\r\n        // TODO: build timestamp isnt actually used anywhere yet so not a big deal until implemented. might be quicker to just open this file rather than access the graph anyway!\r\n        file_map.set(\"meta.json\", JSON.stringify(meta, json_convert_dep_sets_to_arrs));\r\n\r\n        // not actually executing the file map yet, as we need to ensure the graph is valid\r\n\r\n        term.writeln(`${FG.yellow}Updating graph...${STYLE.reset_all}`);\r\n\r\n        // don't need to check if installed or do anything fancy if it is, as previous checks have already run and updated the graph if needed\r\n        // this is guaranteed to be a new install (whether first time or remove was just run)\r\n        // TODO: test if that's true! test it more!\r\n        try {\r\n            await graph_query.install_new_pkg(fs, pkg_name, pkg_version, meta.deps, !depended_by, depended_by);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to add to graph: ${e.message}${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        // if there were dependencies, add this package as a dependent to each of them\r\n        try {\r\n            if (meta.deps && meta.deps.size > 0) {\r\n                for (const dep of meta.deps) {\r\n                    const dep_name = dep.split(\"@\")[0];\r\n                    await graph_query.add_pkg_dependent(fs, dep_name, pkg_name);\r\n                }\r\n            }\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Failed to update dependencies: ${e.message}${STYLE.reset_all}`);\r\n            error_count++;\r\n            term.writeln(`${FG.yellow}Rolling back graph...${STYLE.reset_all}`);\r\n            // TODO: safety check? is it safer to capture the entire graph before starting and then rollback to that? add a capture and rollback method to graph_query?\r\n            await graph_query.remove_pkg(fs, pkg_name);\r\n            term.writeln(`${FG.yellow}Skipping package ${pkg_name}...${STYLE.reset_all}`);\r\n            continue;\r\n        }\r\n\r\n        term.writeln(`${FG.yellow}Installing ${pkg_name}...${STYLE.reset_all}`);\r\n\r\n        await fs.make_dir(pkg_dir);\r\n\r\n        // write each file\r\n        for (const [file, value] of file_map) {\r\n            await fs.write_file(`${pkg_dir}/${file}`, value, true);\r\n        }\r\n\r\n        // TODO: check if this fails somehow, and if it does, rollback the graph\r\n\r\n        term.writeln(`${FG.green}Installed!${STYLE.reset_all}`);\r\n\r\n        term.writeln(`${FG.cyan}Mounting package ${pkg_name}...${STYLE.reset_all}`);\r\n\r\n        // it doesn't matter if mounting fails, the graph is fine and the files are downloaded properly, so no rollback needed\r\n\r\n        // mount each program\r\n        for (const [filename, value] of file_map) {\r\n            if (!filename.endsWith(\".js\")) {\r\n                continue;\r\n            }\r\n\r\n            await prog_reg.mount_and_register_with_output(filename, value, term, true);\r\n        }\r\n\r\n        term.writeln(`${FG.green}Package ${pkg_name}@${pkg_version} installed.${STYLE.reset_all}`);\r\n\r\n        // check for any triggers\r\n        if (meta && meta.triggers && Object.keys(meta.triggers).length > 0) {\r\n            term.writeln(`${FG.cyan}Processing install triggers...${STYLE.reset_all}`);\r\n\r\n            for (const [trigger_name, trigger_data] of Object.entries(meta.triggers)) {\r\n                if (!await triggers.trigger_exists(fs, trigger_name)) {\r\n                    term.writeln(`${FG.yellow}Warning: trigger '${trigger_name}' is not recognised and will be skipped.${STYLE.reset_all}`);\r\n                    continue;\r\n                }\r\n\r\n                term.writeln(`${FG.cyan}Processing install trigger: ${trigger_name}...${STYLE.reset_all}`);\r\n                await triggers.process_install_trigger(trigger_name, trigger_data, pkg_name, pkg_version, term, kernel, shell);\r\n            }\r\n\r\n            term.writeln(`${FG.cyan}Install trigger processing complete.${STYLE.reset_all}`);\r\n        }\r\n    }\r\n\r\n    term.writeln(`${NEWLINE}${FG.magenta + STYLE.bold}========================${STYLE.reset_all}${NEWLINE}`);\r\n\r\n    if (error_count > 0) {\r\n        term.writeln(`${PREFABS.error}Failed to install ${error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.green}Successfully installed ${total_pkgs - error_count} package(s).${STYLE.reset_all}`);\r\n        term.writeln(`${FG.cyan}Total packages: ${total_pkgs}${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`${FG.green}Successfully installed all ${total_pkgs} package(s).${STYLE.reset_all}`);\r\n\r\n    return 0;\r\n}\r\n// TODO: decompose into smaller functions\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {graph_query} from \"./index\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG } = ANSI;\r\nexport const list_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // check for presence of -t flag\r\n    let only_top_level = false;\r\n    if (args[0] === \"-t\") {\r\n        only_top_level = true;\r\n        args.shift();\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n\r\n    const pkg_names = graph_query.list_pkgs(only_top_level);\r\n\r\n    // print each package, marking top level packages in green, dependencies in white, and unused dependencies in gray\r\n    for (const pkg_name of pkg_names) {\r\n        const info = graph_query.get_pkg_info(pkg_name);\r\n\r\n        let color = FG.gray;\r\n        if (info.top_level) {\r\n            color = FG.green;\r\n        } else if (info.dependents.size !== 0) {\r\n            color = FG.white;\r\n        }\r\n\r\n        term.writeln(`${STYLE.bold}${color}${pkg_name}${STYLE.no_bold_or_dim}@${info.version}${STYLE.reset_all}`);\r\n    }\r\n\r\n    return 0;\r\n}\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport type { WrappedTerminal } from \"../../term_ctl\";\r\nimport type { ProgramMainData } from \"../../types\"\r\nimport {graph_query, repo_query} from \"./index\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, PREFABS } = ANSI;\r\n\r\ninterface PkgInfo {\r\n    description?: string;\r\n    author?: string;\r\n    license?: string;\r\n    homepage_url?: string;\r\n    repo_url?: string;\r\n    long_desc?: string;\r\n}\r\n\r\nconst print_info = (term: WrappedTerminal, pkg_name: string, pkg_version: string, pkg_data: PkgInfo, installed: boolean) => {\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`Package: ${STYLE.bold}${pkg_name}${STYLE.no_bold_or_dim}`);\r\n    term.writeln(`Version: ${STYLE.bold}${pkg_version}${STYLE.no_bold_or_dim}`);\r\n    term.writeln(`Description: ${pkg_data.description || \"No description provided.\"}`);\r\n    term.writeln(`Author: ${pkg_data.author || \"Unknown\"}`);\r\n    term.writeln(`License: ${pkg_data.license || \"Unknown\"}`);\r\n    term.writeln(`Installed: ${STYLE.bold}${installed ? \"Yes\" : \"No\"}${STYLE.no_bold_or_dim}`);\r\n\r\n    if (pkg_data.homepage_url) {\r\n        term.writeln(`Homepage: ${pkg_data.homepage_url}`);\r\n    }\r\n\r\n    if (pkg_data.repo_url) {\r\n        term.writeln(`Repository: ${pkg_data.repo_url}`);\r\n    }\r\n\r\n    if (pkg_data.long_desc) {\r\n        term.write(NEWLINE);\r\n        term.writeln(`Long description available. Use ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} read${STYLE.reset_all} ${pkg_name} to read it.`);\r\n    }\r\n}\r\n\r\nexport const info_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // check for presence of -r flag\r\n    let always_fetch = false;\r\n    if (args[0] === \"-r\") {\r\n        always_fetch = true;\r\n        args.shift();\r\n    }\r\n\r\n    // check for package name\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing package name.`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const pkg_at_version = args[0];\r\n\r\n    // if in the format of pkg@version, split it up\r\n    const pkg_split = pkg_at_version.split(\"@\");\r\n    if (pkg_split.length > 2) {\r\n        term.writeln(`${PREFABS.error}Invalid package name: ${pkg_at_version}`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    const pkg_name = pkg_split[0];\r\n    let pkg_version = pkg_split[1];\r\n\r\n    // if no version specified, use what's installed\r\n    // if not installed, fetch latest from repo\r\n    // note that version doesnt really matter other than as a test whether the version exists and installed locally, as pkg.json is shared across versions\r\n    if (!pkg_version) {\r\n        const installed_pkg = graph_query.get_pkg_version(pkg_name);\r\n        if (installed_pkg && !always_fetch) {\r\n            pkg_version = installed_pkg;\r\n        } else {\r\n            const pkg_json = await repo_query.get_pkg_json(pkg_name);\r\n            if (!pkg_json) {\r\n                term.writeln(`${PREFABS.error}Package not found: ${pkg_name}`);\r\n                term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n                return 3;\r\n            }\r\n\r\n            pkg_version = pkg_json.latest_version;\r\n        }\r\n    }\r\n\r\n    const installed_pkg = graph_query.get_pkg_version(pkg_name);\r\n    const requested_version_installed = installed_pkg === pkg_version;\r\n\r\n    const fs = kernel.get_fs();\r\n\r\n    if (!always_fetch && requested_version_installed) {\r\n        const pkg_json_path = graph_query.get_file_path_in_pkg_bin(fs, pkg_name, \"pkg.json\");\r\n\r\n        if (!fs.exists(pkg_json_path)) {\r\n            // shouldnt happen, but just in case\r\n            console.error(`Invalid pkg.json path: ${pkg_json_path}`);\r\n            term.writeln(`${PREFABS.error}Error reading package files for ${pkg_name}`);\r\n            return 3;\r\n        }\r\n\r\n        const pkg_json = await fs.read_file(pkg_json_path) as string;\r\n        const pkg_data = JSON.parse(pkg_json);\r\n\r\n        print_info(term, pkg_name, pkg_version, pkg_data, true);\r\n        return 0;\r\n    }\r\n\r\n    // fetch package data from repo\r\n    const pkg_data = await repo_query.get_pkg_json(pkg_name);\r\n    if (!pkg_data) {\r\n        term.writeln(`${PREFABS.error}Package not found: ${pkg_name}`);\r\n        term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n        return 3;\r\n    }\r\n\r\n    print_info(term, pkg_name, pkg_version, pkg_data, requested_version_installed);\r\n    return 0;\r\n}\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport type { WrappedTerminal } from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {graph_query, repo_query} from \"./index\";\r\nimport type {UserspaceKernel} from \"../../kernel\";\r\nimport type {AbstractShell} from \"../../abstract_shell\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, CURSOR } = ANSI;\r\n\r\nconst ROWS = 10;\r\n\r\nconst view_pkg_info = async (pkg_name: string, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\r\n    const pkg_data = await repo_query.get_pkg_json(pkg_name);\r\n    const pkg_versions = await repo_query.get_pkg_versions(pkg_name);\r\n\r\n    term.clear();\r\n\r\n    term.write(NEWLINE);\r\n    term.writeln(`${STYLE.bold}${FG.cyan}${pkg_name}`);\r\n    term.write(STYLE.dim);\r\n    term.writeln(\"=\".repeat(pkg_name.length));\r\n    term.writeln(STYLE.reset_all);\r\n\r\n    // check for installed version\r\n    const installed_version = graph_query.get_pkg_version(pkg_name);\r\n\r\n    term.write(NEWLINE);\r\n    term.writeln(`${STYLE.bold}Available versions:${STYLE.no_bold_or_dim}`);\r\n    for (const version of pkg_versions) {\r\n        term.writeln(`  - ${version} ${installed_version === version ? `${STYLE.italic}(installed)${STYLE.reset_all}` : \"\"}`);\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n    term.writeln(`${STYLE.bold}Description:${STYLE.no_bold_or_dim} ${pkg_data.description || \"No description provided.\"}`);\r\n    term.writeln(`${STYLE.bold}Author:${STYLE.no_bold_or_dim} ${pkg_data.author || \"Unknown\"}`);\r\n    term.writeln(`${STYLE.bold}License:${STYLE.no_bold_or_dim} ${pkg_data.license || \"Unknown\"}`);\r\n\r\n    let printed_link_header = false;\r\n\r\n    if (pkg_data.homepage_url) {\r\n        if (!printed_link_header) {\r\n            term.write(NEWLINE);\r\n            printed_link_header = true;\r\n        }\r\n\r\n        term.writeln(`${STYLE.bold}Homepage:${STYLE.no_bold_or_dim} ${pkg_data.homepage_url}`);\r\n    }\r\n\r\n    if (pkg_data.repo_url) {\r\n        if (!printed_link_header) {\r\n            term.write(NEWLINE);\r\n            printed_link_header = true;\r\n        }\r\n\r\n        term.writeln(`${STYLE.bold}Repository:${STYLE.no_bold_or_dim} ${pkg_data.repo_url}`);\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n\r\n    term.writeln(`${STYLE.dim}Press 'i' to install the latest version of this package.${STYLE.reset_all}`);\r\n    term.writeln(`${STYLE.dim}Press any other key to return to the list...${STYLE.reset_all}`);\r\n\r\n    const key = await term.wait_for_keypress();\r\n\r\n    if (key.domEvent.key === \"i\") {\r\n        // double check installation\r\n        term.write(NEWLINE);\r\n        term.write(`${STYLE.bold}Are you sure you want to install '${pkg_name}'? (y/N)${STYLE.no_bold_or_dim}`);\r\n\r\n        const confirm_key = await term.wait_for_keypress();\r\n\r\n        if (confirm_key.domEvent.key.toLowerCase() === \"y\") {\r\n            term.write(\" yes\");\r\n            term.write(NEWLINE);\r\n\r\n            await kernel.spawn(\"pkg\", [\"add\", pkg_name], shell).completion;\r\n\r\n            term.write(NEWLINE);\r\n            term.writeln(`${STYLE.dim}Press any key to return to the list...${STYLE.reset_all}`);\r\n            await term.wait_for_keypress();\r\n        } else {\r\n            term.write(\" no\");\r\n            term.writeln(NEWLINE);\r\n\r\n            term.writeln(`${STYLE.dim}Installation cancelled. Press any key to return to the list...${STYLE.reset_all}`);\r\n            await term.wait_for_keypress();\r\n        }\r\n    }\r\n}\r\n\r\n// TODO: accept name argument to jump to specific package\r\n\r\nexport const browse_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel, shell } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    const provided = await repo_query.get_provided_list();\r\n\r\n    let offset = 0;\r\n    let selected_index = 0;\r\n    const draw = () => {\r\n        term.clear();\r\n\r\n        term.write(NEWLINE);\r\n        term.writeln(\"(use up/down arrow keys to scroll, enter to show more info, escape to quit)\");\r\n        term.write(NEWLINE);\r\n        term.write(CURSOR.invisible);\r\n\r\n        // show ... if there are more items above\r\n        if (offset > 0) {\r\n            term.writeln(`  ${STYLE.dim}...${STYLE.reset_all}`);\r\n        } else {\r\n            term.write(NEWLINE);\r\n        }\r\n\r\n        const slice = provided.slice(offset, offset + ROWS);\r\n        for (const [index, name] of slice.entries()) {\r\n            // check for installed version\r\n            const installed_version = graph_query.get_pkg_version(name);\r\n\r\n            // highlight selected item\r\n            if (offset + index === selected_index) {\r\n                term.write(`${FG.cyan}${STYLE.dim}> ${STYLE.no_bold_or_dim}${STYLE.bold}`);\r\n            } else {\r\n                term.write(\"  \");\r\n            }\r\n\r\n            term.writeln(`${name} ${installed_version ? `${STYLE.italic}(installed: ${installed_version})` : \"\"}${STYLE.reset_all}`);\r\n        }\r\n\r\n        // show ... if there are more items below\r\n        if (offset + ROWS < provided.length) {\r\n            term.writeln(`  ${STYLE.dim}...${STYLE.reset_all}`);\r\n        } else {\r\n            term.write(NEWLINE);\r\n        }\r\n    }\r\n\r\n    // TODO: type to filter\r\n\r\n    let quit = false;\r\n    while (!quit) {\r\n        draw();\r\n\r\n        const key = await term.wait_for_keypress();\r\n        console.log(key);\r\n        switch (key.domEvent.key) {\r\n            case \"Escape\":\r\n                quit = true;\r\n                break;\r\n            case \"ArrowUp\":\r\n                if (selected_index > 0) {\r\n                    selected_index--;\r\n                    if (selected_index < offset) {\r\n                        offset--;\r\n                    }\r\n                }\r\n                break;\r\n            case \"ArrowDown\":\r\n                if (selected_index < provided.length - 1) {\r\n                    selected_index++;\r\n                    if (selected_index >= offset + ROWS) {\r\n                        offset++;\r\n                    }\r\n                }\r\n                break;\r\n            case \"Enter\": {\r\n                const pkg_name = provided[selected_index];\r\n                await view_pkg_info(pkg_name, term, kernel, shell);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    term.clear();\r\n    term.write(CURSOR.visible);\r\n    return 0;\r\n}\r\n","import {add_subcommand} from \"./add\";\r\nimport {remove_subcommand} from \"./remove\";\r\n\r\nimport {ANSI, type WrappedTerminal} from \"../../term_ctl\";\r\nimport type {Program} from \"../../types\";\r\nimport type {UserspaceFileSystem} from \"../../filesystem\";\r\nimport {list_subcommand} from \"./list\";\r\nimport {info_subcommand} from \"./info\";\r\nimport {browse_subcommand} from \"./browse\";\r\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\r\n\r\nimport type {UserspaceKernel, SpawnResult} from \"../../kernel\";\r\nimport type {AbstractShell} from \"../../abstract_shell\";\r\n\r\n\r\nconst REPO_URL = \"https://ollieg.codes/pkg_repo\";\r\nconst repo_url_obj = new URL(REPO_URL);\r\n// TODO: in future, this can be changed. it will also be a list of repos in priority order, and the first one that has the package will be used.\r\n\r\nconst GRAPH_DIR = \"/var/lib/pkg\";\r\nconst GRAPH_PATH = GRAPH_DIR + \"/graph.json\";\r\n\r\nconst BIN_DIR = \"/usr/bin\";\r\n\r\nconst TRIGGER_DIR = \"/var/lib/pkg/triggers\";\r\n\r\n// TODO: subcommand template / helper\r\n\r\nconst append_url_pathnames = (url: URL, pathnames: string[]) => {\r\n    const new_url = new URL(url.toString());\r\n    let urlpath = new_url.pathname;\r\n\r\n    // drop trailing /\r\n    if (urlpath.endsWith(\"/\")) {\r\n        urlpath = urlpath.slice(0, urlpath.length - 1);\r\n    }\r\n\r\n    for (const path of pathnames) {\r\n        if (path.includes(\"/\") || path.includes(\"\\\\\") || path.includes(\"..\")) {\r\n            throw new Error(\"Unsafe pathname: \" + path);\r\n        }\r\n\r\n        urlpath += (path === \"\" ? \"\" : \"/\" + path);\r\n    }\r\n\r\n    new_url.pathname = urlpath;\r\n    return new_url;\r\n    // TODO: safe?\r\n}\r\n\r\nexport type PkgAtVersion = `${string}@${string}`;\r\n// TODO: honestly handling of pakcage version sucks rn, need to test if even having deps = \"pkg@version\" works properly\r\n\r\ninterface PackageMeta {\r\n    files: string[];\r\n    version: string;\r\n    deps: Set<PkgAtVersion>;\r\n    triggers: { [trigger_name: string]: unknown };\r\n    build_timestamp: number;\r\n    externals: \"global\" | undefined;\r\n}\r\n\r\nexport const repo_query = {\r\n    // GETs a file path relative to the repo root\r\n    // TODO: why did i write this and not use it?? all other fetches are just this but returning null for a 404?? am i stupid?? it's being exported so maybe i had a reason\r\n    api_call: async (filepath: string) => {\r\n        const url = new URL(filepath, repo_url_obj);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n        return await response.text();\r\n    },\r\n\r\n    // returns null if not found, otherwise returns the contents of the file\r\n    get_pkg_json: async (pkg: string) => {\r\n        pkg = encodeURI(pkg);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, \"pkg.json\"]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        return await response.json();\r\n    },\r\n\r\n    // returns null if not found, otherwise returns the meta.json file as an object\r\n    get_pkg_meta: async (pkg: string, version: string): Promise<PackageMeta> => {\r\n        pkg = encodeURI(pkg);\r\n        version = encodeURI(version);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n        version = version.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/version/\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, version, \"meta.json\"]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        // TODO: validate meta\r\n\r\n        const data = await response.json();\r\n\r\n        // convert deps to set\r\n        data.deps = new Set(data.deps);\r\n\r\n        return data;\r\n    },\r\n\r\n    // gets a file within a package or returns null if not found\r\n    get_pkg_file: async (pkg: string, version: string, filepath: string) => {\r\n        pkg = encodeURI(pkg);\r\n        version = encodeURI(version);\r\n        filepath = encodeURI(filepath);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n        version = version.replace(/\\./g, \"%2E\");\r\n        filepath = filepath.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/version/filepath\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, version, filepath]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        return await response.text();\r\n    },\r\n\r\n    get_provided_list: async () => {\r\n        // repo/provided.txt\r\n        const url = append_url_pathnames(repo_url_obj, [\"provided.txt\"]);\r\n\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        // newline separated list of provided package names\r\n        const data = await response.text();\r\n        return data.split(\"\\n\").map((line) => line.trim()).filter((line) => line.length > 0);\r\n    },\r\n\r\n    get_pkg_versions: async (pkg: string) => {\r\n        pkg = encodeURI(pkg);\r\n        pkg = pkg.replace(/\\./g, \"%2E\");\r\n\r\n        // repo/pkgs/pkg/versions.txt\r\n        const url = append_url_pathnames(repo_url_obj, [\"pkgs\", pkg, \"versions.txt\"]);\r\n        const response = await fetch(url.toString());\r\n        if (!response.ok) {\r\n            if (response.status === 404) {\r\n                return null;\r\n            }\r\n\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n\r\n        // newline separated list of versions\r\n        const data = await response.text();\r\n        return data.split(\"\\n\").map((line) => line.trim()).filter((line) => line.length > 0);\r\n    }\r\n}\r\n\r\ninterface PkgGraphEntry {\r\n    version: string;\r\n    deps: Set<PkgAtVersion | string>;\r\n    dependents: Set<string>;\r\n    top_level: boolean; // as in, specified by the user at install time\r\n}\r\n\r\nexport const json_convert_dep_sets_to_arrs = (key: string, value: any) => {\r\n    if (key !== \"deps\" && key !== \"dependents\") {\r\n        return value;\r\n    }\r\n\r\n    if (value instanceof Set) {\r\n        return Array.from(value);\r\n    }\r\n\r\n    throw new Error(`${key} not a set in graph to be stringified!`);\r\n}\r\n\r\nexport const json_convert_dep_arrs_to_sets = (key: string, value: any) => {\r\n    if (key !== \"deps\" && key !== \"dependents\") {\r\n        return value;\r\n    }\r\n\r\n    if (Array.isArray(value)) {\r\n        return new Set(value);\r\n    }\r\n\r\n    throw new Error(`${key} not an array in graph to be parsed!`);\r\n}\r\n\r\nlet graph: { [pkg_name: string]: PkgGraphEntry } = {};\r\nexport const graph_query = {\r\n    // TODO: graph consistency checks / repair function\r\n    // TODO: dangling dep check\r\n\r\n    // gets the graph entry for a package\r\n    get_pkg_info: (pkg: string): PkgGraphEntry => {\r\n        return graph[pkg];\r\n    },\r\n\r\n    // lists names of all installed packages, optionally only top level\r\n    list_pkgs: (only_top_level = false) => {\r\n        const pkgs = Object.keys(graph);\r\n\r\n        if (only_top_level) {\r\n            return pkgs.filter((pkg) => graph[pkg].top_level);\r\n        }\r\n\r\n        return pkgs;\r\n    },\r\n\r\n    // checks if a package is installed, optionally with a specific version\r\n    pkg_is_installed: (pkg: string, version?: string) => {\r\n        if (!graph[pkg]) {\r\n            return false;\r\n        }\r\n\r\n        if (version) {\r\n            return graph[pkg].version === version;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    // gets the version of an installed package, or undefined if not installed\r\n    get_pkg_version: (pkg: string): string | undefined => {\r\n        return graph[pkg]?.version;\r\n    },\r\n\r\n    // gets the dependents of a package, or undefined if not installed\r\n    get_pkg_dependents: (pkg: string): Set<string> | undefined => {\r\n        return graph[pkg]?.dependents;\r\n    },\r\n\r\n    // gets the dependencies of a package, or undefined if not installed\r\n    get_pkg_dependencies: (pkg: string): Set<PkgAtVersion | string> | undefined => {\r\n        return graph[pkg]?.deps;\r\n    },\r\n\r\n    // installs a NEW package. if this is not a top level package, you must specify an initial dependent. you cannot modify an existing package unless you use the defined functions.\r\n    install_new_pkg: async (fs: UserspaceFileSystem, pkg: string, version: string, deps: Set<PkgAtVersion>, top_level: boolean, dependended_by?: string) => {\r\n        // TODO: resolve what to do if the package is already installed rather than exploding, makes using it a lot simpler\r\n\r\n        if (graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is already installed and cannot be modified.`);\r\n        }\r\n\r\n        // TODO: we could assume top level based on if dependended_by is provided, but that's not very precise. top level packages may be dependencies!\r\n        if (!top_level && !dependended_by) {\r\n            throw new Error(`Package ${pkg} is not installed as a top-level package but does not have a dependent it was installed by.`);\r\n        }\r\n\r\n        const dependents = new Set<string>();\r\n\r\n        if (dependended_by) {\r\n            dependents.add(dependended_by);\r\n        }\r\n\r\n        graph[pkg] = {\r\n            version,\r\n            deps,\r\n            top_level,\r\n            dependents\r\n        };\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // makes a package a top level package, no checks are performed as top level packages may have dependents\r\n    promote_pkg_to_top_level: async (fs: UserspaceFileSystem, pkg: string) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        graph[pkg].top_level = true;\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // makes a package not a top level package, but only if it has no dependents. use add_pkg_dependent FIRST before demoting if it has dependents now.\r\n    demote_pkg_from_top_level: async (fs: UserspaceFileSystem, pkg: string) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        if (graph[pkg].dependents.size > 0) {\r\n            throw new Error(`Package ${pkg} has no dependents and cannot be demoted. Use add_pkg_dependent FIRST.`);\r\n        }\r\n\r\n        graph[pkg].top_level = false;\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // adds a dependent to a package, provided the dependent is already installed. also adds the dependency to the dependent package.\r\n    add_pkg_dependent: async (fs: UserspaceFileSystem, pkg: string, dependent_pkg: string, add_to_deps = false) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        if (!graph[dependent_pkg]) {\r\n            throw new Error(`Dependent ${dependent_pkg} is not installed.`);\r\n        }\r\n\r\n        const pkg_at_version = `${pkg}@${graph[pkg].version}` as PkgAtVersion;\r\n\r\n        graph[pkg].dependents.add(dependent_pkg);\r\n\r\n        if (add_to_deps) {\r\n            graph[dependent_pkg].deps.add(pkg_at_version);\r\n        }\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // removes a dependent from a package, as well as clearing the dependency from the dependent package\r\n    remove_pkg_dependent: async (fs: UserspaceFileSystem, pkg: string, dependent_pkg: string, remove_from_deps = false) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        if (!graph[dependent_pkg]) {\r\n            throw new Error(`Dependent ${dependent_pkg} is not installed.`);\r\n        }\r\n\r\n        if (!graph[pkg].dependents.has(dependent_pkg)) {\r\n            throw new Error(`Package ${pkg} does not have dependent ${dependent_pkg}.`);\r\n        }\r\n\r\n        const pkg_at_version = `${pkg}@${graph[pkg].version}` as PkgAtVersion;\r\n\r\n        if (!graph[dependent_pkg].deps.has(pkg) && !graph[dependent_pkg].deps.has(pkg_at_version)) {\r\n            throw new Error(`Inconsistent graph! Dependent ${dependent_pkg} does not have dependency ${pkg}, but ${pkg} has dependent ${dependent_pkg}.`);\r\n        }\r\n\r\n        graph[pkg].dependents.delete(dependent_pkg);\r\n\r\n        if (remove_from_deps) {\r\n            graph[dependent_pkg].deps.delete(pkg_at_version);\r\n        }\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n\r\n        // uninstall if it has no dependents now? probably not, we can have a separate command for that\r\n    },\r\n\r\n    // removes a package from the graph, provided it has no dependents. you can skip this check, but this will leave dangling dependencies.\r\n    remove_pkg: async (fs: UserspaceFileSystem, pkg: string, skip_dep_check = false) => {\r\n        if (!graph[pkg]) {\r\n            throw new Error(`Package ${pkg} is not installed.`);\r\n        }\r\n\r\n        // check if this package has any dependents\r\n        if (!skip_dep_check && graph[pkg].dependents.size > 0) {\r\n            throw new Error(`Package ${pkg} has dependents and cannot be removed.`);\r\n        }\r\n\r\n        // // remove this package from its dependents' dependencies\r\n        // no! don't do this! if they skip the dep check, we don't want to destroy the fact that there are hanging deps\r\n        // for (const dependent of graph[pkg].dependents) {\r\n        //     const dependent_name = dependent.split(\"@\")[0];\r\n        //     graph[dependent_name].deps = graph[dependent_name].deps.filter((dep) => dep !== pkg);\r\n        // }\r\n\r\n        // remove this package from its dependencies' dependents\r\n        for (const dep of graph[pkg].deps) {\r\n            const dep_name = dep.split(\"@\")[0];\r\n            graph[dep_name].dependents.delete(`${pkg}@${graph[pkg].version}` as PkgAtVersion);\r\n        }\r\n\r\n        // TODO: feels like something is missing? oh well, we'll find out when we test it\r\n\r\n        // remove this package from the graph\r\n        delete graph[pkg];\r\n\r\n        // write to file\r\n        await fs.write_file(GRAPH_PATH, JSON.stringify(graph, json_convert_dep_sets_to_arrs));\r\n    },\r\n\r\n    // lists all packages that are not installed as top level and have no dependents\r\n    list_unused_pkgs: () => {\r\n        return Object.keys(graph).filter((pkg) => !graph[pkg].top_level && graph[pkg].dependents.size === 0);\r\n    },\r\n\r\n    get_file_path_in_pkg_bin: (fs: UserspaceFileSystem, pkg: string, filepath: string) => {\r\n        const pkg_dir = fs.join(BIN_DIR, pkg);\r\n        return fs.join(pkg_dir, filepath);\r\n    }\r\n}\r\n\r\ninterface TriggerFile {\r\n    install_exec?: string;\r\n    uninstall_exec?: string;\r\n}\r\n\r\nexport const triggers = {\r\n    load_trigger_file: async (fs: UserspaceFileSystem, trigger_name: string): Promise<TriggerFile | null> => {\r\n        const trigger_path = fs.join(TRIGGER_DIR, trigger_name + \".json\");\r\n        if (!(await fs.exists(trigger_path))) {\r\n            return null;\r\n        }\r\n\r\n        const data = await fs.read_file(trigger_path) as string;\r\n\r\n        try {\r\n            return JSON.parse(data) as TriggerFile;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    trigger_exists: async (fs: UserspaceFileSystem, trigger_name: string): Promise<boolean> => {\r\n        return (await triggers.load_trigger_file(fs, trigger_name)) !== null;\r\n    },\r\n\r\n    // returns boolean indicating if the trigger was found and processed\r\n    process_install_trigger: async (trigger_name: string, data: unknown, pkg_name: string, pkg_version: string, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\r\n        const fs = kernel.get_fs();\r\n\r\n        const trigger = await triggers.load_trigger_file(fs, trigger_name);\r\n        if (!trigger) {\r\n            return false;\r\n        }\r\n\r\n        if (!trigger.install_exec) {\r\n            // nothing to do\r\n            return true;\r\n        }\r\n\r\n        const data_str = JSON.stringify(data);\r\n\r\n        console.log(`Processing install trigger ${trigger_name} with exec ${trigger.install_exec} and args [${pkg_name}, ${pkg_version}, ${data_str}]`);\r\n\r\n        let spawn_result: SpawnResult;\r\n\r\n        try {\r\n            spawn_result =  kernel.spawn(trigger.install_exec, [pkg_name, pkg_version, data_str], shell);\r\n            const exit_code = await spawn_result.completion;\r\n            if (exit_code !== 0) {\r\n                term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} exited with code ${exit_code}.${ANSI.STYLE.reset_all}`);\r\n            }\r\n\r\n            spawn_result.process.kill(exit_code);\r\n        } catch (e) {\r\n            term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} failed: ${e}.${ANSI.STYLE.reset_all}`);\r\n\r\n            if (spawn_result) {\r\n                spawn_result.process.kill(-1);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    // returns boolean indicating if the trigger was found and processed\r\n    process_uninstall_trigger: async (trigger_name: string, data: unknown, pkg_name: string, pkg_version: string, term: WrappedTerminal, kernel: UserspaceKernel, shell?: AbstractShell) => {\r\n        const fs = kernel.get_fs();\r\n\r\n        const trigger = await triggers.load_trigger_file(fs, trigger_name);\r\n        if (!trigger) {\r\n            return false;\r\n        }\r\n\r\n        if (!trigger.uninstall_exec) {\r\n            // nothing to do\r\n            return true;\r\n        }\r\n\r\n        const data_str = JSON.stringify(data);\r\n\r\n        console.log(`Processing uninstall trigger ${trigger_name} with exec ${trigger.uninstall_exec} and args [${pkg_name}, ${pkg_version}, ${data_str}]`);\r\n\r\n        let spawn_result: SpawnResult;\r\n\r\n        try {\r\n            spawn_result =  kernel.spawn(trigger.uninstall_exec, [pkg_name, pkg_version, data_str], shell);\r\n            const exit_code = await spawn_result.completion;\r\n            if (exit_code !== 0) {\r\n                term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} exited with code ${exit_code}.${ANSI.STYLE.reset_all}`);\r\n            }\r\n\r\n            spawn_result.process.kill(exit_code)\r\n        } catch (e) {\r\n            term.writeln(`${ANSI.PREFABS.error}Warning: trigger ${trigger_name} failed: ${e}.${ANSI.STYLE.reset_all}`);\r\n\r\n            if (spawn_result) {\r\n                spawn_result.process.kill(-1);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS} = ANSI;\r\n\r\n// TODO: update command (update all installed or specific packages)\r\n\r\nexport default {\r\n    name: \"pkg\",\r\n    description: \"The package manager for OllieOS.\",\r\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\r\n    arg_descriptions: {\r\n        \"Subcommands:\": {\r\n            \"add\": `Installs a list of packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} add <packages...>${STYLE.reset_all}`,\r\n            \"remove\": `Uninstalls a list of packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} remove <packages...>${STYLE.reset_all}`,\r\n            \"list\": `Lists all installed packages: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} list [-t]${STYLE.reset_all}`,\r\n            \"info\": `Displays information about a package: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} info [-r] <package>${STYLE.reset_all}`,\r\n            \"read\": `Reads the long description for a package if it has one: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} read [-r] <package>${STYLE.reset_all}`,\r\n            \"browse\": `Browse the repository for packages and versions: ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} browse${STYLE.reset_all}`,\r\n            \"clean\": `Removes all packages that are not top level and have no dependents (and are therefore unused): ${PREFABS.program_name}pkg${STYLE.reset_all + STYLE.italic} clean [-d]${STYLE.reset_all}`,\r\n        },\r\n        \"Arguments:\": {\r\n            \"-h\": \"Displays this help message.\",\r\n            \"For add:\": {\r\n                \"packages\": \"The packages to install, separated by spaces. If you wish to install a specific version, use the format 'package@version'.\",\r\n            },\r\n            \"For remove:\": {\r\n                \"packages\": \"The packages to uninstall, separated by spaces.\",\r\n            },\r\n            \"For list:\": {\r\n                \"-t\": \"List only top-level packages.\",\r\n            },\r\n            \"For info:\": {\r\n                \"-r\": \"Always fetch the latest information from the repository.\",\r\n                \"package\": \"The package to get information about.\",\r\n            },\r\n            \"For read:\": {\r\n                \"-r\": \"Always fetch the latest information from the repository.\",\r\n                \"package\": \"The package to read the long description of.\",\r\n            },\r\n            \"For clean:\": {\r\n                \"-d\": \"Dry run. Lists the packages that would be removed without actually removing them.\",\r\n            }\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // TODO: smarter completion that understands flags for subcommands\r\n        switch (data.arg_index) {\r\n            case 0:\r\n                return helper_completion_options([\"add\", \"remove\", \"list\", \"info\", \"read\", \"browse\", \"clean\"])(data);\r\n            case 1:\r\n                if ([\"info\", \"read\", \"remove\"].includes(data.args[0])) {\r\n                    // complete with installed package names\r\n                    const fs = data.kernel.get_fs();\r\n\r\n                    // load graph\r\n                    let local_graph: { [pkg_name: string]: PkgGraphEntry } = {};\r\n                    try {\r\n                        local_graph = JSON.parse(await fs.read_file(\"/var/lib/pkg/graph.json\") as string, json_convert_dep_arrs_to_sets);\r\n                    } catch (e) {\r\n                        return [];\r\n                    }\r\n\r\n                    const pkgs = Object.keys(local_graph);\r\n                    return helper_completion_options(pkgs)(data);\r\n                }\r\n                break;\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // TODO: safety prompt on first use\r\n\r\n        // extract from data to make code less verbose\r\n        const {args, term, kernel, shell} = data;\r\n        const fs = kernel.get_fs();\r\n\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\r\n            term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"pkg\"], shell).completion;\r\n        }\r\n\r\n        // create /var/lib/pkg if it doesn't exist so subcommands don't have to check\r\n        if (!(await fs.exists(GRAPH_DIR))) {\r\n            await fs.make_dir(GRAPH_DIR);\r\n        }\r\n\r\n        // create /var/lib/pkg/graph.json if it doesn't exist\r\n        if (!(await fs.exists(GRAPH_PATH))) {\r\n            await fs.write_file(GRAPH_PATH, \"{}\");\r\n        }\r\n\r\n        // create /var/lib/pkg/triggers if it doesn't exist\r\n        if (!(await fs.exists(TRIGGER_DIR))) {\r\n            await fs.make_dir(TRIGGER_DIR);\r\n        }\r\n\r\n        // write /var/lib/pkg/triggers/create_trigger.json if it doesn't exist\r\n        const create_trigger_path = fs.join(TRIGGER_DIR, \"create_trigger.json\");\r\n        if (!(await fs.exists(create_trigger_path))) {\r\n            const create_trigger_data: TriggerFile = {\r\n                install_exec: \"trigger_create_trigger\",\r\n                uninstall_exec: \"trigger_remove_trigger\"\r\n            };\r\n\r\n            await fs.write_file(create_trigger_path, JSON.stringify(create_trigger_data));\r\n        }\r\n\r\n        // load graph\r\n        try {\r\n            graph = JSON.parse(await fs.read_file(\"/var/lib/pkg/graph.json\") as string, json_convert_dep_arrs_to_sets);\r\n        } catch (e) {\r\n            term.writeln(`${PREFABS.error}Fatal error: could not load package graph.${STYLE.reset_all}`);\r\n            return 2;\r\n        }\r\n\r\n        switch (args[0]) {\r\n            case \"add\":\r\n                return await add_subcommand(data);\r\n            case \"remove\":\r\n                return await remove_subcommand(data);\r\n            case \"list\":\r\n                return await list_subcommand(data);\r\n            case \"info\":\r\n                return await info_subcommand(data);\r\n            case \"read\":\r\n                term.writeln(`${PREFABS.error}Not implemented yet.${STYLE.reset_all}`);\r\n                break;\r\n            case \"browse\":\r\n                return await browse_subcommand(data);\r\n            case \"clean\":\r\n                term.writeln(`${PREFABS.error}Not implemented yet.${STYLE.reset_all}`);\r\n                break;\r\n            default:\r\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\r\n                term.writeln(`Try 'pkg -h' for more information.${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type {Program} from \"../types\";\r\nimport {ANSI} from \"../term_ctl\";\r\n\r\n// yes, the actual touch command is used to modify access time and has more flags, but this os doesn't have access times and this is meant to be simple\r\n\r\nexport default {\r\n    name: \"touch\",\r\n    description: \"Creates a file.\",\r\n    usage_suffix: \"file\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"file\": \"The file to create.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const {kernel, args, term} = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const {STYLE, PREFABS} = ANSI;\r\n\r\n        // get filesystem\r\n        const fs = kernel.get_fs();\r\n\r\n        // if no arguments, print error\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing file operand.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // if more than one argument, print error\r\n        // TODO: i think this is the only program that checks this, the others drop the extra arguments. do something about this!\r\n        if (args.length > 1) {\r\n            term.writeln(`${PREFABS.error}Too many arguments${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // if the file already exists, do nothing\r\n        const file = args[0];\r\n        const absolute_file = fs.absolute(file);\r\n\r\n        if (await fs.exists(absolute_file)) {\r\n            return 0;\r\n        }\r\n\r\n        // check if the directory exists\r\n        // TODO: should abstractfilesystem have basename and dirname functions? check other programs for similar code!\r\n        const dir = absolute_file.split(\"/\").slice(0, -1).join(\"/\");\r\n        if (!(await fs.dir_exists(dir))) {\r\n            term.writeln(`${PREFABS.error}No such directory: ${dir}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // create the file\r\n        await fs.write_file(absolute_file, \"\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport {ANSI} from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"mkdir\",\r\n    description: \"Creates a directory.\",\r\n    usage_suffix: \"[-p] directory\",\r\n    arg_descriptions: {\r\n        \"Flags:\": {\r\n            \"-p\": \"Create parent directories (recursive) if they don't exist.\"\r\n        },\r\n        \"Arguments:\": {\r\n            \"directory\": \"The directory to create.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n\r\n        // check if -p flag was passed\r\n        let recursive = false;\r\n        if (args[0] === \"-p\") {\r\n            recursive = true;\r\n            args.shift();\r\n        }\r\n\r\n        // check if there is only one argument after parsing flag\r\n        if (args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}Invalid arguments.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // get directory\r\n        const dir = args[0];\r\n        const abs_dir = fs.absolute(dir);\r\n\r\n        // check if directory already exists\r\n        if (await fs.dir_exists(abs_dir)) {\r\n            return 0;\r\n        }\r\n\r\n        // create directory\r\n        // make_dir is recursive by default, so just check the directories exist already if NOT recursive\r\n        if (recursive) {\r\n            await fs.make_dir(abs_dir);\r\n        } else {\r\n            // check if the directory exists\r\n            const parent = abs_dir.split(\"/\").slice(0, -1).join(\"/\");\r\n            if (!(await fs.dir_exists(parent))) {\r\n                term.writeln(`${PREFABS.error}No such directory: ${parent}${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            await fs.make_dir(abs_dir);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import type { Program } from \"../types\";\r\nimport { ANSI } from \"../term_ctl\";\r\n\r\nexport default {\r\n    name: \"mv\",\r\n    description: \"Moves files and directories.\",\r\n    usage_suffix: \"[-n] source destination\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"source\": \"The file or directory to move.\",\r\n            \"destination\": \"The new location for the file or directory.\",\r\n            \"-n\": \"Do not overwrite an existing file.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { PREFABS, STYLE, FG } = ANSI;\r\n\r\n        // get fs\r\n        const fs = kernel.get_fs();\r\n\r\n        // check for -n\r\n        let no_overwrite = false;\r\n        //if (args.includes(\"-n\")) {\r\n            // TODO: why do programs care about flag order? should they?\r\n            //// remove -n from args\r\n            //args.splice(args.indexOf(\"-n\"), 1);\r\n        if (args[0] === \"-n\") {\r\n            no_overwrite = true;\r\n            args.shift();\r\n        }\r\n\r\n        // get source and destination\r\n        const source = fs.absolute(args[0]);\r\n        let destination = fs.absolute(args[1]);\r\n\r\n        // check if source exists\r\n        if (!(await fs.exists(source))) {\r\n            term.writeln(`${PREFABS.error}No such file or directory: ${source}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        const ended_with_slash = destination.endsWith(\"/\");\r\n        const dest_is_dir = await fs.dir_exists(destination);\r\n\r\n        // if destination is a directory and ending with a slash, append the basename of source to destination\r\n        if (dest_is_dir && ended_with_slash) {\r\n            const basename = source.split(\"/\").pop() as string;\r\n            destination = fs.join(destination, basename);\r\n        }\r\n\r\n        // check if destination exists if -n is passed OR we are moving a FILE (not a directory) into a DIRECTORY ending specifically with /\r\n        // TODO: there must be a way to adjust logic of the fs functions to make this check unnecessary or simpler. oh well.\r\n        const do_exists_check = no_overwrite || (dest_is_dir && !(await fs.dir_exists(source)) && ended_with_slash);\r\n        if (do_exists_check && await fs.exists(destination)) {\r\n            term.writeln(`${PREFABS.error}File or directory already exists: ${destination}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // move source to destination\r\n        // TODO: abstractfilesystem should have a file_exists function so we don't have to check if it's a directory first\r\n        if (await fs.dir_exists(source)) {\r\n            // temporary warning\r\n            term.writeln(`${FG.yellow + STYLE.bold}Warning: Moving directories is not fully supported yet. Some features may not work as expected! The operation will be performed anyway.${STYLE.reset_all}`);\r\n\r\n            // move inside if ended with slash OR the destination is a directory that already exists\r\n            // TODO: is this correct???? maybe???\r\n            const move_inside = ended_with_slash || (dest_is_dir && await fs.dir_exists(destination));\r\n            await fs.move_dir(source, destination, no_overwrite, move_inside);\r\n        } else if (await fs.exists(source)) {\r\n            await fs.move_file(source, destination);\r\n        } else {\r\n            term.writeln(`${PREFABS.error}Source is neither a file nor a directory: ${source}${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG } = ANSI;\r\nexport const info_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    term.write(NEWLINE);\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const all_windows = wm!.get_all_windows();\r\n    const visible_windows = all_windows.filter(w => w.visible).length;\r\n\r\n    term.writeln(`Window manager: ${FG.cyan}${wm!.get_unique_manager_type_name()}${STYLE.reset_all}`);\r\n    term.writeln(`Total open windows: ${FG.cyan}${all_windows.length}${STYLE.reset_all}`);\r\n    term.writeln(`Visible windows: ${FG.cyan}${visible_windows}${STYLE.reset_all}`);\r\n    term.writeln(`Invisible windows: ${FG.cyan}${all_windows.length - visible_windows}${STYLE.reset_all}`);\r\n\r\n    return 0;\r\n}\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG } = ANSI;\r\nexport const list_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // check for presence of -v or -i flag\r\n    let only_visible = false;\r\n    let only_invisible = false;\r\n    if (args[0] === \"-v\") {\r\n        only_visible = true;\r\n        args.shift();\r\n    } else if (args[0] === \"-i\") {\r\n        only_invisible = true;\r\n        args.shift();\r\n    }\r\n\r\n    term.write(NEWLINE);\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const all_windows = wm!.get_all_windows();\r\n    for (const win of all_windows) {\r\n        if (only_visible && !win.visible) {\r\n            continue;\r\n        }\r\n\r\n        if (only_invisible && win.visible) {\r\n            continue;\r\n        }\r\n\r\n        // TODO: source process tracking to show which program opened the window\r\n        const visibility_text = win.visible ? `${FG.green}Visible${STYLE.reset_all}` : `${FG.red}Invisible${STYLE.reset_all}`;\r\n        term.writeln(`- [${win.id}] ${FG.cyan}${win.title}${STYLE.reset_all} : ${visibility_text} owned by PID ${FG.yellow}${win.owner_pid}${STYLE.reset_all}`);\r\n    }\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const show_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel: userspace_kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to show\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // check window exists first with userspace kernel\r\n    const userspace_wm = userspace_kernel.get_window_manager();\r\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\r\n    if (!userspace_window) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // request elevation\r\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to show a window.\");\r\n    if (!kernel) {\r\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    // check again for safety\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    if (wind.visible) {\r\n        term.writeln(`Window with ID ${FG.cyan}${window_id}${STYLE.reset_all} is already visible.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    term.writeln(`Showing window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\r\n    wind.show();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const hide_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel: userspace_kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to hide\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // check window exists first with userspace kernel\r\n    const userspace_wm = userspace_kernel.get_window_manager();\r\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\r\n    if (!userspace_window) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // request elevation\r\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to hide a window.\");\r\n    if (!kernel) {\r\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    // check again for safety\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    if (!wind.visible) {\r\n        term.writeln(`Window with ID ${FG.cyan}${window_id}${STYLE.reset_all} is already hidden.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    term.writeln(`Hiding window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\r\n    wind.hide();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const close_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel: userspace_kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to close\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // check window exists first with userspace kernel\r\n    const userspace_wm = userspace_kernel.get_window_manager();\r\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\r\n    if (!userspace_window) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // request elevation\r\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to close a window.\");\r\n    if (!kernel) {\r\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    // check again for safety\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`Closing window with ID ${FG.cyan}${window_id}${STYLE.reset_all}. The process that opened this window may still be running.`);\r\n    wind.close();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport { ProgramMainData } from \"../../types\"\r\nimport {Kernel} from \"../../kernel\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst { STYLE, FG, PREFABS } = ANSI;\r\nexport const center_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const { args, term, kernel: userspace_kernel } = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // get the window id to center\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing window ID.`)\r\n        term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const window_id = parseInt(args[0], 10);\r\n    if (isNaN(window_id)) {\r\n        term.writeln(`${PREFABS.error}Invalid window ID '${args[0]}'. Window ID must be an integer.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // check window exists first with userspace kernel\r\n    const userspace_wm = userspace_kernel.get_window_manager();\r\n    const userspace_window = userspace_wm!.get_window_by_id(window_id);\r\n    if (!userspace_window) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // request elevation\r\n    const kernel = await userspace_kernel.request_privilege(\"Access the window manager to center a window.\");\r\n    if (!kernel) {\r\n        term.writeln(`${PREFABS.error}Permission denied to access the window manager.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const wm = kernel.get_window_manager();\r\n    const wind = wm!.get_window_by_id(window_id);\r\n\r\n    // check again for safety\r\n    if (!wind) {\r\n        term.writeln(`${PREFABS.error}No window found with ID '${window_id}'.`)\r\n        term.writeln(`Try 'window list' to see all open windows.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    term.writeln(`Centering window with ID ${FG.cyan}${window_id}${STYLE.reset_all}.`);\r\n    wind.center();\r\n\r\n    return 0;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport type {Program} from \"../../types\";\r\n\r\nimport {info_subcommand} from \"./info\";\r\nimport {list_subcommand} from \"./list\";\r\nimport {show_subcommand} from \"./show\";\r\nimport {hide_subcommand} from \"./hide\";\r\nimport {close_subcommand} from \"./close\";\r\nimport {center_subcommand} from \"./center\";\r\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS} = ANSI;\r\n\r\n// TODO: maximise restore command, respecting maximisable property but providing a -f force flag\r\n\r\nexport default {\r\n    name: \"window\",\r\n    description: \"Interact with program windows.\",\r\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\r\n    arg_descriptions: {\r\n        \"Subcommands:\": {\r\n            \"info\": `Displays information about the window manager and open windows: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} info${STYLE.reset_all}`,\r\n            \"list\": `Lists all open windows: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} list [-vi]${STYLE.reset_all}`,\r\n            \"show\": `Shows a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} show <window_id>${STYLE.reset_all}`,\r\n            \"hide\": `Hides a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} hide <window_id>${STYLE.reset_all}`,\r\n            \"close\": `Closes a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} close <window_id>${STYLE.reset_all}. Note that this does not terminate the process that opened the window.`,\r\n            \"center\": `Centers a window by its ID: ${PREFABS.program_name}window${STYLE.reset_all + STYLE.italic} show <window_id>${STYLE.reset_all}`,\r\n        },\r\n        \"Arguments:\": {\r\n            \"-h\": \"Displays this help message.\",\r\n            \"For list:\": {\r\n                \"-v\": \"List only visible windows.\",\r\n                \"-i\": \"List only invisible (minimised/hidden) windows.\",\r\n            },\r\n            \"For show, hide, close, and center:\": {\r\n                \"<window_id>\": \"The ID of the window.\",\r\n            }\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        switch (data.arg_index) {\r\n            case 0:\r\n                return helper_completion_options([\"info\", \"list\", \"show\", \"hide\", \"close\", \"center\"])(data);\r\n            case 1:\r\n                // completing first argument of subcommand\r\n                if (data.raw_parts[1] === \"list\") {\r\n                    return helper_completion_options([\"-v\", \"-i\"])(data);\r\n                } else if ([\"show\", \"hide\", \"close\", \"center\"].includes(data.raw_parts[1])) {\r\n                    // complete window ids\r\n                    const wm = data.kernel.get_window_manager();\r\n                    if (!wm) {\r\n                        return [];\r\n                    }\r\n\r\n                    const window_ids = wm.get_all_windows().map((win) => win.id.toString());\r\n                    return helper_completion_options(window_ids)(data);\r\n                }\r\n                return [];\r\n            default:\r\n                return [];\r\n        }\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const {args, term, kernel, shell} = data;\r\n\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\r\n            term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"window\"], shell).completion;\r\n        }\r\n\r\n        if (!kernel.has_window_manager()) {\r\n            term.writeln(`${PREFABS.error}No window manager found.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        switch (args[0]) {\r\n            case \"info\":\r\n                return await info_subcommand(data);\r\n            case \"list\":\r\n                return await list_subcommand(data);\r\n            case \"show\":\r\n                return await show_subcommand(data);\r\n            case \"hide\":\r\n                return await hide_subcommand(data);\r\n            case \"close\":\r\n                return await close_subcommand(data);\r\n            case \"center\":\r\n                return await center_subcommand(data);\r\n            default:\r\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\r\n                term.writeln(`Try 'window -h' for more information.${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n    }\r\n} as Program;\r\n","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"alias\",\r\n    description: \"Define or display aliases. (Use .ollierc to persist aliases)\",\r\n    usage_suffix: \"[name[=value] ...]\",\r\n    arg_descriptions: {\r\n        name: \"The name of the alias to define or display. If no arguments are given, all aliases are displayed. Multiple alias arguments can be provided.\",\r\n        \"name=value\": \"Defines an alias with the given name and value. End the value with a space to allow chaining.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, term } = data;\r\n\r\n        if (!shell) {\r\n            term.writeln(\"No shell available\");\r\n            return 1;\r\n        }\r\n\r\n        // TODO: move to shell builtin, not actual program\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = term.ansi;\r\n\r\n        if (data.args.length === 0) {\r\n            // display all aliases\r\n            const aliases = shell.memory.list_aliases();\r\n            for (const [name, value] of aliases.entries()) {\r\n                term.writeln(`alias ${name}='${value}'`);\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        for (const arg of data.args) {\r\n            if (arg.includes(\"=\")) {\r\n                // define alias\r\n                const [name, ...value_parts] = arg.split(\"=\");\r\n                const value = value_parts.join(\"=\");\r\n\r\n                // remove surrounding quotes if present\r\n                let final_value = value;\r\n                if ((final_value.startsWith(\"'\") && final_value.endsWith(\"'\")) ||\r\n                    (final_value.startsWith(\"\\\"\") && final_value.endsWith(\"\\\"\"))) {\r\n                    final_value = final_value.slice(1, -1);\r\n                }\r\n\r\n                shell.memory.set_alias(name, final_value);\r\n            } else {\r\n                // display alias\r\n                const value = shell.memory.get_alias(arg);\r\n                if (value) {\r\n                    term.writeln(`alias ${arg}='${value}'`);\r\n                } else {\r\n                    term.writeln(`${PREFABS.error}alias: ${arg}: not found${STYLE.reset_all}`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"unalias\",\r\n    description: \"Remove defined aliases.\",\r\n    usage_suffix: \"name [name ...]\",\r\n    arg_descriptions: {\r\n        name: \"The name of the alias to remove. Multiple alias names can be provided.\"\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (!data.shell) {\r\n            return [];\r\n        }\r\n\r\n        const alias_names = [...data.shell.memory.list_aliases().keys()];\r\n        // TODO: check type to see why helper_completion_options wont work here\r\n        return alias_names.filter(name => name.startsWith(data.current_partial));\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { shell, term } = data;\r\n\r\n        if (!shell) {\r\n            term.writeln(\"No shell available\");\r\n            return 1;\r\n        }\r\n\r\n        // TODO: move to shell builtin, not actual program\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = term.ansi;\r\n\r\n        if (data.args.length === 0) {\r\n            term.writeln(`${PREFABS.error}unalias: usage: unalias name [name ...]${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        for (const arg of data.args) {\r\n            const success = shell.memory.unset_alias(arg);\r\n            if (!success) {\r\n                term.writeln(`${PREFABS.error}unalias: ${arg}: not found${STYLE.reset_all}`);\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import {ANSI, NEWLINE} from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"ps\",\r\n    description: \"Display currently running processes.\",\r\n    usage_suffix: \"[-p PID]\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"-p PID\": \"Display information about the process with the given PID. If omitted, displays all running processes.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        console.log(data);\r\n        if (data.arg_index === 0) {\r\n            return helper_completion_options([\"-p\"])(data);\r\n        } else if (data.arg_index === 1 && data.args[0] === \"-p\") {\r\n            const pm = data.kernel.get_process_manager();\r\n            const pids = pm.list_pids().map((pid) => pid.toString());\r\n            return helper_completion_options(pids)(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        // get process manager\r\n        const pm = kernel.get_process_manager();\r\n\r\n        if (data.args[0] === \"-p\") {\r\n            const pid = parseInt(data.args[1]);\r\n            if (isNaN(pid)) {\r\n                term.writeln(`${PREFABS.error}Invalid PID provided.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            const process = pm.get_process(pid);\r\n            if (!process) {\r\n                term.writeln(`${PREFABS.error}No process found with PID ${pid}.${STYLE.reset_all}`);\r\n                return 1;\r\n            }\r\n\r\n            term.write(NEWLINE);\r\n            term.writeln(`${STYLE.bold}PID:${STYLE.no_bold_or_dim} ${process.pid}${STYLE.reset_all}`);\r\n            term.writeln(`${STYLE.bold}Command:${STYLE.no_bold_or_dim} ${process.source_command.command}${STYLE.reset_all}`);\r\n            term.writeln(`${STYLE.bold}Created:${STYLE.no_bold_or_dim} ${process.created_at.toLocaleString()}${STYLE.reset_all}`);\r\n\r\n            return 0;\r\n        }\r\n\r\n        const pids = pm.list_pids();\r\n\r\n        // get longest source command length for formatting\r\n        let longest_command_length = 7 // length of \"COMMAND\"\r\n        for (const pid of pids) {\r\n            const process = pm.get_process(pid)!;\r\n            if (process.source_command.command.length > longest_command_length) {\r\n                longest_command_length = process.source_command.command.length;\r\n            }\r\n        }\r\n\r\n        const get_command_space = (subtract = 0) => \" \".repeat(longest_command_length - subtract);\r\n\r\n        term.write(NEWLINE);\r\n        term.writeln(`${STYLE.bold}PID\\tCOMMAND${get_command_space(7)}\\t\\tCREATED${STYLE.reset_all}`);\r\n        for (const pid of pids) {\r\n            const process = pm.get_process(pid)!;\r\n            term.writeln(`${pid}\\t${process.source_command.command}${get_command_space(process.source_command.command.length)}\\t\\t${process.created_at.toLocaleString()}`);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n","import {ANSI} from \"../term_ctl\";\r\nimport type { Program } from \"../types\";\r\nimport {helper_completion_options} from \"./core/ash/tab_completion\";\r\n\r\nexport default {\r\n    name: \"kill\",\r\n    description: \"Kill a process by its PID.\",\r\n    usage_suffix: \"PID\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"PID\": \"The PID of the process to kill.\"\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        if (data.arg_index === 0) {\r\n            const pm = data.kernel.get_process_manager();\r\n            const pids = pm.list_pids().map((pid) => pid.toString());\r\n            return helper_completion_options(pids)(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        // extract from ANSI to make code less verbose\r\n        const { STYLE, PREFABS } = ANSI;\r\n\r\n        if (data.args.length !== 1) {\r\n            term.writeln(`${PREFABS.error}Exactly one argument (PID) expected.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        // TODO: support more kill signals as arguments\r\n\r\n        // get process manager\r\n        const pm = kernel.get_process_manager();\r\n        const pid = parseInt(data.args[0]);\r\n\r\n        if (isNaN(pid)) {\r\n            term.writeln(`${PREFABS.error}Invalid PID provided.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        pm.kill(pid, 143); // SIGTERM\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: move this to be literal SIGTERM and SIGKILL signals sent to processes\r\n","import {ANSI, NEWLINE} from \"../../term_ctl\";\r\nimport {ProgramMainData} from \"../../types\"\r\n\r\nimport type {IgnitionIPCReply} from \"../core/ignition\";\r\nimport type {ServiceStatus} from \"../core/ignition/services\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, FG, PREFABS} = ANSI;\r\n\r\nexport const service_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const {args, term, process, kernel} = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    if (args.length === 0) {\r\n        term.writeln(`${PREFABS.error}Missing action.`);\r\n        term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    if (args.length === 1) {\r\n        term.writeln(`${PREFABS.error}Missing service ID.`);\r\n        term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    const action = args[0];\r\n    const service_id = args[1];\r\n\r\n    // open ipc with ignition\r\n    const ipc = kernel.get_ipc();\r\n    const channel_id = ipc.create_channel(\"init\");\r\n\r\n    if (!channel_id) {\r\n        term.writeln(`${PREFABS.error}Failed to communicate with ignition.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    // function can be defined to handle response data, string responses and errors handled by default\r\n    let on_data: (msg_data: unknown) => void;\r\n    let reply_timeout: number;\r\n    let return_code = 0;\r\n\r\n    // listen for replies\r\n    ipc.channel_listen(channel_id, async (msg) => {\r\n        const payload = msg.data as IgnitionIPCReply;\r\n\r\n        if (payload.type === \"data\") {\r\n            if (on_data) {\r\n                on_data(payload.data);\r\n            } else {\r\n                term.writeln(`${FG.yellow}Warning: Unhandled data response: ${JSON.stringify(payload.data)}${STYLE.reset_all}`);\r\n            }\r\n        } else if (payload.type === \"response\") {\r\n            term.writeln(`${FG.green}${payload.message}${STYLE.reset_all}`);\r\n        } else if (payload.type === \"error\") {\r\n            term.writeln(`${PREFABS.error}${payload.message}${STYLE.reset_all}`);\r\n            return_code = 1;\r\n        }\r\n\r\n        if (reply_timeout) {\r\n            process.cancel_timeout(reply_timeout);\r\n        }\r\n    });\r\n\r\n    if (action === \"status\") {\r\n        // special handler for status data\r\n        on_data = (msg_data: unknown) => {\r\n            const status = msg_data as ServiceStatus;\r\n\r\n            term.write(NEWLINE);\r\n            term.writeln(`${FG.cyan}Service ID:${STYLE.reset_all} ${service_id}`);\r\n\r\n            term.write(`${FG.cyan}Status: ${STYLE.reset_all}`);\r\n            switch (status.state) {\r\n                case \"running\":\r\n                    term.writeln(`${FG.green}Running${STYLE.reset_all}`);\r\n                    term.writeln(`${FG.cyan}PID:${STYLE.reset_all} ${status.pid}`);\r\n                    break;\r\n                case \"stopped\":\r\n                    term.writeln(`${FG.yellow}Stopped${STYLE.reset_all}`);\r\n                    break;\r\n                case \"failed\":\r\n                    term.writeln(`${FG.red}Failed${STYLE.reset_all}`);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // wait up to 3 seconds for a reply before erroring\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    reply_timeout = process.create_timeout(() => {}, 3000);\r\n\r\n    // can just send the action and service id directly rather than needing additional checking as the action matches the ipc action names\r\n    ipc.channel_send(channel_id, {\r\n        type: \"service\",\r\n        action,\r\n        service_id\r\n    });\r\n\r\n    if (!process.has_timeout(reply_timeout)) {\r\n        // timeout already cleared, meaning we got a response\r\n        return return_code;\r\n    }\r\n\r\n    const got_no_reply = await process.wait_for_timeout(reply_timeout);\r\n\r\n    if (got_no_reply) {\r\n        term.writeln(`${PREFABS.error}No response from ignition.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    // TODO: all this logic is kinda jank, trying to be too clever with timeouts and async ipc\r\n\r\n    return return_code;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport {ProgramMainData} from \"../../types\"\r\n\r\nimport type {IgnitionIPCReply} from \"../core/ignition\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, FG, PREFABS} = ANSI;\r\n\r\nexport const reload_services_subcommand = async (data: ProgramMainData) => {\r\n    // extract from data to make code less verbose\r\n    const {args, term, process, kernel} = data;\r\n\r\n    // remove subcommand name\r\n    args.shift();\r\n\r\n    // TODO: make function to do this back and forth with ignition rather than duplicating code for each subcommand\r\n\r\n    // open ipc with ignition\r\n    const ipc = kernel.get_ipc();\r\n    const channel_id = ipc.create_channel(\"init\");\r\n\r\n    if (!channel_id) {\r\n        term.writeln(`${PREFABS.error}Failed to communicate with ignition.${STYLE.reset_all}`);\r\n        return 1;\r\n    }\r\n\r\n    let reply_timeout: number;\r\n    let return_code = 0;\r\n\r\n    // listen for replies\r\n    ipc.channel_listen(channel_id, async (msg) => {\r\n        const payload = msg.data as IgnitionIPCReply;\r\n\r\n        if (payload.type === \"response\") {\r\n            term.writeln(`${FG.green}${payload.message}${STYLE.reset_all}`);\r\n        } else if (payload.type === \"error\") {\r\n            term.writeln(`${PREFABS.error}${payload.message}${STYLE.reset_all}`);\r\n            return_code = 1;\r\n        }\r\n\r\n        if (reply_timeout) {\r\n            process.cancel_timeout(reply_timeout);\r\n        }\r\n    });\r\n\r\n    // wait up to 3 seconds for a reply before erroring\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    reply_timeout = process.create_timeout(() => {}, 3000);\r\n\r\n    ipc.channel_send(channel_id, {\r\n        type: \"reload_services\"\r\n    });\r\n\r\n    if (!process.has_timeout(reply_timeout)) {\r\n        // timeout already cleared, meaning we got a response\r\n        return return_code;\r\n    }\r\n\r\n    const got_no_reply = await process.wait_for_timeout(reply_timeout);\r\n\r\n    if (got_no_reply) {\r\n        term.writeln(`${PREFABS.error}No response from ignition.${STYLE.reset_all}`);\r\n        return 2;\r\n    }\r\n\r\n    // TODO: all this logic is kinda jank, trying to be too clever with timeouts and async ipc\r\n\r\n    return return_code;\r\n}\r\n","import {ANSI} from \"../../term_ctl\";\r\nimport type {Program} from \"../../types\";\r\nimport {helper_completion_options} from \"../core/ash/tab_completion\";\r\n\r\nimport {service_subcommand} from \"./service\";\r\nimport {reload_services_subcommand} from \"./reload_services\";\r\n\r\n// extract from ANSI to make code less verbose\r\nconst {STYLE, PREFABS} = ANSI;\r\n\r\n\r\nexport default {\r\n    name: \"spark\",\r\n    description: \"Manage your system with ignition.\",\r\n    usage_suffix: \"[-h] [subcommand] [arguments]\",\r\n    arg_descriptions: {\r\n        \"Subcommands:\": {\r\n            \"service\": \"Manage running services.\",\r\n            \"reload-services\": \"Reload the service definition files.\",\r\n        },\r\n        \"Arguments:\": {\r\n            \"-h\": \"Displays this help message.\",\r\n            \"For service:\": {\r\n                \"action\": \"The action to perform (start, stop, restart, status).\",\r\n                \"service_id\": \"The ID of the service to manage.\",\r\n            },\r\n        }\r\n    },\r\n    compat: \"2.0.0\",\r\n    completion: async (data) => {\r\n        // TODO: smarter completion that understands flags for subcommands\r\n        switch (data.arg_index) {\r\n            case 0:\r\n                return helper_completion_options([\"service\"])(data);\r\n        }\r\n\r\n        return [];\r\n    },\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const {args, term, kernel, shell} = data;\r\n\r\n        if (args.length === 0) {\r\n            term.writeln(`${PREFABS.error}Missing subcommand.`)\r\n            term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n            return 1;\r\n        }\r\n\r\n        if (args.includes(\"-h\")) {\r\n            return await kernel.spawn(\"help\", [\"spark\"], shell).completion;\r\n        }\r\n\r\n        switch (args[0]) {\r\n            case \"service\":\r\n                return await service_subcommand(data);\r\n            case \"reload-services\":\r\n                return await reload_services_subcommand(data);\r\n            default:\r\n                term.writeln(`${PREFABS.error}Invalid subcommand.`);\r\n                term.writeln(`Try 'spark -h' for more information.${STYLE.reset_all}`);\r\n                return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"ipc_bg_test\",\r\n    description: \"\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term, process } = data;\r\n\r\n        process.detach();\r\n\r\n        const ipc = kernel.get_ipc();\r\n        ipc.service_register(\"ipc_bg_test\", async (channel_id, from_pid) => {\r\n            ipc.channel_listen(channel_id, async (msg) => {\r\n                term.writeln(`Received message on channel ${channel_id} from PID ${msg.from}: ${JSON.stringify(msg.data)}`);\r\n            });\r\n        });\r\n\r\n        term.writeln(\"ipc_bg_test service started and listening for messages.\");\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"ipc_fg_test\",\r\n    description: \"\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term } = data;\r\n\r\n        const ipc = kernel.get_ipc();\r\n        const channel = ipc.create_channel(\"ipc_bg_test\");\r\n        \r\n        if (!channel) {\r\n            term.writeln(\"Failed to create IPC channel to service 'ipc_bg_test'.\");\r\n            return 1;\r\n        }\r\n\r\n        ipc.channel_send(channel, { message: \"Hello from ipc_fg_test!\" });\r\n\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../types\";\r\n\r\nexport default {\r\n    name: \"taskbar_test\",\r\n    description: \"\",\r\n    usage_suffix: \"\",\r\n    arg_descriptions: {},\r\n    compat: \"2.0.0\",\r\n    hide_from_help: true,\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, term, process, shell } = data;\r\n\r\n        if (!kernel.has_window_manager()) {\r\n            term.writeln(\"This program requires a window manager.\");\r\n            return 1;\r\n        }\r\n\r\n        const wind = process.create_window();\r\n\r\n        wind.title = \"Taskbar\";\r\n\r\n        wind.set_custom_flag(\"no-top-bar\", true);\r\n\r\n        wind.x = \"0vw\";\r\n        wind.y = \"92.5vh\";\r\n\r\n        wind.height = \"7.5vh\";\r\n        wind.width = \"100vw\";\r\n\r\n        const buttons = document.createElement(\"div\");\r\n        buttons.style.display = \"flex\";\r\n        buttons.style.height = \"100%\";\r\n        buttons.style.alignItems = \"center\";\r\n        buttons.style.gap = \"1vh\";\r\n        buttons.style.padding = \"0 1vh\";\r\n\r\n        wind.dom.appendChild(buttons);\r\n\r\n        const fsedit_button = document.createElement(\"button\");\r\n        fsedit_button.innerText = \"FSEdit\";\r\n        fsedit_button.style.height = \"100%\";\r\n        fsedit_button.style.fontSize = \"2vh\";\r\n        fsedit_button.onclick = () => {\r\n            kernel.spawn(\"fsedit\", [], shell);\r\n        };\r\n\r\n        buttons.appendChild(fsedit_button);\r\n\r\n        // if minecraft is installed, add a button for it\r\n        const prog_reg = kernel.get_program_registry();\r\n        if (prog_reg.getProgram(\"minecraft\")) {\r\n            const mc_button = document.createElement(\"button\");\r\n            mc_button.style.height = \"100%\";\r\n            mc_button.style.fontSize = \"2vh\";\r\n            mc_button.onclick = () => {\r\n                kernel.spawn(\"minecraft\", [], shell);\r\n            };\r\n\r\n            const mc_image = document.createElement(\"img\");\r\n            mc_image.src = \"https://brandlogos.net/wp-content/uploads/2022/07/minecraft-logo_brandlogos.net_faqdi-512x560.png\";\r\n            mc_image.style.height = \"100%\";\r\n            mc_image.style.objectFit = \"contain\";\r\n            mc_image.alt = \"Minecraft\";\r\n            mc_image.draggable = false;\r\n            mc_button.appendChild(mc_image);\r\n\r\n            buttons.appendChild(mc_button);\r\n        }\r\n\r\n        wind.show();\r\n\r\n        process.detach();\r\n        return 0;\r\n    }\r\n} as Program;","import type { Program } from \"../../../types\";\r\n\r\nexport default {\r\n    name: \"trigger_create_trigger\",\r\n    description: \"A trigger to create another trigger. Use this trigger to deploy custom triggers!\",\r\n    usage_suffix: \"pkg_name pkg_version trigger_file\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"pkg_name\": \"The name of the package creating the trigger, which will namespace the trigger. Passed automatically by the package manager.\",\r\n            \"pkg_version\": \"Ignored. Passed automatically by the package manager.\",\r\n            \"trigger_file\": \"The path to the trigger file to create. This is the string that you pass into the create_trigger trigger in your package's meta.json triggers section.\"\r\n        }\r\n    },\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        if (args.length !== 3) {\r\n            term.writeln(\"Usage: trigger_create_trigger pkg_name pkg_version trigger_file\");\r\n            return 1;\r\n        }\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        const pkg_name = args[0];\r\n        const trigger_file = JSON.parse(args[2]);\r\n\r\n        // trigger must end with .json\r\n        if (!trigger_file.endsWith(\".json\")) {\r\n            term.writeln(\"Error: Trigger file must end with .json\");\r\n            return 1;\r\n        }\r\n\r\n        // source path will be /usr/bin/PKG_NAME/TRIGGER_FILE\r\n        const source_path = fs.join(\"/usr/bin\", pkg_name, trigger_file);\r\n\r\n        // check the path is valid\r\n        if (!await fs.exists(source_path)) {\r\n            term.writeln(`Error: Trigger file not found at ${source_path}`);\r\n            return 1;\r\n        }\r\n\r\n        // destination path will be /var/lib/pkg/triggers/PKG_NAME/TRIGGER_FILE\r\n        const dest_path = fs.join(\"/var/lib/pkg/triggers\", pkg_name, trigger_file);\r\n\r\n        // check the destination path does not already exist\r\n        if (await fs.exists(dest_path)) {\r\n            term.writeln(`Error: Trigger file already exists at ${dest_path}.`);\r\n            return 1;\r\n        }\r\n\r\n        // copy the trigger file to the destination\r\n        // TODO: make fs support copy operation\r\n        const content = await fs.read_file(source_path);\r\n        await fs.write_file(dest_path, content);\r\n\r\n        term.writeln(`Trigger created at ${dest_path}`);\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: way to pass trigger data as json and identify it. then a way to pass just program name to use as both create and remove trigger?\r\n","import type { Program } from \"../../../types\";\r\n\r\nexport default {\r\n    name: \"trigger_remove_trigger\",\r\n    description: \"A trigger to remove a trigger.\",\r\n    usage_suffix: \"pkg_name pkg_version trigger_file\",\r\n    arg_descriptions: {\r\n        \"Arguments:\": {\r\n            \"pkg_name\": \"The name of the package that created the trigger, which is used to namespace the trigger. Passed automatically by the package manager.\",\r\n            \"pkg_version\": \"Ignored. Passed automatically by the package manager.\",\r\n            \"trigger_file\": \"The path to the trigger file to remove. This is the string that you pass into the create_trigger trigger in your package's meta.json triggers section.\"\r\n        }\r\n    },\r\n    hide_from_help: true,\r\n    compat: \"2.0.0\",\r\n    completion: async () => [],\r\n    main: async (data) => {\r\n        // extract from data to make code less verbose\r\n        const { kernel, args, term } = data;\r\n\r\n        if (args.length !== 3) {\r\n            term.writeln(\"Usage: trigger_remove_trigger pkg_name pkg_version trigger_file\");\r\n            return 1;\r\n        }\r\n\r\n        const fs = kernel.get_fs();\r\n\r\n        const pkg_name = args[0];\r\n        const trigger_file = JSON.parse(args[2]);\r\n\r\n        // trigger must end with .json\r\n        if (!trigger_file.endsWith(\".json\")) {\r\n            term.writeln(\"Error: Trigger file must end with .json\");\r\n            return 1;\r\n        }\r\n\r\n        // destination path will be /var/lib/pkg/triggers/PKG_NAME/TRIGGER_FILE\r\n        const dest_path = fs.join(\"/var/lib/pkg/triggers\", pkg_name, trigger_file);\r\n\r\n        // check the destination path exists\r\n        if (!await fs.exists(dest_path)) {\r\n            return 0;\r\n        }\r\n\r\n        // remove the trigger file\r\n        await fs.delete_file(dest_path);\r\n\r\n        term.writeln(`Trigger removed from ${dest_path}`);\r\n\r\n        return 0;\r\n    }\r\n} as Program;\r\n\r\n// TODO: should triggers support using the same program as the uninstall trigger, an just passing different arguments?\r\n","import { AbstractFileSystem, FSEventType, NonRecursiveDirectoryError, PathNotFoundError } from \"../filesystem\";\r\n\r\n// TODO: may get laggy with large files and many files or dirs\r\n// NOTE: not using implements (TS) so the real methods can be used\r\n// indexeddb fs is superior\r\n// TODO: unsolveable prototype pollution without banning filenames. tried using map, but recursive traversal wont work as the instances are distinct (not writing to the original state dict)\r\nexport class LocalStorageFS extends AbstractFileSystem {\r\n    get_unique_fs_type_name(): string {\r\n        return \"localstorage\";\r\n    }\r\n\r\n    async is_ready() {\r\n        return true;\r\n    }\r\n\r\n    async erase_all() {\r\n        localStorage.removeItem(\"fs\");\r\n        localStorage.removeItem(\"fs_readonly_paths\");\r\n        localStorage.removeItem(\"fs_migrations\");\r\n    }\r\n\r\n    async make_dir(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // create directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            const absolute_path = parts.slice(0, parts.indexOf(part) + 1).join(\"/\");\r\n\r\n            if (!current_dir[part]) {\r\n                current_dir[part] = {};\r\n                this._call_callbacks(FSEventType.MADE_DIR, absolute_path);\r\n            }\r\n\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // save state\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async delete_dir_direct(path: string, recursive: boolean) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // delete innermost directory\r\n        for (let part_idx = 0; part_idx < parts.length; part_idx++) {\r\n            const part = parts[part_idx];\r\n            const absolute_path = parts.slice(0, parts.indexOf(part) + 1).join(\"/\");\r\n\r\n            if (!recursive && (await this.list_dir(absolute_path)).length > 0) {\r\n                throw new NonRecursiveDirectoryError(part);\r\n            }\r\n\r\n            // check if directory exists\r\n            if (!current_dir[part]) {\r\n                throw new PathNotFoundError(absolute_path);\r\n            }\r\n\r\n            // delete directory if it's the last part\r\n            if (part_idx === parts.length - 1) {\r\n                delete current_dir[part];\r\n                this._call_callbacks(FSEventType.DELETED_DIR, absolute_path);\r\n            }\r\n\r\n            // recurse into directory to discover the next part\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // save state\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async move_dir_direct(src: string, dest: string, no_overwrite: boolean, move_inside: boolean) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n\r\n        // using unix style rules, i.e\r\n        \r\n        // mv dir1 dir2 -> rename dir1 to dir2, or move dir1 into dir2 if dir2 already exists (THIS IS WHEN MOVE_INSIDE IS FALSE)\r\n        // overwrite any files in the destination directory if they exist in the source directory if no_overwrite is false\r\n        // and of course move across any files from the source directory to the destination directory and leave any only in the destination directory alone\r\n        \r\n        // mv dir1 dir2/ -> move dir1 into dir2 (dir2 must exist, dir1 must not exist in dir2) (THIS IS WHEN MOVE_INSIDE IS TRUE, THERE WILL NOT BE A TRAILING / IN THE DESTINATION PATH)\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const src_parts = src === this._root ? [\"\"] : src.split(\"/\");\r\n        const dest_parts = dest.split(\"/\");\r\n\r\n        // get directory for each part inside the previous one\r\n        let current_dir = state;\r\n        let current_dir_parent = null;\r\n        for (const part of src_parts) {\r\n            if (!current_dir[part]) {\r\n                throw new PathNotFoundError(src);\r\n            }\r\n            current_dir_parent = current_dir;\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // check if source is a directory\r\n        if (typeof current_dir !== \"object\") {\r\n            throw new PathNotFoundError(src);\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        let dest_current_dir = state;\r\n        //let dest_current_dir_parent = null;\r\n        for (const part of dest_parts) {\r\n            if (!dest_current_dir[part]) {\r\n                // if this is the last part, create the directory, otherwise throw an error\r\n                // TODO: is this correct? it acts correct, but is it too lax?\r\n                if (part === dest_parts[dest_parts.length - 1]) {\r\n                    dest_current_dir[part] = {};\r\n                } else {\r\n                    throw new PathNotFoundError(dest);\r\n                }\r\n            }\r\n            //dest_current_dir_parent = dest_current_dir;\r\n            dest_current_dir = dest_current_dir[part];\r\n        }\r\n\r\n        // check if destination is a directory\r\n        if (typeof dest_current_dir !== \"object\") {\r\n            throw new PathNotFoundError(dest);\r\n        }\r\n\r\n        // if we have equivalent paths, do nothing (so we don't accidentally delete the directory when calling delete after move)\r\n        if (src === dest) {\r\n            console.warn(\"source and destination are the same\");\r\n            return;\r\n        }\r\n\r\n        // TODO: significant fixes required! moving directories is just a mess\r\n        // TODO: need to consolidate exactly when we should be merging directories. its not exactly clear and chatgpt contradicts itself when asking for a formal definition!\r\n\r\n        if (move_inside) {\r\n            // if moving inside, check that the directory named the same as the source does not exist in the destination\r\n            if (dest_current_dir[src_parts[src_parts.length - 1]]) {\r\n                throw new Error(`Directory already exists in destination: ${dest}`);\r\n            }\r\n\r\n            // move directory inside destination\r\n            dest_current_dir[src_parts[src_parts.length - 1]] = current_dir;\r\n\r\n            // delete source directory\r\n            delete current_dir_parent[src_parts[src_parts.length - 1]];\r\n        } else {\r\n            // not moving inside, so merge files and directories from source into destination\r\n            for (const key of Object.keys(current_dir)) {\r\n                if (dest_current_dir[key] && no_overwrite) {\r\n                    throw new Error(`File or directory already exists in destination: ${dest}`);\r\n                }\r\n\r\n                dest_current_dir[key] = current_dir[key];\r\n            }\r\n\r\n            // delete source directory\r\n            delete current_dir_parent[src_parts[src_parts.length - 1]];\r\n        }\r\n\r\n        // save state\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async list_dir(path: string, dirs_first = false) {\r\n        this._call_callbacks(FSEventType.LISTING_DIR, path);\r\n\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // trim trailing slash\r\n        if (parts[parts.length - 1] === \"\") {\r\n            parts.pop();\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            if (current_dir[part]) {\r\n                current_dir = current_dir[part];\r\n            } else {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n        }\r\n\r\n        // if this is the root we will have an empty parts array, so we need to access the root directory\r\n        // our whole fs is stored under an empty top level key because im stupid\r\n        // we might have to do this elsewhere\r\n        if (parts.length === 0) {\r\n            current_dir = state[\"\"];\r\n        }\r\n\r\n        // return list of files in directory\r\n        const keys = Object.keys(current_dir);\r\n\r\n        if (dirs_first) {\r\n            for (const key of keys) {\r\n                // promote directories to the front of the list\r\n                if (typeof current_dir[key] === \"object\") {\r\n                    keys.splice(keys.indexOf(key), 1);\r\n                    keys.unshift(key);\r\n                }\r\n            }\r\n        }\r\n\r\n        return keys;\r\n    }\r\n\r\n\r\n    async read_file_direct(path: string, as_uint = false) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n        let current_part = state;\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // if this is not the last part, check if it is a directory\r\n            if (parts.indexOf(part) !== parts.length - 1 && !current_part[part]) {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n\r\n            current_part = current_part[part];\r\n        }\r\n\r\n        // check if file exists\r\n        if (current_part !== undefined) {\r\n            // if file is empty, return empty string / uint8array (or else it will be read as null byte)\r\n            if (current_part.length === 0) {\r\n                if (as_uint) {\r\n                    return new Uint8Array();\r\n                } else {\r\n                    return \"\";\r\n                }\r\n            }\r\n\r\n            const binary_string = atob(current_part);\r\n            const bytes = Uint8Array.from(binary_string, m => m.charCodeAt(0));\r\n\r\n            if (as_uint) {\r\n                return bytes;\r\n            } else {\r\n                return new TextDecoder().decode(bytes);\r\n            }\r\n        }\r\n\r\n        throw new PathNotFoundError(path);\r\n    }\r\n\r\n    async write_file_direct(path: string, data: string | ArrayBuffer | Uint8Array) {\r\n        let uint: Uint8Array;\r\n\r\n        // convert string to uint8array\r\n        if (typeof data === \"string\") {\r\n            uint = new TextEncoder().encode(data);\r\n        }\r\n\r\n        // convert array buffer to uint8array\r\n        if (data instanceof ArrayBuffer) {\r\n            uint = new Uint8Array(data);\r\n        }\r\n\r\n        if (data instanceof Uint8Array) {\r\n            uint = data;\r\n        }\r\n\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n        const file_name = parts[parts.length - 1];\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // go until before the last part\r\n            if (parts.indexOf(part) !== parts.length - 1) {\r\n                if (!current_dir[part]) {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                current_dir = current_dir[part];\r\n            }\r\n        }\r\n\r\n        // convert uint8array to base64\r\n        // uint.toBase64() isnt mainstream yet\r\n        current_dir[file_name] = btoa(String.fromCharCode.apply(null, uint));\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n\r\n    async delete_file_direct(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_dir = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n        const file_name = parts[parts.length - 1];\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // go until before the last part\r\n            if (parts.indexOf(part) !== parts.length - 1) {\r\n                if (!current_dir[part]) {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                current_dir = current_dir[part];\r\n            }\r\n        }\r\n\r\n        // delete file from directory\r\n        delete current_dir[file_name];\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n\r\n        // remove from readonly list if it is there\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        if (readonly_list.includes(path)) {\r\n            readonly_list.splice(readonly_list.indexOf(path), 1);\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n        }\r\n    }\r\n\r\n    async move_file_direct(src: string, dest: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n\r\n        // split paths into parts, if root, use single empty string to avoid doubling\r\n        const src_parts = src === this._root ? [\"\"] : src.split(\"/\");\r\n        const dest_parts = dest === this._root ? [\"\"] : dest.split(\"/\");\r\n        const file_name = src_parts[src_parts.length - 1];\r\n        const new_file_name = dest_parts[dest_parts.length - 1];\r\n\r\n        // get directory for each part inside the previous one\r\n        let current_dir = state;\r\n        for (const part of src_parts.slice(0, -1)) {\r\n            if (!current_dir[part]) {\r\n                throw new PathNotFoundError(src);\r\n            }\r\n            current_dir = current_dir[part];\r\n        }\r\n\r\n        // check if file exists\r\n        if (current_dir[file_name] === undefined) {\r\n            throw new PathNotFoundError(src);\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        let new_current_dir = state;\r\n        for (const part of dest_parts.slice(0, -1)) {\r\n            if (!new_current_dir[part]) {\r\n                throw new PathNotFoundError(dest);\r\n            }\r\n            new_current_dir = new_current_dir[part];\r\n        }\r\n\r\n        // if we have equivalent paths, do nothing (so we don't accidentally delete the file when calling delete after move)\r\n        if (file_name === new_file_name && current_dir === new_current_dir) {\r\n            console.warn(\"source and destination are the same\");\r\n            return;\r\n        }\r\n\r\n        // move file from source to destination\r\n        new_current_dir[new_file_name] = current_dir[file_name];\r\n        delete current_dir[file_name];\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n\r\n        // relocate in readonly list if it is there\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        if (readonly_list.includes(src)) {\r\n            readonly_list.splice(readonly_list.indexOf(src), 1);\r\n            readonly_list.push(dest);\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n        }\r\n    }\r\n\r\n    async set_readonly_direct(path: string, readonly: boolean) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n\r\n        if (readonly && !state.includes(path)) {\r\n            state.push(path);\r\n        } else if (!readonly && state.includes(path)) {\r\n            state.splice(state.indexOf(path), 1);\r\n        }\r\n\r\n        localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(state));\r\n    }\r\n\r\n    async is_readonly_direct(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        return state.includes(path);\r\n    }\r\n\r\n    async exists_direct(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_part = state;\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // remove trailing /\r\n        if (parts[parts.length - 1] === \"\") {\r\n            parts.pop();\r\n        }\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            // important! empty strings are falsy so we need to specifically check for undefined\r\n            if (current_part[part] !== undefined) {\r\n                current_part = current_part[part];\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async dir_exists(path: string) {\r\n        const state = JSON.parse(localStorage.getItem(\"fs\"));\r\n        let current_part = state;\r\n\r\n        // if path ends with /, remove it\r\n        if (path.endsWith(\"/\")) {\r\n            path = path.slice(0, -1);\r\n        }\r\n\r\n        // split path into parts, if root, use single empty string to avoid doubling\r\n        const parts = path === this._root ? [\"\"] : path.split(\"/\");\r\n\r\n        // get directory for each part inside the previous one\r\n        for (const part of parts) {\r\n            if (current_part[part]) {\r\n                current_part = current_part[part];\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return typeof current_part === \"object\";\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        // initialise file system\r\n        if (!localStorage.getItem(\"fs\")) {\r\n            localStorage.setItem(\"fs\", JSON.stringify({}));\r\n        }\r\n\r\n        if (!localStorage.getItem(\"fs_readonly_paths\")) {\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify([]));\r\n        }\r\n\r\n        const existing_migrations = localStorage.getItem(\"fs_migrations\");\r\n        if (!existing_migrations) {\r\n            localStorage.setItem(\"fs_migrations\", JSON.stringify({\r\n                string_to_array: false,\r\n                array_to_b64: false,\r\n            }));\r\n        }\r\n\r\n        const migrations = JSON.parse(localStorage.getItem(\"fs_migrations\"));\r\n\r\n        if (!migrations.string_to_array) {\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            migrate_old_string_fs(JSON.parse(localStorage.getItem(\"fs\")), true);\r\n        }\r\n\r\n        if (!migrations.array_to_b64) {\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            migrate_old_array_fs(JSON.parse(localStorage.getItem(\"fs\")));\r\n        }\r\n\r\n        // mark all migrations as done\r\n        migrations.string_to_array = true;\r\n        migrations.array_to_b64 = true;\r\n        localStorage.setItem(\"fs_migrations\", JSON.stringify(migrations));\r\n\r\n        // initialise root and home directory\r\n        this.make_dir(this._home).then(() => {\r\n            this._initialised = true;\r\n        }).catch((err) => {\r\n            console.error(\"Failed to create home directory:\", err);\r\n        });\r\n    }\r\n}\r\n\r\nconst migrate_old_string_fs = (state: object, is_outer = false) => {\r\n    // migration step: we used to use a string but now we use an array for files\r\n    // need to iterate DEEPLY into nested objects and convert string values to arrays\r\n    // (so recurse)\r\n    // TODO make iterative\r\n\r\n    for (const key of Object.keys(state)) {\r\n        if (typeof state[key] === \"object\" && !Array.isArray(state[key])) {\r\n            migrate_old_string_fs(state[key]);\r\n        } else if (typeof state[key] === \"string\") {\r\n            console.log(`Migration: converting ${key} to array`);\r\n            state[key] = state[key].split(\",\").map((x) => parseInt(x));\r\n        }\r\n    }\r\n\r\n    if (is_outer) {\r\n        // only save if we are at the outermost level\r\n        localStorage.setItem(\"fs\", JSON.stringify(state));\r\n    }\r\n}\r\n\r\nconst migrate_old_array_fs = (state: object) => {\r\n    // migration step: we used to use an array for files but now we use base64 strings\r\n    // need to iterate DEEPLY into nested objects and convert array values to strings\r\n\r\n    // use a stack to avoid recursion limit issues\r\n    const stack = [state];\r\n\r\n    while (stack.length > 0) {\r\n        // get the next object to process\r\n        const current_obj = stack.pop();\r\n\r\n        if (current_obj === null || typeof current_obj !== \"object\" || Array.isArray(current_obj)) {\r\n            continue;\r\n        }\r\n\r\n        // iterate over the keys of the current object\r\n        for (const key of Object.keys(current_obj)) {\r\n            const value = current_obj[key];\r\n\r\n            if (!value) {\r\n                continue;\r\n            } else if (typeof value === \"object\" && !Array.isArray(value)) {\r\n                // if the value is a nested object, add it to the stack to be processed later (depth first)\r\n                stack.push(value);\r\n            } else if (Array.isArray(value)) {\r\n                console.log(`Migration: converting ${key} to b64 string`);\r\n\r\n                try {\r\n                    const values = value.map((x: string) => parseInt(x));\r\n                    const uint = new Uint8Array(values);\r\n                    // uint.toBase64() isnt mainstream yet\r\n                    current_obj[key] = btoa(String.fromCharCode.apply(null, uint));\r\n                } catch (e) {\r\n                    console.error(`Migration failed for key \"${key}\":`, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // only save after the whole traversal\r\n    localStorage.setItem(\"fs\", JSON.stringify(state));\r\n}\r\n","import {AbstractFileSystem, NonRecursiveDirectoryError, PathNotFoundError} from \"../filesystem\";\r\n\r\nexport class OPFSFileSystem extends AbstractFileSystem {\r\n    private _opfs_handle: FileSystemDirectoryHandle | null = null;\r\n\r\n    get_unique_fs_type_name(): string {\r\n        return \"opfs\";\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        if (!localStorage.getItem(\"fs_readonly_paths\")) {\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify([]));\r\n        }\r\n\r\n        // get the root directory handle\r\n        navigator.storage.getDirectory().then((handle) => {\r\n            this._opfs_handle = handle;\r\n            this._initialised = true;\r\n        }).catch((err) => {\r\n            console.error(\"Failed to get OPFS directory handle:\", err);\r\n        });\r\n    }\r\n\r\n    async is_ready() {\r\n        return this._opfs_handle !== null;\r\n    }\r\n\r\n    private get_root_handle(): FileSystemDirectoryHandle {\r\n        if (!this._opfs_handle) {\r\n            throw new Error(\"OPFS directory handle is not initialised.\");\r\n        }\r\n\r\n        return this._opfs_handle;\r\n    }\r\n\r\n    async make_dir(path: string) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            current_handle = await current_handle.getDirectoryHandle(part, { create: true });\r\n        }\r\n    }\r\n\r\n    async dir_exists(path: string): Promise<boolean> {\r\n        // should return true only for directories\r\n\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(part);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && (err.name === \"NotFoundError\" || err.name === \"TypeMismatchError\")) {\r\n                    return false;\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async exists_direct(path: string) {\r\n        // should return true for both files and directories\r\n\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(part);\r\n            } catch (err) {\r\n                try {\r\n                    await current_handle.getFileHandle(part);\r\n                    return true;\r\n                } catch (err2) {\r\n                    if (err2 instanceof DOMException && err2.name === \"NotFoundError\") {\r\n                        return false;\r\n                    }\r\n                    throw err2;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    async delete_dir_direct(path: string, recursive: boolean) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        try {\r\n            // recurse into directories\r\n            let current_handle = root;\r\n            for (let i = 0; i < parts.length - 1; i++) {\r\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\r\n            }\r\n\r\n            await current_handle.removeEntry(parts[parts.length - 1], { recursive });\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n\r\n            if (err instanceof DOMException && err.name === \"InvalidModificationError\" && !recursive) {\r\n                throw new NonRecursiveDirectoryError(path);\r\n            }\r\n\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    async list_dir(path: string) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        let current_handle = root;\r\n        for (const part of parts) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(part);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        const entries: string[] = [];\r\n        for await (const [name, handle] of current_handle.entries()) {\r\n            entries.push(name);\r\n        }\r\n\r\n        return entries;\r\n    }\r\n\r\n    async is_readonly_direct(path: string) {\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\") || \"[]\");\r\n        return readonly_list.includes(path);\r\n    }\r\n\r\n    async set_readonly_direct(path: string, readonly: boolean) {\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\") || \"[]\");\r\n\r\n        if (readonly) {\r\n            if (!readonly_list.includes(path)) {\r\n                readonly_list.push(path);\r\n            }\r\n        } else {\r\n            if (readonly_list.includes(path)) {\r\n                readonly_list.splice(readonly_list.indexOf(path), 1);\r\n            }\r\n        }\r\n\r\n        localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n    }\r\n\r\n    async move_dir_direct(src: string, dest: string, no_overwrite: boolean, move_inside: boolean) {\r\n        // TODO: implement\r\n        return Promise.resolve(undefined);\r\n    }\r\n\r\n    async read_file_direct(path: string, as_uint: boolean) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        // recurse into directories\r\n        let current_handle = root;\r\n        for (let i = 0; i < parts.length - 1; i++) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        let file_handle: FileSystemFileHandle;\r\n        try {\r\n            file_handle = await current_handle.getFileHandle(parts[parts.length - 1]);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        const file = await file_handle.getFile();\r\n        const array_buffer = await file.arrayBuffer();\r\n\r\n        if (as_uint) {\r\n            return new Uint8Array(array_buffer);\r\n        } else {\r\n            const decoder = new TextDecoder();\r\n            return decoder.decode(array_buffer);\r\n        }\r\n    }\r\n\r\n    async write_file_direct(path: string, data: string | Uint8Array) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n        \r\n        // recurse into directories\r\n        let current_handle = root;\r\n        for (let i = 0; i < parts.length - 1; i++) {\r\n            current_handle = await current_handle.getDirectoryHandle(parts[i], { create: true });\r\n        }\r\n\r\n        const file_handle = await current_handle.getFileHandle(parts[parts.length - 1], { create: true });\r\n        const writable = await file_handle.createWritable();\r\n\r\n        const data_to_write = (data instanceof Uint8Array) ? data : new TextEncoder().encode(data);\r\n\r\n        await writable.write(data_to_write.buffer as ArrayBuffer);\r\n        await writable.close();\r\n    }\r\n\r\n    async delete_file_direct(path: string) {\r\n        const root = this.get_root_handle();\r\n        const parts = path.split(\"/\").filter(part => part.length > 0);\r\n\r\n        // recurse into directories\r\n        let current_handle = root;\r\n        for (let i = 0; i < parts.length - 1; i++) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(path);\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        try {\r\n            await current_handle.removeEntry(parts[parts.length - 1]);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(path);\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        // remove from readonly list if it is there\r\n        const readonly_list = JSON.parse(localStorage.getItem(\"fs_readonly_paths\"));\r\n        if (readonly_list.includes(path)) {\r\n            readonly_list.splice(readonly_list.indexOf(path), 1);\r\n            localStorage.setItem(\"fs_readonly_paths\", JSON.stringify(readonly_list));\r\n        }\r\n    }\r\n\r\n    async move_file_direct(src: string, dest: string) {\r\n        const root = this.get_root_handle();\r\n        const src_parts = src.split(\"/\").filter(part => part.length > 0);\r\n        const dest_parts = dest.split(\"/\").filter(part => part.length > 0);\r\n\r\n        // get source file handle\r\n        let current_handle = root;\r\n        for (let i = 0; i < src_parts.length - 1; i++) {\r\n            try {\r\n                current_handle = await current_handle.getDirectoryHandle(src_parts[i]);\r\n            } catch (err) {\r\n                if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                    throw new PathNotFoundError(src);\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n\r\n        let file_handle: FileSystemFileHandle;\r\n        try {\r\n            file_handle = await current_handle.getFileHandle(src_parts[src_parts.length - 1]);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"NotFoundError\") {\r\n                throw new PathNotFoundError(src);\r\n            }\r\n            throw err;\r\n        }\r\n\r\n        const file = await file_handle.getFile();\r\n        const array_buffer = await file.arrayBuffer();\r\n\r\n        // write to destination\r\n        current_handle = root;\r\n        for (let i = 0; i < dest_parts.length - 1; i++) {\r\n            current_handle = await current_handle.getDirectoryHandle(dest_parts[i], { create: true });\r\n        }\r\n\r\n        const dest_file_handle = await current_handle.getFileHandle(dest_parts[dest_parts.length - 1], { create: true });\r\n        const writable = await dest_file_handle.createWritable();\r\n        await writable.write(array_buffer);\r\n        await writable.close();\r\n\r\n        // delete source file\r\n        await this.delete_file_direct(src);\r\n    }\r\n\r\n    async erase_all() {\r\n        const root = this.get_root_handle();\r\n\r\n        for await (const [name, handle] of root.entries()) {\r\n            if (handle.kind === \"file\") {\r\n                await root.removeEntry(name);\r\n            } else if (handle.kind === \"directory\") {\r\n                await root.removeEntry(name, { recursive: true });\r\n            }\r\n        }\r\n\r\n        localStorage.removeItem(\"fs_readonly_paths\");\r\n    }\r\n}\r\n\r\n// TODO: emit events\r\n","import { AbstractFileSystem } from \"./filesystem\";\r\nimport { ANSI, NEWLINE } from \"./term_ctl\";\r\n\r\nconst setup_boot = async (fs: AbstractFileSystem) => {\r\n    // create boot directory if it doesn't exist\r\n    const absolute_boot = fs.absolute(\"/boot\");\r\n    if (!(await fs.dir_exists(absolute_boot))) {\r\n        await fs.make_dir(absolute_boot);\r\n    }\r\n\r\n    // create init file if it doesn't exist\r\n    const init_content = \"ignition\";\r\n    const absolute_init = fs.absolute(\"/boot/init\");\r\n    if (!(await fs.exists(absolute_init))) {\r\n        await fs.write_file(absolute_init, init_content);\r\n    }\r\n\r\n    // create etc directory if it doesn't exist\r\n    const absolute_etc = fs.absolute(\"/etc\");\r\n    if (!(await fs.dir_exists(absolute_etc))) {\r\n        await fs.make_dir(absolute_etc);\r\n    }\r\n\r\n    // create boot_target file if it doesn't exist\r\n    const boot_target_content = \"jetty\";\r\n    const absolute_boot_target = fs.absolute(\"/etc/boot_target\");\r\n    if (!(await fs.exists(absolute_boot_target))) {\r\n        await fs.write_file(absolute_boot_target, boot_target_content);\r\n    }\r\n\r\n    // create default_shell file if it doesn't exist\r\n    const default_shell_content = \"ash --login\";\r\n    const absolute_default_shell = fs.absolute(\"/etc/default_shell\");\r\n    if (!(await fs.exists(absolute_default_shell))) {\r\n        await fs.write_file(absolute_default_shell, default_shell_content);\r\n    }\r\n\r\n    // create sys directory if it doesn't exist\r\n    const absolute_sys = fs.absolute(\"/sys\");\r\n    if (!(await fs.dir_exists(absolute_sys))) {\r\n        await fs.make_dir(absolute_sys);\r\n    }\r\n\r\n    // create privilege_agent file if it doesn't exist\r\n    const privilege_agent_content = \"default_privilege_agent\";\r\n    const absolute_privilege_agent = fs.absolute(\"/sys/privilege_agent\");\r\n    if (!(await fs.exists(absolute_privilege_agent))) {\r\n        await fs.write_file(absolute_privilege_agent, privilege_agent_content);\r\n    }\r\n}\r\n\r\nconst setup_motd = async (fs: AbstractFileSystem) => {\r\n    // create etc directory if it doesn't exist\r\n    const absolute_etc = fs.absolute(\"/etc\");\r\n    if (!(await fs.dir_exists(absolute_etc))) {\r\n        await fs.make_dir(absolute_etc);\r\n    }\r\n\r\n    // create motd file if it doesn't exist\r\n    const motd_content = ` Welcome to ${ANSI.STYLE.italic + ANSI.STYLE.bold + ANSI.FG.magenta}OllieOS...${ANSI.STYLE.reset_all} \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}help${ANSI.STYLE.no_italic + ANSI.FG.blue} for a list of commands.${ANSI.STYLE.reset_all}        \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}mefetch${ANSI.STYLE.no_italic + ANSI.FG.blue} for info about me.${ANSI.STYLE.reset_all}          \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}cd projects${ANSI.STYLE.no_italic + ANSI.FG.blue} to view project info.${ANSI.STYLE.reset_all}   \r\n  ${ANSI.STYLE.bold + ANSI.FG.blue}Type ${ANSI.PREFABS.program_name}bugreport${ANSI.STYLE.no_italic + ANSI.FG.blue} to open the bug reporter.${ANSI.STYLE.reset_all} \r\n`.replace(/\\n/g, NEWLINE);\r\n\r\n    const absolute_motd = fs.absolute(\"/etc/motd.txt\");\r\n    if (!(await fs.exists(absolute_motd))) {\r\n        await fs.write_file(absolute_motd, motd_content);\r\n    }\r\n};\r\n\r\nconst migrate_rc_profile = async (fs: AbstractFileSystem) => {\r\n    // if .ollie_profile exists, and .ash_profile doesn't, rename it to .ash_profile\r\n    const absolute_ollie_profile = fs.absolute(\"~/.ollie_profile\");\r\n    const absolute_ash_profile = fs.absolute(\"~/.ash_profile\");\r\n    if (await fs.exists(absolute_ollie_profile) && !(await fs.exists(absolute_ash_profile))) {\r\n        await fs.move_file(absolute_ollie_profile, absolute_ash_profile);\r\n    }\r\n\r\n    // if .ollierc exists, and .ashrc doesn't, rename it to .ashrc\r\n    const absolute_ollierc = fs.absolute(\"~/.ollierc\");\r\n    const absolute_ashrc = fs.absolute(\"~/.ashrc\");\r\n    if (await fs.exists(absolute_ollierc) && !(await fs.exists(absolute_ashrc))) {\r\n        await fs.move_file(absolute_ollierc, absolute_ashrc);\r\n    }\r\n};\r\n\r\nconst setup_credits = async (fs: AbstractFileSystem) => {\r\n    // create credits file\r\n    const credits_content = `\r\nCredits\r\n=======\r\n\r\nThis website was created by obfuscatedgenerated using the following technologies:\r\n\r\n- TypeScript\r\n- xterm.js\r\n- Handlebars.js\r\n- Webpack\r\n\r\nAs well as the following libraries:\r\n\r\n- imgToAscii (modified)\r\n- node-sixel\r\n- @xterm/addon-fit\r\n- @xterm/addon-web-links\r\n- @xterm/addon-image\r\n- xterm-link-provider\r\n- howler.js\r\n- html-to-text\r\n- some code from rss-parser (modified)\r\n\r\nPlease consult https://ollieg.codes/public/script/3rdpartylicenses.txt for full license information.\r\n\r\nAdditionally, fsedit uses:\r\n\r\n- Font Awesome\r\n\r\nThe source code is available on GitHub at https://github.com/obfuscatedgenerated/obfuscatedgenerated.github.io.\r\n`.replace(/\\n/g, NEWLINE);\r\n\r\n    // only overwrite the file if it doesn't exist or the content is different\r\n    const absolute_credits = fs.absolute(\"~/credits.txt\");\r\n    if (!(await fs.exists(absolute_credits)) || await fs.read_file(absolute_credits) !== credits_content) {\r\n        await fs.write_file(absolute_credits, credits_content, true);\r\n        await fs.set_readonly(absolute_credits, true);\r\n    }\r\n};\r\n\r\n// syncs the data repository from the data service (data.ollieg.codes)\r\nconst setup_data_repo = async (fs: AbstractFileSystem) => {\r\n    console.log(\"Syncing data repository...\");\r\n\r\n    // check if data dir exists locally\r\n    const data_dir = fs.absolute(\"/var/lib/data\");\r\n    let existing_rev = \"\";\r\n    if (!(await fs.dir_exists(data_dir))) {\r\n        await fs.make_dir(data_dir);\r\n    } else {\r\n        // read the existing revision from version.json\r\n        const version_file = fs.join(data_dir, \"version.json\");\r\n        if (await fs.exists(version_file)) {\r\n            const version_data = JSON.parse(await fs.read_file(version_file) as string);\r\n            existing_rev = version_data.rev;\r\n        }\r\n    }\r\n\r\n    try {\r\n        // fetch the latest revision from the data service\r\n        const svc_version = await fetch(\"https://data.ollieg.codes/version.json\").then(res => res.json());\r\n        const latest_rev = svc_version.rev;\r\n\r\n        // if the revisions match, no need to update\r\n        if (existing_rev === latest_rev) {\r\n            console.log(\"Data repository is already up to date.\");\r\n            return;\r\n        }\r\n\r\n        // back up existing data folder\r\n        const possible_backup_dir = fs.absolute(`/var/lib/.data.old_${existing_rev}`);\r\n        if (existing_rev) {\r\n            await fs.move_dir(data_dir, possible_backup_dir);\r\n            await fs.make_dir(data_dir);\r\n        }\r\n\r\n        // fetch the index file\r\n        const index = await fetch(\"https://data.ollieg.codes/index.json\").then(res => res.json());\r\n\r\n        // check if the index file has the optional \"groups\" field\r\n        if (!index.groups) {\r\n            throw new Error(\"Index file is missing 'groups' field.\");\r\n        }\r\n\r\n        // write the index and version file to the data folder\r\n        await fs.write_file(fs.join(data_dir, \"index.json\"), JSON.stringify(index, null, 2), true);\r\n        await fs.write_file(fs.join(data_dir, \"version.json\"), JSON.stringify(svc_version, null, 2), true);\r\n\r\n        // for each group, fetch the index and then fetch each file listed in its index\r\n        for (const group of index.groups) {\r\n            console.log(`Syncing data group: ${group}`);\r\n\r\n            // ensure the group directory exists\r\n            const group_dir = fs.join(data_dir, group);\r\n            if (!(await fs.dir_exists(group_dir))) {\r\n                await fs.make_dir(group_dir);\r\n            }\r\n\r\n            // fetch the group index\r\n            const group_index = await fetch(`https://data.ollieg.codes/${group}/index.json`).then(res => res.json());\r\n\r\n            // ensure the group index is an array\r\n            if (!Array.isArray(group_index)) {\r\n                throw new Error(`Group index for ${group} is not an array.`);\r\n            }\r\n\r\n            // write the group index to the group folder\r\n            await fs.write_file(fs.join(group_dir, \"index.json\"), JSON.stringify(group_index, null, 2), true);\r\n\r\n            // for each file in the group index, fetch the file and write it to the data folder\r\n            for (const entry of group_index) {\r\n                console.log(`  Fetching file: ${entry}.json`);\r\n\r\n                const file_data = await fetch(`https://data.ollieg.codes/${group}/${entry}.json`).then(res => res.text());\r\n                const file_path = fs.join(group_dir, `${entry}.json`);\r\n\r\n                await fs.write_file(file_path, file_data, true);\r\n            }\r\n        }\r\n\r\n        console.log(\"Data repository synced successfully.\");\r\n\r\n        // delete backup if exists\r\n        if (await fs.dir_exists(possible_backup_dir)) {\r\n            await fs.delete_dir(possible_backup_dir, true);\r\n        }\r\n\r\n        // return new rev\r\n        return latest_rev;\r\n    } catch (e) {\r\n        console.error(\"Failed to sync data repository:\");\r\n        console.error(e);\r\n\r\n        // restore backup if exists\r\n        const possible_backup_dir = fs.absolute(`/var/lib/.data.old_${existing_rev}`);\r\n        if (await fs.dir_exists(possible_backup_dir)) {\r\n            console.error(\"Restoring backup...\");\r\n            await fs.move_dir(data_dir, fs.absolute(\"/var/lib/data.discard\"));\r\n            await fs.move_dir(possible_backup_dir, data_dir);\r\n            await fs.delete_dir(fs.absolute(\"/var/lib/data.discard\"), true);\r\n        } else {\r\n            // just delete the data dir in progress to prevent partial data\r\n            await fs.delete_dir(data_dir, true);\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nconst fetch_file_with_ttl = async (url: string, skip_cache: boolean) => {\r\n    // check if url exists in TTL cache\r\n    const ttl_cache = localStorage.getItem(\"fetch_ttl_cache\");\r\n    const ttl_cache_obj = ttl_cache ? JSON.parse(ttl_cache) : {};\r\n\r\n    // if the url's TTL hasn't expired, don't fetch the file\r\n    // saves time acquiring heavy files at startup whilst still allowing for updates at some point\r\n    if (!skip_cache && ttl_cache_obj[url]) {\r\n        if (ttl_cache_obj[url] > Date.now()) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // fetch the file and convert it to a Uint8Array\r\n    const response = await fetch(url);\r\n    const array_buffer = await response.arrayBuffer();\r\n\r\n    // add the url to the TTL cache\r\n    ttl_cache_obj[url] = Date.now() + 1000 * 60 * 60 * 24 * 7; // 1 week\r\n    localStorage.setItem(\"fetch_ttl_cache\", JSON.stringify(ttl_cache_obj));\r\n\r\n    return new Uint8Array(array_buffer);\r\n};\r\n\r\nconst generate_project_folder = async (fs: AbstractFileSystem, base_dir: string, data_projects_dir: string, project_entry: string, project_data: any = null): Promise<boolean> => {\r\n    console.log(`Generating project folder for ${project_entry}...`);\r\n\r\n    const project_dir = fs.join(base_dir, project_entry);\r\n    await fs.make_dir(project_dir);\r\n\r\n    // generate info.txt\r\n    const info_content = `\r\n${project_data.name}\r\n=${\"=\".repeat(project_data.name.length)}\r\n\r\n${project_data.primary_language ? `Primary Language: ${project_data.primary_language}\\n\\n` : \"\"}${project_data.description}\r\n${project_data.live_url ? `\\nLive URL: ${project_data.live_url}` : \"\"}${project_data.repo_url ? `\\nRepository: ${project_data.repo_url}` : \"\"}\r\n`.replace(/\\n/g, NEWLINE).trim();\r\n\r\n    await fs.write_file(fs.join(project_dir, \"info.txt\"), NEWLINE + info_content + NEWLINE, true);\r\n\r\n    // download image with ttl if defined\r\n    // not a fatal failure so don't return false on failure\r\n    if (project_data.image) {\r\n        const file_ext_regex = /\\.([a-zA-Z0-9]+)(?:\\?|$)/;\r\n        const match = project_data.image.match(file_ext_regex);\r\n\r\n        // if theres no file extension, default to png bc why not :)\r\n        const image_ext = match ? match[1] : \"png\";\r\n        if (image_ext) {\r\n            const absolute_file = fs.join(project_dir, `image.${image_ext}`);\r\n            let content: Uint8Array | null;\r\n\r\n            try {\r\n                // if the file doesn't exist, skip the TTL cache\r\n                const skip_cache = !(await fs.exists(absolute_file));\r\n\r\n                // fetch the file if TTL cache is expired or doesn't exist\r\n                content = await fetch_file_with_ttl(project_data.image, skip_cache);\r\n\r\n                // write the file if content is not null\r\n                if (content) {\r\n                    await fs.write_file(absolute_file, content, true);\r\n                }\r\n            } catch (e) {\r\n                console.error(`Failed to fetch image for project ${project_entry}:`);\r\n                console.error(e);\r\n            }\r\n        } else {\r\n            console.warn(`Project image for ${project_entry} has unsupported file extension; skipping image.`);\r\n        }\r\n    }\r\n\r\n    console.log(`Project folder for ${project_entry} generated successfully.`);\r\n\r\n    // recurse for sub_projects\r\n    if (project_data.sub_projects && Array.isArray(project_data.sub_projects)) {\r\n        for (const sub_project_entry of project_data.sub_projects) {\r\n            const success = await generate_project_folder(fs, project_dir, data_projects_dir, sub_project_entry.name, sub_project_entry);\r\n            if (!success) {\r\n                console.error(`Failed to generate sub-project folder for ${sub_project_entry}`);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nconst setup_projects = async (fs: AbstractFileSystem, data_rev: string | null) => {\r\n    // if data_rev is null, try read it from the data repo\r\n    if (!data_rev) {\r\n        try {\r\n            const version_file = fs.absolute(\"/var/lib/data/version.json\");\r\n            if (await fs.exists(version_file)) {\r\n                const version_data = JSON.parse(await fs.read_file(version_file) as string);\r\n                data_rev = version_data.rev;\r\n            } else {\r\n                throw new Error(\"Version file does not exist.\");\r\n            }\r\n        } catch (e) {\r\n            console.error(\"Failed to read data revision from data repository:\");\r\n            console.error(e);\r\n            data_rev = null;\r\n        }\r\n    }\r\n\r\n    // if data rev is still null, skip project setup\r\n    if (!data_rev) {\r\n        console.warn(\"Data repo not synced; skipping project setup.\");\r\n        return;\r\n    }\r\n\r\n    // create projects directory if it doesn't exist\r\n    const absolute_projects = fs.absolute(\"~/projects\");\r\n    let project_rev = \"\";\r\n    if (!(await fs.dir_exists(absolute_projects))) {\r\n        await fs.make_dir(absolute_projects);\r\n    } else {\r\n        // read the existing revision from the hidden .rev file\r\n        const version_file = fs.join(absolute_projects, \".rev\");\r\n        if (await fs.exists(version_file)) {\r\n            project_rev = await fs.read_file(version_file) as string;\r\n        }\r\n    }\r\n\r\n    // if the revisions match, no need to update\r\n    if (project_rev === data_rev) {\r\n        console.log(\"Projects are already up to date.\");\r\n        return;\r\n    }\r\n\r\n    // back up existing projects folder\r\n    const possible_backup_dir = fs.absolute(`~/.projects.old_${project_rev}`);\r\n    if (project_rev) {\r\n        await fs.move_dir(absolute_projects, possible_backup_dir);\r\n        await fs.make_dir(absolute_projects);\r\n    }\r\n\r\n    try {\r\n        // for each project in the data repo, convert the json to the file structure in the projects folder\r\n        const data_projects_dir = fs.absolute(\"/var/lib/data/project\");\r\n        const project_index_file = fs.join(data_projects_dir, \"index.json\");\r\n\r\n        if (!(await fs.exists(project_index_file))) {\r\n            throw new Error(\"Project index file does not exist in data repository.\");\r\n        }\r\n\r\n        const projects = JSON.parse(await fs.read_file(project_index_file) as string);\r\n        if (!Array.isArray(projects)) {\r\n            throw new Error(\"Project index file is not an array.\");\r\n        }\r\n\r\n        for (const project_entry of projects) {\r\n            console.log(`Setting up project: ${project_entry}`);\r\n\r\n            const project_file = fs.join(data_projects_dir, `${project_entry}.json`);\r\n            if (!(await fs.exists(project_file))) {\r\n                console.warn(`Project file for ${project_entry} does not exist; skipping.`);\r\n                return false;\r\n            }\r\n\r\n            const project_data = JSON.parse(await fs.read_file(project_file) as string);\r\n\r\n            const success = await generate_project_folder(fs, absolute_projects, data_projects_dir, project_entry, project_data);\r\n            if (!success) {\r\n                // TODO: is it better to still keep partial data or throw an error?\r\n                throw new Error(`Failed to generate project folder for ${project_entry}`);\r\n            }\r\n        }\r\n\r\n        // write the new revision to the hidden .rev file\r\n        const version_file = fs.join(absolute_projects, \".rev\");\r\n        await fs.write_file(version_file, data_rev, true);\r\n\r\n        console.log(\"Projects set up successfully.\");\r\n    } catch (e) {\r\n        console.error(\"Failed to set up projects:\");\r\n        console.error(e);\r\n\r\n        // restore backup if exists\r\n        if (await fs.dir_exists(possible_backup_dir)) {\r\n            console.error(\"Restoring backup...\");\r\n            await fs.move_dir(absolute_projects, fs.absolute(\"~/projects.discard\"));\r\n            await fs.move_dir(possible_backup_dir, absolute_projects);\r\n            await fs.delete_dir(fs.absolute(\"~/projects.discard\"), true);\r\n        } else {\r\n            // just delete the projects dir in progress to prevent partial data\r\n            await fs.delete_dir(absolute_projects, true);\r\n        }\r\n\r\n        return;\r\n    }\r\n};\r\n\r\nexport const initial_fs_setup = async (fs: AbstractFileSystem) => {\r\n    await setup_boot(fs);\r\n    await setup_motd(fs);\r\n    await migrate_rc_profile(fs);\r\n    await setup_credits(fs);\r\n\r\n\r\n    const latest_rev = await setup_data_repo(fs);\r\n    await setup_projects(fs, latest_rev);\r\n};\r\n","export type WindowEvent = \"close\" | \"hide\" | \"show\" | \"focus\" | \"move\" | \"rename\" | \"resize\" | \"maximise\" | \"restore\";\r\n\r\nexport interface UserspaceOtherWindow {\r\n    readonly id: number;\r\n    readonly manager: UserspaceWindowManager;\r\n    readonly owner_pid: number;\r\n\r\n    readonly title: string;\r\n    readonly width: string;\r\n    readonly height: string;\r\n    readonly x: string | number;\r\n    readonly y: string | number;\r\n    readonly visible: boolean;\r\n    readonly maximised: boolean;\r\n}\r\n\r\nexport interface UserspaceWindow extends UserspaceOtherWindow {\r\n    readonly manager: UserspaceWindowManager;\r\n    readonly dom: ShadowRoot;\r\n\r\n    title: string;\r\n    width: string;\r\n    height: string;\r\n    x: string | number;\r\n    y: string | number;\r\n\r\n    visible: boolean;\r\n    maximised: boolean;\r\n\r\n    center(): void;\r\n    focus(): void;\r\n    show(): void;\r\n    hide(): void;\r\n    toggle(): void;\r\n    close(): void;\r\n\r\n    add_event_listener(event: WindowEvent, callback: () => void): void;\r\n    wait_for_event(event: WindowEvent): Promise<void>;\r\n}\r\n\r\nexport abstract class AbstractWindow {\r\n    abstract readonly id: number;\r\n\r\n    // TODO: more generic type somehow? depends if we ever need implementations that dont use shadow DOM\r\n    abstract readonly dom: ShadowRoot;\r\n\r\n    abstract readonly manager: AbstractWindowManager;\r\n\r\n    abstract moveable: boolean;\r\n\r\n    abstract resizable: boolean;\r\n\r\n    abstract maximisable: boolean;\r\n    abstract maximised: boolean;\r\n\r\n    private readonly _owner_pid: number;\r\n\r\n    protected constructor(owner_pid: number) {\r\n        this._owner_pid = owner_pid;\r\n    }\r\n\r\n    get owner_pid(): number {\r\n        return this._owner_pid;\r\n    }\r\n\r\n    abstract get title(): string;\r\n    abstract set title(new_title: string);\r\n\r\n    abstract get width(): string;\r\n    abstract set width(css_width: string);\r\n\r\n    abstract get height(): string;\r\n    abstract set height(css_height: string);\r\n\r\n    // number to be interpreted as pixels\r\n    abstract get x(): string | number;\r\n    abstract set x(css_pos: string | number);\r\n\r\n    // number to be interpreted as pixels\r\n    abstract get y(): string | number;\r\n    abstract set y(css_pos: string | number);\r\n\r\n    abstract center(): void;\r\n\r\n    abstract get visible(): boolean;\r\n    abstract set visible(is_visible: boolean);\r\n\r\n    abstract add_event_listener(event: WindowEvent, callback: () => Promise<void> | void): void;\r\n\r\n    abstract remove_event_listener(event: WindowEvent, callback: () => Promise<void> | void): void;\r\n\r\n    abstract dispose(): void;\r\n\r\n    abstract close(): void;\r\n\r\n    abstract focus(): void;\r\n\r\n    abstract show(): void;\r\n    abstract hide(): void;\r\n    abstract toggle(): void;\r\n\r\n    // best effort flags, may not be supported by all implementations (e.g. transparent flag)\r\n    abstract get_custom_flag(flag: string): boolean;\r\n    abstract set_custom_flag(flag: string, value: boolean): void;\r\n\r\n    abstract wait_for_event(event: WindowEvent): Promise<void>;\r\n\r\n    create_userspace_proxy_as_other_window(): UserspaceOtherWindow {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        Object.defineProperties(proxy, {\r\n            id: { get: () => self.id, enumerable: true },\r\n            manager: { get: () => self.manager.create_userspace_proxy(), enumerable: true },\r\n            owner_pid: { get: () => self.owner_pid, enumerable: true },\r\n            title: { get: () => self.title, enumerable: true },\r\n            width: { get: () => self.width, enumerable: true },\r\n            height: { get: () => self.height, enumerable: true },\r\n            x: { get: () => self.x, enumerable: true },\r\n            y: { get: () => self.y, enumerable: true },\r\n            visible: { get: () => self.visible, enumerable: true },\r\n            maximised: { get: () => self.maximised, enumerable: true }\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n\r\n    create_userspace_proxy_as_full_window(): UserspaceWindow {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        const manager_proxy = self.manager.create_userspace_proxy();\r\n\r\n        Object.defineProperties(proxy, {\r\n            id: { get: () => self.id, enumerable: true },\r\n            manager: { get: () => manager_proxy, enumerable: true },\r\n            owner_pid: { get: () => self.owner_pid, enumerable: true },\r\n            dom: { get: () => self.dom, enumerable: true },\r\n            title: {\r\n                get: () => self.title,\r\n                set: (new_title: string) => { self.title = new_title; },\r\n                enumerable: true\r\n            },\r\n            width: {\r\n                get: () => self.width,\r\n                set: (css_width: string) => { self.width = css_width; },\r\n                enumerable: true\r\n            },\r\n            height: {\r\n                get: () => self.height,\r\n                set: (css_height: string) => { self.height = css_height; },\r\n                enumerable: true\r\n            },\r\n            x: {\r\n                get: () => self.x,\r\n                set: (css_pos: string | number) => { self.x = css_pos; },\r\n                enumerable: true\r\n            },\r\n            y: {\r\n                get: () => self.y,\r\n                set: (css_pos: string | number) => { self.y = css_pos; },\r\n                enumerable: true\r\n            },\r\n            visible: {\r\n                get: () => self.visible,\r\n                set: (is_visible: boolean) => { self.visible = is_visible; },\r\n                enumerable: true\r\n            },\r\n            maximised: { get: () => self.maximised, enumerable: true },\r\n            center: { value: () => { self.center(); }, enumerable: true },\r\n            focus: { value: () => { self.focus(); }, enumerable: true },\r\n            show: { value: () => { self.show(); }, enumerable: true },\r\n            hide: { value: () => { self.hide(); }, enumerable: true },\r\n            toggle: { value: () => { self.toggle(); }, enumerable: true },\r\n            close: { value: () => { self.close(); }, enumerable: true },\r\n            add_event_listener: { value: (event: WindowEvent, callback: () => void) => { self.add_event_listener(event, callback); }, enumerable: true },\r\n            wait_for_event: { value: (event: WindowEvent) => self.wait_for_event(event), enumerable: true }\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\nexport interface UserspaceWindowManager {\r\n    get_unique_manager_type_name(): string;\r\n    get_all_windows(): UserspaceOtherWindow[];\r\n    get_window_by_id(id: number): UserspaceOtherWindow | null;\r\n}\r\n\r\nexport abstract class AbstractWindowManager {\r\n    abstract get_unique_manager_type_name(): string;\r\n\r\n    abstract get Window(): new (owner_pid: number) => AbstractWindow;\r\n\r\n    abstract get_all_windows(): AbstractWindow[];\r\n\r\n    abstract get_window_by_id(id: number): AbstractWindow | null;\r\n\r\n    abstract dispose_all(): void;\r\n\r\n    create_userspace_proxy(): UserspaceWindowManager {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        const proxy = Object.create(null);\r\n\r\n        Object.defineProperties(proxy, {\r\n            get_unique_manager_type_name: { value: () => self.get_unique_manager_type_name(), enumerable: true },\r\n            get_all_windows: {\r\n                value: () => self.get_all_windows().map((win) => win.create_userspace_proxy_as_other_window()),\r\n                enumerable: true\r\n            },\r\n            get_window_by_id: {\r\n                value: (id: number) => {\r\n                    const win = self.get_window_by_id(id);\r\n                    return win ? win.create_userspace_proxy_as_other_window() : null;\r\n                },\r\n                enumerable: true\r\n            }\r\n        });\r\n\r\n        return Object.freeze(proxy);\r\n    }\r\n}\r\n\r\n// TODO: use separate interfaces so that only the process registry can create windows\r\n","import {AbstractWindow, AbstractWindowManager, WindowEvent} from \"../windowing\";\r\n\r\nexport class DOMWindowManager extends AbstractWindowManager {\r\n    #top_z_index = 10;\r\n\r\n    #window_id_counter = 1;\r\n    readonly #window_map: Map<number, AbstractWindow> = new Map();\r\n\r\n    readonly #WindowClass: new (owner_pid: number) => AbstractWindow;\r\n\r\n    get_unique_manager_type_name(): string {\r\n        return \"DOM\";\r\n    }\r\n\r\n    get Window() {\r\n        return this.#WindowClass;\r\n    }\r\n\r\n    get_all_windows = () => {\r\n        return Array.from(this.#window_map.values());\r\n    }\r\n\r\n    get_window_by_id = (id: number) => {\r\n        return this.#window_map.get(id) || null;\r\n    }\r\n\r\n    dispose_all() {\r\n        for (const window of this.#window_map.values()) {\r\n            window.dispose();\r\n        }\r\n\r\n        this.#window_map.clear();\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const manager = this;\r\n\r\n        class DOMWindow extends AbstractWindow {\r\n            private readonly _manager = manager;\r\n\r\n            private readonly _window_id: number;\r\n\r\n            private readonly _window_root: HTMLDivElement;\r\n            private readonly _window_top_bar: HTMLDivElement;\r\n            private readonly _window_top_bar_title: HTMLSpanElement;\r\n            private readonly _window_top_bar_maximise_button: HTMLButtonElement;\r\n\r\n            private readonly _content_host: HTMLDivElement;\r\n            private readonly _shadow_dom: ShadowRoot;\r\n\r\n            private readonly _event_listeners: Map<WindowEvent, Array<() => Promise<void>>> = new Map();\r\n\r\n            private _title_text = \"New Window\";\r\n\r\n            moveable = true;\r\n            resizable = true;\r\n\r\n            private _maximisable = true;\r\n            private _maximised = false;\r\n\r\n            private readonly _custom_flags: Set<string> = new Set();\r\n\r\n            get manager() {\r\n                return this._manager;\r\n            }\r\n\r\n            constructor(owner_pid: number) {\r\n                super(owner_pid);\r\n\r\n                this._window_id = manager.#window_id_counter++;\r\n\r\n                // contains the entire window\r\n                this._window_root = document.createElement(\"div\");\r\n                this._window_root.classList.add(\"window\");\r\n                this._window_root.role = \"dialog\";\r\n                this._window_root.ariaHidden = \"true\";\r\n                this._window_root.id = `window-${this._window_id}`;\r\n                document.body.appendChild(this._window_root);\r\n\r\n                this._window_root.style.zIndex = manager.#top_z_index.toString();\r\n                this._window_root.addEventListener(\"mousedown\", () => this.focus(), { capture: true });\r\n                window.addEventListener(\"blur\", () => this._handle_window_blur());\r\n\r\n                // draggable top bar containing title and controls\r\n                this._window_top_bar = document.createElement(\"div\");\r\n                this._window_top_bar.classList.add(\"window-top-bar\");\r\n                this._window_root.appendChild(this._window_top_bar);\r\n\r\n                this._window_top_bar_title = document.createElement(\"span\");\r\n                this._window_top_bar_title.classList.add(\"window-top-bar-title\");\r\n                this._window_top_bar_title.innerText = this._title_text;\r\n                this._window_top_bar_title.id = `${this._window_root.id}-title`;\r\n                this._window_top_bar.appendChild(this._window_top_bar_title);\r\n                this._window_root.setAttribute(\"aria-labelledby\", this._window_top_bar_title.id);\r\n\r\n                const top_bar_controls = document.createElement(\"div\");\r\n                top_bar_controls.classList.add(\"window-top-bar-controls\");\r\n                top_bar_controls.addEventListener(\"mousedown\", (e) => e.stopPropagation());\r\n                this._window_top_bar.appendChild(top_bar_controls);\r\n\r\n                const minimise_button = document.createElement(\"button\");\r\n                minimise_button.title = \"Minimise window\";\r\n                minimise_button.classList.add(\"window-button\", \"window-minimise-button\");\r\n                minimise_button.innerText = \"\";\r\n                minimise_button.addEventListener(\"click\", () => this.hide());\r\n\r\n                this._window_top_bar_maximise_button = document.createElement(\"button\");\r\n                this._window_top_bar_maximise_button.title = \"Maximise window\";\r\n                this._window_top_bar_maximise_button.classList.add(\"window-button\", \"window-maximise-button\");\r\n                this._window_top_bar_maximise_button.innerText = \"\";\r\n                this._window_top_bar_maximise_button.addEventListener(\"click\", (ev) => {\r\n                    if (!this.maximisable) {\r\n                        return;\r\n                    }\r\n\r\n                    this.maximised = !this.maximised;\r\n                });\r\n\r\n                const close_button = document.createElement(\"button\");\r\n                close_button.title = \"Close window\";\r\n                close_button.classList.add(\"window-button\", \"window-close-button\");\r\n                close_button.innerText = \"\";\r\n                close_button.addEventListener(\"click\", this.close.bind(this));\r\n\r\n                top_bar_controls.appendChild(minimise_button);\r\n                top_bar_controls.appendChild(this._window_top_bar_maximise_button);\r\n                top_bar_controls.appendChild(close_button);\r\n\r\n                this._window_top_bar.addEventListener(\"mousedown\", (e) => this._start_drag(e));\r\n\r\n                // hosts the shadow dom where programs can add their content\r\n                this._content_host = document.createElement(\"div\");\r\n                this._content_host.classList.add(\"window-content-host\");\r\n\r\n                this._shadow_dom = this._content_host.attachShadow({ mode: \"closed\" });\r\n\r\n                this._window_root.appendChild(this._content_host);\r\n\r\n                // TODO: resize handles\r\n                // TODO: way to prevent windows existing when the program that created them exits? or is that not needed? theyll have to run background tasks to allow multitasking anyway\r\n\r\n                manager.#window_map.set(this._window_id, this);\r\n            }\r\n\r\n            get id() {\r\n                return this._window_id;\r\n            }\r\n\r\n            dispose() {\r\n                this._window_root.remove();\r\n                manager.#window_map.delete(this._window_id);\r\n            }\r\n\r\n            close() {\r\n                this._window_root.classList.add(\"animating-close\");\r\n                this._window_root.ariaHidden = \"true\";\r\n\r\n                this._emit_event(\"close\");\r\n\r\n                setTimeout(() => {\r\n                    this.dispose();\r\n                }, 200);\r\n            }\r\n\r\n            focus() {\r\n                this._emit_event(\"focus\");\r\n\r\n                manager.#top_z_index += 1;\r\n                this._window_root.style.zIndex = manager.#top_z_index.toString();\r\n            }\r\n\r\n            private _handle_window_blur() {\r\n                // TODO: fix for when focus jumps between iframes inside the window, this doesnt fire in that case\r\n\r\n                setTimeout(() => {\r\n                    if (document.activeElement === this._content_host) {\r\n                        this.focus();\r\n                    }\r\n                }, 0);\r\n            }\r\n\r\n            private async _emit_event(event: WindowEvent) {\r\n                if (!this._event_listeners.has(event)) {\r\n                    return;\r\n                }\r\n\r\n                const listeners = this._event_listeners.get(event)!;\r\n                await Promise.all(listeners.map(callback => callback()));\r\n            }\r\n\r\n            private _start_drag(start_event: MouseEvent) {\r\n                if (!this.moveable) {\r\n                    return;\r\n                }\r\n\r\n                this._content_host.classList.add(\"dragging\");\r\n\r\n                start_event.preventDefault();\r\n\r\n                const rect = this._window_root.getBoundingClientRect();\r\n                let offset_x = start_event.clientX - rect.left;\r\n                const offset_y = start_event.clientY - rect.top;\r\n\r\n                const mouse_move = (move_event: MouseEvent) => {\r\n                    move_event.preventDefault();\r\n\r\n                    if (this._maximised) {\r\n                        // break out of maximised, restoring size but not position\r\n                        this.maximised = false;\r\n\r\n                        // adjust offset_x to account for new window size\r\n                        const new_rect = this._window_root.getBoundingClientRect();\r\n                        const width_ratio = offset_x / rect.width;\r\n                        offset_x = new_rect.width * width_ratio;\r\n                    }\r\n\r\n                    this._window_root.style.left = `${move_event.clientX - offset_x}px`;\r\n                    this._window_root.style.top = `${move_event.clientY - offset_y}px`;\r\n\r\n                    this._emit_event(\"move\");\r\n                };\r\n\r\n                const mouse_up = (up_event: MouseEvent) => {\r\n                    document.removeEventListener(\"mousemove\", mouse_move);\r\n                    document.removeEventListener(\"mouseup\", mouse_up);\r\n\r\n                    this._content_host.classList.remove(\"dragging\");\r\n\r\n                    if (!this._maximised) {\r\n                        // if the mouse is at the top of the screen, maximise the window\r\n                        if (up_event.clientY <= 0 && this._maximisable) {\r\n                            this.maximised = true;\r\n                        }\r\n                    }\r\n\r\n                    // TODO: right and left side snapping to half the screen\r\n\r\n                    // if the rect is out of the top when released, snap it back in\r\n                    if (this._window_root.getBoundingClientRect().top < 0) {\r\n                        this._window_root.style.top = \"0px\";\r\n                    }\r\n                };\r\n\r\n                document.addEventListener(\"mousemove\", mouse_move);\r\n                document.addEventListener(\"mouseup\", mouse_up);\r\n            }\r\n\r\n            add_event_listener(event: WindowEvent, callback: () => Promise<void>) {\r\n                if (!this._event_listeners.has(event)) {\r\n                    this._event_listeners.set(event, []);\r\n                }\r\n\r\n                this._event_listeners.get(event)!.push(callback);\r\n            }\r\n\r\n            remove_event_listener(event: WindowEvent, callback: () => Promise<void>) {\r\n                if (!this._event_listeners.has(event)) {\r\n                    return;\r\n                }\r\n\r\n                const listeners = this._event_listeners.get(event)!;\r\n                const index = listeners.indexOf(callback);\r\n                if (index !== -1) {\r\n                    listeners.splice(index, 1);\r\n                }\r\n            }\r\n\r\n            get title() {\r\n                return this._title_text;\r\n            }\r\n\r\n            set title(new_title: string) {\r\n                this._window_top_bar_title.innerText = new_title;\r\n                this._title_text = new_title;\r\n\r\n                this._emit_event(\"rename\");\r\n            }\r\n\r\n            get width() {\r\n                return this._window_root.style.width;\r\n            }\r\n\r\n            set width(css_width: string) {\r\n                this._window_root.style.width = css_width;\r\n            }\r\n\r\n            get height() {\r\n                return this._window_root.style.height;\r\n            }\r\n\r\n            set height(css_height: string) {\r\n                this._window_root.style.height = css_height;\r\n            }\r\n\r\n            get maximisable() {\r\n                return this._maximisable;\r\n            }\r\n\r\n            set maximisable(value: boolean) {\r\n                this._maximisable = value;\r\n                this._window_top_bar_maximise_button.disabled = !value;\r\n            }\r\n\r\n            get maximised() {\r\n                return this._maximised;\r\n            }\r\n\r\n            set maximised(value: boolean) {\r\n                this._maximised = value;\r\n                this._window_root.classList.toggle(\"maximised\", value);\r\n\r\n                if (value) {\r\n                    this._window_top_bar_maximise_button.innerText = \"\";\r\n                    this._window_top_bar_maximise_button.title = \"Restore window\";\r\n\r\n                    this._emit_event(\"maximise\");\r\n                } else {\r\n                    this._window_top_bar_maximise_button.innerText = \"\";\r\n                    this._window_top_bar_maximise_button.title = \"Maximise window\";\r\n\r\n                    this._emit_event(\"restore\");\r\n                }\r\n            }\r\n\r\n            get x() {\r\n                return this._window_root.style.left;\r\n            }\r\n\r\n            set x(css_pos: string | number) {\r\n                if (typeof css_pos === \"number\") {\r\n                    css_pos = `${css_pos}px`;\r\n                }\r\n\r\n                this._window_root.style.left = css_pos;\r\n            }\r\n\r\n            get y() {\r\n                return this._window_root.style.top;\r\n            }\r\n\r\n            set y(css_pos: string | number) {\r\n                if (typeof css_pos === \"number\") {\r\n                    css_pos = `${css_pos}px`;\r\n                }\r\n\r\n                this._window_root.style.top = css_pos;\r\n            }\r\n\r\n            center() {\r\n                this.x = `calc(calc(100vw - ${this.width}) / 2)`;\r\n                this.y = `calc(calc(100vh - ${this.height}) / 2)`;\r\n            }\r\n\r\n            get dom() {\r\n                return this._shadow_dom;\r\n            }\r\n\r\n            show() {\r\n                this._window_root.classList.remove(\"animating-out\");\r\n                this._window_root.classList.add(\"visible\", \"animating-in\");\r\n                this._window_root.ariaHidden = \"false\";\r\n\r\n                setTimeout(() => {\r\n                    this._window_root.classList.remove(\"animating-in\");\r\n                }, 200);\r\n\r\n                this._emit_event(\"show\");\r\n            }\r\n\r\n            hide() {\r\n                this._window_root.classList.remove(\"animating-in\");\r\n                this._window_root.classList.add(\"animating-out\");\r\n                this._window_root.ariaHidden = \"true\";\r\n\r\n                setTimeout(() => {\r\n                    this._window_root.classList.remove(\"visible\", \"animating-out\");\r\n                }, 200);\r\n\r\n                this._emit_event(\"hide\");\r\n            }\r\n\r\n            toggle() {\r\n                this._window_root.classList.toggle(\"visible\");\r\n\r\n                if (this.visible) {\r\n                    this._emit_event(\"show\");\r\n                } else {\r\n                    this._emit_event(\"hide\");\r\n                }\r\n            }\r\n\r\n            get visible() {\r\n                return this._window_root.classList.contains(\"visible\");\r\n            }\r\n\r\n            set visible(is_visible: boolean) {\r\n                if (is_visible) {\r\n                    this.show();\r\n                } else {\r\n                    this.hide();\r\n                }\r\n            }\r\n\r\n            get_custom_flag(flag: string) {\r\n                return this._custom_flags.has(flag);\r\n            }\r\n\r\n            set_custom_flag(flag: string, value: boolean) {\r\n                if (value) {\r\n                    this._custom_flags.add(flag);\r\n                } else {\r\n                    this._custom_flags.delete(flag);\r\n                }\r\n\r\n                switch (flag) {\r\n                    case \"transparent\":\r\n                        if (value) {\r\n                            this._content_host.classList.add(\"transparent\");\r\n                        } else {\r\n                            this._content_host.classList.remove(\"transparent\");\r\n                        }\r\n                        break;\r\n                    case \"no-top-bar\":\r\n                        if (value) {\r\n                            this._window_top_bar.classList.add(\"hidden\");\r\n                        } else {\r\n                            this._window_top_bar.classList.remove(\"hidden\");\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n\r\n            wait_for_event(event: WindowEvent): Promise<void> {\r\n                return new Promise((resolve) => {\r\n                    const callback = async () => {\r\n                        this.remove_event_listener(event, callback);\r\n                        resolve();\r\n                    };\r\n\r\n                    this.add_event_listener(event, callback);\r\n                });\r\n            }\r\n        }\r\n\r\n        this.#WindowClass = DOMWindow;\r\n    }\r\n}\r\n","// provides expected externals of pkgbuild programs into global\r\n\r\nimport * as howler from \"howler\";\r\nimport * as htmlToText from \"html-to-text\";\r\nimport * as sixel from \"sixel\";\r\nimport * as xterm from \"@xterm/xterm\";\r\n\r\nglobalThis.ollieos = {};\r\nglobalThis.howler = howler;\r\nglobalThis[\"html-to-text\"] = htmlToText;\r\nglobalThis.sixel = sixel;\r\nglobalThis[\"@xterm/xterm\"] = xterm;\r\n\r\n// support old xterm names\r\nglobalThis[\"xterm\"] = xterm;\r\n\r\nif (typeof window !== \"undefined\") {\r\n    console.log(\"Loading browser-specific global externals...\");\r\n\r\n    (async() => {\r\n        const fitAddon = await import(\"@xterm/addon-fit\");\r\n        const webLinksAddon = await import(\"@xterm/addon-web-links\");\r\n        const imageAddon = await import(\"@xterm/addon-image\");\r\n        const xtermLinkProvider = await import(\"xterm-link-provider\");\r\n\r\n        const sweetalert2 = await import(\"sweetalert2\");\r\n\r\n        globalThis[\"@xterm/addon-fit\"] = fitAddon;\r\n        globalThis[\"@xterm/addon-web-links\"] = webLinksAddon;\r\n        globalThis[\"@xterm/addon-image\"] = imageAddon;\r\n        globalThis[\"xterm-link-provider\"] = xtermLinkProvider;\r\n\r\n        globalThis.sweetalert2 = sweetalert2;\r\n\r\n        globalThis[\"xterm-addon-fit\"] = fitAddon;\r\n        globalThis[\"xterm-addon-web-links\"] = webLinksAddon;\r\n        globalThis[\"xterm-addon-image\"] = imageAddon;\r\n\r\n        console.log(\"Browser-specific global externals loaded successfully.\");\r\n    })();\r\n}\r\n","import { FitAddon } from \"@xterm/addon-fit\";\r\nimport { WebLinksAddon } from \"@xterm/addon-web-links\";\r\nimport { ImageAddon } from \"@xterm/addon-image\";\r\n\r\nimport {ANSI, NEWLINE, WrappedTerminal} from \"./term_ctl\";\r\n\r\nimport {Kernel} from \"./kernel\";\r\n\r\nimport {ProgramRegistry} from \"./prog_registry\";\r\nimport * as programs from \"./programs/@ALL\";\r\n\r\nimport { SoundRegistry } from \"./sfx_registry\";\r\n\r\nimport type {AbstractFileSystem} from \"./filesystem\";\r\nimport { LocalStorageFS } from \"./fs_impl/localstorage\";\r\nimport { OPFSFileSystem } from \"./fs_impl/opfs\";\r\nimport { initial_fs_setup } from \"./initial_fs_setup\";\r\n\r\nimport {DOMWindowManager} from \"./window_impl/dom\";\r\n\r\nimport \"./load_global_externals\";\r\n\r\nexport const boot_os = async (on_init_spawned?: (kernel: Kernel) => Promise<void>) => {\r\n    // create a program registry by importing all programs\r\n    const prog_reg = new ProgramRegistry();\r\n    for (const prog of Object.values(programs)) {\r\n        await prog_reg.registerProgram({\r\n            program: prog,\r\n            built_in: true,\r\n        });\r\n    }\r\n\r\n\r\n    // create a sound registry\r\n    const sfx_reg = new SoundRegistry();\r\n    sfx_reg.register_file(\"reader_on\", \"public/sfx/reader_on.mp3\");\r\n    sfx_reg.register_file(\"reader_off\", \"public/sfx/reader_off.mp3\");\r\n\r\n\r\n    // create a filesystem\r\n    // try opfs but use localstorage if not available, or already in use\r\n    // TODO migrate from localstorage to opfs automatically\r\n    let fs: AbstractFileSystem;\r\n    if (!localStorage.getItem(\"fs\") && navigator.storage && \"getDirectory\" in navigator.storage) {\r\n        fs = new OPFSFileSystem();\r\n    } else {\r\n        fs = new LocalStorageFS();\r\n    }\r\n\r\n    if (!(await fs.is_ready())) {\r\n        // poll every 10ms until ready\r\n        await new Promise<void>((resolve) => {\r\n            const interval = setInterval(async () => {\r\n                if (await fs.is_ready()) {\r\n                    clearInterval(interval);\r\n                    resolve();\r\n                }\r\n            }, 10);\r\n        });\r\n    }\r\n\r\n    // create initial files\r\n    await initial_fs_setup(fs);\r\n\r\n    // create a dom window manager\r\n    const wm = new DOMWindowManager();\r\n\r\n    // create a terminal using the registry and filesystem\r\n    const term = new WrappedTerminal({\r\n        screenReaderMode: false,\r\n        cursorBlink: true,\r\n    });\r\n\r\n    // load addons\r\n    const fit = new FitAddon();\r\n    term.loadAddon(fit);\r\n\r\n    term.loadAddon(new WebLinksAddon());\r\n\r\n    term.loadAddon(new ImageAddon());\r\n\r\n\r\n    // open the terminal\r\n    const render = <HTMLElement>document.querySelector(\"#terminal\");\r\n    term.open(render);\r\n    fit.fit();\r\n\r\n\r\n    // if this is a small screen, show a message\r\n    if (window.innerWidth < 600) {\r\n        const wrapped = term.word_wrap(`${ANSI.BG.red + ANSI.FG.white}Warning: The screen that the terminal is running on is rather small!${NEWLINE + NEWLINE}Some programs may not display correctly, consider using a larger screen such as a computer or tablet.${NEWLINE + NEWLINE}An alternative interface is in the works. You can also use the command \"legacy\" to view the old (outdated) site.${ANSI.STYLE.reset_all}`, term.cols);\r\n        term.writeln(wrapped);\r\n    }\r\n\r\n\r\n    // disable F1 help\r\n    window.addEventListener(\"keydown\", function (e) {\r\n        if (e.code === \"F1\") {\r\n            e.preventDefault();\r\n        }\r\n    });\r\n\r\n\r\n    // on resize, resize the terminal\r\n    window.addEventListener(\"resize\", () => {\r\n        fit.fit();\r\n    });\r\n\r\n\r\n    // bind right click to copy/paste\r\n    window.addEventListener(\"contextmenu\", (e) => {\r\n        e.preventDefault();\r\n        term.copy_or_paste();\r\n    });\r\n\r\n    // create the kernel\r\n    const kernel = new Kernel(term, fs, prog_reg, sfx_reg, wm);\r\n    kernel.set_env_info(document.body.dataset.version, \"web\");\r\n\r\n    // boot the kernel and check for a false return (indicating boot failure). should probably never return true as the os should hopefully always run!\r\n    return await kernel.boot(on_init_spawned);\r\n}\r\n"],"names":["NEWLINE","NON_PRINTABLE_REGEX","ANSI_ESCAPE_REGEX","ANSI_UNESCAPED_REGEX","FG","reset","black","red","green","yellow","blue","magenta","cyan","white","gray","STYLE","reset_all","bold","dim","no_bold_or_dim","italic","no_italic","underline","double_underline","no_underline","inverse","no_inverse","hidden","no_hidden","strikethrough","no_strikethrough","negative","positive","CURSOR","invisible","visible","ANSI","BG","PREFABS","program_name","error","variable_name","file_path","dir_name","secret","WrappedTerminal","Terminal","Map","ansi","newline","non_printable_regex","ansi_escape_regex","ansi_unescaped_regex","read_line","async","custom_key_handlers","custom_printable_handler","buffer","current_line","current_index","set_current_line","new_line","set_current_index","new_index","handler_dispose","Promise","resolve","handlers","_e","term","write","length","before","slice","after","repeat","this","register_key_event_handler","e","key","match","before_cursor","after_cursor","console","warn","block","high_priority","_search_handlers","domEventCode","strict","pair","entries","identfier","handler","props","identifier","keyString","entry","existing_entries","set","unshift","push","get","splice","indexOf","delete","_handle_key_event","all_key_entries","undefined","domEvent","code","register_on_printable_key_event_handler","_enqueue_key_event","_handle_key_event_queue","shift","wait_for_keypress","dispose","onKey","get_text","max_length","text","unregister_handler","word_wrap","width","lines","split","wrapped_lines","line","words","word","join","copy","navigator","clipboard","writeText","getSelection","then","clearSelection","paste","readText","char","dom_event_code","toUpperCase","copy_or_paste","hasSelection","handle_kernel_panic","message","process_info","debug_info","textarea","disabled","writeln","Date","toISOString","window","location","origin","constructor","xterm_opts","super","build_registrant_from_js","js_code","built_in","warn_deprecation","startsWith","data_url","encodeURIComponent","encode_js_to_url","program","import","default","Error","name","globalThis","OLLIEOS_NODE","node_opt_out","description","usage_suffix","arg_descriptions","main","async_main","old_main","data","determine_program_name_from_js","mount_and_register_with_output","filename","content","prog_reg","output_success","reg","endsWith","registerProgram","recurse_mount_and_register_with_output","fs","dir_path","prog_registry","list_dir","entry_path","dir_exists","read_file","ProgramRegistry","program_reg","has","getProgramRegistrant","getProgram","listProgramRegistrants","includes_builtin","includes_mounted","arr","Array","from","values","filter","listProgramNames","keys","listPrograms","map","forceUnregister","unregister","create_userspace_proxy","init_program","self","proxy","Object","create","check_protected","privilege_agent_program","trim","defineProperties","value","enumerable","inc_builtin","inc_mounted","freeze","PathNotFoundError","path","NonRecursiveDirectoryError","ReadOnlyError","FSEventType","AbstractFileSystem","_initialised","_root","_home","_cwd","purge_cache","smart","exists_direct","clear","force_remove_from_cache","remote_purge_cache","localStorage","setItem","toString","remote_remove_from_cache","getItem","removeItem","remove_from_cache","register_callback","event_type","callback","_call_callbacks","as_uint","READING_FILE","cached","exists","read_file_direct","readonly","is_readonly","write_file","force","Uint8Array","write_file_direct","WROTE_FILE","delete_file","delete_file_direct","DELETED_FILE","move_file","new_path","move_file_direct","MOVED_FILE","set_readonly","set_readonly_direct","SET_READONLY","is_readonly_direct","delete_dir","recursive","delete_dir_direct","move_dir","src","dest","no_overwrite","move_inside","move_dir_direct","get_cwd","GETTING_CWD","set_cwd","SET_CWD","get_home","GETTING_HOME","set_home","SET_HOME","get_root","GETTING_ROOT","set_root","SET_ROOT","CHECKING_EXISTS","absolute","includes","effective_cwd","lastIndexOf","base_dir","paths","setInterval","check_path","absolute_path","get_unique_fs_type_name","erase_all","dirs_first","base","make_dir","ProcessAttachment","SoundRegistry","register_howl","howl","ready","register_file","file","Howl","onload","await_ready","interval","reject","timer","clearInterval","play","is_ready","wait_to_play","log","IPCManager","process_manager","service","get_process","pid","channel_id","channel","initiator_process","initiator","peer_process","peer","dispose_all","service_register","on_connection","service_unregister","service_lookup","create_direct_channel","initiator_pid","peer_pid","initiator_to_peer_queue","peer_to_initiator_queue","listeners","create_channel","service_name","catch","err","reserve_kernel_channel","assign_kernel_channel","destroy_channel","channel_listen","listening_pid","listener","Set","add","channel_unlisten","channel_send","from_pid","msg","to","to_pid","process_pid","ProcessContext","FOREGROUND","source_command","registry","shell","run_in_bg","BACKGROUND","created_at","is_detached","DETACHED","is_background","is_foreground","attachment","detaches_silently","detach","silently","dispose_resources","forEach","id","clearTimeout","win","kill","exit_code","mark_terminated","add_exit_listener","create_timeout","delay","on_cancel","setTimeout","resolvers","cancel_timeout","cancel_callback","has_timeout","create_interval","has_interval","clear_interval","wait_for_timeout","create_window","wm","window_manager","Window","add_event_listener","create_userspace_proxy_as_other_process","ProcessManager","ipc_manager","process","create_process","context","list_pids","ipc_mgr_proxy","Kernel","version","env","panicked","get_program_registry","get_sound_registry","get_fs","get_window_manager","has_window_manager","get_process_manager","get_ipc","get_env_info","set_env_info","spawn","cmd_or_parse","explicit_args","start_privileged","parsed_line","command","args","unsubbed_args","raw_parts","compat","result_promise","kernel","completion","panic","proc_mgr","pids","proc","trimEnd","boot","on_init_spawned","usr_bin","init_args","init_parts","init","request_privilege","reason","agent_program","ipc","agent_proc","handling_request","approved","handling","granted","process_proxy","start_time","now","sound_registry","kernel_fs","proc_mgr_proxy","prog_reg_proxy","fs_proxy","SERVICES_DIR","CLEAN_EXIT_CODES","ServiceManager","load_service_files","service_files","file_name","file_content","service_data","JSON","parse","service_id","substring","existing_service_id","_calculate_service_start_order","visited","temp_mark","result","visit","dependencies","dep","start_initial_services","start_order","start_service","spawn_result","exec","_handle_service_exit","stop_service","restart_service","get_service_status","state","restart_policy","restart","on","delay_ms","hide_from_help","boot_target","boot_args","boot_target_parts","svc_mgr","payload","type","service_msg","action","status","current_tty_process","running","final_code","boot_target_proc","default_shell","default_shell_args","default_shell_parts","current_shell_process","shell_proc","AshMemory","current_history_index","clear_history","get_previous_history_entry","get_next_history_entry","add_history_entry","list_variables","get_variable","set_variable","unset_variable","list_aliases","get_alias","set_alias","unset_alias","VAR_ASSIGNMENT_REGEX","parse_line","memory","sub","i","part","alias_value","alias_parts","pop","skip_variable_sub_idxs","arg","var_name","var_value","arg_idx","replace","var1","var2","AshShell","_discard_cached_matches","execute","edit_doc_title","program_final_completion_callback","old_title","document","title","on_execute_completion","color","insert_prompt","run_script","get_prompt_suffix","set_prompt_suffix","suffix","get_prompt_string","RegExp","cached_matches","current_cached_match_index","tab_complete","discard_cached_matches","updated_discard","completeable_arguments","completion_data","current_partial","arg_index","completion_result","obj","Symbol","asyncIterator","results","get_completeable_arguments","complete_argument","parts","current_arg_partial","fill_completed_argument","programs","complete_command","fill_completed_command","helper_completion_options","options","option","env_info","absolute_profile","absolute_rc","profile_content","rc_content","read_line_key_handlers","make_read_line_key_handlers","read_line_printable_handler","make_read_line_printable_handler","focus","input","my_process","channel_id_str","parseInt","isNaN","finished","event","toLowerCase","timeout_id","header","single_column","visible_programs","programs_fmt","sort","max_allowable_length","Math","floor","cols","column1","_","column2","longest_program_length","max","new_args","paired_programs","program1","program2","program1_real_length","program2_real_length","recurse","descs","nest_level","output","time","time_arg","parsed_time","reload","show_hidden","dir","max_width","setup","h_padding_l","ceil","h_padding_r","rows","footer","f_padding_l","f_padding_r","split_content","saved","cursor_y","normal","cursorY","line_length","cursor_x","cursorX","before_newline","after_newline","newline_content","left","right","test","url","proc_url","URL","protocol","overwrite","binary","method","headers","body","next_arg","abs_path","response","headers_obj","fetch","ok","arrayBuffer","filepath","hex","byte","padStart","idx","padded","concat","fill","MY_USERNAME","GH_USERNAME_REGEX","version_str","max_columns","asc_width","username","gh_info","res","json","bio","blog","followers","following","twitter","twitter_username","get_github_info","avatar_url","username_to_avatar_url","ascii_pfp","size","img","round","loadImage","stringANSI8BitColor","convert_to_ascii","known_data","data_index_str","user_data_str","pronouns","subject","object_or_alt","possessive","interests","websites","extra","known_info","stranger_info","txt_line_prefix","txt_line_suffix","asc_lines","txt_lines","max_lines","max_asc_line_length","max_txt_line_length","center_padding_size","side_padding_size","center_padding","side_padding","asc_line","txt_line","asc_line_padding","sfx_reg","screenReaderMode","sound_name","hint","querySelector","remove","pad","str","invis_codes","y_count","mime","width_arg","head_req","get_req","createObjectURL","Blob","data_out","canvas","createElement","ctx","getContext","Image","crossOrigin","onerror","height","drawImage","img_data","getImageData","array","convert_to_image_data","img_width","img_height","width_scale","new_height","scaled_img_data","x","y","scaled_x","scaled_i","sixel","image2sixel","blob","createImageBitmap","trusted_formats","ext","directory","fs_name","encoded_dir","open","iframe","style","border","wind","dom","appendChild","show","other_fsedit_running","processes","message_handler","source","contentWindow","close","removeEventListener","addEventListener","rimraf","type_suffixes","bug","feature","other","HTML_TAG_REGEX","fields","feed","item","DocType","author","publisher","date","link","summary","get_field","doc","doc_type","field","as_html","dict","FEED","field_value","isArray","sub_field","sub_field_doc","getElementsByTagName","sub_value","innerHTML","textContent","max_items","index","no_content","parser","DOMParser","parseFromString","feed_title","site_link","site_description","items","item_idx","item_title","ITEM","convert","formatters","elem","walk","builder","openBlock","addInline","opener","children","closeBlock","img_fmt","a_fmt","selectors","selector","format","_data","assign","wait_block","run_cmd","cmd","welcome","end","remove_subcommand","unique_args","error_count","total_pkgs","pkg","pkg_dir","meta_triggers","meta_version","meta_deps","meta_raw","meta","triggers","deps","dep_pkg","dep_pkg_name","graph_query","remove_pkg_dependent","remove_pkg","files","trigger_name","trigger_data","trigger_exists","process_uninstall_trigger","add_subcommand","depended_by","pkg_at_version","pkg_split","pkg_name","pkg_version","pkg_json","repo_query","get_pkg_json","latest_version","get_pkg_meta","externals","pkg_is_installed","get_pkg_version","remove_data","virtual_args","virtual_data","content_list","file_map","file_contents","get_pkg_file","stringify","json_convert_dep_sets_to_arrs","install_new_pkg","dep_name","add_pkg_dependent","process_install_trigger","print_info","pkg_data","installed","license","homepage_url","repo_url","long_desc","view_pkg_info","pkg_versions","get_pkg_versions","installed_version","printed_link_header","repo_url_obj","GRAPH_DIR","GRAPH_PATH","TRIGGER_DIR","append_url_pathnames","pathnames","new_url","urlpath","pathname","api_call","encodeURI","get_provided_list","json_convert_dep_arrs_to_sets","graph","get_pkg_info","list_pkgs","only_top_level","pkgs","top_level","get_pkg_dependents","dependents","get_pkg_dependencies","dependended_by","promote_pkg_to_top_level","demote_pkg_from_top_level","dependent_pkg","add_to_deps","remove_from_deps","skip_dep_check","list_unused_pkgs","get_file_path_in_pkg_bin","load_trigger_file","trigger_path","trigger","install_exec","data_str","uninstall_exec","local_graph","create_trigger_path","create_trigger_data","pkg_names","info","list_subcommand","always_fetch","installed_pkg","requested_version_installed","pkg_json_path","info_subcommand","provided","offset","selected_index","draw","quit","browse_subcommand","absolute_file","abs_dir","parent","destination","ended_with_slash","dest_is_dir","basename","window_ids","get_all_windows","all_windows","visible_windows","w","get_unique_manager_type_name","only_visible","only_invisible","visibility_text","owner_pid","userspace_kernel","window_id","get_window_by_id","show_subcommand","hide","hide_subcommand","close_subcommand","center","center_subcommand","aliases","value_parts","final_value","pm","toLocaleString","longest_command_length","get_command_space","subtract","on_data","reply_timeout","return_code","msg_data","service_subcommand","reload_services_subcommand","set_custom_flag","buttons","display","alignItems","gap","padding","fsedit_button","innerText","fontSize","onclick","mc_button","mc_image","objectFit","alt","draggable","trigger_file","source_path","dest_path","LocalStorageFS","current_dir","MADE_DIR","part_idx","DELETED_DIR","src_parts","dest_parts","current_dir_parent","dest_current_dir","LISTING_DIR","current_part","binary_string","atob","bytes","m","charCodeAt","TextDecoder","decode","uint","TextEncoder","encode","ArrayBuffer","btoa","String","fromCharCode","apply","readonly_list","new_file_name","new_current_dir","string_to_array","array_to_b64","migrations","migrate_old_string_fs","migrate_old_array_fs","is_outer","stack","current_obj","OPFSFileSystem","_opfs_handle","storage","getDirectory","handle","get_root_handle","root","current_handle","getDirectoryHandle","DOMException","getFileHandle","err2","removeEntry","file_handle","getFile","array_buffer","writable","createWritable","data_to_write","dest_file_handle","kind","generate_project_folder","data_projects_dir","project_entry","project_data","project_dir","info_content","primary_language","live_url","image","file_ext_regex","image_ext","skip_cache","ttl_cache","ttl_cache_obj","fetch_file_with_ttl","sub_projects","sub_project_entry","AbstractWindow","_owner_pid","create_userspace_proxy_as_other_window","manager","maximised","create_userspace_proxy_as_full_window","manager_proxy","new_title","css_width","css_height","css_pos","is_visible","toggle","wait_for_event","AbstractWindowManager","DOMWindowManager","_manager","_window_id","_window_root","_window_top_bar","_window_top_bar_title","_window_top_bar_maximise_button","_content_host","_shadow_dom","_event_listeners","_title_text","moveable","resizable","_maximisable","_maximised","_custom_flags","classList","role","ariaHidden","zIndex","capture","_handle_window_blur","setAttribute","top_bar_controls","stopPropagation","minimise_button","ev","maximisable","close_button","bind","_start_drag","attachShadow","mode","_emit_event","activeElement","all","start_event","preventDefault","rect","getBoundingClientRect","offset_x","clientX","offset_y","clientY","top","mouse_move","move_event","new_rect","width_ratio","mouse_up","up_event","remove_event_listener","contains","get_custom_flag","flag","ollieos","howler","xterm","fitAddon","webLinksAddon","imageAddon","xtermLinkProvider","sweetalert2","boot_os","prog","absolute_boot","absolute_init","absolute_etc","absolute_boot_target","absolute_default_shell","absolute_sys","absolute_privilege_agent","setup_boot","motd_content","absolute_motd","setup_motd","absolute_ollie_profile","absolute_ash_profile","absolute_ollierc","absolute_ashrc","migrate_rc_profile","credits_content","absolute_credits","setup_credits","latest_rev","data_dir","existing_rev","version_file","rev","svc_version","possible_backup_dir","groups","group","group_dir","group_index","file_data","setup_data_repo","data_rev","absolute_projects","project_rev","project_index_file","projects","project_file","setup_projects","initial_fs_setup","cursorBlink","fit","FitAddon","loadAddon","WebLinksAddon","ImageAddon","render","innerWidth","wrapped","dataset"],"sourceRoot":""}